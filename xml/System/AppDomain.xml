<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ea61cb4223b387adbeae8acfa4c08e31102abc3b" /><Meta Name="ms.sourcegitcommit" Value="662f143e6be46d519ff8ab4451d543d91e651478" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/18/2018" /><Meta Name="ms.locfileid" Value="53568774" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="eece9-101">응용 프로그램이 실행되는 격리된 환경인 응용 프로그램 도메인을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-101">Represents an application domain, which is an isolated environment where applications execute.</span></span> <span data-ttu-id="eece9-102">이 클래스는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-103">으로 표현 되는 응용 프로그램 도메인 <xref:System.AppDomain> 개체를 관리 되는 코드를 실행 하는 것에 대 한 격리, 언로드 및 보안 경계를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-103">Application domains, which are represented by <xref:System.AppDomain> objects, help provide isolation, unloading, and security boundaries for executing managed code.</span></span>  
  
-   <span data-ttu-id="eece9-104">응용 프로그램 도메인을 사용 하 여 프로세스를 중단 시킬 수 있는 작업을 격리 하기.</span><span class="sxs-lookup"><span data-stu-id="eece9-104">Use application domains to isolate tasks that might bring down a process.</span></span> <span data-ttu-id="eece9-105">경우의 상태를 <xref:System.AppDomain> 작업을 실행 하는 불안정 합니다 <xref:System.AppDomain> 프로세스에 영향을 주지 않고 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-105">If the state of the <xref:System.AppDomain> that's executing a task becomes unstable, the <xref:System.AppDomain> can be unloaded without affecting the process.</span></span> <span data-ttu-id="eece9-106">이 경우 중요 한 프로세스를 다시 시작 하지 않고 오랫동안 실행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-106">This is important when a process must run for long periods without restarting.</span></span> <span data-ttu-id="eece9-107">또한 데이터를 공유 해야 하는 작업을 격리 하기 응용 프로그램 도메인을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-107">You can also use application domains to isolate tasks that should not share data.</span></span>  
  
-   <span data-ttu-id="eece9-108">어셈블리 기본 응용 프로그램 도메인에 로드 된 경우 프로세스를 실행 하는 동안 메모리에서 언로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-108">If an assembly is loaded into the default application domain, it cannot be unloaded from memory while the process is running.</span></span> <span data-ttu-id="eece9-109">그러나을 로드 하는 어셈블리를 실행 하는 두 번째 응용 프로그램 도메인을 열면 해당 응용 프로그램 도메인이 언로드될 때 어셈블리 로드 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-109">However, if you open a second application domain to load and execute the assembly, the assembly is unloaded when that application domain is unloaded.</span></span> <span data-ttu-id="eece9-110">이 기술을 사용 하 여 경우에 따라 큰 Dll을 사용 하는 장기 실행 프로세스의 작업 집합을 최소화 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-110">Use this technique to minimize the working set of long-running processes that occasionally use large DLLs.</span></span>  
  
 > [!NOTE]
 >  <span data-ttu-id="eece9-111">.NET Core에서의 <xref:System.AppDomain> 구현 디자인에 의해 제한 됩니다 및 격리, 언로드 또는 보안 경계를 제공 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-111">On .NET Core, the <xref:System.AppDomain> implementation is limited by design and does not provide isolation, unloading, or security boundaries.</span></span> <span data-ttu-id="eece9-112">.NET core가 정확히 하나인 <xref:System.AppDomain>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-112">For .NET Core, there is exactly one <xref:System.AppDomain>.</span></span> <span data-ttu-id="eece9-113">격리 및 언로드를 통해 제공 됩니다 <xref:System.Runtime.Loader.AssemblyLoadContext>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-113">Isolation and unloading are provided through <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span> <span data-ttu-id="eece9-114">보안 경계 프로세스 경계를 적절 한 원격 기술을 제공 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-114">Security boundaries should be provided by process boundaries and appropriate remoting techniques.</span></span>
 
 <span data-ttu-id="eece9-115">여러 응용 프로그램 도메인은 단일 프로세스;에서 실행할 수 있습니다. 그러나 응용 프로그램 도메인과 스레드 간에 한 일 상관 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-115">Multiple application domains can run in a single process; however, there is not a one-to-one correlation between application domains and threads.</span></span> <span data-ttu-id="eece9-116">여러 스레드를 단일 응용 프로그램 도메인에 속할 수 있습니다 하 고 스레드는 단일 응용 프로그램 도메인에서 실행 동안 지정 된 스레드가 지정된 된 시간에 단일 응용 프로그램 도메인에 한정 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-116">Several threads can belong to a single application domain, and while a given thread is not confined to a single application domain, at any given time, a thread executes in a single application domain.</span></span>  
  
 <span data-ttu-id="eece9-117">응용 프로그램 도메인을 사용 하 여 만들어집니다는 <xref:System.AppDomain.CreateDomain%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-117">Application domains are created using the <xref:System.AppDomain.CreateDomain%2A> method.</span></span> <span data-ttu-id="eece9-118"><xref:System.AppDomain> 인스턴스는 로드 하 고 어셈블리를 실행 하는 데 사용 됩니다 (<xref:System.Reflection.Assembly>).</span><span class="sxs-lookup"><span data-stu-id="eece9-118"><xref:System.AppDomain> instances are used to load and execute assemblies (<xref:System.Reflection.Assembly>).</span></span> <span data-ttu-id="eece9-119">경우는 <xref:System.AppDomain> 는 더 이상 사용에서이 언로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-119">When an <xref:System.AppDomain> is no longer in use, it can be unloaded.</span></span>  
  
 <span data-ttu-id="eece9-120"><xref:System.AppDomain> 클래스 또는 처리 되지 않은 예외가 throw 되 면 응용 프로그램 도메인으로 로드 됩니다 하는 경우 어셈블리 로드 될 때 응답 하도록 응용 프로그램을 사용 하도록 설정 하는 이벤트의 집합을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-120">The <xref:System.AppDomain> class implements a set of events that enable applications to respond when an assembly is loaded, when an application domain will be unloaded, or when an unhandled exception is thrown.</span></span>  
  
 <span data-ttu-id="eece9-121">응용 프로그램 도메인 사용에 대 한 자세한 내용은 참조 하세요. [응용 프로그램 도메인](~/docs/framework/app-domains/application-domains.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-121">For more information on using application domains, see [Application Domains](~/docs/framework/app-domains/application-domains.md).</span></span>  
  
 <span data-ttu-id="eece9-122">이 클래스에서 구현 된 <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, 및 <xref:System.Security.IEvidenceFactory> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-122">This class implements the <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, and <xref:System.Security.IEvidenceFactory> interfaces.</span></span>  
  
 <span data-ttu-id="eece9-123">원격으로 사용 가능한 래퍼를 만들지 마십시오는 <xref:System.AppDomain> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-123">You should never create a remotable wrapper for an <xref:System.AppDomain> object.</span></span> <span data-ttu-id="eece9-124">이렇게 하는에 대 한 원격 참조를 게시할 수 <xref:System.AppDomain>와 같은 메서드를 노출 <xref:System.AppDomain.CreateInstance%2A> 원격 액세스 하 고 효과적으로 코드 액세스 보안에 대 한 제거 <xref:System.AppDomain>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-124">Doing so could publish a remote reference to that <xref:System.AppDomain>, exposing methods such as <xref:System.AppDomain.CreateInstance%2A> to remote access and effectively destroying code access security for that <xref:System.AppDomain>.</span></span> <span data-ttu-id="eece9-125">악의적인 클라이언트가 연결 하는 원격 <xref:System.AppDomain> 모든 리소스에 대 한 액세스를 얻을 수는 <xref:System.AppDomain> 자체에 대 한 액세스.</span><span class="sxs-lookup"><span data-stu-id="eece9-125">Malicious clients connecting to the remoted <xref:System.AppDomain> could obtain access to any resource the <xref:System.AppDomain> itself has access to.</span></span> <span data-ttu-id="eece9-126">확장 하는 모든 형식에 대해 원격으로 사용 가능한 래퍼를 만들지 마십시오 <xref:System.MarshalByRefObject> 보안 시스템을 무시 하는 악의적인 클라이언트가 사용할 수 있는 메서드를 구현 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-126">Do not create remotable wrappers for any type that extends <xref:System.MarshalByRefObject> and that implements methods that could be used by malicious clients to bypass the security system.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="eece9-127">기본값은 <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> 속성은 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-127">The default value for the <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> property is `false`.</span></span> <span data-ttu-id="eece9-128">이 설정은 서비스에 대 한 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-128">This setting is unsafe for services.</span></span> <span data-ttu-id="eece9-129">서비스에서 부분적으로 신뢰할 수 있는 코드 다운로드를 방지 하려면이 속성을 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-129">To prevent services from downloading partially trusted code, set this property to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-130">이 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.AppDomain>, 하는 형식을 새로 인스턴스화할 <xref:System.AppDomain>, 해당 형식의 개체와 통신 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-130">This example shows how to create a new <xref:System.AppDomain>, instantiate a type in that new <xref:System.AppDomain>, and communicate with that type's object.</span></span> <span data-ttu-id="eece9-131">또한이 예제에서는 언로드를 <xref:System.AppDomain> 개체가 가비지 수집 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-131">In addition, this example shows how to unload the <xref:System.AppDomain> causing the object to be garbage collected.</span></span>  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482"><span data-ttu-id="eece9-132">방법: 응용 프로그램 도메인 구성</span><span class="sxs-lookup"><span data-stu-id="eece9-132">How To: Configure an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/ba1fa43e-49f5-47d9-bd7f-3024af16f4ba"><span data-ttu-id="eece9-133">방법: 응용 프로그램 도메인 만들기</span><span class="sxs-lookup"><span data-stu-id="eece9-133">How To: Create an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/1432aa2d-bd83-4346-bf3b-a1b7920e2aa9"><span data-ttu-id="eece9-134">방법: 응용 프로그램 도메인에 어셈블리 로드</span><span class="sxs-lookup"><span data-stu-id="eece9-134">How to: Load Assemblies into an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/f356116d-e415-4f7c-a332-6e6a60227192"><span data-ttu-id="eece9-135">방법: 응용 프로그램 도메인 언로드</span><span class="sxs-lookup"><span data-stu-id="eece9-135">How to: Unload an Application Domain</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-136">현재 응용 프로그램 도메인의 활성화 컨텍스트를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-136">Gets the activation context for the current application domain.</span></span></summary>
        <value><span data-ttu-id="eece9-137">현재 응용 프로그램 도메인의 활성화 컨텍스트를 나타내는 개체이거나, 이 도메인에 활성화 컨텍스트가 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-137">An object that represents the activation context for the current application domain, or <see langword="null" /> if the domain has no activation context.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-138">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-138">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-139">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-139">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="eece9-140">전용 경로에 추가되는 디렉터리 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-140">The name of the directory to be appended to the private path.</span></span></param>
        <summary><span data-ttu-id="eece9-141">지정된 디렉터리 이름을 전용 경로 목록에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-141">Appends the specified directory name to the private path list.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-142">이 속성의 사용에 이미 로드 된 후에 어셈블리에 대 한 검색 경로 변경 될 수 있으므로 권장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-142">The use of this property is not recommended, because it might change the probing path for assemblies after they have already been loaded.</span></span> <span data-ttu-id="eece9-143">대신 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> 속성을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-143">Use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property instead.</span></span>  
  
 <span data-ttu-id="eece9-144">전용 경로 또는 상대 검색 경로 전용 어셈블리에 대 한 어셈블리 확인자 프로브는 기본 디렉터리에 상대적 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-144">The private path, or relative search path, is the path relative to the base directory where the assembly resolver probes for private assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-145">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-145">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-146">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-146">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-147">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-147">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-148">응용 프로그램 도메인에서 응용 프로그램의 ID를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-148">Gets the identity of the application in the application domain.</span></span></summary>
        <value><span data-ttu-id="eece9-149">응용 프로그램 도메인에서 응용 프로그램을 식별하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-149">An object that identifies the application in the application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-150">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-150">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-151">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-151">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-152">응용 프로그램에 부여된 권한 및 해당 응용 프로그램을 실행할 수 있는 신뢰 수준이 있는지를 설명하는 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-152">Gets information describing permissions granted to an application and whether the application has a trust level that allows it to run.</span></span></summary>
        <value><span data-ttu-id="eece9-153">응용 프로그램 도메인의 응용 프로그램에 대한 권한과 신뢰 정보를 캡슐화하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-153">An object that encapsulates permission and trust information for the application in the application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-154">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-154">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-155">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-155">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-156"><see cref="P:System.Reflection.Assembly.FullName" /> 속성에서 제공하는 형식의 어셈블리 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-156">The assembly display name, in the form provided by the <see cref="P:System.Reflection.Assembly.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="eece9-157">정책이 적용된 후 어셈블리 표시 이름을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-157">Returns the assembly display name after policy has been applied.</span></span></summary>
        <returns><span data-ttu-id="eece9-158">정책이 적용된 후의 어셈블리 표시 이름이 포함된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-158">A string containing the assembly display name after policy has been applied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-159"><xref:System.AppDomain.ApplyPolicy%2A> 메서드는 어셈블리 표시 이름 및 사후 정책 표시 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-159">The <xref:System.AppDomain.ApplyPolicy%2A> method takes an assembly display name and returns the post-policy display name.</span></span> <span data-ttu-id="eece9-160">리플렉션 전용 컨텍스트에 정책 수 없기 때문에 정책을 사용 하 여 어셈블리를 로드 해야 하는 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-160">This is useful if you need to load an assembly using policy, because the reflection-only context does not apply policy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-161">어셈블리가 로드될 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-161">Occurs when an assembly is loaded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-162"><xref:System.AssemblyLoadEventHandler> 이 이벤트는 나타냅니다 로드 된 어셈블리에 대 한 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-162">The <xref:System.AssemblyLoadEventHandler> delegate for this event indicates what assembly was loaded.</span></span>  
  
 <span data-ttu-id="eece9-163">이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-163">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="eece9-164">이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="eece9-164">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-165">다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.AssemblyLoad> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-165">The following sample demonstrates the <xref:System.AppDomain.AssemblyLoad> event.</span></span>  
  
 <span data-ttu-id="eece9-166">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-166">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="eece9-167">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-167">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-168">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-168">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-169">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-169">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-170">어셈블리를 확인하지 못할 경우 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-170">Occurs when the resolution of an assembly fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-171">책임이 합니다 <xref:System.ResolveEventHandler> 어셈블리를 반환 하 여 지정 된이 이벤트에 대 한는 <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> 속성 또는 어셈블리 인식 되지 않으면 null을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-171">It is the responsibility of the <xref:System.ResolveEventHandler> for this event to return the assembly that is specified by the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property, or to return null if the assembly is not recognized.</span></span> <span data-ttu-id="eece9-172">어셈블리는 실행 컨텍스트에 로드 해야 합니다. 리플렉션 전용 컨텍스트에 로드 되 면이 이벤트를 발생 시킨 로드는 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-172">The assembly must be loaded into an execution context; if it is loaded into the reflection-only context, the load that caused this event to be raised fails.</span></span>  
  
 <span data-ttu-id="eece9-173">이 이벤트의 사용에 대 한 지침을 참조 하세요 [어셈블리 로드 해결](~/docs/framework/app-domains/resolve-assembly-loads.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-173">For guidance on the use of this event, see [Resolving Assembly Loads](~/docs/framework/app-domains/resolve-assembly-loads.md).</span></span>  
  
 <span data-ttu-id="eece9-174">부터는 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> 속성 확인할 수 없습니다. 어셈블리 로드 요청 어셈블리를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-174">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property returns the assembly that requested the assembly load that could not be resolved.</span></span> <span data-ttu-id="eece9-175">예를 들어, 로더가 요청 하는 어셈블리 및 해당 종속성 검색 경로에 없기 때문에 요청 하는 어셈블리의 종속성을 로드 하는 일을 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-175">For example, the loader might be unable to load a dependency of the requesting assembly because the requesting assembly and its dependency are not in the probing path.</span></span> <span data-ttu-id="eece9-176">요청 하는 어셈블리의 id를 알고 있으면 종속성의 버전이 둘 이상 사용할 수 있는 경우 올바른 버전을 확인 또는 종속성을 찾거나 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-176">Knowing the identity of the requesting assembly might be useful in locating the dependency or in identifying the correct version, if more than one version of the dependency is available.</span></span> <span data-ttu-id="eece9-177">자세한 내용은 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-177">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eece9-178">로 시작 합니다 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <xref:System.ResolveEventHandler> 리소스 어셈블리를 포함 하 여 모든 어셈블리에 대 한 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-178">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the <xref:System.ResolveEventHandler> event is raised for all assemblies, including resource assemblies.</span></span> <span data-ttu-id="eece9-179">이전 버전에서는 리소스 어셈블리에 대 한 이벤트 발생 하지 했습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-179">In earlier versions, the event was not raised for resource assemblies.</span></span> <span data-ttu-id="eece9-180">운영 체제에 지역화 된 처리기에 여러 번 호출할 수 있습니다: 대체 (fallback) 체인의 각 문화권에 한 번씩입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-180">If the operating system is localized, the handler might be called multiple times: once for each culture in the fallback chain.</span></span>  
  
 <span data-ttu-id="eece9-181">이 이벤트는 <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> 속성 정책 적용 되기 전에 어셈블리 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-181">For this event, the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property returns the assembly name before policy is applied.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eece9-182">둘 이상의 이벤트 처리기는이 이벤트에 대 한 등록 되 면 이벤트 처리기를 이벤트 처리기에 없는 값 반환 될 때까지 순서 대로 호출 됩니다 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-182">If more than one event handler is registered for this event, the event handlers are called in order until an event handler returns a value that isn't `null`.</span></span> <span data-ttu-id="eece9-183">후속 이벤트 처리기는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-183">Subsequent event handlers are ignored.</span></span>
  
 <span data-ttu-id="eece9-184">이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="eece9-184">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-185">다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-185">The following sample demonstrates the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="eece9-186">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-186">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="eece9-187">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-187">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-188">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-188">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-189">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-189">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
        <related type="Article" href="https://msdn.microsoft.com/library/5099e549-f4fd-49fb-a290-549edd456c6a"><span data-ttu-id="eece9-190">어셈블리 로드 해결</span><span class="sxs-lookup"><span data-stu-id="eece9-190">Resolving Assembly Loads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-191">어셈블리 확인자에서 어셈블리를 조사하는 데 사용하는 기본 디렉터리를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-191">Gets the base directory that the assembly resolver uses to probe for assemblies.</span></span></summary>
        <value><span data-ttu-id="eece9-192">어셈블리 확인자에서 어셈블리를 조사하는 데 사용하는 기본 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-192">The base directory that the assembly resolver uses to probe for assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-193">이 속성에 해당 하는 <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-193">This property corresponds to the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="eece9-194">또한 검색할 수 있습니다 사용 하는 <xref:System.AppDomain.GetData%2A> "APPBASE" 문자열을 사용 하 여 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-194">It can also be retrieved using the <xref:System.AppDomain.GetData%2A> method with the string "APPBASE".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-195">다음 코드 예제는 도메인에 로드 하려면 어셈블리에 대해 검색할 때 사용할 기본 디렉터리를 지정 하는 새 응용 프로그램 도메인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-195">The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain.</span></span> <span data-ttu-id="eece9-196">이 예제에서는 다음 사용 하 여는 <xref:System.AppDomain.BaseDirectory%2A> 속성을 콘솔에 표시 하기 위해 기본 디렉터리 경로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-196">The example then uses the <xref:System.AppDomain.BaseDirectory%2A> property to obtain the base directory path, for display to the console.</span></span>  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-197">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-197">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-198">경로 자체의 정보에 액세스에 대 한 경우 포함 하 여 경로 "file://" 형식에서 또는 \\\UNC\dir 또는 "c:\\"입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-198">for access to the information in the path itself, including if the path is in the form "file://" or \\\UNC\dir or "c:\\".</span></span> <span data-ttu-id="eece9-199">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-199">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="eece9-200">전용 어셈블리의 위치를 지정하는 경로를 빈 문자열("")로 다시 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-200">Resets the path that specifies the location of private assemblies to the empty string ("").</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-201">전용 경로 공용 언어 런타임 전용 어셈블리를 찾을 수를 검색 하는 기본 디렉터리의 상대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-201">The private path is a path relative to the base directory that the common language runtime searches to locate private assemblies.</span></span>  
  
 <span data-ttu-id="eece9-202">자세한 내용은 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="eece9-202">For more information, see <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-203">다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.AppDomain.ClearPrivatePath%2A> 어셈블리가 로드 되는 경우를 검색 하는 개인 경로 목록에서 모든 항목을 제거 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-203">The following code example demonstrates how to use the <xref:System.AppDomain.ClearPrivatePath%2A> method to remove all entries from the list of private paths to search when assemblies are loaded.</span></span>  
  
 <span data-ttu-id="eece9-204">이 메서드는 이제 이전 하며 새로운 개발에 쓰일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-204">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-205">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-205">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-206">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-206">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-207">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-207">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="eece9-208">섀도 복사된 어셈블리를 포함하는 디렉터리 목록을 빈 문자열("")로 다시 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-208">Resets the list of directories containing shadow copied assemblies to the empty string ("").</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-209">섀도 복사본 경로가 어셈블리 섀도 복사 디렉터리의 목록이 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-209">The shadow copy path is a list of directories where shadow copied assemblies are stored.</span></span>  
  
 <span data-ttu-id="eece9-210">자세한 내용은 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> 하 고 [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-210">For more information, see <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-211">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-211">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-212">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-212">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-213">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-213">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="F:System.String.Empty" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="eece9-214">어셈블리 섀도 복사</span><span class="sxs-lookup"><span data-stu-id="eece9-214">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="eece9-215">지정한 COM 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-215">Creates a new instance of a specified COM type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-216">요청된 형식을 정의하는 어셈블리가 포함된 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-216">The name of a file containing an assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-217">요청된 형식의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-217">The name of the requested type.</span></span></param>
        <summary><span data-ttu-id="eece9-218">지정한 COM 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-218">Creates a new instance of a specified COM type.</span></span> <span data-ttu-id="eece9-219">매개 변수는 형식 및 형식 이름을 포함하는 어셈블리가 포함된 파일 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-219">Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="eece9-220"><paramref name="typeName" />에서 지정한 새 인스턴스의 래퍼인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-220">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="eece9-221">실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-221">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-222">이 메서드를 사용 하 여 로컬로 유형을 로드 하지 않고도 원격 개체를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-222">Use this method to create objects remotely without having to load the type locally.</span></span>  
  
 <span data-ttu-id="eece9-223">반환 값은 실제 개체에 액세스 하기 위해 래핑 없게 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-223">The return value must to be unwrapped to access the real object.</span></span>  
  
 <span data-ttu-id="eece9-224">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> 특성의 값을 사용 하 여 `true` 해당 형식의 인스턴스를 만들려면이 메서드에 대 한 COM 형식으로 명시적으로 나 기본적으로 적용할 해야이 고, 그렇지 <xref:System.TypeLoadException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-224">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribute with a value of `true` must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <xref:System.TypeLoadException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-225">다음 샘플을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="eece9-225">The following sample demonstrates</span></span>  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-226"><paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-226"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-227">형식을 로드할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="eece9-227">The type cannot be loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-228">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-228">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-229">매개 변수가 없는 public 생성자를 찾지 못한 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-229">No public parameterless constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-230"><paramref name="assemblyName" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-230"><paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="eece9-231"><paramref name="typeName" />는 추상 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-231"><paramref name="typeName" /> is an abstract class.</span></span>  
  
<span data-ttu-id="eece9-232">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-232">-or-</span></span> 
<span data-ttu-id="eece9-233">이 멤버가 런타임에 바인딩된 메커니즘을 사용하여 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-233">This member was invoked with a late-binding mechanism.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-234">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-234">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-235"><paramref name="assemblyName" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-235"><paramref name="assemblyName" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-236"><paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-236"><paramref name="assemblyName" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-237">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-237">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="eece9-238">참조되는 COM 개체가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-238">The COM object that is being referred to is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-239">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-239">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-240">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-240">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-241">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-241">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="eece9-242">요청된 형식을 정의하는 어셈블리가 포함된 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-242">The name of a file containing an assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-243">요청된 형식의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-243">The name of the requested type.</span></span></param>
        <param name="hashValue"><span data-ttu-id="eece9-244">계산된 해시 코드의 값을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-244">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="eece9-245">어셈블리 매니페스트에 사용되는 해시 알고리즘을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-245">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="eece9-246">지정한 COM 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-246">Creates a new instance of a specified COM type.</span></span> <span data-ttu-id="eece9-247">매개 변수는 형식 및 형식 이름을 포함하는 어셈블리가 포함된 파일 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-247">Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="eece9-248"><paramref name="typeName" />에서 지정한 새 인스턴스의 래퍼인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-248">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="eece9-249">실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-249">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-250">이 메서드를 사용 하 여 로컬로 유형을 로드 하지 않고도 원격 개체를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-250">Use this method to create objects remotely without having to load the type locally.</span></span>  
  
 <span data-ttu-id="eece9-251">반환 값은 실제 개체에 액세스 하기 위해 래핑 없게 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-251">The return value must to be unwrapped to access the real object.</span></span>  
  
 <span data-ttu-id="eece9-252">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> 특성의 값을 사용 하 여 `true` 해당 형식의 인스턴스를 만들려면이 메서드에 대 한 COM 형식으로 명시적으로 나 기본적으로 적용할 해야이 고, 그렇지 <xref:System.TypeLoadException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-252">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribute with a value of `true` must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <xref:System.TypeLoadException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-253"><paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-253"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-254">형식을 로드할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="eece9-254">The type cannot be loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-255">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-255">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-256">매개 변수가 없는 public 생성자를 찾지 못한 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-256">No public parameterless constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-257"><paramref name="assemblyFile" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-257"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="eece9-258"><paramref name="typeName" />는 추상 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-258"><paramref name="typeName" /> is an abstract class.</span></span>  
  
<span data-ttu-id="eece9-259">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-259">-or-</span></span> 
<span data-ttu-id="eece9-260">이 멤버가 런타임에 바인딩된 메커니즘을 사용하여 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-260">This member was invoked with a late-binding mechanism.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-261">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-261">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-262"><paramref name="assemblyFile" />가 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-262"><paramref name="assemblyFile" /> is the empty string ("").</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-263"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-263"><paramref name="assemblyFile" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-264">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-264">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="eece9-265">참조되는 COM 개체가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-265">The COM object that is being referred to is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-266">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-266">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-267">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-267">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-268">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-268">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="eece9-269">새 응용 프로그램 도메인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-269">Creates a new application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="eece9-270">도메인의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-270">The friendly name of the domain.</span></span></param>
        <summary><span data-ttu-id="eece9-271">지정한 이름을 가진 새 응용 프로그램 도메인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-271">Creates a new application domain with the specified name.</span></span></summary>
        <returns><span data-ttu-id="eece9-272">새로 만든 응용 프로그램 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-272">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-273">`friendlyName` 매개 변수 사용자에 게 의미 있는 방식으로 도메인 식별 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-273">The `friendlyName` parameter is intended to identify the domain in a manner that is meaningful to humans.</span></span> <span data-ttu-id="eece9-274">이 문자열은 사용자 인터페이스에 표시 하기에 적합 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-274">This string should be suitable for display in user interfaces.</span></span>  
  
 <span data-ttu-id="eece9-275">이 메서드 오버 로드는 <xref:System.AppDomainSetup> 기본 응용 프로그램 도메인의 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-275">This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-276">다음 예제에서는, 일반적으로 중 하나를 사용 하 여 도메인을 만드는 방법의 <xref:System.AppDomain.CreateDomain%2A> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-276">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-277"><paramref name="friendlyName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-277"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="eece9-278">.NET Core에서 지원되지 않는 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-278">Method not supported on .NET Core.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-279">증명 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-279">to provide evidence.</span></span> <span data-ttu-id="eece9-280">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-280">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="eece9-281">도메인의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-281">The friendly name of the domain.</span></span> <span data-ttu-id="eece9-282">이 이름은 도메인을 식별하기 위해 사용자 인터페이스에 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-282">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="eece9-283">자세한 내용은 <see cref="P:System.AppDomain.FriendlyName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-283">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="eece9-284">응용 프로그램 도메인에서 실행되는 코드의 ID를 설정하는 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-284">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="eece9-285">현재 응용 프로그램 도메인의 증거를 사용하려면 <see langword="null" />을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-285">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <summary><span data-ttu-id="eece9-286">제공된 증명 정보를 사용하여 지정한 이름을 가진 새 응용 프로그램 도메인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-286">Creates a new application domain with the given name using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="eece9-287">새로 만든 응용 프로그램 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-287">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-288">이 메서드 오버 로드는 <xref:System.AppDomainSetup> 기본 응용 프로그램 도메인의 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-288">This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
 <span data-ttu-id="eece9-289">경우 `securityInfo` 가 제공 되지 않으면 현재 응용 프로그램 도메인의 증명 정보가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-289">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eece9-290">샌드박스 응용 프로그램 도메인을 만들려면이 메서드 오버 로드를 사용 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-290">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="eece9-291">로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에 대해 제공한 증명 정보 `securityInfo` 더 이상 응용 프로그램 도메인의 권한 부여 집합에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-291">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="eece9-292">사용 된 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> 샌드박스 응용 프로그램 도메인을 만드는 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-292">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-293">다음 예제에서는, 일반적으로 중 하나를 사용 하 여 도메인을 만드는 방법의 <xref:System.AppDomain.CreateDomain%2A> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-293">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-294"><paramref name="friendlyName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-294"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-295">증명 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-295">to provide evidence.</span></span> <span data-ttu-id="eece9-296">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-296">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="eece9-297">도메인의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-297">The friendly name of the domain.</span></span> <span data-ttu-id="eece9-298">이 이름은 도메인을 식별하기 위해 사용자 인터페이스에 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-298">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="eece9-299">자세한 내용은 <see cref="P:System.AppDomain.FriendlyName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-299">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="eece9-300">응용 프로그램 도메인에서 실행되는 코드의 ID를 설정하는 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-300">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="eece9-301">현재 응용 프로그램 도메인의 증거를 사용하려면 <see langword="null" />을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-301">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="info"><span data-ttu-id="eece9-302">응용 프로그램 도메인 초기화 정보를 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-302">An object that contains application domain initialization information.</span></span></param>
        <summary><span data-ttu-id="eece9-303">지정한 이름, 증명 정보 및 응용 프로그램 도메인 설치 정보를 사용하여 새 응용 프로그램 도메인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-303">Creates a new application domain using the specified name, evidence, and application domain setup information.</span></span></summary>
        <returns><span data-ttu-id="eece9-304">새로 만든 응용 프로그램 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-304">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-305">경우 `info` 가 제공 되지 않으면이 메서드 오버 로드를 사용 합니다 <xref:System.AppDomainSetup> 기본 응용 프로그램 도메인에서 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-305">If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
 <span data-ttu-id="eece9-306">경우 `securityInfo` 가 제공 되지 않으면 현재 응용 프로그램 도메인의 증명 정보가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-306">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eece9-307">샌드박스 응용 프로그램 도메인을 만들려면이 메서드 오버 로드를 사용 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-307">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="eece9-308">로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에 대해 제공한 증명 정보 `securityInfo` 더 이상 응용 프로그램 도메인의 권한 부여 집합에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-308">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="eece9-309">사용 된 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> 샌드박스 응용 프로그램 도메인을 만드는 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-309">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-310">다음 예제에서는, 일반적으로 중 하나를 사용 하 여 도메인을 만드는 방법의 <xref:System.AppDomain.CreateDomain%2A> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-310">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-311"><paramref name="friendlyName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-311"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-312">증명 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-312">to provide evidence.</span></span> <span data-ttu-id="eece9-313">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-313">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="eece9-314">도메인의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-314">The friendly name of the domain.</span></span> <span data-ttu-id="eece9-315">이 이름은 도메인을 식별하기 위해 사용자 인터페이스에 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-315">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="eece9-316">자세한 내용은 <see cref="P:System.AppDomain.FriendlyName" />의 설명을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-316">For more information, see the description of <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="eece9-317">응용 프로그램 도메인에서 실행되는 코드의 ID를 설정하는 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-317">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="eece9-318">현재 응용 프로그램 도메인의 증거를 사용하려면 <see langword="null" />을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-318">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="info"><span data-ttu-id="eece9-319">응용 프로그램 도메인 초기화 정보를 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-319">An object that contains application domain initialization information.</span></span></param>
        <param name="grantSet"><span data-ttu-id="eece9-320">새 응용 프로그램 도메인에 로드된 특정 권한이 없는 모든 어셈블리에 부여된 기본 권한 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-320">A default permission set that is granted to all assemblies loaded into the new application domain that do not have specific grants.</span></span></param>
        <param name="fullTrustAssemblies"><span data-ttu-id="eece9-321">새 응용 프로그램 도메인에서 완전히 신뢰할 수 있는 것으로 간주할 어셈블리를 나타내는 강력한 이름의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-321">An array of strong names representing assemblies to be considered fully trusted in the new application domain.</span></span></param>
        <summary><span data-ttu-id="eece9-322">지정한 이름, 증명 정보, 응용 프로그램 도메인 설치 정보, 기본 권한 집합 및 완전히 신뢰할 수 있는 어셈블리의 배열을 사용하여 새 응용 프로그램 도메인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-322">Creates a new application domain using the specified name, evidence, application domain setup information, default permission set, and array of fully trusted assemblies.</span></span></summary>
        <returns><span data-ttu-id="eece9-323">새로 만든 응용 프로그램 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-323">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-324">설정 해야 합니다는 <xref:System.AppDomainSetup.ApplicationBase%2A> 의 속성을 <xref:System.AppDomainSetup> 개체에 대해 제공 하는 `info`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-324">You must set the <xref:System.AppDomainSetup.ApplicationBase%2A> property of the <xref:System.AppDomainSetup> object that you supply for `info`.</span></span> <span data-ttu-id="eece9-325">그러지 않으면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-325">Otherwise, an exception is thrown.</span></span>  
  
 <span data-ttu-id="eece9-326">경우 `securityInfo` 가 제공 되지 않으면 현재 응용 프로그램 도메인의 증명 정보가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-326">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="eece9-327">에 대 한 제공 된 정보 `grantSet` 하 고 `fullTrustAssemblies` 만드는 데 사용 되는 <xref:System.Security.Policy.ApplicationTrust> 새 응용 프로그램 도메인에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-327">The information provided for `grantSet` and `fullTrustAssemblies` is used to create an <xref:System.Security.Policy.ApplicationTrust> object for the new application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-328"><paramref name="friendlyName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-328"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="eece9-329">응용 프로그램 도메인이 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-329">The application domain is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-330">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-330">-or-</span></span> 
<span data-ttu-id="eece9-331"><see cref="P:System.AppDomainSetup.ApplicationBase" /> 속성은 <paramref name="info" />에 대해 공급되는 <see cref="T:System.AppDomainSetup" /> 개체에 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-331">The <see cref="P:System.AppDomainSetup.ApplicationBase" /> property is not set on the <see cref="T:System.AppDomainSetup" /> object that is supplied for <paramref name="info" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-332">만들고 응용 프로그램 도메인을 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-332">for the ability to create and manipulate an application domain.</span></span> <span data-ttu-id="eece9-333">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /></span><span class="sxs-lookup"><span data-stu-id="eece9-333">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span></span> <span data-ttu-id="eece9-334">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-334">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="eece9-335">도메인의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-335">The friendly name of the domain.</span></span> <span data-ttu-id="eece9-336">이 이름은 도메인을 식별하기 위해 사용자 인터페이스에 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-336">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="eece9-337">자세한 내용은 <see cref="P:System.AppDomain.FriendlyName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-337">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="eece9-338">응용 프로그램 도메인에서 실행되는 코드의 ID를 설정하는 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-338">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="eece9-339">현재 응용 프로그램 도메인의 증거를 사용하려면 <see langword="null" />을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-339">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="appBasePath"><span data-ttu-id="eece9-340">어셈블리 확인자에서 어셈블리를 조사하는 데 사용하는 기본 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-340">The base directory that the assembly resolver uses to probe for assemblies.</span></span> <span data-ttu-id="eece9-341">자세한 내용은 <see cref="P:System.AppDomain.BaseDirectory" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-341">For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</span></span></param>
        <param name="appRelativeSearchPath"><span data-ttu-id="eece9-342">어셈블리 확인자에서 전용 어셈블리를 조사할 기본 디렉터리에 대한 상대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-342">The path relative to the base directory where the assembly resolver should probe for private assemblies.</span></span> <span data-ttu-id="eece9-343">자세한 내용은 <see cref="P:System.AppDomain.RelativeSearchPath" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-343">For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</span></span></param>
        <param name="shadowCopyFiles"><span data-ttu-id="eece9-344"><see langword="true" />인 경우 어셈블리의 섀도 복사본이 이 응용 프로그램 도메인에 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-344">If <see langword="true" />, a shadow copy of an assembly is loaded into this application domain.</span></span></param>
        <summary><span data-ttu-id="eece9-345">어셈블리의 섀도 복사본이 응용 프로그램 도메인에 로드되는지를 지정하는 매개 변수, 증명 정보, 응용 프로그램 기본 경로 및 상대 검색 경로를 사용하여 지정한 이름을 가진 새 응용 프로그램 도메인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-345">Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</span></span></summary>
        <returns><span data-ttu-id="eece9-346">새로 만든 응용 프로그램 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-346">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-347">경우 `securityInfo` 가 제공 되지 않으면 현재 응용 프로그램 도메인의 증명 정보가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-347">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="eece9-348">섀도 복사 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.AppDomain.ShadowCopyFiles%2A> 하 고 [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-348">For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eece9-349">샌드박스 응용 프로그램 도메인을 만들려면이 메서드 오버 로드를 사용 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-349">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="eece9-350">로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에 대해 제공한 증명 정보 `securityInfo` 더 이상 응용 프로그램 도메인의 권한 부여 집합에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-350">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="eece9-351">사용 된 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> 샌드박스 응용 프로그램 도메인을 만드는 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-351">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-352">다음 예제에서는, 일반적으로 중 하나를 사용 하 여 도메인을 만드는 방법의 <xref:System.AppDomain.CreateDomain%2A> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-352">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-353"><paramref name="friendlyName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-353"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-354">증명 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-354">to provide evidence.</span></span> <span data-ttu-id="eece9-355">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-355">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="eece9-356">도메인의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-356">The friendly name of the domain.</span></span> <span data-ttu-id="eece9-357">이 이름은 도메인을 식별하기 위해 사용자 인터페이스에 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-357">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="eece9-358">자세한 내용은 <see cref="P:System.AppDomain.FriendlyName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-358">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="eece9-359">응용 프로그램 도메인에서 실행되는 코드의 ID를 설정하는 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-359">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="eece9-360">현재 응용 프로그램 도메인의 증거를 사용하려면 <see langword="null" />을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-360">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="appBasePath"><span data-ttu-id="eece9-361">어셈블리 확인자에서 어셈블리를 조사하는 데 사용하는 기본 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-361">The base directory that the assembly resolver uses to probe for assemblies.</span></span> <span data-ttu-id="eece9-362">자세한 내용은 <see cref="P:System.AppDomain.BaseDirectory" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-362">For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</span></span></param>
        <param name="appRelativeSearchPath"><span data-ttu-id="eece9-363">어셈블리 확인자에서 전용 어셈블리를 조사할 기본 디렉터리에 대한 상대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-363">The path relative to the base directory where the assembly resolver should probe for private assemblies.</span></span> <span data-ttu-id="eece9-364">자세한 내용은 <see cref="P:System.AppDomain.RelativeSearchPath" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-364">For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</span></span></param>
        <param name="shadowCopyFiles"><span data-ttu-id="eece9-365">어셈블리의 섀도 복사본을 응용 프로그램 도메인에 로드하려면 <see langword="true" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-365"><see langword="true" /> to load a shadow copy of an assembly into the application domain.</span></span></param>
        <param name="adInit"><span data-ttu-id="eece9-366">새 <see cref="T:System.AppDomain" /> 개체가 초기화될 때 호출할 콜백 메서드를 나타내는 <see cref="T:System.AppDomainInitializer" /> 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-366">An <see cref="T:System.AppDomainInitializer" /> delegate that represents a callback method to invoke when the new <see cref="T:System.AppDomain" /> object is initialized.</span></span></param>
        <param name="adInitArgs"><span data-ttu-id="eece9-367">새 <see cref="T:System.AppDomain" /> 개체가 초기화될 때 <paramref name="adInit" />에서 나타내는 콜백으로 전달할 문자열 인수의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-367">An array of string arguments to be passed to the callback represented by <paramref name="adInit" />, when the new <see cref="T:System.AppDomain" /> object is initialized.</span></span></param>
        <summary><span data-ttu-id="eece9-368">어셈블리의 섀도 복사본이 응용 프로그램 도메인에 로드되는지를 지정하는 매개 변수, 증명 정보, 응용 프로그램 기본 경로 및 상대 검색 경로를 사용하여 지정한 이름을 가진 새 응용 프로그램 도메인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-368">Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</span></span> <span data-ttu-id="eece9-369">응용 프로그램 도메인이 초기화될 때 호출되는 콜백 메서드와 콜백 메서드를 전달할 문자열 인수의 배열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-369">Specifies a callback method that is invoked when the application domain is initialized, and an array of string arguments to pass the callback method.</span></span></summary>
        <returns><span data-ttu-id="eece9-370">새로 만든 응용 프로그램 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-370">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-371">가 나타내는 메서드의 `adInit` 새로 만든된 응용 프로그램 도메인의 컨텍스트에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-371">The method represented by `adInit` is executed in the context of the newly created application domain.</span></span>  
  
 <span data-ttu-id="eece9-372">경우 `securityInfo` 가 제공 되지 않으면 현재 응용 프로그램 도메인의 증명 정보가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-372">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="eece9-373">섀도 복사 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.AppDomain.ShadowCopyFiles%2A> 하 고 [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-373">For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eece9-374">샌드박스 응용 프로그램 도메인을 만들려면이 메서드 오버 로드를 사용 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-374">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="eece9-375">로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에 대해 제공한 증명 정보 `securityInfo` 더 이상 응용 프로그램 도메인의 권한 부여 집합에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-375">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="eece9-376">사용 된 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> 샌드박스 응용 프로그램 도메인을 만드는 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-376">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-377"><paramref name="friendlyName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-377"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-378">증명 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-378">to provide evidence.</span></span> <span data-ttu-id="eece9-379">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-379">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="eece9-380">지정한 어셈블리에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-380">Creates a new instance of a specified type defined in a specified assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-381">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-381">The display name of the assembly.</span></span> <span data-ttu-id="eece9-382"><see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-382">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-383">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-383">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="eece9-384">지정된 어셈블리에 정의되어 있는 지정된 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-384">Creates a new instance of the specified type defined in the specified assembly.</span></span></summary>
        <returns><span data-ttu-id="eece9-385"><paramref name="typeName" />에서 지정한 새 인스턴스의 래퍼인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-385">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="eece9-386">실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-386">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-387">이 메서드 호출에 대 한 기본 생성자를 `typeName`입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-387">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="eece9-388">참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-388">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="eece9-389">호출 하려는 시도 <xref:System.AppDomain.CreateInstance%2A> 현재 응용 프로그램 도메인 없는 응용 프로그램 도메인을 대상에 대상 응용 프로그램 도메인에서 어셈블리의 로드를 성공적으로 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-389">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="eece9-390">하므로 <xref:System.Reflection.Assembly> 아닙니다 <xref:System.MarshalByRefObject>이 메서드는 반환 하려고 시도 하는 경우는 <xref:System.Reflection.Assembly> 현재 응용 프로그램 도메인에 로드 된 어셈블리에 대 한 공용 언어 런타임에서 현재 응용 프로그램 도메인에 어셈블리 로드를 시도 하며 부하 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-390">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="eece9-391">현재 응용 프로그램 도메인에 로드 된 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정이 다른 경우 먼저 로드 된 어셈블리에서 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-391">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-392">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-392">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-393"><paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-393"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-394"><paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-394"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-395">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-395">-or-</span></span> 
<span data-ttu-id="eece9-396">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-396">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-397">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-397">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-398"><paramref name="assemblyName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-398"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-399">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-399">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-400">일치하는 public 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-400">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-401"><paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-401"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="eece9-402">이 인스턴스가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-402">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-403">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-403">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="eece9-404">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-404">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-405">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-405">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-406">대리자의 인스턴스를 만들 때 관리 되지 않는 코드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-406">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="eece9-407">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="eece9-407">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-408">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-408">The display name of the assembly.</span></span> <span data-ttu-id="eece9-409"><see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-409">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-410">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-410">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="eece9-411">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-411">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="eece9-412">일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-412">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="eece9-413">이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-413">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="eece9-414">분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-414">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="eece9-415">지정된 어셈블리에 정의되어 있는 지정된 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-415">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="eece9-416">매개 변수에서는 활성화 특성의 배열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-416">A parameter specifies an array of activation attributes.</span></span></summary>
        <returns><span data-ttu-id="eece9-417"><paramref name="typeName" />에서 지정한 새 인스턴스의 래퍼인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-417">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="eece9-418">실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-418">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-419">이 메서드 호출에 대 한 기본 생성자를 `typeName`입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-419">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="eece9-420">참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-420">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="eece9-421">호출 하려는 시도 <xref:System.AppDomain.CreateInstance%2A> 현재 응용 프로그램 도메인 없는 응용 프로그램 도메인을 대상에 대상 응용 프로그램 도메인에서 어셈블리의 로드를 성공적으로 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-421">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="eece9-422">하므로 <xref:System.Reflection.Assembly> 아닙니다 <xref:System.MarshalByRefObject>이 메서드는 반환 하려고 시도 하는 경우는 <xref:System.Reflection.Assembly> 현재 응용 프로그램 도메인에 로드 된 어셈블리에 대 한 공용 언어 런타임에서 현재 응용 프로그램 도메인에 어셈블리 로드를 시도 하며 부하 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-422">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="eece9-423">현재 응용 프로그램 도메인에 로드 된 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정이 다른 경우 먼저 로드 된 어셈블리에서 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-423">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-424">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-424">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-425"><paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-425"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-426"><paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-426"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-427">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-427">-or-</span></span> 
<span data-ttu-id="eece9-428">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-428">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-429">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-429">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-430"><paramref name="assemblyName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-430"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-431">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-431">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-432">일치하는 public 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-432">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-433">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-433">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-434"><paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-434"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="eece9-435">이 인스턴스가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-435">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-436">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-436">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-437">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-437">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-438">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-438">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-439">대리자의 인스턴스를 만들 때 관리 되지 않는 코드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-439">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="eece9-440">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="eece9-440">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="eece9-441">모든 형식 멤버에 대 한 작업을 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-441">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="eece9-442">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="eece9-442">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-443">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-443">The display name of the assembly.</span></span> <span data-ttu-id="eece9-444"><see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-444">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-445">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-445">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="eece9-446">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-446">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="eece9-447"><paramref name="typeName" /> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-447">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="eece9-448"><paramref name="bindingAttr" />가 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-448">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="eece9-449">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체의 검색을 가능하게 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-449">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="eece9-450"><paramref name="binder" />가 null이면 기본 바인더가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-450">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-451">생성자에 전달할 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-451">The arguments to pass to the constructor.</span></span> <span data-ttu-id="eece9-452">이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-452">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="eece9-453">기본 생성자를 사용하려면 <paramref name="args" />가 빈 배열이거나 null이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-453">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="eece9-454"><paramref name="typeName" /> 생성자에 대해 선언된 공식적인 형식에 <paramref name="args" />를 강제로 적용하는 것을 제어하는 문화권별 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-454">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="eece9-455"><paramref name="culture" />가 <see langword="null" />이면 현재 스레드의 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-455">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="eece9-456">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-456">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="eece9-457">일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-457">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="eece9-458">이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-458">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="eece9-459">클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-459">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="eece9-460">분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-460">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="eece9-461">지정된 어셈블리에 정의되어 있는 지정된 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-461">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="eece9-462">매개 변수는 바인더, 바인딩 플래그, 생성자 인수, 인수 해석에 사용되는 문화권별 정보 및 선택적 활성화 특성을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-462">Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, and optional activation attributes.</span></span></summary>
        <returns><span data-ttu-id="eece9-463"><paramref name="typeName" />에서 지정한 새 인스턴스의 래퍼인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-463">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="eece9-464">실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-464">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-465">참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-465">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="eece9-466">호출 하려는 시도 <xref:System.AppDomain.CreateInstance%2A> 현재 응용 프로그램 도메인 없는 응용 프로그램 도메인을 대상에 대상 응용 프로그램 도메인에서 어셈블리의 로드를 성공적으로 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-466">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="eece9-467">하므로 <xref:System.Reflection.Assembly> 아닙니다 <xref:System.MarshalByRefObject>이 메서드는 반환 하려고 시도 하는 경우는 <xref:System.Reflection.Assembly> 현재 응용 프로그램 도메인에 로드 된 어셈블리에 대 한 공용 언어 런타임에서 현재 응용 프로그램 도메인에 어셈블리 로드를 시도 하며 부하 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-467">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="eece9-468">현재 응용 프로그램 도메인에 로드 된 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정이 다른 경우 먼저 로드 된 어셈블리에서 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-468">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-469">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-469">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-470"><paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-470"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-471"><paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-471"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-472">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-472">-or-</span></span> 
 <span data-ttu-id="eece9-473"><paramref name="assemblyName" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-473"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-474">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-474">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-475"><paramref name="assemblyName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-475"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-476">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-476">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-477">일치하는 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-477">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-478">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-478">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-479"><paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-479"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="eece9-480">이 인스턴스가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-480">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-481">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-481">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-482">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-482">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-483">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-483">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-484">대리자의 인스턴스를 만들 때 관리 되지 않는 코드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-484">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="eece9-485">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="eece9-485">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="eece9-486">모든 형식 멤버에 대 한 작업을 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-486">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="eece9-487">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="eece9-487">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-488">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-488">The display name of the assembly.</span></span> <span data-ttu-id="eece9-489"><see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-489">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-490">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-490">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="eece9-491">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-491">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="eece9-492"><paramref name="typeName" /> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-492">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="eece9-493"><paramref name="bindingAttr" />가 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-493">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="eece9-494">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체의 검색을 가능하게 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-494">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="eece9-495"><paramref name="binder" />가 null이면 기본 바인더가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-495">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-496">생성자에 전달할 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-496">The arguments to pass to the constructor.</span></span> <span data-ttu-id="eece9-497">이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-497">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="eece9-498">기본 생성자를 사용하려면 <paramref name="args" />가 빈 배열이거나 null이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-498">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="eece9-499"><paramref name="typeName" /> 생성자에 대해 선언된 공식적인 형식에 <paramref name="args" />를 강제로 적용하는 것을 제어하는 문화권별 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-499">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="eece9-500"><paramref name="culture" />가 <see langword="null" />이면 현재 스레드의 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-500">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="eece9-501">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-501">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="eece9-502">일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-502">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="eece9-503">이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-503">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="eece9-504">분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-504">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="eece9-505"><paramref name="typeName" />의 생성을 인증하는 데 사용하는 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-505">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="eece9-506">지정된 어셈블리에 정의되어 있는 지정된 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-506">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="eece9-507">매개 변수에서는 바인더, 바인딩 플래그, 생성자 인수, 인수 해석에 사용되는 문화권별 정보, 활성화 특성 및 형식을 만들기 위한 인증을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-507">Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, activation attributes, and authorization to create the type.</span></span></summary>
        <returns><span data-ttu-id="eece9-508"><paramref name="typeName" />에서 지정한 새 인스턴스의 래퍼인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-508">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="eece9-509">실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-509">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-510">참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-510">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="eece9-511">호출 하려는 시도 <xref:System.AppDomain.CreateInstance%2A> 현재 응용 프로그램 도메인 없는 응용 프로그램 도메인을 대상에 대상 응용 프로그램 도메인에서 어셈블리의 로드를 성공적으로 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-511">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="eece9-512">하므로 <xref:System.Reflection.Assembly> 아닙니다 <xref:System.MarshalByRefObject>이 메서드는 반환 하려고 시도 하는 경우는 <xref:System.Reflection.Assembly> 현재 응용 프로그램 도메인에 로드 된 어셈블리에 대 한 공용 언어 런타임에서 현재 응용 프로그램 도메인에 어셈블리 로드를 시도 하며 부하 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-512">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="eece9-513">현재 응용 프로그램 도메인에 로드 된 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정이 다른 경우 먼저 로드 된 어셈블리에서 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-513">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-514">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-514">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-515"><paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-515"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-516"><paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-516"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-517">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-517">-or-</span></span> 
<span data-ttu-id="eece9-518">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-518">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-519">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-519">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-520"><paramref name="assemblyName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-520"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-521">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-521">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-522">일치하는 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-522">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-523">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-523">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span>  
  
<span data-ttu-id="eece9-524">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-524">-or-</span></span> 
 <span data-ttu-id="eece9-525"><paramref name="securityAttributes" />이 <see langword="null" />가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-525"><paramref name="securityAttributes" /> is not <see langword="null" />.</span></span> <span data-ttu-id="eece9-526">레거시 CAS 정책을 사용하지 않을 때는 <paramref name="securityAttributes" />는 <see langword="null." />이 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-526">When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null." /></span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-527"><paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-527"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="eece9-528">이 인스턴스가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-528">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-529">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-529">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-530">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-530">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-531">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-531">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-532">증명 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-532">to provide evidence.</span></span> <span data-ttu-id="eece9-533">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-533">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="eece9-534">모든 형식 멤버에 대 한 작업을 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-534">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="eece9-535">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="eece9-535">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="eece9-536">지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-536">Creates a new instance of a specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-537">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-537">The display name of the assembly.</span></span> <span data-ttu-id="eece9-538"><see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-538">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-539">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-539">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="eece9-540">지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-540">Creates a new instance of the specified type.</span></span> <span data-ttu-id="eece9-541">매개 변수에서는 형식이 정의되는 어셈블리와 해당 형식의 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-541">Parameters specify the assembly where the type is defined, and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="eece9-542"><paramref name="typeName" />에서 지정한 개체의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-542">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-543">메서드는 이것이 <xref:System.AppDomain.CreateInstance%2A> 고 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-543">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="eece9-544">이 메서드 호출에 대 한 기본 생성자를 `typeName`입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-544">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="eece9-545">참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-545">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="eece9-546">참조 된 <xref:System.Type.FullName%2A?displayProperty=nameWithType> 형식의 속성 `typeName`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-546">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-547">메서드에 대 한 초기 바인딩 호출을 수행한 `M` 형식의 개체의 `T1` 반환한 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, 메서드 형식의 개체의 메서드에 초기 바인딩된 호출을 수행 하 고 `T2` 어셈블리에 `C` 이외의 합니다 현재 어셈블리 또는 포함 된 어셈블리 `T1`, 어셈블리 `C` 현재 응용 프로그램 도메인에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-547">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="eece9-548">이 로드 된 초기 바인딩된 호출을 하는 경우에 발생 `T1.M()` 본문에서 수행 된를 <xref:System.Reflection.Emit.DynamicMethod>, 또는 다른 동적으로 생성 된 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-548">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="eece9-549">현재 도메인은 기본 도메인, 어셈블리에 있으면 `C` 프로세스가 종료 될 때까지 언로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-549">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="eece9-550">현재 도메인 나중에 어셈블리를 로드 하려고 할 경우 `C`, 로드가 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-550">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-551">다음 코드 예제에는 다른 응용 프로그램 도메인에서 코드를 실행 하는 가장 간단한 방법은 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-551">The following code example shows the simplest way to execute code in another application domain.</span></span> <span data-ttu-id="eece9-552">이 예제에서는 라는 클래스를 정의 `Worker` 에서 상속 되는 <xref:System.MarshalByRefObject>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-552">The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="eece9-553">`Worker` 클래스 실행 되는 응용 프로그램 도메인의 이름을 표시 하는 메서드를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-553">The `Worker` class defines a method that displays the name of the application domain in which it is executing.</span></span> <span data-ttu-id="eece9-554">인스턴스를 만듭니다 `Worker` 기본 응용 프로그램 도메인에 새 응용 프로그램 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-554">The example creates instances of `Worker` in the default application domain and in a new application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-555">포함 된 어셈블리 `Worker` 두 응용 프로그램 도메인에 로드 해야 하지만 새 응용 프로그램 도메인에만 존재 하는 다른 어셈블리를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-555">The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.</span></span>  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-556"><paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-556"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-557">일치하는 public 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-557">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-558"><paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-558"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-559"><paramref name="assemblyName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-559"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-560">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-560">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-561">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-561">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-562"><paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-562"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-563">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-563">-or-</span></span> 
<span data-ttu-id="eece9-564">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-564">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-565">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-565">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-566">어셈블리 매니페스트를 포함 하는 파일을 읽을 수에 대 한 매니페스트 파일이 아닌 다른 모듈에서 형식을 만드는 경우 또는 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-566">for the ability to read the file containing the assembly manifest, or if you are creating a type from a module other than the manifest file.</span></span> <span data-ttu-id="eece9-567">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-567">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-568">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-568">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-569">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-569">The display name of the assembly.</span></span> <span data-ttu-id="eece9-570"><see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-570">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-571">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-571">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="eece9-572">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-572">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="eece9-573">일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-573">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="eece9-574">이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-574">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="eece9-575">분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-575">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="eece9-576">지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-576">Creates a new instance of the specified type.</span></span> <span data-ttu-id="eece9-577">매개 변수에서는 형식이 정의되는 어셈블리, 해당 형식의 이름 및 활성화 특성의 배열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-577">Parameters specify the assembly where the type is defined, the name of the type, and an array of activation attributes.</span></span></summary>
        <returns><span data-ttu-id="eece9-578"><paramref name="typeName" />에서 지정한 개체의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-578">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-579">메서드는 이것이 <xref:System.AppDomain.CreateInstance%2A> 고 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-579">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="eece9-580">이 메서드 호출에 대 한 기본 생성자를 `typeName`입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-580">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="eece9-581">참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-581">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="eece9-582">참조 된 <xref:System.Type.FullName%2A?displayProperty=nameWithType> 형식의 속성 `typeName`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-582">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-583">메서드에 대 한 초기 바인딩 호출을 수행한 `M` 형식의 개체의 `T1` 반환한 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, 메서드 형식의 개체의 메서드에 초기 바인딩된 호출을 수행 하 고 `T2` 어셈블리에 `C` 이외의 합니다 현재 어셈블리 또는 포함 된 어셈블리 `T1`, 어셈블리 `C` 현재 응용 프로그램 도메인에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-583">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="eece9-584">이 로드 된 초기 바인딩된 호출을 하는 경우에 발생 `T1.M()` 본문에서 수행 된를 <xref:System.Reflection.Emit.DynamicMethod>, 또는 다른 동적으로 생성 된 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-584">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="eece9-585">현재 도메인은 기본 도메인, 어셈블리에 있으면 `C` 프로세스가 종료 될 때까지 언로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-585">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="eece9-586">현재 도메인 나중에 어셈블리를 로드 하려고 할 경우 `C`, 로드가 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-586">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-587"><paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-587"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-588">일치하는 public 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-588">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-589"><paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-589"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-590"><paramref name="assemblyName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-590"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-591">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-591">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-592">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-592">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-593">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-593">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-594"><paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-594"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-595">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-595">-or-</span></span> 
<span data-ttu-id="eece9-596">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-596">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-597">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-597">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-598">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-598">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-599">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-599">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-600">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-600">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-601">대리자의 인스턴스를 만들 때 관리 되지 않는 코드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-601">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="eece9-602">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="eece9-602">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="eece9-603">모든 형식 멤버에 대 한 작업을 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-603">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="eece9-604">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="eece9-604">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-605">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-605">The display name of the assembly.</span></span> <span data-ttu-id="eece9-606"><see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-606">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-607">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-607">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="eece9-608">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-608">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="eece9-609"><paramref name="typeName" /> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-609">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="eece9-610"><paramref name="bindingAttr" />가 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-610">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="eece9-611">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체의 검색을 가능하게 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-611">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="eece9-612"><paramref name="binder" />가 null이면 기본 바인더가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-612">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-613">생성자에 전달할 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-613">The arguments to pass to the constructor.</span></span> <span data-ttu-id="eece9-614">이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-614">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="eece9-615">기본 생성자를 사용하려면 <paramref name="args" />가 빈 배열이거나 null이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-615">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="eece9-616">형식의 강제 변환을 제어하는 데 사용되는 문화권별 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-616">A culture-specific object used to govern the coercion of types.</span></span> <span data-ttu-id="eece9-617"><paramref name="culture" />가 <see langword="null" />이면 현재 스레드의 <see langword="CultureInfo" />가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-617">If <paramref name="culture" /> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="eece9-618">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-618">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="eece9-619">일반적으로 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-619">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object.</span></span> <span data-ttu-id="eece9-620">원격 개체를 활성화하는 데 필요한 URL을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-620">that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="eece9-621">이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-621">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="eece9-622">클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-622">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="eece9-623">분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-623">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="eece9-624">형식 이름의 대/소문자를 구분할지 여부, 만들 형식을 선택하는 데 사용되는 바인더와 바인딩 특성, 생성자의 인수, 문화권 및 활성화 특성을 지정하여, 지정한 어셈블리에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-624">Creates a new instance of the specified type defined in the specified assembly, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</span></span></summary>
        <returns><span data-ttu-id="eece9-625"><paramref name="typeName" />에서 지정한 개체의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-625">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-626">메서드는 이것이 <xref:System.AppDomain.CreateInstance%2A> 고 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-626">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="eece9-627">참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-627">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="eece9-628">참조 된 <xref:System.Type.FullName%2A?displayProperty=nameWithType> 형식의 속성 `typeName`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-628">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-629">메서드에 대 한 초기 바인딩 호출을 수행한 `M` 형식의 개체의 `T1` 반환한 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, 메서드 형식의 개체의 메서드에 초기 바인딩된 호출을 수행 하 고 `T2` 어셈블리에 `C` 이외의 합니다 현재 어셈블리 또는 포함 된 어셈블리 `T1`, 어셈블리 `C` 현재 응용 프로그램 도메인에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-629">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="eece9-630">이 로드 된 초기 바인딩된 호출을 하는 경우에 발생 `T1.M()` 본문에서 수행 된를 <xref:System.Reflection.Emit.DynamicMethod>, 또는 다른 동적으로 생성 된 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-630">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="eece9-631">현재 도메인은 기본 도메인, 어셈블리에 있으면 `C` 프로세스가 종료 될 때까지 언로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-631">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="eece9-632">현재 도메인 나중에 어셈블리를 로드 하려고 할 경우 `C`, 로드가 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-632">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-633">다음 샘플을 사용 하는 `ignoreCase` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-633">The following sample demonstrates the use of the `ignoreCase` parameter.</span></span>  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-634"><paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-634"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-635">일치하는 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-635">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-636"><paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-636"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-637"><paramref name="assemblyName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-637"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-638">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-638">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-639">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-639">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-640">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-640">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-641"><paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-641"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-642">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-642">-or-</span></span> 
 <span data-ttu-id="eece9-643"><paramref name="assemblyName" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-643"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-644">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-644">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-645">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-645">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-646">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-646">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-647">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-647">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-648">대리자의 인스턴스를 만들 때 관리 되지 않는 코드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-648">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="eece9-649">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="eece9-649">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="eece9-650">모든 형식 멤버에 대 한 작업을 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-650">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="eece9-651">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="eece9-651">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-652">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-652">The display name of the assembly.</span></span> <span data-ttu-id="eece9-653"><see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-653">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-654">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-654">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="eece9-655">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-655">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="eece9-656"><paramref name="typeName" /> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-656">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="eece9-657"><paramref name="bindingAttr" />가 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-657">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="eece9-658">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체의 검색을 가능하게 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-658">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="eece9-659"><paramref name="binder" />가 null이면 기본 바인더가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-659">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-660">생성자에 전달할 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-660">The arguments to pass to the constructor.</span></span> <span data-ttu-id="eece9-661">이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-661">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="eece9-662">기본 생성자를 사용하려면 <paramref name="args" />가 빈 배열이거나 null이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-662">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="eece9-663">형식의 강제 변환을 제어하는 데 사용되는 문화권별 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-663">A culture-specific object used to govern the coercion of types.</span></span> <span data-ttu-id="eece9-664"><paramref name="culture" />가 <see langword="null" />이면 현재 스레드의 <see langword="CultureInfo" />가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-664">If <paramref name="culture" /> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="eece9-665">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-665">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="eece9-666">일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-666">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="eece9-667">이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-667">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="eece9-668">클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-668">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="eece9-669">분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-669">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="eece9-670"><paramref name="typeName" />의 생성을 인증하는 데 사용하는 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-670">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="eece9-671">지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-671">Creates a new instance of the specified type.</span></span> <span data-ttu-id="eece9-672">매개 변수에서는 형식의 이름 및 형식을 찾고 만들 수 있는 방법을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-672">Parameters specify the name of the type, and how it is found and created.</span></span></summary>
        <returns><span data-ttu-id="eece9-673"><paramref name="typeName" />에서 지정한 개체의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-673">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-674">메서드는 이것이 <xref:System.AppDomain.CreateInstance%2A> 고 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-674">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="eece9-675">참조 <xref:System.Reflection.AssemblyName> 형식의 `assemblyName`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-675">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="eece9-676">참조 된 <xref:System.Type.FullName%2A?displayProperty=nameWithType> 형식의 속성 `typeName`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-676">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-677">메서드에 대 한 초기 바인딩 호출을 수행한 `M` 형식의 개체의 `T1` 반환한 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, 메서드 형식의 개체의 메서드에 초기 바인딩된 호출을 수행 하 고 `T2` 어셈블리에 `C` 이외의 합니다 현재 어셈블리 또는 포함 된 어셈블리 `T1`, 어셈블리 `C` 현재 응용 프로그램 도메인에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-677">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="eece9-678">이 로드 된 초기 바인딩된 호출을 하는 경우에 발생 `T1.M()` 본문에서 수행 된를 <xref:System.Reflection.Emit.DynamicMethod>, 또는 다른 동적으로 생성 된 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-678">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="eece9-679">현재 도메인은 기본 도메인, 어셈블리에 있으면 `C` 프로세스가 종료 될 때까지 언로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-679">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="eece9-680">현재 도메인 나중에 어셈블리를 로드 하려고 할 경우 `C`, 로드가 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-680">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-681">다음 샘플을 사용 하는 `ignoreCase` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-681">The following sample demonstrates the use of the `ignoreCase` parameter.</span></span>  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-682"><paramref name="assemblyName" /> 또는 <paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-682"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-683">일치하는 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-683">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-684"><paramref name="assemblyName" />에서 <paramref name="typename" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-684"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-685"><paramref name="assemblyName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-685"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-686">호출자에게 이 생성자를 호출할 수 있는 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-686">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-687">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-687">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-688">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-688">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-689"><paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-689"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-690">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-690">-or-</span></span> 
<span data-ttu-id="eece9-691">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-691">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-692">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-692">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-693">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-693">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-694">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-694">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-695">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-695">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-696">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-696">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-697">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-697">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="eece9-698">모든 형식 멤버에 대 한 작업을 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-698">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="eece9-699">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="eece9-699">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="eece9-700">지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-700">Creates a new instance of a specified type defined in the specified assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="eece9-701">경로를 포함하여 요청된 형식을 정의하는 어셈블리가 포함된 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-701">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="eece9-702">어셈블리는 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 메서드를 사용하여 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-702">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-703">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-703">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="eece9-704">지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-704">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="eece9-705">새 인스턴스에 대한 래퍼인 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-705">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="eece9-706">실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-706">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-707">에 대 한 기본 생성자를 `typeName` 가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-707">The default constructor for `typeName` is invoked.</span></span>  
  
 <span data-ttu-id="eece9-708">자세한 내용은 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-708">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="eece9-709">경우는 <xref:System.AppDomain.CreateInstanceFrom%2A> 메서드는 호출 되는 응용 프로그램 도메인 이외의 대상 응용 프로그램 도메인에서 인스턴스를 만드는 데, 어셈블리는 대상 응용 프로그램 도메인에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-709">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="eece9-710">그러나 인스턴스 호출 응용 프로그램 도메인에서 래핑 해제 된 경우 특정 방식으로 래핑되지 않은 인스턴스를 사용 하 여 호출 응용 프로그램 도메인에 로드 될 어셈블리를 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-710">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="eece9-711">예를 들어, 그 형식 정보를 요청, 해당 메서드를 호출 하기 위해 런타임에 바인딩된 인스턴스 래핑 해제 된 후입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-711">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="eece9-712">어셈블리 호출 응용 프로그램 도메인에 로드 되 면 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-712">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="eece9-713">동일한 어셈블리의 다른 버전 이전에 호출 응용 프로그램 도메인에 로드 하는 경우 또는 호출 응용 프로그램 도메인의 로드 경로 같은 대상 응용 프로그램 도메인, 예외와 다른 경우 <xref:System.MissingMethodException> 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-713">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="eece9-714">호출 응용 프로그램 도메인 인스턴스 형식의 초기 바인딩 호출 하는 경우 <xref:System.InvalidCastException> 인스턴스 캐스팅 하려고 시도 하는 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-714">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-715">다음 예제에서는 사용 하는 방법의 <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> 메서드 오버 로드를 대상 응용 프로그램 도메인에서 개체의 인스턴스를 만들고 해당 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-715">The following example shows how to use the <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> method overload to create an instance of an object in a target application domain and call its methods.</span></span>  
  
 <span data-ttu-id="eece9-716">이 예제에서는 정의 `MarshallableExample` 클래스를 응용 프로그램 도메인 경계를 넘어 마샬링될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-716">The example defines the `MarshallableExample` class, which can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="eece9-717">이 예제에서는 현재 실행 중인 어셈블리에 대 한 경로 빌드, 대상 응용 프로그램 도메인을 만들고 사용 하는 <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> 메서드 오버 로드의 인스턴스를 만들고 예제 어셈블리의 대상 응용 프로그램 도메인에 로드 `MarshallableExample`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-717">The example builds a path to the currently executing assembly, creates a target application domain, and uses the <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> method overload to load the example assembly into the target application domain and create an instance of `MarshallableExample`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-718">이 예제에서는 절대 경로 있지만 상대 경로도 때문에 작동 합니다 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 메서드를 사용 하 여 어셈블리를 로드 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-718">The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method is used to load the assembly.</span></span>  
  
 <span data-ttu-id="eece9-719">개체 핸들에 대 한 래핑 해제 한 후 예제에 개체를 사용 하는 대상 응용 프로그램 도메인에서 세 가지 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-719">After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:</span></span>  
  
-   <span data-ttu-id="eece9-720">리플렉션을 사용 하 여 런타임에 바인딩을 사용 하 여 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-720">Invoking a method with late binding, using reflection.</span></span> <span data-ttu-id="eece9-721">이 호출자의 응용 프로그램 도메인에 로드 될 어셈블리를 사용 하면 형식 정보가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-721">This requires type information, which causes the assembly to be loaded into the application domain of the caller.</span></span> <span data-ttu-id="eece9-722">(이 예제에서는 이미 로드 됩니다.)</span><span class="sxs-lookup"><span data-stu-id="eece9-722">(In this example, it is already loaded.)</span></span>  
  
-   <span data-ttu-id="eece9-723">호출자와 호출 수신자 모두에 알려진 인터페이스 개체를 캐스팅 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-723">Casting the object to an interface known to both the caller and the callee.</span></span> <span data-ttu-id="eece9-724">인터페이스를 호출 하는 어셈블리 또는 호출자와 호출 수신자에서 참조 하는 세 번째 어셈블리에 정의 된 경우 호출된 된 어셈블리는 호출자의 응용 프로그램 도메인에 로드 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-724">If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.</span></span>  
  
-   <span data-ttu-id="eece9-725">호출자에 게 해당 형식이 알려지지 경우 직접 개체를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-725">Using the object directly when its type is known to the caller.</span></span> <span data-ttu-id="eece9-726">어셈블리는 호출자의 응용 프로그램 도메인에 로드 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-726">The assembly must be loaded into the application domain of the caller.</span></span>  
  
 <span data-ttu-id="eece9-727">파생 호출자가 호출자의 응용 프로그램 도메인에서 호출된 되는 어셈블리 로드 방지 하는 또 다른 방법은 것을 <xref:System.MarshalByRefObject> 클래스 및 대상 응용 프로그램 도메인에서 실행할 수 있는 메서드를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-727">Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain.</span></span> <span data-ttu-id="eece9-728">해당 메서드 수 리플렉션을 사용 하 여 대상 어셈블리를 검사할 대상 어셈블리가 이미 대상 응용 프로그램 도메인에 로드 하기 때문에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-728">That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain.</span></span> <span data-ttu-id="eece9-729">예제를 참조 합니다 <xref:System.AppDomain.DynamicDirectory%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-729">See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.</span></span>  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-730"><paramref name="assemblyFile" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-730"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-731">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-731">-or-</span></span> 
 <span data-ttu-id="eece9-732"><paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-732"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-733"><paramref name="assemblyFile" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-733"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-734"><paramref name="assemblyFile" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-734"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-735">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-735">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-736">매개 변수가 없는 public 생성자를 찾지 못한 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-736">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-737">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-737">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-738"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-738"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-739">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-739">-or-</span></span> 
<span data-ttu-id="eece9-740">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-740">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-741">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-741">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="eece9-742">이 인스턴스가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-742">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-743">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-743">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-744">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-744">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-745">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-745">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="eece9-746">경로를 포함하여 요청된 형식을 정의하는 어셈블리가 포함된 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-746">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="eece9-747">어셈블리는 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 메서드를 사용하여 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-747">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-748">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-748">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="eece9-749">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-749">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="eece9-750">일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-750">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="eece9-751">이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-751">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="eece9-752">분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-752">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="eece9-753">지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-753">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="eece9-754">새 인스턴스에 대한 래퍼인 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-754">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="eece9-755">실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-755">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-756">에 대 한 기본 생성자를 `typeName` 가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-756">The default constructor for `typeName` is invoked.</span></span>  
  
 <span data-ttu-id="eece9-757">이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-757">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="eece9-758">경우는 <xref:System.AppDomain.CreateInstanceFrom%2A> 메서드는 호출 되는 응용 프로그램 도메인 이외의 대상 응용 프로그램 도메인에서 인스턴스를 만드는 데, 어셈블리는 대상 응용 프로그램 도메인에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-758">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="eece9-759">그러나 인스턴스 호출 응용 프로그램 도메인에서 래핑 해제 된 경우 특정 방식으로 래핑되지 않은 인스턴스를 사용 하 여 호출 응용 프로그램 도메인에 로드 될 어셈블리를 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-759">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="eece9-760">예를 들어, 그 형식 정보를 요청, 해당 메서드를 호출 하기 위해 런타임에 바인딩된 인스턴스 래핑 해제 된 후입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-760">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="eece9-761">어셈블리 호출 응용 프로그램 도메인에 로드 되 면 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-761">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="eece9-762">동일한 어셈블리의 다른 버전 이전에 호출 응용 프로그램 도메인에 로드 하는 경우 또는 호출 응용 프로그램 도메인의 로드 경로 같은 대상 응용 프로그램 도메인, 예외와 다른 경우 <xref:System.MissingMethodException> 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-762">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="eece9-763">호출 응용 프로그램 도메인 인스턴스 형식의 초기 바인딩 호출 하는 경우 <xref:System.InvalidCastException> 인스턴스 캐스팅 하려고 시도 하는 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-763">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-764"><paramref name="assemblyFile" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-764"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-765"><paramref name="assemblyFile" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-765"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-766"><paramref name="assemblyFile" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-766"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-767">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-767">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-768">일치하는 public 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-768">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-769">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-769">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-770">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-770">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-771"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-771"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-772">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-772">-or-</span></span> 
<span data-ttu-id="eece9-773">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-773">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-774">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-774">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="eece9-775">이 인스턴스가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-775">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-776">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-776">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-777">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-777">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-778">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-778">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="eece9-779">경로를 포함하여 요청된 형식을 정의하는 어셈블리가 포함된 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-779">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="eece9-780">어셈블리는 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 메서드를 사용하여 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-780">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-781">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-781">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="eece9-782">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-782">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="eece9-783"><paramref name="typeName" /> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-783">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="eece9-784"><paramref name="bindingAttr" />가 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-784">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="eece9-785">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체 검색을 사용할 수 있도록 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-785">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="eece9-786"><paramref name="binder" />가 null이면 기본 바인더가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-786">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-787">생성자에 전달할 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-787">The arguments to pass to the constructor.</span></span> <span data-ttu-id="eece9-788">이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-788">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="eece9-789">기본 생성자를 사용하려면 <paramref name="args" />가 빈 배열이거나 null이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-789">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="eece9-790"><paramref name="typeName" /> 생성자에 대해 선언된 공식적인 형식에 <paramref name="args" />를 강제로 적용하는 것을 제어하는 문화권별 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-790">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="eece9-791"><paramref name="culture" />가 <see langword="null" />이면 현재 스레드의 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-791">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="eece9-792">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-792">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="eece9-793">일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-793">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="eece9-794">이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-794">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="eece9-795">클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-795">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="eece9-796">분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-796">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="eece9-797">지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-797">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="eece9-798">새 인스턴스에 대한 래퍼인 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-798">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="eece9-799">실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-799">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-800">자세한 내용은 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-800">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="eece9-801">경우는 <xref:System.AppDomain.CreateInstanceFrom%2A> 메서드는 호출 되는 응용 프로그램 도메인 이외의 대상 응용 프로그램 도메인에서 인스턴스를 만드는 데, 어셈블리는 대상 응용 프로그램 도메인에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-801">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="eece9-802">그러나 인스턴스 호출 응용 프로그램 도메인에서 래핑 해제 된 경우 특정 방식으로 래핑되지 않은 인스턴스를 사용 하 여 호출 응용 프로그램 도메인에 로드 될 어셈블리를 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-802">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="eece9-803">예를 들어, 그 형식 정보를 요청, 해당 메서드를 호출 하기 위해 런타임에 바인딩된 인스턴스 래핑 해제 된 후입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-803">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="eece9-804">어셈블리 호출 응용 프로그램 도메인에 로드 되 면 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-804">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="eece9-805">동일한 어셈블리의 다른 버전 이전에 호출 응용 프로그램 도메인에 로드 하는 경우 또는 호출 응용 프로그램 도메인의 로드 경로 같은 대상 응용 프로그램 도메인, 예외와 다른 경우 <xref:System.MissingMethodException> 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-805">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="eece9-806">호출 응용 프로그램 도메인 인스턴스 형식의 초기 바인딩 호출 하는 경우 <xref:System.InvalidCastException> 인스턴스 캐스팅 하려고 시도 하는 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-806">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-807"><paramref name="assemblyFile" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-807"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-808">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-808">-or-</span></span> 
 <span data-ttu-id="eece9-809"><paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-809"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-810">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-810">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-811">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-811">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-812"><paramref name="assemblyFile" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-812"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-813"><paramref name="assemblyFile" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-813"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-814">일치하는 public 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-814">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-815">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-815">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-816"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-816"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-817">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-817">-or-</span></span> 
 <span data-ttu-id="eece9-818"><paramref name="assemblyFile" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-818"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-819">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-819">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="eece9-820">이 인스턴스가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-820">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-821">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-821">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-822">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-822">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-823">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-823">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="eece9-824">경로를 포함하여 요청된 형식을 정의하는 어셈블리가 포함된 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-824">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="eece9-825">어셈블리는 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 메서드를 사용하여 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-825">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-826">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-826">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="eece9-827">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-827">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="eece9-828"><paramref name="typeName" /> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-828">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="eece9-829"><paramref name="bindingAttr" />가 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-829">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="eece9-830">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체 검색을 사용할 수 있도록 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-830">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="eece9-831"><paramref name="binder" />가 null이면 기본 바인더가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-831">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-832">생성자에 전달할 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-832">The arguments to pass to the constructor.</span></span> <span data-ttu-id="eece9-833">이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-833">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="eece9-834">기본 생성자를 사용하려면 <paramref name="args" />가 빈 배열이거나 null이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-834">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="eece9-835"><paramref name="typeName" /> 생성자에 대해 선언된 공식적인 형식에 <paramref name="args" />를 강제로 적용하는 것을 제어하는 문화권별 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-835">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="eece9-836"><paramref name="culture" />가 <see langword="null" />이면 현재 스레드의 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-836">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="eece9-837">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-837">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="eece9-838">일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-838">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="eece9-839">이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-839">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="eece9-840">클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-840">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="eece9-841">분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-841">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="eece9-842"><paramref name="typeName" />의 생성을 인증하는 데 사용하는 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-842">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="eece9-843">지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-843">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="eece9-844">새 인스턴스에 대한 래퍼인 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-844">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="eece9-845">실제 개체에 액세스하려면 반환 값은 래핑되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-845">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-846">이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-846">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="eece9-847">경우는 <xref:System.AppDomain.CreateInstanceFrom%2A> 메서드는 호출 되는 응용 프로그램 도메인 이외의 대상 응용 프로그램 도메인에서 인스턴스를 만드는 데, 어셈블리는 대상 응용 프로그램 도메인에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-847">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="eece9-848">그러나 인스턴스 호출 응용 프로그램 도메인에서 래핑 해제 된 경우 특정 방식으로 래핑되지 않은 인스턴스를 사용 하 여 호출 응용 프로그램 도메인에 로드 될 어셈블리를 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-848">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="eece9-849">예를 들어, 그 형식 정보를 요청, 해당 메서드를 호출 하기 위해 런타임에 바인딩된 인스턴스 래핑 해제 된 후입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-849">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="eece9-850">어셈블리 호출 응용 프로그램 도메인에 로드 되 면 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-850">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="eece9-851">동일한 어셈블리의 다른 버전 이전에 호출 응용 프로그램 도메인에 로드 하는 경우 또는 호출 응용 프로그램 도메인의 로드 경로 같은 대상 응용 프로그램 도메인, 예외와 다른 경우 <xref:System.MissingMethodException> 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-851">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="eece9-852">호출 응용 프로그램 도메인 인스턴스 형식의 초기 바인딩 호출 하는 경우 <xref:System.InvalidCastException> 인스턴스 캐스팅 하려고 시도 하는 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-852">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-853"><paramref name="assemblyFile" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-853"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-854">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-854">-or-</span></span> 
 <span data-ttu-id="eece9-855"><paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-855"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-856">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-856">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span>  
  
<span data-ttu-id="eece9-857">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-857">-or-</span></span> 
 <span data-ttu-id="eece9-858"><paramref name="securityAttributes" />이 <see langword="null" />가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-858"><paramref name="securityAttributes" /> is not <see langword="null" />.</span></span> <span data-ttu-id="eece9-859">레거시 CAS 정책을 사용하지 않을 때는 <paramref name="securityAttributes" />는 <see langword="null" />이 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-859">When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-860">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-860">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-861"><paramref name="assemblyFile" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-861"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-862"><paramref name="assemblyFile" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-862"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-863">일치하는 public 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-863">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-864">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-864">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-865"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-865"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-866">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-866">-or-</span></span> 
<span data-ttu-id="eece9-867">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-867">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-868">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-868">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="eece9-869">이 인스턴스가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-869">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-870">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-870">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-871">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-871">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-872">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-872">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-873">증명 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-873">to provide evidence.</span></span> <span data-ttu-id="eece9-874">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-874">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="eece9-875">지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-875">Creates a new instance of a specified type defined in the specified assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-876">요청된 형식을 정의하는 어셈블리의 파일 이름과 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-876">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-877">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-877">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="eece9-878">지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-878">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="eece9-879">요청된 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-879">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-880">메서드는 이것이 <xref:System.AppDomain.CreateInstanceFrom%2A> 고 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-880">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="eece9-881">이 메서드 호출에 대 한 기본 생성자를 `typeName`입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-881">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="eece9-882">자세한 내용은 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-882">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-883"><paramref name="assemblyName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-883"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-884">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-884">-or-</span></span> 
 <span data-ttu-id="eece9-885"><paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-885"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-886">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-886">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-887"><paramref name="assemblyName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-887"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-888"><paramref name="assemblyName" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-888"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-889">매개 변수가 없는 public 생성자를 찾지 못한 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-889">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-890">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-890">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-891"><paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-891"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-892">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-892">-or-</span></span> 
<span data-ttu-id="eece9-893">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-893">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-894">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-894">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-895">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-895">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-896">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-896">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-897">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-897">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-898">요청된 형식을 정의하는 어셈블리의 파일 이름과 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-898">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-899">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름입니다(<see cref="P:System.Type.FullName" /> 속성 참조).</span><span class="sxs-lookup"><span data-stu-id="eece9-899">The fully qualified name of the requested type, including the namespace but not the assembly (see the <see cref="P:System.Type.FullName" /> property).</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="eece9-900">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-900">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="eece9-901">일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-901">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="eece9-902">이 매개 변수는 클라이언트 활성 개체와 관련이 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-902">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="eece9-903">분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-903">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="eece9-904">지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-904">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="eece9-905">요청된 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-905">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-906">메서드는 이것이 <xref:System.AppDomain.CreateInstanceFrom%2A> 고 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-906">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="eece9-907">이 메서드 호출에 대 한 기본 생성자를 `typeName`입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-907">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="eece9-908">이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-908">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-909"><paramref name="assemblyName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-909"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-910">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-910">-or-</span></span> 
 <span data-ttu-id="eece9-911"><paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-911"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-912">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-912">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-913">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-913">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-914"><paramref name="assemblyName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-914"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-915"><paramref name="assemblyName" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-915"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-916">매개 변수가 없는 public 생성자를 찾지 못한 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-916">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-917">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-917">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-918"><paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-918"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-919">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-919">-or-</span></span> 
<span data-ttu-id="eece9-920">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-920">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-921">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-921">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-922">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-922">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-923">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-923">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-924">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-924">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="eece9-925">요청된 형식을 정의하는 어셈블리의 파일 이름과 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-925">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-926">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-926">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="eece9-927">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-927">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="eece9-928"><paramref name="typeName" /> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-928">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="eece9-929"><paramref name="bindingAttr" />가 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-929">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="eece9-930">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체 검색을 사용할 수 있도록 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-930">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="eece9-931"><paramref name="binder" />가 null이면 기본 바인더가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-931">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-932">생성자에 전달할 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-932">The arguments to pass to the constructor.</span></span> <span data-ttu-id="eece9-933">이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-933">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="eece9-934">기본 생성자를 사용하려면 <paramref name="args" />가 빈 배열이거나 null이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-934">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="eece9-935"><paramref name="typeName" /> 생성자에 대해 선언된 공식적인 형식에 <paramref name="args" />를 강제로 적용하는 것을 제어하는 문화권별 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-935">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="eece9-936"><paramref name="culture" />가 <see langword="null" />이면 현재 스레드의 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-936">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="eece9-937">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-937">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="eece9-938">일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-938">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="eece9-939">이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-939">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="eece9-940">클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-940">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="eece9-941">분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-941">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="eece9-942">형식 이름의 대/소문자를 구분할지 여부, 만들 형식을 선택하는 데 사용되는 바인더와 바인딩 특성, 생성자의 인수, 문화권 및 활성화 특성을 지정하여, 지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-942">Creates a new instance of the specified type defined in the specified assembly file, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</span></span></summary>
        <returns><span data-ttu-id="eece9-943">요청된 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-943">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-944">메서드는 이것이 <xref:System.AppDomain.CreateInstanceFrom%2A> 고 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-944">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="eece9-945">이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-945">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-946"><paramref name="assemblyName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-946"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-947">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-947">-or-</span></span> 
 <span data-ttu-id="eece9-948"><paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-948"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-949">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-949">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-950">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-950">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-951"><paramref name="assemblyName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-951"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-952"><paramref name="assemblyName" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-952"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-953">일치하는 public 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-953">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-954">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-954">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-955"><paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-955"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-956">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-956">-or-</span></span> 
 <span data-ttu-id="eece9-957"><paramref name="assemblyName" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-957"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime that the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-958">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-958">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-959">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-959">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-960">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-960">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-961">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-961">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-962">요청된 형식을 정의하는 어셈블리의 파일 이름과 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-962">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="eece9-963">네임스페이스만 포함하고 어셈블리는 포함하지 않는 요청된 형식의 정규화된 이름으로, <see cref="P:System.Type.FullName" /> 속성에 의해 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-963">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="eece9-964">검색할 때 대/소문자를 구분할지를 지정하는 부울 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-964">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="eece9-965"><paramref name="typeName" /> 생성자 검색에 영향을 미치는 0 또는 그 이상의 비트 플래그 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-965">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="eece9-966"><paramref name="bindingAttr" />가 0이면 대/소문자를 구분한 public 생성자 검색이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-966">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="eece9-967">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체 검색을 사용할 수 있도록 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-967">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="eece9-968"><paramref name="binder" />가 null이면 기본 바인더가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-968">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-969">생성자에 전달할 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-969">The arguments to pass to the constructor.</span></span> <span data-ttu-id="eece9-970">이 인수 배열은 호출할 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-970">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="eece9-971">기본 생성자를 사용하려면 <paramref name="args" />가 빈 배열이거나 null이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-971">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="eece9-972"><paramref name="typeName" /> 생성자에 대해 선언된 공식적인 형식에 <paramref name="args" />를 강제로 적용하는 것을 제어하는 문화권별 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-972">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="eece9-973"><paramref name="culture" />가 <see langword="null" />이면 현재 스레드의 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-973">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="eece9-974">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-974">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="eece9-975">일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-975">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="eece9-976">이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-976">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="eece9-977">클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-977">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="eece9-978">분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-978">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="eece9-979"><paramref name="typeName" />의 생성을 인증하는 데 사용하는 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-979">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="eece9-980">지정한 어셈블리 파일에 정의된 지정한 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-980">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="eece9-981">요청된 개체이거나, <paramref name="typeName" />이 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-981">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-982">메서드는 이것이 <xref:System.AppDomain.CreateInstanceFrom%2A> 고 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-982">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="eece9-983">이 메서드에 대 한 자세한 내용은 참조는 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-983">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-984"><paramref name="assemblyName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-984"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-985">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-985">-or-</span></span> 
 <span data-ttu-id="eece9-986"><paramref name="typeName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-986"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-987">호출자가 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 개체에 대한 활성화 특성을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-987">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-988">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-988">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-989"><paramref name="assemblyName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-989"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="eece9-990"><paramref name="assemblyName" />에서 <paramref name="typeName" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-990"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-991">일치하는 public 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-991">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="eece9-992">호출자에게 이 생성자를 호출할 수 있는 충분한 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-992">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-993"><paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-993"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-994">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-994">-or-</span></span> 
<span data-ttu-id="eece9-995">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-995">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-996">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-996">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="eece9-997">어셈블리 매니페스트가 들어 있는 파일을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-997">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="eece9-998">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="eece9-998">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-999">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-999">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-1000">현재 <see cref="T:System.Threading.Thread" />에 대한 현재 응용 프로그램 도메인을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1000">Gets the current application domain for the current <see cref="T:System.Threading.Thread" />.</span></span></summary>
        <value><span data-ttu-id="eece9-1001">현재 응용 프로그램 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1001">The current application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="eece9-1002">다음 코드 예제에서는 새 응용 프로그램 도메인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1002">The following code example creates a new application domain.</span></span> <span data-ttu-id="eece9-1003">합니다 <xref:System.AppDomain.CurrentDomain%2A> 속성은 가져오는 데는 <xref:System.AppDomain> 현재 응용 프로그램 도메인을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1003">The <xref:System.AppDomain.CurrentDomain%2A> property is used to obtain an <xref:System.AppDomain> object that represents the current application domain.</span></span> <span data-ttu-id="eece9-1004"><xref:System.AppDomain.FriendlyName%2A> 속성은 명령줄에서 다음 표시 되는 현재 응용 프로그램 도메인의 이름을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1004">The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="eece9-1005">현재 응용 프로그램 도메인에서 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1005">Defines a dynamic assembly in the current application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-1006">동적 어셈블리의 고유 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1006">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="eece9-1007">동적 어셈블리의 액세스 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1007">The access mode for the dynamic assembly.</span></span></param>
        <summary><span data-ttu-id="eece9-1008">지정한 이름 및 액세스 모드를 사용하여 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1008">Defines a dynamic assembly with the specified name and access mode.</span></span></summary>
        <returns><span data-ttu-id="eece9-1009">지정한 이름 및 액세스 모드를 사용하는 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1009">A dynamic assembly with the specified name and access mode.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1010">이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의 하만 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1010">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="eece9-1011">자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1011">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1012">동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하 여 <xref:System.AppDomain.DefineDynamicAssembly%2A> 동적 어셈블리를 포함 하는 증명 정보를 제공 하는 증명 정보 및 사용 권한을 지정 하는 방법 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에서 `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="eece9-1012">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="eece9-1013">포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL 확인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1013">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="eece9-1014">이 방법의 제한 사항은를 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드를 사용 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1014">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1015">다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1015">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="eece9-1016">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1016">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="eece9-1017">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1017">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1018"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1018"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-1019"><paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1019">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-1020">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1020">-or-</span></span> 
<span data-ttu-id="eece9-1021"><paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1021">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1022">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1022">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-1023">동적 어셈블리의 고유 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1023">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="eece9-1024">동적 어셈블리의 액세스 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1024">The access mode for the dynamic assembly.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="eece9-1025">어셈블리에 적용되는 특성의 열거형 목록이거나 특성이 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1025">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="eece9-1026">지정한 이름, 액세스 모드 및 사용자 지정 특성을 사용하여 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1026">Defines a dynamic assembly with the specified name, access mode, and custom attributes.</span></span></summary>
        <returns><span data-ttu-id="eece9-1027">지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1027">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1028">이 메서드 오버 로드를 사용 하 여 동적 어셈블리를 만들 때 적용 하지 않으면 올바르게 작동 하지 않는 특성을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1028">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="eece9-1029">예를 들어, 보안 등의 특성 <xref:System.Security.SecurityTransparentAttribute> 고 <xref:System.Security.SecurityCriticalAttribute> 동적 어셈블리를 만든 후 추가 된 경우 올바르게 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1029">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="eece9-1030">현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에이 메서드를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1030">This method should be used only to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="eece9-1031">이 제한에 대 한 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1031">For more information about this restriction, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 <span data-ttu-id="eece9-1032">이 메서드는 오버 로드는 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1032">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1033">다음 코드 샘플에 있는 동적 어셈블리를 만드는 방법을 보여 줍니다는 <xref:System.Security.SecurityTransparentAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1033">The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>.</span></span> <span data-ttu-id="eece9-1034">배열의 요소와 특성을 지정 해야 합니다 <xref:System.Reflection.Emit.CustomAttributeBuilder> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1034">The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.</span></span>  
  
 <span data-ttu-id="eece9-1035">만드는 첫 번째 단계는 <xref:System.Reflection.Emit.CustomAttributeBuilder> 특성에 대 한 생성자를 가져오는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1035">The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute.</span></span> <span data-ttu-id="eece9-1036">생성자에 매개 변수가 사용 되지 않으므로 <xref:System.Type.GetConstructor%2A> 메서드는 빈 배열을 사용 하 여 <xref:System.Type> 매개 변수의 형식을 나타내는 개체를 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1036">The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters.</span></span> <span data-ttu-id="eece9-1037">결과 전달 하는 두 번째 단계입니다 <xref:System.Reflection.ConstructorInfo> 개체에 대 한 생성자에는 <xref:System.Reflection.Emit.CustomAttributeBuilder> 형식의 빈 배열 함께 클래스 <xref:System.Object> 인수를 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1037">The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.</span></span>  
  
 <span data-ttu-id="eece9-1038">결과 <xref:System.Reflection.Emit.CustomAttributeBuilder> 전달 되어를 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드로 배열의 유일한 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1038">The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the <xref:System.AppDomain.DefineDynamicAssembly%2A> method as the only element of an array.</span></span>  
  
 <span data-ttu-id="eece9-1039">예제 코드는 새 동적 어셈블리에서 모듈 및 형식을 정의 하 고 어셈블리의 특성을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1039">The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.</span></span>  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1040"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1040"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-1041"><paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1041">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-1042">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1042">-or-</span></span> 
<span data-ttu-id="eece9-1043"><paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함하는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1043">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1044">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1044">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-1045">동적 어셈블리의 고유 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1045">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="eece9-1046">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1046">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="evidence"><span data-ttu-id="eece9-1047">동적 어셈블리에 제공된 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1047">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="eece9-1048">증명 정보는 변경되지 않고 정책 결정을 위한 최종 증명 정보로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1048">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <summary><span data-ttu-id="eece9-1049">지정한 이름, 액세스 모드 및 증명 정보를 사용하여 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1049">Defines a dynamic assembly using the specified name, access mode, and evidence.</span></span></summary>
        <returns><span data-ttu-id="eece9-1050">지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1050">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1051">호출자가 제공할 수 있습니다를 완전히 신뢰할 수 있는 해당 `evidence` 동적 정의할 때 <xref:System.Reflection.Assembly>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1051">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="eece9-1052">런타임에 매핑될는 <xref:System.Security.Policy.Evidence> 부여 된 권한을 확인 하는 보안 정책을 통해.</span><span class="sxs-lookup"><span data-stu-id="eece9-1052">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="eece9-1053">호출자가 null을 제공 해야 합니다를 부분적으로 신뢰할 수 있는 `evidence`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1053">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="eece9-1054">경우 `evidence` 은 `null`런타임에서 사용 권한 집합을 복사, 현재가 권한을 부여 하 고 호출자에서 집합을 거부 하는, 즉 <xref:System.Reflection.Assembly> 동적 <xref:System.Reflection.Assembly> 정의 되 고 정책을 확인할 것으로 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1054">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="eece9-1055">경우 동적 <xref:System.Reflection.Assembly> 는 디스크에 저장 후속 로드 받을 위치에 연결 된 정책에 따라 승인 여기서는 <xref:System.Reflection.Assembly> 저장 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1055">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="eece9-1056">이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의 하만 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1056">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="eece9-1057">자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1057">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1058">동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하 여 <xref:System.AppDomain.DefineDynamicAssembly%2A> 동적 어셈블리를 포함 하는 증명 정보를 제공 하는 증명 정보 및 사용 권한을 지정 하는 방법 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에서 `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="eece9-1058">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="eece9-1059">포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL 확인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1059">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="eece9-1060">이 방법의 제한 사항은를 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드를 사용 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1060">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1061">다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1061">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="eece9-1062">코드 예제에서는 먼저의 인스턴스를 만들 하려고 `MyDynamicType` 를 호출 하 여는 <xref:System.AppDomain.CreateInstance%2A> 메서드는 잘못 된 어셈블리 이름 사용 하 여 결과 예외를 catch 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1062">First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.</span></span>  
  
 <span data-ttu-id="eece9-1063">코드 예제에서는 다음에 대 한 이벤트 처리기를 추가 합니다 <xref:System.AppDomain.AssemblyResolve> 이벤트의 인스턴스를 만들려고 시도 및 다시`MyDynamicType`입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1063">The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`.</span></span> <span data-ttu-id="eece9-1064">호출 하는 동안 <xref:System.AppDomain.CreateInstance%2A>, <xref:System.AppDomain.AssemblyResolve> 잘못 된 어셈블리에 대 한 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1064">During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly.</span></span> <span data-ttu-id="eece9-1065">이벤트 처리기 라는 형식을 포함 하는 동적 어셈블리를 만듭니다 `MyDynamicType`, 형식 매개 변수가 없는 생성자를 제공 하 고 새 동적 어셈블리를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1065">The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly.</span></span> <span data-ttu-id="eece9-1066">에 대 한 호출 <xref:System.AppDomain.CreateInstance%2A> 성공적으로 완료 한 다음에 대 한 생성자 및 `MyDynamicType` 콘솔에 메시지를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1066">The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1067"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1067"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-1068"><paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1068">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-1069">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1069">-or-</span></span> 
<span data-ttu-id="eece9-1070"><paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1070">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1071">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1071">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1072">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1072">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1073">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1073">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-1074">동적 어셈블리의 고유 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1074">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="eece9-1075">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1075">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="eece9-1076">어셈블리가 저장될 디렉터리 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1076">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="eece9-1077"><paramref name="dir" />가 <see langword="null" />이면 현재 디렉터리가 기본값으로 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1077">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <summary><span data-ttu-id="eece9-1078">지정한 이름, 액세스 모드 및 저장소 디렉터리를 사용하여 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1078">Defines a dynamic assembly using the specified name, access mode, and storage directory.</span></span></summary>
        <returns><span data-ttu-id="eece9-1079">지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1079">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1080">이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의 하만 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1080">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="eece9-1081">자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1081">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1082">동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하 여 <xref:System.AppDomain.DefineDynamicAssembly%2A> 동적 어셈블리를 포함 하는 증명 정보를 제공 하는 증명 정보 및 사용 권한을 지정 하는 방법 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에서 `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="eece9-1082">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="eece9-1083">포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL 확인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1083">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="eece9-1084">이 방법의 제한 사항은를 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드를 사용 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1084">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1085">다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1085">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="eece9-1086">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1086">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="eece9-1087">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1087">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1088"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1088"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-1089"><paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1089">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-1090">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1090">-or-</span></span> 
<span data-ttu-id="eece9-1091"><paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1091">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1092">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1092">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-1093">동적 어셈블리의 고유 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1093">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="eece9-1094">동적 어셈블리의 액세스 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1094">The access mode for the dynamic assembly.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="eece9-1095">어셈블리에 적용되는 특성의 열거형 목록이거나 특성이 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1095">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <param name="securityContextSource"><span data-ttu-id="eece9-1096">보안 컨텍스트의 소스입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1096">The source of the security context.</span></span></param>
        <summary><span data-ttu-id="eece9-1097">지정한 이름, 액세스 모드 및 사용자 지정 특성과 보안 컨텍스트에 대해 지정한 소스를 사용하여 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1097">Defines a dynamic assembly with the specified name, access mode, and custom attributes, and using the specified source for its security context.</span></span></summary>
        <returns><span data-ttu-id="eece9-1098">지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1098">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1099">이 메서드 오버 로드를 사용 하 여 동적 어셈블리를 만들 때 적용 하지 않으면 올바르게 작동 하지 않는 특성을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1099">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="eece9-1100">예를 들어, 보안 등의 특성 <xref:System.Security.SecurityTransparentAttribute> 고 <xref:System.Security.SecurityCriticalAttribute> 동적 어셈블리를 만든 후 추가 된 경우 올바르게 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1100">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="eece9-1101">현재 응용 프로그램 도메인에서 동적 어셈블리를 정의에이 메서드를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1101">This method should be used only to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="eece9-1102">이 제한에 대 한 자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1102">For more information about this restriction, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1103"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1103"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-1104"><paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1104">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-1105">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1105">-or-</span></span> 
<span data-ttu-id="eece9-1106"><paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함하는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1106">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1107">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1107">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="eece9-1108"><paramref name="securityContextSource" />의 값이 열거형 값 중 하나가 아니었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1108">The value of <paramref name="securityContextSource" /> was not one of the enumeration values.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-1109">동적 어셈블리의 고유 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1109">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="eece9-1110">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1110">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="eece9-1111">어셈블리가 저장될 디렉터리 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1111">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="eece9-1112"><paramref name="dir" />가 <see langword="null" />이면 현재 디렉터리가 기본값으로 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1112">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="eece9-1113">동적 어셈블리에 제공된 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1113">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="eece9-1114">증명 정보는 변경되지 않고 정책 결정을 위한 최종 증명 정보로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1114">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <summary><span data-ttu-id="eece9-1115">지정한 이름, 액세스 모드, 저장소 디렉터리 및 증명 정보를 사용하여 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1115">Defines a dynamic assembly using the specified name, access mode, storage directory, and evidence.</span></span></summary>
        <returns><span data-ttu-id="eece9-1116">지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1116">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1117">호출자가 제공할 수 있습니다를 완전히 신뢰할 수 있는 해당 `evidence` 동적 정의할 때 <xref:System.Reflection.Assembly>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1117">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="eece9-1118">런타임에 매핑될는 <xref:System.Security.Policy.Evidence> 부여 된 권한을 확인 하는 보안 정책을 통해.</span><span class="sxs-lookup"><span data-stu-id="eece9-1118">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="eece9-1119">호출자가 null을 제공 해야 합니다를 부분적으로 신뢰할 수 있는 `evidence`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1119">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="eece9-1120">경우 `evidence` 은 `null`런타임에서 사용 권한 집합을 복사, 현재가 권한을 부여 하 고 호출자에서 집합을 거부 하는, 즉 <xref:System.Reflection.Assembly> 동적 <xref:System.Reflection.Assembly> 정의 되 고 정책을 확인할 것으로 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1120">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="eece9-1121">경우 동적 <xref:System.Reflection.Assembly> 는 디스크에 저장 후속 로드 받을 위치에 연결 된 정책에 따라 승인 여기서는 <xref:System.Reflection.Assembly> 저장 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1121">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="eece9-1122">이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의 하만 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1122">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="eece9-1123">자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1123">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1124">동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하 여 <xref:System.AppDomain.DefineDynamicAssembly%2A> 동적 어셈블리를 포함 하는 증명 정보를 제공 하는 증명 정보 및 사용 권한을 지정 하는 방법 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에서 `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="eece9-1124">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="eece9-1125">포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL 확인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1125">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="eece9-1126">이 방법의 제한 사항은를 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드를 사용 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1126">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1127">다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1127">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="eece9-1128">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1128">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="eece9-1129">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1129">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1130"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1130"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-1131"><paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1131">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-1132">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1132">-or-</span></span> 
<span data-ttu-id="eece9-1133"><paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1133">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1134">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1134">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1135">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1135">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1136">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1136">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-1137">동적 어셈블리의 고유 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1137">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="eece9-1138">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1138">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="eece9-1139">필수 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1139">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="eece9-1140">선택적 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1140">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="eece9-1141">거부된 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1141">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="eece9-1142">지정한 이름, 액세스 모드 및 권한 요청을 사용하여 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1142">Defines a dynamic assembly using the specified name, access mode, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="eece9-1143">지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1143">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1144">에 대 한 지정한 사용 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 동적 어셈블리가 저장 되 고 메모리로 다시 로드 하지 않는 한 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1144">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are not used unless the dynamic assembly has been saved and reloaded into memory.</span></span> <span data-ttu-id="eece9-1145">임시 어셈블리의 오버 로드를 사용 하는 디스크에 저장 되지 않은 대 한 사용 권한 요청을 지정 하는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 요청 된 사용 권한 및 공급 증명 정보를 지정 하는 메서드는 <xref:System.Security.Policy.Evidence> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1145">To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1146">동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하 여 <xref:System.AppDomain.DefineDynamicAssembly%2A> 동적 어셈블리를 포함 하는 증명 정보를 제공 하는 증명 정보 및 사용 권한을 지정 하는 방법 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에서 `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="eece9-1146">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="eece9-1147">포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL 확인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1147">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="eece9-1148">이 방법의 제한 사항은를 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드를 사용 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1148">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="eece9-1149">이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의 하만 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1149">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="eece9-1150">자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1150">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1151">다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1151">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="eece9-1152">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1152">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="eece9-1153">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1153">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1154"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1154"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-1155"><paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1155">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-1156">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1156">-or-</span></span> 
<span data-ttu-id="eece9-1157"><paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1157">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1158">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1158">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-1159">동적 어셈블리의 고유 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1159">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="eece9-1160">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1160">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="eece9-1161">동적 어셈블리를 저장할 디렉터리 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1161">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="eece9-1162"><paramref name="dir" />이 <see langword="null" />인 경우 현재 디렉터리가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1162">If <paramref name="dir" /> is <see langword="null" />, the current directory is used.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="eece9-1163">동적 어셈블리에서 모듈, 형식 및 멤버 만들기를 동기화하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1163"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="eece9-1164">어셈블리에 적용되는 특성의 열거형 목록이거나 특성이 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1164">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="eece9-1165">지정한 이름, 액세스 모드, 저장소 디렉터리 및 동기화 옵션을 사용하여 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1165">Defines a dynamic assembly using the specified name, access mode, storage directory, and synchronization option.</span></span></summary>
        <returns><span data-ttu-id="eece9-1166">지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1166">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1167">이 메서드 오버 로드를 사용 하 여 동적 어셈블리를 만들 때 적용 하지 않으면 올바르게 작동 하지 않는 특성을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1167">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="eece9-1168">예를 들어, 보안 등의 특성 <xref:System.Security.SecurityTransparentAttribute> 고 <xref:System.Security.SecurityCriticalAttribute> 동적 어셈블리를 만든 후 추가 된 경우 올바르게 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1168">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="eece9-1169">경우 `isSynchronized` 됩니다 `true`, 결과의 다음 메서드 <xref:System.Reflection.Emit.AssemblyBuilder> 동기화 됩니다: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>를 <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, 및 <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1169">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="eece9-1170">이러한 방법 중 두 가지 다른 스레드에서 호출 되는 경우 다른 완료 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1170">If two of these methods are called on different threads, one will block until the other is completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1171"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1171"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-1172"><paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1172">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-1173">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1173">-or-</span></span> 
<span data-ttu-id="eece9-1174"><paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함하는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1174">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1175">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1175">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-1176">동적 어셈블리의 고유 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1176">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="eece9-1177">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1177">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="evidence"><span data-ttu-id="eece9-1178">동적 어셈블리에 제공된 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1178">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="eece9-1179">증명 정보는 변경되지 않고 정책 결정을 위한 최종 증명 정보로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1179">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="eece9-1180">필수 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1180">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="eece9-1181">선택적 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1181">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="eece9-1182">거부된 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1182">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="eece9-1183">지정한 이름, 액세스 모드, 증명 정보 및 권한 요청을 사용하여 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1183">Defines a dynamic assembly using the specified name, access mode, evidence, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="eece9-1184">지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1184">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1185">에 대 한 지정한 사용 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 경우에 사용 됩니다 `evidence` 변수도 제공한 동적 어셈블리를 저장 하 고 메모리로 다시 로드 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="eece9-1185">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1186">동적 어셈블리를 내보내는 코드를 개발 하는 동안 해당 되는 것이 좋습니다 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에서 `refusedPermissions`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1186">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="eece9-1187">포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL 확인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1187">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="eece9-1188">이 방법의 제한 사항은를 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드를 사용 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1188">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="eece9-1189">호출자가 제공할 수 있습니다를 완전히 신뢰할 수 있는 해당 `evidence` 동적 정의할 때 <xref:System.Reflection.Assembly>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1189">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="eece9-1190">런타임에 매핑될는 <xref:System.Security.Policy.Evidence> 부여 된 권한을 확인 하는 보안 정책을 통해.</span><span class="sxs-lookup"><span data-stu-id="eece9-1190">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="eece9-1191">호출자가 null을 제공 해야 합니다를 부분적으로 신뢰할 수 있는 `evidence`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1191">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="eece9-1192">경우 `evidence` 은 `null`런타임에서 사용 권한 집합을 복사, 현재가 권한을 부여 하 고 호출자에서 집합을 거부 하는, 즉 <xref:System.Reflection.Assembly> 동적 <xref:System.Reflection.Assembly> 정의 되 고 정책을 확인할 것으로 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1192">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="eece9-1193">경우 동적 <xref:System.Reflection.Assembly> 는 디스크에 저장 후속 로드 받을 위치에 연결 된 정책에 따라 승인 여기서는 <xref:System.Reflection.Assembly> 저장 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1193">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="eece9-1194">이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의 하만 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1194">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="eece9-1195">자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1195">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1196">다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1196">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="eece9-1197">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1197">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="eece9-1198">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1198">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1199"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1199"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-1200"><paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1200">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-1201">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1201">-or-</span></span> 
<span data-ttu-id="eece9-1202"><paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1202">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1203">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1203">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1204">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1204">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1205">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1205">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-1206">동적 어셈블리의 고유 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1206">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="eece9-1207">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1207">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="eece9-1208">어셈블리가 저장될 디렉터리 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1208">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="eece9-1209"><paramref name="dir" />가 <see langword="null" />이면 현재 디렉터리가 기본값으로 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1209">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="eece9-1210">필수 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1210">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="eece9-1211">선택적 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1211">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="eece9-1212">거부된 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1212">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="eece9-1213">지정한 이름, 액세스 모드, 저장소 디렉터리 및 권한 요청을 사용하여 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1213">Defines a dynamic assembly using the specified name, access mode, storage directory, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="eece9-1214">지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1214">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1215">에 대 한 지정한 사용 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 동적 어셈블리가 저장 되 고 메모리로 다시 로드 하지 않는 한 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1215">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are not used unless the dynamic assembly has been saved and reloaded into memory.</span></span> <span data-ttu-id="eece9-1216">임시 어셈블리의 오버 로드를 사용 하는 디스크에 저장 되지 않은 대 한 사용 권한 요청을 지정 하는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 요청 된 사용 권한 및 공급 증명 정보를 지정 하는 메서드는 <xref:System.Security.Policy.Evidence> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1216">To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1217">동적 어셈블리를 내보내는 코드를 개발 하는 동안 것이 좋습니다의 오버 로드를 사용 하 여 <xref:System.AppDomain.DefineDynamicAssembly%2A> 동적 어셈블리를 포함 하는 증명 정보를 제공 하는 증명 정보 및 사용 권한을 지정 하는 방법 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에서 `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="eece9-1217">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="eece9-1218">포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL 확인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1218">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="eece9-1219">이 방법의 제한 사항은를 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드를 사용 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1219">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="eece9-1220">이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의 하만 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1220">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="eece9-1221">자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1221">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1222">다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1222">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="eece9-1223">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1223">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="eece9-1224">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1224">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1225"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1225"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-1226"><paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1226">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-1227">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1227">-or-</span></span> 
<span data-ttu-id="eece9-1228"><paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1228">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1229">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1229">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-1230">동적 어셈블리의 고유 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1230">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="eece9-1231">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1231">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="eece9-1232">어셈블리가 저장될 디렉터리 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1232">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="eece9-1233"><paramref name="dir" />가 <see langword="null" />이면 현재 디렉터리가 기본값으로 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1233">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="eece9-1234">동적 어셈블리에 제공된 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1234">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="eece9-1235">증명 정보는 변경되지 않고 정책 결정을 위한 최종 증명 정보로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1235">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="eece9-1236">필수 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1236">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="eece9-1237">선택적 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1237">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="eece9-1238">거부된 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1238">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="eece9-1239">지정한 이름, 액세스 모드, 저장소 디렉터리, 증명 정보 및 권한 요청을 사용하여 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1239">Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="eece9-1240">지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1240">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1241">에 대 한 지정한 사용 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 경우에 사용 됩니다 `evidence` 변수도 제공한 동적 어셈블리를 저장 하 고 메모리로 다시 로드 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="eece9-1241">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1242">동적 어셈블리를 내보내는 코드를 개발 하는 동안 해당 되는 것이 좋습니다 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에서 `refusedPermissions`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1242">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="eece9-1243">포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL 확인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1243">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="eece9-1244">이 방법의 제한 사항은를 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드를 사용 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1244">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="eece9-1245">호출자가 제공할 수 있습니다를 완전히 신뢰할 수 있는 해당 `evidence` 동적 정의할 때 <xref:System.Reflection.Assembly>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1245">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="eece9-1246">런타임에 매핑될는 <xref:System.Security.Policy.Evidence> 부여 된 권한을 확인 하는 보안 정책을 통해.</span><span class="sxs-lookup"><span data-stu-id="eece9-1246">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="eece9-1247">호출자가 null을 제공 해야 합니다를 부분적으로 신뢰할 수 있는 `evidence`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1247">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="eece9-1248">경우 `evidence` 은 `null`런타임에서 사용 권한 집합을 복사, 현재가 권한을 부여 하 고 호출자에서 집합을 거부 하는, 즉 <xref:System.Reflection.Assembly> 동적 <xref:System.Reflection.Assembly> 정의 되 고 정책을 확인할 것으로 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1248">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="eece9-1249">경우 동적 <xref:System.Reflection.Assembly> 는 디스크에 저장 후속 로드 받을 위치에 연결 된 정책에 따라 승인 여기서는 <xref:System.Reflection.Assembly> 저장 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1249">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="eece9-1250">이 메서드는 현재 응용 프로그램 도메인에서 동적 어셈블리를 정의 하만 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1250">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="eece9-1251">자세한 내용은 참조는 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1251">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1252">다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1252">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="eece9-1253">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1253">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="eece9-1254">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1254">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1255"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1255"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-1256"><paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1256">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-1257">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1257">-or-</span></span> 
<span data-ttu-id="eece9-1258"><paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1258">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1259">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1259">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1260">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1260">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1261">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1261">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-1262">동적 어셈블리의 고유 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1262">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="eece9-1263">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1263">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="eece9-1264">동적 어셈블리를 저장할 디렉터리 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1264">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="eece9-1265"><paramref name="dir" />가 <see langword="null" />이면 현재 디렉터리가 기본값으로 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1265">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="eece9-1266">동적 어셈블리에 제공된 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1266">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="eece9-1267">증명 정보는 변경되지 않고 정책 결정을 위한 최종 증명 정보로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1267">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="eece9-1268">필수 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1268">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="eece9-1269">선택적 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1269">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="eece9-1270">거부된 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1270">The refused permissions request.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="eece9-1271">동적 어셈블리에서 모듈, 형식 및 멤버 만들기를 동기화하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1271"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="eece9-1272">지정한 이름, 액세스 모드, 저장소 디렉터리, 증명 정보, 권한 요청 및 동기화 옵션을 사용하여 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1272">Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, permission requests, and synchronization option.</span></span></summary>
        <returns><span data-ttu-id="eece9-1273">지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1273">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1274">에 대 한 지정한 사용 권한 요청 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 경우에 사용 됩니다 `evidence` 변수도 제공한 동적 어셈블리를 저장 하 고 메모리로 다시 로드 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="eece9-1274">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1275">동적 어셈블리를 내보내는 코드를 개발 하는 동안 해당 되는 것이 좋습니다 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 에서 `refusedPermissions`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1275">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="eece9-1276">포함 하 여 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> 에 `refusedPermissions` 매개 변수를 사용 하면 MSIL 확인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1276">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="eece9-1277">이 방법의 제한 사항은를 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드를 사용 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1277">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="eece9-1278">동적 정의할 때 완전히 신뢰할 수 있는 호출자가 증명 정보를 제공할 수 있습니다만 <xref:System.Reflection.Assembly>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1278">Only fully trusted callers can supply their evidence when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="eece9-1279">런타임에 매핑될는 <xref:System.Security.Policy.Evidence> 부여 된 권한을 확인 하는 보안 정책을 통해.</span><span class="sxs-lookup"><span data-stu-id="eece9-1279">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="eece9-1280">호출자를 부분적으로 신뢰할 수 있는 `null` 에 대 한는 `evidence` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1280">Partially trusted callers must supply `null` for the `evidence` parameter.</span></span> <span data-ttu-id="eece9-1281">경우 `evidence` 은 `null`런타임에서 사용 권한 집합을 복사, 현재가 권한을 부여 하 고 호출자에서 집합을 거부 하는, 즉 <xref:System.Reflection.Assembly> 동적 <xref:System.Reflection.Assembly> 정의 되 고 정책을 확인할 것으로 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1281">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="eece9-1282">경우 동적 <xref:System.Reflection.Assembly> 는 디스크에 저장 후속 로드 받을 위치에 연결 된 정책에 따라 승인 여기서는 <xref:System.Reflection.Assembly> 저장 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1282">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="eece9-1283">경우 `isSynchronized` 됩니다 `true`, 결과의 다음 메서드 <xref:System.Reflection.Emit.AssemblyBuilder> 동기화 됩니다: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>를 <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, 및 <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1283">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="eece9-1284">이러한 방법 중 두 가지 다른 스레드에서 호출 되는 경우 다른가 완료 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1284">If two of these methods are called on different threads, one will block until the other completes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1285">다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.DefineDynamicAssembly%2A> 메서드 및 <xref:System.AppDomain.AssemblyResolve> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1285">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="eece9-1286">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1286">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="eece9-1287">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1287">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1288"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1288"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-1289"><paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1289">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-1290">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1290">-or-</span></span> 
<span data-ttu-id="eece9-1291"><paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1291">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1292">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1292">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1293">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1293">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1294">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1294">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-1295">동적 어셈블리의 고유 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1295">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="eece9-1296">동적 어셈블리에 액세스하는 데 사용되는 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1296">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="eece9-1297">동적 어셈블리를 저장할 디렉터리 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1297">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="eece9-1298"><paramref name="dir" />이 <see langword="null" />인 경우 현재 디렉터리가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1298">If <paramref name="dir" /> is <see langword="null" />, the current directory is used.</span></span></param>
        <param name="evidence"><span data-ttu-id="eece9-1299">동적 어셈블리에 제공된 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1299">The evidence that is supplied for the dynamic assembly.</span></span> <span data-ttu-id="eece9-1300">증명 정보는 변경되지 않고 정책 결정을 위한 최종 증명 정보로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1300">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="eece9-1301">필수 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1301">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="eece9-1302">선택적 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1302">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="eece9-1303">거부된 권한 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1303">The refused permissions request.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="eece9-1304">동적 어셈블리에서 모듈, 형식 및 멤버 만들기를 동기화하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1304"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="eece9-1305">어셈블리에 적용되는 특성의 열거형 목록이거나 특성이 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1305">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="eece9-1306">지정한 이름, 액세스 모드, 저장소 디렉터리, 증명 정보, 권한 요청, 동기화 옵션 및 사용자 지정 특성을 사용하여 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1306">Defines a dynamic assembly with the specified name, access mode, storage directory, evidence, permission requests, synchronization option, and custom attributes.</span></span></summary>
        <returns><span data-ttu-id="eece9-1307">지정한 이름 및 기능을 사용하는 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1307">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1308">이 메서드 오버 로드를 사용 하 여 동적 어셈블리를 만들 때 적용 하지 않으면 올바르게 작동 하지 않는 특성을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1308">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="eece9-1309">예를 들어, 보안 등의 특성 <xref:System.Security.SecurityTransparentAttribute> 고 <xref:System.Security.SecurityCriticalAttribute> 동적 어셈블리를 만든 후 추가 된 경우 올바르게 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1309">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="eece9-1310">에 대 한 지정한 사용 권한 요청은 `requiredPermissions`, `optionalPermissions`, 및 `refusedPermissions` 경우에 매개 변수를 사용 합니다 `evidence` 매개 변수도 제공한, 동적 어셈블리를 저장 하 고 메모리로 다시 로드 하는 경우 또는 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1310">The permission requests specified for the `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` parameters are used only if the `evidence` parameter is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1311">동적 어셈블리를 생성 하는 코드를 개발 하는 경우 포함 하는 것이 좋습니다 합니다 <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> 플래그를 `refusedPermissions` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1311">When you develop code that emits dynamic assemblies, we recommend that you include the <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> flag in the `refusedPermissions` parameter.</span></span> <span data-ttu-id="eece9-1312">이 플래그를 포함 되도록 Microsoft 중간 언어 (MSIL)를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1312">The inclusion of this flag ensures that the Microsoft intermediate language (MSIL) will be verified.</span></span> <span data-ttu-id="eece9-1313">이 기술은 의도 하지 않은 있는 하기가 매우 어렵습니다 비안정형 코드가 생성을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1313">This technique will detect the unintentional generation of unverifiable code, which otherwise is very difficult to detect.</span></span> <span data-ttu-id="eece9-1314">이 방법의 제한 사항은를 <xref:System.Security.SecurityException> 완전 신뢰를 요청 하는 코드를 사용 하 여 사용 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1314">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when it is used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="eece9-1315">동적 정의할 때 완전히 신뢰할 수 있는 호출자가 증명 정보를 제공할 수 있습니다만 <xref:System.Reflection.Assembly>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1315">Only fully trusted callers can supply evidence when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="eece9-1316">런타임에 매핑되는 <xref:System.Security.Policy.Evidence> 부여 된 권한을 확인 하는 보안 정책을 통해.</span><span class="sxs-lookup"><span data-stu-id="eece9-1316">The runtime maps the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="eece9-1317">호출자를 부분적으로 신뢰할 수 있는 `null` 에 대 한는 `evidence` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1317">Partially trusted callers must supply `null` for the `evidence` parameter.</span></span> <span data-ttu-id="eece9-1318">하는 경우 `evidence` 는 `null`, 런타임에서 호출자의 어셈블리에서 정의 되 고 정책을 확인으로 표시 하는 동적 어셈블리에 (즉, 현재 권한 부여 및 거부 집합) 사용 권한 집합을 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1318">If `evidence` is `null`, the runtime copies the permission sets (that is, the current grant and deny sets) from the caller's assembly to the dynamic assembly that is being defined, and marks the policy as resolved.</span></span>  
  
 <span data-ttu-id="eece9-1319">동적 어셈블리를 후속 디스크에 저장 됩니다 하는 경우 로드는 동적 어셈블리를 저장 된 위치와 연결 된 정책을 기반으로 하는 권한을 부여 받습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1319">If the dynamic assembly is saved to disk, subsequent loads will get grants based on policies that are associated with the location where the dynamic assembly was saved.</span></span>  
  
 <span data-ttu-id="eece9-1320">경우 `isSynchronized` 됩니다 `true`, 결과의 다음 메서드 <xref:System.Reflection.Emit.AssemblyBuilder> 동기화 됩니다: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>를 <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, 및 <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1320">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="eece9-1321">이러한 방법 중 두 가지 다른 스레드에서 호출 되는 경우 다른 완료 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1321">If two of these methods are called on different threads, one will block until the other is completed.</span></span>  
  
 <span data-ttu-id="eece9-1322">이 메서드는 오버 로드는 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1322">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1323"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1323"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-1324"><paramref name="name" />의 <see langword="Name" /> 속성이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1324">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="eece9-1325">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1325">-or-</span></span> 
<span data-ttu-id="eece9-1326"><paramref name="name" />의 <see langword="Name" /> 속성이 공백으로 시작하거나 슬래시 또는 백슬래시를 포함하는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1326">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1327">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1327">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1328">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1328">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1329">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1329">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate"><span data-ttu-id="eece9-1330">호출할 메서드를 지정하는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1330">A delegate that specifies a method to call.</span></span></param>
        <summary><span data-ttu-id="eece9-1331">지정한 대리자에서 식별한 다른 응용 프로그램 도메인에 있는 코드를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1331">Executes the code in another application domain that is identified by the specified delegate.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1332">`callBackDelegate` 마샬링-by-값을 지정할 수 있습니다 <xref:System.MarshalByRefObject>, 또는 <xref:System.ContextBoundObject>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1332">`callBackDelegate` can specify a marshal-by-value, <xref:System.MarshalByRefObject>, or <xref:System.ContextBoundObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1333">다음 예제에서는 정적을 사용 하 여 <xref:System.AppDomain.DoCallBack%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1333">The following sample demonstrates using a static <xref:System.AppDomain.DoCallBack%2A> method.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 <span data-ttu-id="eece9-1334">다음 샘플을 사용 하는 <xref:System.AppDomain.DoCallBack%2A> 값별로 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1334">The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by value.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 <span data-ttu-id="eece9-1335">다음 샘플을 사용 하는 <xref:System.AppDomain.DoCallBack%2A> 메서드를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1335">The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by reference.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1336"><paramref name="callBackDelegate" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1336"><paramref name="callBackDelegate" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-1337">응용 프로그램 도메인이 초기화될 때 호스트에서 제공한 도메인 관리자를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1337">Gets the domain manager that was provided by the host when the application domain was initialized.</span></span></summary>
        <value><span data-ttu-id="eece9-1338">응용 프로그램 도메인이 초기화될 때 호스트에서 제공한 도메인 관리자를 나타내는 개체이거나, 도메인 관리자가 제공되지 않은 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1338">An object that represents the domain manager provided by the host when the application domain was initialized, or <see langword="null" /> if no domain manager was provided.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1339">CLR (공용 언어 런타임)의 관리 되지 않는 호스트를 도메인 관리자를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1339">An unmanaged host of the common language runtime (CLR) can provide a domain manager.</span></span> <span data-ttu-id="eece9-1340">도메인 관리자를 새 응용 프로그램 도메인 초기화에 참여할 및와 같은 다른 관리자를 제공할 수는 <xref:System.Security.HostSecurityManager>에 참여 하는 응용 프로그램 도메인의 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1340">The domain manager can participate in initializing the new application domain and supply other managers, such as a <xref:System.Security.HostSecurityManager>, that participate in the operations of the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-1341">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1341">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-1342">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1342">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-1343"><see cref="T:System.AppDomain" />이 언로드되려고 할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1343">Occurs when an <see cref="T:System.AppDomain" /> is about to be unloaded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1344"><xref:System.EventHandler> 대리자이 이벤트는 응용 프로그램 도메인이 언로드되기 전에 종료 동작을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1344">The <xref:System.EventHandler> delegate for this event can perform any termination activities before the application domain is unloaded.</span></span>  
  
 <span data-ttu-id="eece9-1345">각 응용 프로그램 도메인을 언로드할 때 처리를 수행 해야 하는이 이벤트에 대 한 이벤트 처리기를 등록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1345">Each application domain that needs to perform processing when it is unloaded should register an event handler for this event.</span></span> <span data-ttu-id="eece9-1346">공유 이벤트 처리기를 해야 하지 때문에 사용할 수는 <xref:System.EventHandler> 대리자 언로드되는 중 도메인을 식별 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1346">A shared event handler should not be used, because the <xref:System.EventHandler> delegate does not identify the domain that is being unloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1347">기본 응용 프로그램 도메인에서이 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1347">This event is never raised in the default application domain.</span></span>  
  
 <span data-ttu-id="eece9-1348">이벤트가 발생 하는 스레드에 대 한 가정을 수행 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-1348">Do not make assumptions about the thread the event is raised on.</span></span> <span data-ttu-id="eece9-1349">호출 하는 것 보다 다른 스레드에서 이벤트가 발생할 수 있습니다는 <xref:System.AppDomain.Unload%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1349">The event can be raised on a different thread than the one that called the <xref:System.AppDomain.Unload%2A> method.</span></span>  
  
 <span data-ttu-id="eece9-1350">이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="eece9-1350">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-1351">어셈블리 확인자에서 동적으로 만든 어셈블리를 조사하는 데 사용하는 디렉터리를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1351">Gets the directory that the assembly resolver uses to probe for dynamically created assemblies.</span></span></summary>
        <value><span data-ttu-id="eece9-1352">어셈블리 확인자에서 동적으로 만든 어셈블리를 조사하는 데 사용하는 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1352">The directory that the assembly resolver uses to probe for dynamically created assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1353">동적 디렉터리를 설정 하려면 기본 디렉터리 경로를 할당 합니다 <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> 속성의는 <xref:System.AppDomainSetup> 새 응용 프로그램 도메인을 만드는 데 사용할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1353">To set the dynamic directory, assign a base directory path to the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property of the <xref:System.AppDomainSetup> object that will be used to create the new application domain.</span></span> <span data-ttu-id="eece9-1354">속성에 할당 하는 기본 디렉터리 경로 간단한 이름이를 할당 하는 문자열의 해시 코드는 하위 디렉터리를 추가 하 여 수정 합니다 <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> 속성을 기본 디렉터리의 형식은 *원래 경로* \\ *해시 코드*합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1354">The base directory path you assign to the property is modified by the addition of a subdirectory whose simple name is the hash code of the string you assign to the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> property, so the format of the base directory is *original path*\\*hash code*.</span></span> <span data-ttu-id="eece9-1355">동적 디렉터리에는이 기본 디렉터리의 하위 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1355">The dynamic directory is a subdirectory of this base directory.</span></span> <span data-ttu-id="eece9-1356">간단한 이름 값은는 <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> 속성을 해당 형식 이므로 *원래 경로*\\*해시 코드*\\*응용 프로그램 이름*합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1356">Its simple name is the value of the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> property, so its format is *original path*\\*hash code*\\*application name*.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1357">다음 예제에서는 동적 어셈블리에 대 한 디렉터리를 사용 하 여 응용 프로그램 도메인을 만듭니다, 그리고 동적 어셈블리를 내보내 및 동적 디렉터리에 저장 한 다음 새 응용 프로그램 도메인에 어셈블리를 로드 및 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1357">The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.</span></span>  
  
 <span data-ttu-id="eece9-1358">이 예에서는 만듭니다는 <xref:System.AppDomainSetup> 개체 집합과 해당 <xref:System.AppDomainSetup.ApplicationName%2A> 속성을 "예" 고 <xref:System.AppDomainSetup.DynamicBase%2A> 속성을 "C:\DynamicAssemblyDir".</span><span class="sxs-lookup"><span data-stu-id="eece9-1358">The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to "Example" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to "C:\DynamicAssemblyDir".</span></span> <span data-ttu-id="eece9-1359">다음 예제의 <xref:System.AppDomainSetup.DynamicBase%2A> 응용 프로그램 이름의 해시 코드를 원래 할당 된 경로의 하위 디렉터리로 추가 되었는지는 표시할 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1359">The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1360">이 예제의 기본 디렉터리에 예제 응용 프로그램에 대 한 검색 경로 외부에 있을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1360">The base directory in this example is intended to be outside the probing path for the example application.</span></span> <span data-ttu-id="eece9-1361">다른 위치에 예제를 컴파일하려면 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1361">Be sure to compile the example in a different location.</span></span> <span data-ttu-id="eece9-1362">기본 디렉터리 및 모든 하위 디렉터리를 예제를 실행할 때마다 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1362">Delete the base directory and all its subdirectories each time you run the example.</span></span>  
  
 <span data-ttu-id="eece9-1363">예제에서는 새 응용 프로그램 도메인을 만들고 사용 하 여는 <xref:System.AppDomainSetup> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1363">The example creates a new application domain, using the <xref:System.AppDomainSetup> object.</span></span> <span data-ttu-id="eece9-1364">이 예제에서는 사용 된 <xref:System.AppDomain.DynamicDirectory%2A> 디렉터리를 만들 수 있도록 디렉터리의 이름을 검색 하는 속성.</span><span class="sxs-lookup"><span data-stu-id="eece9-1364">The example uses the <xref:System.AppDomain.DynamicDirectory%2A> property to retrieve the name of the directory, so it can create the directory.</span></span> <span data-ttu-id="eece9-1365">(이 예제에서는 간단 하 게 만들 수 디렉터리 미리 원래 경로, 응용 프로그램 이름과 응용 프로그램 이름, 해시 코드를 연결 하 여.)</span><span class="sxs-lookup"><span data-stu-id="eece9-1365">(The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)</span></span>  
  
 <span data-ttu-id="eece9-1366">이 예제에는 `GenerateDynamicAssembly` 이라는 어셈블리를 생성 하는 메서드 `DynamicHelloWorld.dll` 새 응용 프로그램 도메인의 동적 디렉터리에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1366">The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory.</span></span> <span data-ttu-id="eece9-1367">동적 어셈블리를 포함 한 가지 형식만 `HelloWorld`, 정적 메서드가 (`Shared` Visual Basic에서 메서드) 라는 `HelloFromAD`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1367">The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`.</span></span> <span data-ttu-id="eece9-1368">이 메서드를 호출 응용 프로그램 도메인의 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1368">Calling this method displays the name of the application domain.</span></span>  
  
 <span data-ttu-id="eece9-1369">`Example` 클래스에서 파생 되며 <xref:System.MarshalByRefObject>예제에서는 새 응용 프로그램 도메인 및 호출에서 클래스의 인스턴스를 만들 수 있으므로 해당 `Test` 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1369">The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method.</span></span> <span data-ttu-id="eece9-1370">합니다 `Test` 메서드는 표시 이름을 사용 하 여 동적 어셈블리를 로드 하 고 정적 호출 `HelloFromAD` 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1370">The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.</span></span>  
  
 <span data-ttu-id="eece9-1371">이라는 어셈블리에 대 한 코드를 작성 하 여 정상적인 검색 경로 후 동적 디렉터리 검색 됩니다 표시할 수 있습니다 `DynamicHelloWorld.dll` 및이 예제와 동일한 디렉터리에 컴파일.</span><span class="sxs-lookup"><span data-stu-id="eece9-1371">You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example.</span></span> <span data-ttu-id="eece9-1372">어셈블리에 클래스가 있어야 `HelloWorld` 라는 정적 메서드를 사용 하 여 `HelloFromAD`입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1372">The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`.</span></span> <span data-ttu-id="eece9-1373">이 메서드를 예제;에 있는 것과 동일한 기능이 필요가 없습니다. 단순히 문자열을 콘솔에 표시할 수 있으며</span><span class="sxs-lookup"><span data-stu-id="eece9-1373">This method does not have to have the same functionality as the one in the example; it can simply display a string to the console.</span></span> <span data-ttu-id="eece9-1374">어셈블리에도 있어야는 <xref:System.Reflection.AssemblyVersionAttribute> 버전 1.0.0.0으로 설정 하는 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1374">The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0.</span></span> <span data-ttu-id="eece9-1375">예제를 실행 하는 경우 현재 디렉터리에 컴파일된 어셈블리가 동적 디렉터리를 검색 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1375">When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1376">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1376">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1377">경로 정보에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1377">for access to the path information.</span></span> <span data-ttu-id="eece9-1378">연관된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1378">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-1379">이 응용 프로그램 도메인과 관련된 <see cref="T:System.Security.Policy.Evidence" />를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1379">Gets the <see cref="T:System.Security.Policy.Evidence" /> associated with this application domain.</span></span></summary>
        <value><span data-ttu-id="eece9-1380">이 응용 프로그램 도메인과 관련된 증거입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1380">The evidence associated with this application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1381">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1381">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1382">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1382">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1383">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1383">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="eece9-1384">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1384">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="eece9-1385">지정한 파일에 포함된 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1385">Executes the assembly contained in the specified file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="eece9-1386">실행할 어셈블리가 포함된 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1386">The name of the file that contains the assembly to execute.</span></span></param>
        <summary><span data-ttu-id="eece9-1387">지정한 파일에 포함된 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1387">Executes the assembly contained in the specified file.</span></span></summary>
        <returns><span data-ttu-id="eece9-1388">어셈블리의 진입점에서 반환한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1388">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1389">어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1389">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="eece9-1390">이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다 및 진입점 메서드를 새 스레드에서 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1390">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="eece9-1391">이 메서드를 사용 하 여 어셈블리 로드를 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1391">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="eece9-1392">사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1392">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="eece9-1393">만들려는 합니다 <xref:System.AppDomain> 로드 하 고 실행 하려면를 <xref:System.AppDomain.CreateDomain%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1393">To create the <xref:System.AppDomain> to load and execute, use the <xref:System.AppDomain.CreateDomain%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1394">다음 예제에서는 오버 로드 중 하나를 사용 하 여 <xref:System.AppDomain.ExecuteAssembly%2A> 두 개의 서로 다른 도메인에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1394">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1395"><paramref name="assemblyFile" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1395"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1396"><paramref name="assemblyFile" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1396"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1397"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1397"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1398">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1398">-or-</span></span> 
<span data-ttu-id="eece9-1399">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1399">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1400">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1400">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1401">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1401">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-1402">지정된 어셈블리에 진입점이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1402">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1403">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1403">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="eece9-1404">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1404">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1405">"file://"로 시작 하지 않는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1405">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="eece9-1406">콘솔 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1406">to execute a console application.</span></span> <span data-ttu-id="eece9-1407">연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1407">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="eece9-1408">실행할 어셈블리가 포함된 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1408">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="eece9-1409">어셈블리 로드에 사용할 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1409">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="eece9-1410">지정한 증명 정보를 사용하여 지정한 파일에 포함된 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1410">Executes the assembly contained in the specified file, using the specified evidence.</span></span></summary>
        <returns><span data-ttu-id="eece9-1411">어셈블리의 진입점에서 반환한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1411">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1412">어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1412">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="eece9-1413"><xref:System.AppDomain.ExecuteAssembly%2A> 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다 및 진입점 메서드를 새 스레드에서 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1413">The <xref:System.AppDomain.ExecuteAssembly%2A> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="eece9-1414">이 메서드를 사용 하 여 어셈블리 로드를 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1414">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="eece9-1415">사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1415">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1416">다음 예제에서는 오버 로드 중 하나를 사용 하 여 <xref:System.AppDomain.ExecuteAssembly%2A> 두 개의 서로 다른 도메인에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1416">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1417"><paramref name="assemblyFile" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1417"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1418"><paramref name="assemblyFile" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1418"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1419"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1419"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1420">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1420">-or-</span></span> 
<span data-ttu-id="eece9-1421">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1421">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1422">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1422">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1423">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1423">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-1424">지정된 어셈블리에 진입점이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1424">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1425">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1425">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1426">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1426">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1427">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1427">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="eece9-1428">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1428">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1429">"file://"로 시작 하지 않는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1429">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="eece9-1430">콘솔 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1430">to execute a console application.</span></span> <span data-ttu-id="eece9-1431">연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1431">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="eece9-1432">실행할 어셈블리가 포함된 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1432">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-1433">어셈블리의 진입점에 대한 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1433">The arguments to the entry point of the assembly.</span></span></param>
        <summary><span data-ttu-id="eece9-1434">지정한 인수를 사용하여 지정한 파일에 포함된 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1434">Executes the assembly contained in the specified file, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="eece9-1435">어셈블리의 진입점에서 반환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1435">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1436">어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1436">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="eece9-1437">이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다 및 진입점 메서드를 새 스레드에서 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1437">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="eece9-1438">이 메서드를 사용 하 여 어셈블리 로드를 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1438">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="eece9-1439">사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1439">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1440">다음 예제에서는 오버 로드 중 하나를 사용 하 여 <xref:System.AppDomain.ExecuteAssembly%2A> 두 개의 서로 다른 도메인에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1440">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1441"><paramref name="assemblyFile" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1441"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1442"><paramref name="assemblyFile" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1442"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1443"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1443"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1444">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1444">-or-</span></span> 
 <span data-ttu-id="eece9-1445"><paramref name="assemblyFile" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1445"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1446">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1446">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1447">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1447">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-1448">지정된 어셈블리에 진입점이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1448">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1449">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1449">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="eece9-1450">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1450">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1451">"file://"로 시작 하지 않는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1451">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="eece9-1452">콘솔 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1452">to execute a console application.</span></span> <span data-ttu-id="eece9-1453">연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1453">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="eece9-1454">실행할 어셈블리가 포함된 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1454">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="eece9-1455">어셈블리에 제공된 증거입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1455">The supplied evidence for the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-1456">어셈블리의 진입점에 대한 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1456">The arguments to the entry point of the assembly.</span></span></param>
        <summary><span data-ttu-id="eece9-1457">지정한 증명 정보 및 인수를 사용하여 지정한 파일에 포함된 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1457">Executes the assembly contained in the specified file, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="eece9-1458">어셈블리의 진입점에서 반환한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1458">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1459">어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1459">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="eece9-1460">이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다 및 진입점 메서드를 새 스레드에서 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1460">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="eece9-1461">이 메서드를 사용 하 여 어셈블리 로드를 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1461">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="eece9-1462">사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1462">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1463">다음 예제에서는 오버 로드 중 하나를 사용 하 여 <xref:System.AppDomain.ExecuteAssembly%2A> 두 개의 서로 다른 도메인에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1463">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1464"><paramref name="assemblyFile" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1464"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1465"><paramref name="assemblyFile" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1465"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1466"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1466"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1467">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1467">-or-</span></span> 
<span data-ttu-id="eece9-1468">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1468">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1469">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1469">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1470">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1470">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-1471"><paramref name="assemblySecurity" />이 <see langword="null" />가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1471"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="eece9-1472">레거시 CAS 정책을 사용하지 않을 때는 <paramref name="assemblySecurity" />는 <see langword="null" />이 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1472">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-1473">지정된 어셈블리에 진입점이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1473">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1474">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1474">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1475">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1475">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1476">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1476">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="eece9-1477">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1477">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1478">"file://"로 시작 하지 않는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1478">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="eece9-1479">콘솔 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1479">to execute a console application.</span></span> <span data-ttu-id="eece9-1480">연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1480">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="eece9-1481">실행할 어셈블리가 포함된 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1481">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-1482">어셈블리의 진입점에 대한 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1482">The arguments to the entry point of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="eece9-1483">계산된 해시 코드의 값을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1483">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="eece9-1484">어셈블리 매니페스트에 사용되는 해시 알고리즘을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1484">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="eece9-1485">지정한 인수, 해시 값 및 해시 알고리즘을 사용하여 지정한 파일에 포함된 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1485">Executes the assembly contained in the specified file, using the specified arguments, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="eece9-1486">어셈블리의 진입점에서 반환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1486">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1487">어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1487">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="eece9-1488">이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다 및 진입점 메서드를 새 스레드에서 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1488">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="eece9-1489">이 메서드를 사용 하 여 어셈블리 로드를 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1489">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="eece9-1490">사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1490">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1491">다음 예제에서는 오버 로드 중 하나를 사용 하 여 <xref:System.AppDomain.ExecuteAssembly%2A> 두 개의 서로 다른 도메인에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1491">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1492"><paramref name="assemblyFile" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1492"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1493"><paramref name="assemblyFile" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1493"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1494"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1494"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1495">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1495">-or-</span></span> 
 <span data-ttu-id="eece9-1496"><paramref name="assemblyFile" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1496"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1497">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1497">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1498">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1498">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-1499">지정된 어셈블리에 진입점이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1499">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1500">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1500">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="eece9-1501">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1501">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1502">"file://"로 시작 하지 않는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1502">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="eece9-1503">콘솔 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1503">to execute a console application.</span></span> <span data-ttu-id="eece9-1504">연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1504">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="eece9-1505">실행할 어셈블리가 포함된 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1505">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="eece9-1506">어셈블리에 제공된 증거입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1506">The supplied evidence for the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-1507">어셈블리의 진입점에 대한 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1507">The arguments to the entry point of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="eece9-1508">계산된 해시 코드의 값을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1508">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="eece9-1509">어셈블리 매니페스트에 사용되는 해시 알고리즘을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1509">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="eece9-1510">지정한 증명 정보, 인수, 해시 값 및 해시 알고리즘을 사용하여 지정한 파일에 포함된 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1510">Executes the assembly contained in the specified file, using the specified evidence, arguments, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="eece9-1511">어셈블리의 진입점에서 반환한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1511">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1512">어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1512">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="eece9-1513">이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다 및 진입점 메서드를 새 스레드에서 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1513">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="eece9-1514">이 메서드를 사용 하 여 어셈블리 로드를 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1514">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="eece9-1515">사용 하 여 어셈블리를 실행할 수도 있습니다는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드를 사용 하 여 어셈블리를 로드 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1515">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1516">다음 샘플에서는 오버 로드 중 하나를 사용 하 여 보여 줍니다. <xref:System.AppDomain.ExecuteAssembly%2A> 두 개의 서로 다른 도메인에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1516">Thefollowing sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1517"><paramref name="assemblyFile" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1517"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1518"><paramref name="assemblyFile" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1518"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1519"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1519"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1520">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1520">-or-</span></span> 
<span data-ttu-id="eece9-1521">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1521">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1522">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1522">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1523">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1523">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-1524"><paramref name="assemblySecurity" />이 <see langword="null" />가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1524"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="eece9-1525">레거시 CAS 정책을 사용하지 않을 때는 <paramref name="assemblySecurity" />는 <see langword="null" />이 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1525">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-1526">지정된 어셈블리에 진입점이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1526">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1527">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1527">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1528">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1528">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1529">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1529">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="eece9-1530">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1530">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1531">"file://"로 시작 하지 않는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1531">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="eece9-1532">콘솔 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1532">to execute a console application.</span></span> <span data-ttu-id="eece9-1533">연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1533">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="eece9-1534">어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1534">Executes an assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-1535">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1535">The display name of the assembly.</span></span> <span data-ttu-id="eece9-1536"><see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-1536">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <summary><span data-ttu-id="eece9-1537">표시 이름이 지정된 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1537">Executes an assembly given its display name.</span></span></summary>
        <returns><span data-ttu-id="eece9-1538">어셈블리의 진입점에서 반환한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1538">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1539"><xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 유사한 기능을 제공 합니다 <xref:System.AppDomain.ExecuteAssembly%2A> 메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName> 아닌 파일 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1539">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="eece9-1540">따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 사용 하 여 어셈블리를 로드 합니다 <xref:System.Reflection.Assembly.Load%2A> 메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1540">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="eece9-1541">어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1541">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="eece9-1542">이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다 및 진입점 메서드를 새 스레드에서 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1542">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="eece9-1543">만들려는 합니다 <xref:System.AppDomain> 로드 하 고 실행 하려면를 <xref:System.AppDomain.CreateDomain%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1543">To create the <xref:System.AppDomain> to load and execute, use the <xref:System.AppDomain.CreateDomain%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1544"><paramref name="assemblyName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1544"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1545"><paramref name="assemblyName" />으로 지정한 어셈블리를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1545">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1546"><paramref name="assemblyName" />으로 지정한 어셈블리가 올바른 어셈블리가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1546">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1547">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1547">-or-</span></span> 
<span data-ttu-id="eece9-1548">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1548">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1549">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1549">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1550"><paramref name="assemblyName" />으로 지정한 어셈블리를 찾았으나 로드할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1550">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-1551">지정된 어셈블리에 진입점이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1551">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1552">파일 또는 디렉터리 경로 자체의 정보에 액세스 하 고 표시 이름을 리디렉션하는 경로 읽기에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1552">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="eece9-1553">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1553">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1554">표시 이름 URL로 리디렉션될 때 웹 사이트에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1554">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="eece9-1555">콘솔 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1555">to execute a console application.</span></span> <span data-ttu-id="eece9-1556">연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1556">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-1557">어셈블리의 이름을 나타내는 <see cref="T:System.Reflection.AssemblyName" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1557">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-1558">프로세스를 시작할 때 전달할 명령줄 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1558">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="eece9-1559">지정한 인수를 사용하여 <see cref="T:System.Reflection.AssemblyName" />이 지정된 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1559">Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="eece9-1560">어셈블리의 진입점에서 반환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1560">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1561"><xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 유사한 기능을 제공 합니다 <xref:System.AppDomain.ExecuteAssembly%2A> 메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName> 아닌 파일 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1561">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="eece9-1562">따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 사용 하 여 어셈블리를 로드 합니다 <xref:System.Reflection.Assembly.Load%2A> 메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1562">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="eece9-1563">어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1563">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="eece9-1564">이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다 및 진입점 메서드를 새 스레드에서 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1564">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1565"><paramref name="assemblyName" />으로 지정한 어셈블리를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1565">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1566"><paramref name="assemblyName" />으로 지정한 어셈블리를 찾았으나 로드할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1566">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1567"><paramref name="assemblyName" />으로 지정한 어셈블리가 올바른 어셈블리가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1567">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1568">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1568">-or-</span></span> 
 <span data-ttu-id="eece9-1569"><paramref name="assemblyName" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1569"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1570">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1570">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-1571">지정된 어셈블리에 진입점이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1571">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1572">파일 또는 디렉터리 경로 자체의 정보에 액세스 하 고 표시 이름을 리디렉션하는 경로 읽기에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1572">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="eece9-1573">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1573">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1574">표시 이름 URL로 리디렉션될 때 웹 사이트에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1574">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="eece9-1575">콘솔 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1575">to execute a console application.</span></span> <span data-ttu-id="eece9-1576">연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1576">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-1577">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1577">The display name of the assembly.</span></span> <span data-ttu-id="eece9-1578"><see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-1578">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="eece9-1579">어셈블리 로드에 사용할 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1579">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="eece9-1580">지정한 증명 정보를 사용하여 표시 이름이 지정된 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1580">Executes an assembly given its display name, using the specified evidence.</span></span></summary>
        <returns><span data-ttu-id="eece9-1581">어셈블리의 진입점에서 반환한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1581">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1582"><xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 유사한 기능을 제공 합니다 <xref:System.AppDomain.ExecuteAssembly%2A> 메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName> 아닌 파일 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1582">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="eece9-1583">따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 사용 하 여 어셈블리를 로드 합니다 <xref:System.Reflection.Assembly.Load%2A> 메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1583">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="eece9-1584">어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1584">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="eece9-1585"><xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다 및 진입점 메서드를 새 스레드에서 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1585">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1586">사용 하는 경우는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1586">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="eece9-1587">인수로 제공 하는 증거의 조각을 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1587">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1588"><paramref name="assemblyName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1588"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1589"><paramref name="assemblyName" />으로 지정한 어셈블리를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1589">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1590"><paramref name="assemblyName" />으로 지정한 어셈블리를 찾았으나 로드할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1590">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1591"><paramref name="assemblyName" />으로 지정한 어셈블리가 올바른 어셈블리가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1591">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1592">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1592">-or-</span></span> 
<span data-ttu-id="eece9-1593">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1593">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1594">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1594">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-1595">지정된 어셈블리에 진입점이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1595">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1596">파일 또는 디렉터리 경로 자체의 정보에 액세스 하 고 표시 이름을 리디렉션하는 경로 읽기에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1596">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="eece9-1597">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1597">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1598">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1598">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1599">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1599">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1600">표시 이름 URL로 리디렉션될 때 웹 사이트에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1600">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="eece9-1601">콘솔 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1601">to execute a console application.</span></span> <span data-ttu-id="eece9-1602">연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1602">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-1603">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1603">The display name of the assembly.</span></span> <span data-ttu-id="eece9-1604"><see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-1604">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-1605">프로세스를 시작할 때 전달할 명령줄 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1605">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="eece9-1606">지정한 인수를 사용하여 표시 이름이 지정된 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1606">Executes the assembly given its display name, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="eece9-1607">어셈블리의 진입점에서 반환된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1607">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1608"><xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 유사한 기능을 제공 합니다 <xref:System.AppDomain.ExecuteAssembly%2A> 메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName> 아닌 파일 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1608">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="eece9-1609">따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 사용 하 여 어셈블리를 로드 합니다 <xref:System.Reflection.Assembly.Load%2A> 메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1609">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="eece9-1610">어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1610">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="eece9-1611">이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다 및 진입점 메서드를 새 스레드에서 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1611">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1612"><paramref name="assemblyName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1612"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1613"><paramref name="assemblyName" />으로 지정한 어셈블리를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1613">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1614"><paramref name="assemblyName" />으로 지정한 어셈블리를 찾았으나 로드할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1614">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1615"><paramref name="assemblyName" />으로 지정한 어셈블리가 올바른 어셈블리가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1615">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1616">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1616">-or-</span></span> 
 <span data-ttu-id="eece9-1617"><paramref name="assemblyName" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1617"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1618">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1618">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-1619">지정된 어셈블리에 진입점이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1619">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1620">파일 또는 디렉터리 경로 자체의 정보에 액세스 하 고 표시 이름을 리디렉션하는 경로 읽기에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1620">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="eece9-1621">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1621">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1622">표시 이름 URL로 리디렉션될 때 웹 사이트에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1622">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="eece9-1623">콘솔 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1623">to execute a console application.</span></span> <span data-ttu-id="eece9-1624">연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1624">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-1625">어셈블리의 이름을 나타내는 <see cref="T:System.Reflection.AssemblyName" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1625">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="eece9-1626">어셈블리 로드에 사용할 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1626">Evidence for loading the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-1627">프로세스를 시작할 때 전달할 명령줄 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1627">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="eece9-1628">지정한 증거와 인수를 사용하여 <see cref="T:System.Reflection.AssemblyName" />이 지정된 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1628">Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="eece9-1629">어셈블리의 진입점에서 반환한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1629">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1630"><xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 유사한 기능을 제공 합니다 <xref:System.AppDomain.ExecuteAssembly%2A> 메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName> 아닌 파일 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1630">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="eece9-1631">따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 사용 하 여 어셈블리를 로드 합니다 <xref:System.Reflection.Assembly.Load%2A> 메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1631">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="eece9-1632">어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1632">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="eece9-1633">이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다 및 진입점 메서드를 새 스레드에서 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1633">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1634">사용 하는 경우는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1634">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="eece9-1635">인수로 제공 하는 증거의 조각을 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1635">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1636"><paramref name="assemblyName" />으로 지정한 어셈블리를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1636">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1637"><paramref name="assemblyName" />으로 지정한 어셈블리를 찾았으나 로드할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1637">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1638"><paramref name="assemblyName" />으로 지정한 어셈블리가 올바른 어셈블리가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1638">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1639">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1639">-or-</span></span> 
<span data-ttu-id="eece9-1640">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1640">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1641">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1641">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-1642"><paramref name="assemblySecurity" />이 <see langword="null" />가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1642"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="eece9-1643">레거시 CAS 정책을 사용하지 않을 때는 <paramref name="assemblySecurity" />는 <see langword="null" />이 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1643">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-1644">지정된 어셈블리에 진입점이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1644">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1645">파일 또는 디렉터리 경로 자체의 정보에 액세스 하 고 표시 이름을 리디렉션하는 경로 읽기에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1645">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="eece9-1646">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1646">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1647">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1647">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1648">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1648">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1649">표시 이름 URL로 리디렉션될 때 웹 사이트에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1649">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="eece9-1650">콘솔 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1650">to execute a console application.</span></span> <span data-ttu-id="eece9-1651">연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1651">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="eece9-1652">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1652">The display name of the assembly.</span></span> <span data-ttu-id="eece9-1653"><see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-1653">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="eece9-1654">어셈블리 로드에 사용할 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1654">Evidence for loading the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="eece9-1655">프로세스를 시작할 때 전달할 명령줄 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1655">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="eece9-1656">지정한 증명 정보와 인수를 사용하여 표시 이름이 지정된 어셈블리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1656">Executes the assembly given its display name, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="eece9-1657">어셈블리의 진입점에서 반환한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1657">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1658"><xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 유사한 기능을 제공 합니다 <xref:System.AppDomain.ExecuteAssembly%2A> 메서드를 표시 이름으로 어셈블리를 지정 하지만 또는 <xref:System.Reflection.AssemblyName> 아닌 파일 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1658">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="eece9-1659">따라서 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 사용 하 여 어셈블리를 로드 합니다 <xref:System.Reflection.Assembly.Load%2A> 메서드 대신는 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1659">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="eece9-1660">어셈블리는.NET Framework 헤더에 지정 된 진입점에서 실행을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1660">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="eece9-1661">이 메서드는 새 프로세스 또는 응용 프로그램 도메인을 만들지 않습니다 및 진입점 메서드를 새 스레드에서 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1661">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1662">사용 하는 경우는 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1662">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="eece9-1663">인수로 제공 하는 증거의 조각을 <xref:System.AppDomain.ExecuteAssemblyByName%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1663">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1664"><paramref name="assemblyName" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1664"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1665"><paramref name="assemblyName" />으로 지정한 어셈블리를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1665">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1666"><paramref name="assemblyName" />으로 지정한 어셈블리를 찾았으나 로드할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1666">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1667"><paramref name="assemblyName" />으로 지정한 어셈블리가 올바른 어셈블리가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1667">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1668">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1668">-or-</span></span> 
<span data-ttu-id="eece9-1669">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyName" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1669">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1670">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1670">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-1671"><paramref name="assemblySecurity" />이 <see langword="null" />가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1671"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="eece9-1672">레거시 CAS 정책을 사용하지 않을 때는 <paramref name="assemblySecurity" />는 <see langword="null" />이 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1672">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="eece9-1673">지정된 어셈블리에 진입점이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1673">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1674">파일 또는 디렉터리 경로 자체의 정보에 액세스 하 고 표시 이름을 리디렉션하는 경로 읽기에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1674">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="eece9-1675">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1675">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1676">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1676">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1677">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1677">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1678">표시 이름 URL로 리디렉션될 때 웹 사이트에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1678">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="eece9-1679">콘솔 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1679">to execute a console application.</span></span> <span data-ttu-id="eece9-1680">연관된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1680">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-1681">응용 프로그램 도메인에서 런타임이 예외 처리기에 대한 호출 스택을 검색하기 전에 관리 코드에서 예외가 throw될 경우 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1681">Occurs when an exception is thrown in managed code, before the runtime searches the call stack for an exception handler in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1682">이 이벤트는 알림만 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1682">This event is only a notification.</span></span> <span data-ttu-id="eece9-1683">이 이벤트 처리 해도 예외를 처리 하거나 어떤 방식으로 처리 하는 후속 예외 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1683">Handling this event does not handle the exception or affect subsequent exception handling in any way.</span></span> <span data-ttu-id="eece9-1684">이벤트 발생 후 이벤트 처리기가 호출 된 공용 언어 런타임 (CLR) 예외 처리기 검색을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1684">After the event has been raised and event handlers have been invoked, the common language runtime (CLR) begins to search for a handler for the exception.</span></span> <span data-ttu-id="eece9-1685"><xref:System.AppDomain.FirstChanceException> 관리 되는 모든 예외를 검사 하는 첫 번째 기회를 사용 하 여 응용 프로그램 도메인을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1685"><xref:System.AppDomain.FirstChanceException> provides the application domain with a first chance to examine any managed exception.</span></span>  
  
 <span data-ttu-id="eece9-1686">응용 프로그램 도메인 별로 이벤트를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1686">The event can be handled per application domain.</span></span> <span data-ttu-id="eece9-1687">스레드 호출을 실행 하는 동안 여러 응용 프로그램 도메인을 통해 전달, CLR 해당 응용 프로그램 도메인의 일치 하는 예외 처리기 검색을 시작 하기 전에 이벤트 처리기를 등록 된 각 응용 프로그램 도메인에서 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1687">If a thread passes through multiple application domains while executing a call, the event is raised in each application domain that has registered an event handler, before the CLR begins searching for a matching exception handler in that application domain.</span></span> <span data-ttu-id="eece9-1688">이벤트가 처리 된 후 해당 응용 프로그램 도메인의 일치 하는 예외 처리기에 대 한 검색이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1688">After the event has been handled, a search is made for a matching exception handler in that application domain.</span></span> <span data-ttu-id="eece9-1689">미디어가 없는 경우 다음 응용 프로그램 도메인에서 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1689">If none is found, the event is raised in the next application domain.</span></span>  
  
 <span data-ttu-id="eece9-1690">에 대 한 처리기를 이벤트에서 발생 하는 모든 예외를 처리 해야 합니다는 <xref:System.AppDomain.FirstChanceException> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1690">You must handle all exceptions that occur in the event handler for the <xref:System.AppDomain.FirstChanceException> event.</span></span> <span data-ttu-id="eece9-1691">그렇지 않으면 <xref:System.AppDomain.FirstChanceException> 이 재귀적으로 발생된 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1691">Otherwise, <xref:System.AppDomain.FirstChanceException> is raised recursively.</span></span> <span data-ttu-id="eece9-1692">이 스택 오버플로 및 응용 프로그램이 종료 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1692">This could result in a stack overflow and termination of the application.</span></span> <span data-ttu-id="eece9-1693">메모리 부족 또는 스택 오버플로와 같은 인프라 관련 예외 예외 알림이 하는 동안 가상 컴퓨터에 영향을 주지 않도록 하려면 제약이 있는 실행 지역 (Cer)으로이 이벤트에 대 한 이벤트 처리기를 구현 하는 것이 좋습니다. 처리 중입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1693">We recommend that you implement event handlers for this event as constrained execution regions (CERs), to keep infrastructure-related exceptions such as out-of-memory or stack overflow from affecting the virtual machine while the exception notification is being processed.</span></span>  
  
 <span data-ttu-id="eece9-1694">액세스 위반 등의 프로세스 상태 손상에 보안에 중요 한 이벤트 처리기 이며 경우가 아니면이 나타내는 예외에 대해이 이벤트가 발생 하지 않습니다는 <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1694">This event is not raised for exceptions that indicate corruption of process state, such as access violations, unless the event handler is security-critical and has the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute.</span></span>  
  
 <span data-ttu-id="eece9-1695">이 알림 이벤트를 처리 하는 동안 공용 언어 런타임 스레드 중단을 일시 중단 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1695">The common language runtime suspends thread aborts while this notification event is being handled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1696">다음 예제에서는 일련의 명명 된 응용 프로그램 도메인을 만듭니다 `AD0` 를 통해 `AD3`를 사용 하 여를 `Worker` 각 응용 프로그램 도메인의 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1696">The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain.</span></span> <span data-ttu-id="eece9-1697">각 `Worker` 개체에 대 한 참조에는 `Worker` 제외 하 고 다음 응용 프로그램 도메인의 개체는 `Worker` 마지막 응용 프로그램 도메인에서.</span><span class="sxs-lookup"><span data-stu-id="eece9-1697">Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain.</span></span> <span data-ttu-id="eece9-1698">합니다 <xref:System.AppDomain.FirstChanceException> 를 제외한 모든 응용 프로그램 도메인에서 이벤트를 처리 `AD1`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1698">The <xref:System.AppDomain.FirstChanceException> event is handled in all application domains except `AD1`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1699">여러 응용 프로그램 도메인에서 첫째 예외 알림을 보여 주는이 예제 외에도 간단한 사용 사례를 찾을 수 있습니다 [방법: 첫째 예외 알림 받기](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1699">In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).</span></span>  
  
 <span data-ttu-id="eece9-1700">응용 프로그램 도메인을 만든 경우 기본 응용 프로그램 도메인 호출을 `TestException` 메서드 첫 번째 응용 프로그램 도메인에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1700">When the application domains have been created, the default application domain calls the `TestException` method for the first application domain.</span></span> <span data-ttu-id="eece9-1701">각 `Worker` 호출 개체의 `TestException` 마지막까지 다음 응용 프로그램 도메인에 대 한 메서드 `Worker` 처리 되거나 처리 되지 않은 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1701">Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled.</span></span> <span data-ttu-id="eece9-1702">따라서 현재 스레드는 모든 응용 프로그램 도메인을 통해 전달 및 `TestException` 스택의 각 응용 프로그램 도메인에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1702">Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.</span></span>  
  
 <span data-ttu-id="eece9-1703">때 마지막 `Worker` 개체에서 예외를 처리 합니다 <xref:System.AppDomain.FirstChanceException> 마지막 응용 프로그램 도메인에만 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1703">When the last `Worker` object handles the exception, the <xref:System.AppDomain.FirstChanceException> event is raised only in the last application domain.</span></span> <span data-ttu-id="eece9-1704">다른 응용 프로그램 도메인 이벤트가 발생 하므로 예외를 처리 하는 받은 적입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1704">The other application domains never get a chance to handle the exception, so the event is not raised.</span></span>  
  
 <span data-ttu-id="eece9-1705">때 마지막 `Worker` 개체에서 예외를 처리 하지 않습니다는 <xref:System.AppDomain.FirstChanceException> 이벤트는 이벤트 처리기가 각 응용 프로그램 도메인에서 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1705">When the last `Worker` object does not handle the exception, the <xref:System.AppDomain.FirstChanceException> event is raised in each application domain that has an event handler.</span></span> <span data-ttu-id="eece9-1706">각 이벤트 처리기가 끝나면 스택 해제 예외는 기본 응용 프로그램 도메인에서 발견 될 때까지 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1706">After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1707">변경 이벤트가 더 가까운 곳으로 스택 표시 증가 하는 방법 및 기본 응용 프로그램 도메인에 가까울수록 서로 볼 `e.Exception.Message` 에 `e.Exception` 에 `FirstChanceHandler` 이벤트 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1707">To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers.</span></span> <span data-ttu-id="eece9-1708">때 `TestException` 라고 응용 프로그램 도메인 경계를 가로질러 두 번 나타납니다: 프록시에 한 번씩 및 스텁에 대 한 한 번입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1708">Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.</span></span>  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-1709">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1709">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-1710">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1710">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
        <related type="Article" href="https://msdn.microsoft.com/library/66f002b8-a97d-4a6e-a503-2cec01689113"><span data-ttu-id="eece9-1711">방법: 첫째 예외 알림 받기</span><span class="sxs-lookup"><span data-stu-id="eece9-1711">How to: Receive First-Chance Exception Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-1712">이 응용 프로그램 도메인의 이름을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1712">Gets the friendly name of this application domain.</span></span></summary>
        <value><span data-ttu-id="eece9-1713">이 응용 프로그램 도메인의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1713">The friendly name of this application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1714">기본 응용 프로그램 도메인의 이름에는 프로세스 실행 파일의 파일 이름이입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1714">The friendly name of the default application domain is the file name of the process executable.</span></span> <span data-ttu-id="eece9-1715">예를 들어, 프로세스를 시작 하는 데 실행 파일 인지 `"c:\MyAppDirectory\MyAssembly.exe"`, 기본 응용 프로그램 도메인의 친숙 한 이름은 `"MyAssembly.exe"`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1715">For example, if the executable used to start the process is `"c:\MyAppDirectory\MyAssembly.exe"`, the friendly name of the default application domain is `"MyAssembly.exe"`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1716">다음 코드 예제에서는 <xref:System.AppDomain.FriendlyName%2A> 속성을 현재 응용 프로그램 도메인의 친숙 한 이름을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1716">The following code example uses the <xref:System.AppDomain.FriendlyName%2A> property to get the friendly name of the current application domain.</span></span> <span data-ttu-id="eece9-1717">기본 응용 프로그램 도메인에 친숙 한 이름은 응용 프로그램의 실행 파일의 이름이입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1717">For the default application domain, the friendly name is the name of the application's executable file.</span></span> <span data-ttu-id="eece9-1718">또한이 코드 예제에서는 응용 프로그램 도메인에 대 한 추가 정보를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1718">The code example also displays additional information about the application domain.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1719">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1719">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="eece9-1720">이 응용 프로그램 도메인의 실행 컨텍스트에 로드된 어셈블리를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1720">Gets the assemblies that have been loaded into the execution context of this application domain.</span></span></summary>
        <returns><span data-ttu-id="eece9-1721">이 응용 프로그램 도메인에 있는 어셈블리의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1721">An array of assemblies in this application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="eece9-1722">다음 코드 예제에서는 <xref:System.AppDomain.GetAssemblies%2A> 메서드를 응용 프로그램 도메인에 로드 된 모든 어셈블리의 목록을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1722">The following code example uses the <xref:System.AppDomain.GetAssemblies%2A> method to get a list of all assemblies that have been loaded into the application domain.</span></span> <span data-ttu-id="eece9-1723">어셈블리를 콘솔에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1723">The assemblies are then displayed to the console.</span></span>  
  
 <span data-ttu-id="eece9-1724">이 코드 예제를 실행 하려면 어셈블리를 만들 필요가 `CustomLibrary.dll`에 전달 되는 어셈블리 이름을 변경 하거나는 <xref:System.AppDomain.GetAssemblies%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1724">To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the <xref:System.AppDomain.GetAssemblies%2A> method.</span></span>  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1725">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1725">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="eece9-1726">현재 스레드 식별자를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1726">Gets the current thread identifier.</span></span></summary>
        <returns><span data-ttu-id="eece9-1727">현재 스레드의 식별자인 부호 있는 32비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1727">A 32-bit signed integer that is the identifier of the current thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1728">사용 된 <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> 속성은.NET Framework 파이버 (즉, 경량 스레드)를 지 원하는 환경에서 호스팅하는 경우에 안정적입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1728">Use the <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property, which is stable even when the .NET Framework is hosted by an environment that supports fibers (that is, lightweight threads).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1729">이 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1729">to call this method.</span></span> <span data-ttu-id="eece9-1730">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1730">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span> <span data-ttu-id="eece9-1731">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1731">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-1732">미리 정의된 응용 프로그램 도메인 속성의 이름 또는 사용자가 정의한 응용 프로그램 도메인 속성의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1732">The name of a predefined application domain property, or the name of an application domain property you have defined.</span></span></param>
        <summary><span data-ttu-id="eece9-1733">지정한 이름에 대해 현재 응용 프로그램 도메인에 저장된 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1733">Gets the value stored in the current application domain for the specified name.</span></span></summary>
        <returns><span data-ttu-id="eece9-1734"><paramref name="name" /> 속성의 값이거나, 속성이 없을 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1734">The value of the <paramref name="name" /> property, or <see langword="null" /> if the property does not exist.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1735">이 메서드를 사용 하 여이 인스턴스의 속성을 설명 하는 이름-데이터 쌍의 내부 캐시에 있는 항목의 값을 검색할 <xref:System.AppDomain>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1735">Use this method to retrieve the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <xref:System.AppDomain>.</span></span> <span data-ttu-id="eece9-1736">비교 `name` 키-값 쌍의 이름으로는 대/소문자 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1736">Note that the comparison of `name` with the name of key-value pairs is case-sensitive.</span></span>  
  
 <span data-ttu-id="eece9-1737">캐시는 자동으로 응용 프로그램 도메인이 만들어질 때 삽입 되는 미리 정의 된 시스템 항목을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1737">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="eece9-1738">사용 하 여 해당 값을 검사할 수 있습니다 합니다 <xref:System.AppDomain.GetData%2A> 메서드 또는 해당 <xref:System.AppDomainSetup> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1738">You can inspect their values with the <xref:System.AppDomain.GetData%2A> method, or the equivalent <xref:System.AppDomainSetup> properties.</span></span>  
  
 <span data-ttu-id="eece9-1739">삽입 하거나 고유한 사용자 정의 이름-데이터 쌍을 수정할 수는 <xref:System.AppDomain.SetData%2A> 메서드 사용 하 여 해당 값을 검사 하 고는 <xref:System.AppDomain.GetData%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1739">You can insert or modify your own user defined name-data pairs with the <xref:System.AppDomain.SetData%2A> method and inspect their values with the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
 <span data-ttu-id="eece9-1740">다음 표에 `name` 각각의 미리 정의 된 시스템 항목 및 해당 <xref:System.AppDomainSetup> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1740">The following table describes the `name` of each predefined system entry and its corresponding <xref:System.AppDomainSetup> property.</span></span>  
  
|<span data-ttu-id="eece9-1741">'Name' 값</span><span class="sxs-lookup"><span data-stu-id="eece9-1741">Value of 'name'</span></span>|<span data-ttu-id="eece9-1742">속성</span><span class="sxs-lookup"><span data-stu-id="eece9-1742">Property</span></span>|  
|---------------------|--------------|  
|<span data-ttu-id="eece9-1743">"APPBASE"</span><span class="sxs-lookup"><span data-stu-id="eece9-1743">"APPBASE"</span></span>|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="eece9-1744">"APP_CONFIG_FILE"</span><span class="sxs-lookup"><span data-stu-id="eece9-1744">"APP_CONFIG_FILE"</span></span>|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="eece9-1745">"APP_LAUNCH_URL"</span><span class="sxs-lookup"><span data-stu-id="eece9-1745">"APP_LAUNCH_URL"</span></span>|<span data-ttu-id="eece9-1746">(속성 없음)</span><span class="sxs-lookup"><span data-stu-id="eece9-1746">(no property)</span></span><br /><br /> <span data-ttu-id="eece9-1747">"APP_LAUNCH_URL" 모든 리디렉션 하기 전에 사용자가 원래 요청한 URL을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1747">"APP_LAUNCH_URL" represents the URL originally requested by the user, before any redirection.</span></span> <span data-ttu-id="eece9-1748">Internet Explorer와 같은 브라우저를 사용 하 여 응용 프로그램 시작 되었습니다 하는 경우에 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1748">It is available only when the application has been launched with a browser such as Internet Explorer.</span></span> <span data-ttu-id="eece9-1749">일부 브라우저는이 값을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1749">Not all browsers provide this value.</span></span>|  
|<span data-ttu-id="eece9-1750">"APP_NAME"</span><span class="sxs-lookup"><span data-stu-id="eece9-1750">"APP_NAME"</span></span>|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="eece9-1751">"BINPATH_PROBE_ONLY"</span><span class="sxs-lookup"><span data-stu-id="eece9-1751">"BINPATH_PROBE_ONLY"</span></span>|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="eece9-1752">"CACHE_BASE"</span><span class="sxs-lookup"><span data-stu-id="eece9-1752">"CACHE_BASE"</span></span>|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="eece9-1753">"CODE_DOWNLOAD_DISABLED"</span><span class="sxs-lookup"><span data-stu-id="eece9-1753">"CODE_DOWNLOAD_DISABLED"</span></span>|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="eece9-1754">"DEV_PATH"</span><span class="sxs-lookup"><span data-stu-id="eece9-1754">"DEV_PATH"</span></span>|<span data-ttu-id="eece9-1755">(속성 없음)</span><span class="sxs-lookup"><span data-stu-id="eece9-1755">(no property)</span></span>|  
|<span data-ttu-id="eece9-1756">"DISALLOW_APP"</span><span class="sxs-lookup"><span data-stu-id="eece9-1756">"DISALLOW_APP"</span></span>|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="eece9-1757">"DISALLOW_APP_BASE_PROBING"</span><span class="sxs-lookup"><span data-stu-id="eece9-1757">"DISALLOW_APP_BASE_PROBING"</span></span>|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="eece9-1758">"DISALLOW_APP_REDIRECTS"</span><span class="sxs-lookup"><span data-stu-id="eece9-1758">"DISALLOW_APP_REDIRECTS"</span></span>|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="eece9-1759">"DYNAMIC_BASE"</span><span class="sxs-lookup"><span data-stu-id="eece9-1759">"DYNAMIC_BASE"</span></span>|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="eece9-1760">"FORCE_CACHE_INSTALL"</span><span class="sxs-lookup"><span data-stu-id="eece9-1760">"FORCE_CACHE_INSTALL"</span></span>|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="eece9-1761">"LICENSE_FILE" 또는 응용 프로그램별 문자열</span><span class="sxs-lookup"><span data-stu-id="eece9-1761">"LICENSE_FILE", or an application-specific string</span></span>|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="eece9-1762">"LOADER_OPTIMIZATION"</span><span class="sxs-lookup"><span data-stu-id="eece9-1762">"LOADER_OPTIMIZATION"</span></span>|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="eece9-1763">"LOCATION_URI"</span><span class="sxs-lookup"><span data-stu-id="eece9-1763">"LOCATION_URI"</span></span>|<span data-ttu-id="eece9-1764">(속성 없음)</span><span class="sxs-lookup"><span data-stu-id="eece9-1764">(no property)</span></span>|  
|<span data-ttu-id="eece9-1765">"PRIVATE_BINPATH"</span><span class="sxs-lookup"><span data-stu-id="eece9-1765">"PRIVATE_BINPATH"</span></span>|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="eece9-1766">"REGEX_DEFAULT_MATCH_TIMEOUT"</span><span class="sxs-lookup"><span data-stu-id="eece9-1766">"REGEX_DEFAULT_MATCH_TIMEOUT"</span></span>|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> <span data-ttu-id="eece9-1767">"REGEX_DEFAULT_MATCH_TIMEOUT" 시스템 항목을 아니며 해당 값을 호출 하 여 설정할 수는 <xref:System.AppDomain.SetData%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1767">"REGEX_DEFAULT_MATCH_TIMEOUT" is not a system entry, and its value can be set by calling the <xref:System.AppDomain.SetData%2A> method.</span></span>|  
|<span data-ttu-id="eece9-1768">"SHADOW_COPY_DIRS"</span><span class="sxs-lookup"><span data-stu-id="eece9-1768">"SHADOW_COPY_DIRS"</span></span>|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1769">다음 예제에서는 새 응용 프로그램 도메인을 만들고, 도메인에 대해 시스템이 제공한 값을 설정 및 도메인에 대 한 새 값 쌍을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1769">The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain.</span></span> <span data-ttu-id="eece9-1770">이 예제에서는 사용 하는 방법을 보여 줍니다는 <xref:System.AppDomain.GetData%2A> 메서드를 이러한 값 쌍에서 데이터를 검색 하 고 콘솔에 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1770">The example then demonstrates how to use the <xref:System.AppDomain.GetData%2A> method to retrieve the data from these value pairs and display them to the console.</span></span>  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1771"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1771"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1772">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1772">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1773">경로 속성을 경로에 적용 되는 경우 자체의 정보에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1773">for access to the information in the path itself, if the property applies to a path.</span></span> <span data-ttu-id="eece9-1774">연관된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1774">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="eece9-1775">현재 인스턴스의 형식을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1775">Gets the type of the current instance.</span></span></summary>
        <returns><span data-ttu-id="eece9-1776">현재 인스턴스의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1776">The type of the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-1777">프로세스 내 응용 프로그램 도메인을 고유하게 식별하는 정수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1777">Gets an integer that uniquely identifies the application domain within the process.</span></span></summary>
        <value><span data-ttu-id="eece9-1778">응용 프로그램 도메인을 식별하는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1778">An integer that identifies the application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="eece9-1779">다음 코드 예제에서는 두 번째 응용 프로그램 도메인을 만들고 기본 도메인 및 새 도메인에 대 한 정보를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1779">The following code example creates a second application domain and displays information about the default domain and the new domain.</span></span>  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="eece9-1780">임대가 만들어지는 것을 방지하여 <see cref="T:System.AppDomain" />에 영구적 수명을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1780">Gives the <see cref="T:System.AppDomain" /> an infinite lifetime by preventing a lease from being created.</span></span></summary>
        <returns><span data-ttu-id="eece9-1781">항상 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1781">Always <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1782">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1782">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-1783">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1783">requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-1784">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1784">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="eece9-1785">테스트할 호환성 스위치입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1785">The compatibility switch to test.</span></span></param>
        <summary><span data-ttu-id="eece9-1786">호환성 스위치가 설정되어 있는지를 확인하고 설정되어 있으면 지정한 호환성 스위치가 설정되어 있는지를 나타내는 nullable 부울 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1786">Gets a nullable Boolean value that indicates whether any compatibility switches are set, and if so, whether the specified compatibility switch is set.</span></span></summary>
        <returns><span data-ttu-id="eece9-1787">호환성 스위치가 설정되어 있으면 <paramref name="value" />에 지정된 호환성 스위치가 설정되어 있는지 여부를 나타내는 부울 값이고, 그러지 않으면 Null 참조(Visual Basic의 경우 <see langword="Nothing" />)입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1787">A null reference (<see langword="Nothing" /> in Visual Basic) if no compatibility switches are set; otherwise, a Boolean value that indicates whether the compatibility switch that is specified by <paramref name="value" /> is set.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1788">이 메서드는 현재 응용 프로그램 도메인 지정한 호환성 스위치가 설정 되어 있는지 여부를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1788">This method tests whether the specified compatibility switch has been set for the current application domain.</span></span> <span data-ttu-id="eece9-1789">(예: 방식으로 문자열을 정렬 하 고) 일반적으로 호환성 스위치 동작을 복원 하는.NET Framework의 버전 간에 변경 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1789">Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.</span></span>  <span data-ttu-id="eece9-1790">호출 하 여 설정 된 <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> 응용 프로그램 도메인을 만들기 전에 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1790">They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> method before creating an application domain.</span></span>  
  
 <span data-ttu-id="eece9-1791">다음 표에서.NET Framework의 이전 버전의 동작을 복원 하려면 설정할 수 있는 호환성 스위치의 예제를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1791">The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.</span></span>  
  
|<span data-ttu-id="eece9-1792">전환</span><span class="sxs-lookup"><span data-stu-id="eece9-1792">Switch</span></span>|<span data-ttu-id="eece9-1793">의미</span><span class="sxs-lookup"><span data-stu-id="eece9-1793">Meaning</span></span>|  
|------------|-------------|  
|<span data-ttu-id="eece9-1794">"NetFx40_LegacySecurityPolicy"</span><span class="sxs-lookup"><span data-stu-id="eece9-1794">"NetFx40_LegacySecurityPolicy"</span></span>|<span data-ttu-id="eece9-1795">액세스 보안 (CA)에 대 한 코드는 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 이 응용 프로그램 도메인에서 사용 하도록 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1795">Code access security (CAS) for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span> <span data-ttu-id="eece9-1796">참조 [ &lt;NetFx40_LegacySecurityPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1796">See [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</span></span>|  
|<span data-ttu-id="eece9-1797">"NetFx40_Legacy20SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="eece9-1797">"NetFx40_Legacy20SortingBehavior"</span></span>|<span data-ttu-id="eece9-1798">문자열에 대 한 기본값을 정렬 된 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 이 응용 프로그램 도메인에서 활성화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1798">String sorting defaults for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] are enabled in this application domain.</span></span> <span data-ttu-id="eece9-1799">성공 sort00001000.dll을 설치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1799">Its success requires sort00001000.dll to be installed.</span></span> <span data-ttu-id="eece9-1800">참조 [ &lt;CompatSortNLSVersion&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1800">See [&lt;CompatSortNLSVersion&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).</span></span>|  
|<span data-ttu-id="eece9-1801">"NetFx40_Legacy40SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="eece9-1801">"NetFx40_Legacy40SortingBehavior"</span></span>|<span data-ttu-id="eece9-1802">문자열에 대 한 기본값을 정렬 된 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]유니코드 5.0이 응용 프로그램 도메인에서 사용 되 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1802">String sorting defaults for the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain.</span></span> <span data-ttu-id="eece9-1803">성공 sort00060101.dll 설치할 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1803">Its success requires sort00060101.dll to be installed.</span></span>|  
|<span data-ttu-id="eece9-1804">"NetFx40_TimeSpanLegacyFormatMode"</span><span class="sxs-lookup"><span data-stu-id="eece9-1804">"NetFx40_TimeSpanLegacyFormatMode"</span></span>|<span data-ttu-id="eece9-1805"><xref:System.TimeSpan> 서식 지정에 대 한 동작을 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 이 응용 프로그램 도메인에서 사용 하도록 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1805"><xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span>  <span data-ttu-id="eece9-1806">참조 [ &lt;TimeSpan_LegacyFormatMode&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) 및 "레거시 TimeSpan 서식 복원" 섹션을 <xref:System.TimeSpan> 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1806">See [&lt;TimeSpan_LegacyFormatMode&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) and the "Restoring Legacy TimeSpan Formatting" section of the <xref:System.TimeSpan> topic.</span></span>|  
|<span data-ttu-id="eece9-1807">"UseRandomizedStringHashAlgorithm"</span><span class="sxs-lookup"><span data-stu-id="eece9-1807">"UseRandomizedStringHashAlgorithm"</span></span>|<span data-ttu-id="eece9-1808">문자열에 대 한 해시 코드를 계산 하는 런타임에 응용 프로그램 도메인 간에 일관 된 해시 코드를 생성 하는 단일 해싱 알고리즘을 사용 하는 대신 응용 프로그램 도메인 별로 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1808">The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains.</span></span> <span data-ttu-id="eece9-1809">참조 [ &lt;UseRandomizedStringHashAlgorithm&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1809">See [&lt;UseRandomizedStringHashAlgorithm&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="eece9-1810">응용 프로그램 도메인이 해당 프로세스에 대한 기본 응용 프로그램 도메인인지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1810">Returns a value that indicates whether the application domain is the default application domain for the process.</span></span></summary>
        <returns><span data-ttu-id="eece9-1811">현재 <see cref="T:System.AppDomain" /> 개체가 해당 프로세스에 대한 기본 응용 프로그램 도메인을 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1811"><see langword="true" /> if the current <see cref="T:System.AppDomain" /> object represents the default application domain for the process; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1812">관리 되는 모든 프로세스에는 기본 응용 프로그램 도메인에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1812">Every managed process has a default application domain.</span></span> <span data-ttu-id="eece9-1813">기본 도메인에서 실행이 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1813">Execution begins in the default domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1814">다음 코드 예제에서는 두 번째 응용 프로그램 도메인을 만들고 기본 도메인 및 새 도메인에 대 한 정보를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1814">The following code example creates a second application domain and displays information about the default domain and the new domain.</span></span>  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="eece9-1815">이 응용 프로그램 도메인의 언로드 여부 및 공용 언어 런타임에서 이 응용 프로그램 도메인에 포함된 개체를 종료하고 있는지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1815">Indicates whether this application domain is unloading, and the objects it contains are being finalized by the common language runtime.</span></span></summary>
        <returns><span data-ttu-id="eece9-1816">이 응용 프로그램 도메인의 언로드 작업이 수행되고 공용 언어 런타임에서 이미 종료자를 호출했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1816"><see langword="true" /> if this application domain is unloading and the common language runtime has started invoking finalizers; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1817">개체에 대 한 종료 메서드는 개체가 가비지 수집 되기 전에 필요한 정리 작업을 수행할 기회를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1817">The finalization method for an object provides you an opportunity to perform any necessary cleanup operations before the object is garbage collected.</span></span> <span data-ttu-id="eece9-1818">종료 된 후 개체가 액세스할 수 있지만 잘못 된 상태에 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1818">After finalization, the object is accessible but in an invalid state and therefore unusable.</span></span> <span data-ttu-id="eece9-1819">결국 가비지 수집이 완료 하 고 개체를 회수 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1819">Eventually, garbage collection completes and reclaims the object.</span></span>  
  
 <span data-ttu-id="eece9-1820">개체의 종료 메서드는 다음 상황 중 하나에서: 가비지 수집 중 공용 언어 런타임 종료 될 때 또는 개체를 포함 하는 응용 프로그램 도메인이 언로드될 때.</span><span class="sxs-lookup"><span data-stu-id="eece9-1820">An object's finalization method is called in one of the following situations: during garbage collection, when the common language runtime is shutting down, or when the application domain that contains the object is unloaded.</span></span> <span data-ttu-id="eece9-1821">합니다 <xref:System.AppDomain.IsFinalizingForUnload%2A> 메서드가 반환 `true` ; 마지막 경우에만 반환 하지 않는 `true` 종료 CLR 종료 또는 일상적인 가비지 수집에서 발생 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="eece9-1821">The <xref:System.AppDomain.IsFinalizingForUnload%2A> method returns `true` only in the last case; it does not return `true` if finalization results from routine garbage collection or from CLR shutdown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1822">CLR 종료로 인해 종료 인지 여부를 확인 하려면 사용 된 <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1822">To determine whether finalization is due to CLR shutdown, use the <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="eece9-1823">반환 `true` 또는 종료 하 고 CLR 응용 프로그램 도메인 언로드 중으로 인해 종료 되는 경우.</span><span class="sxs-lookup"><span data-stu-id="eece9-1823">It returns `true` if finalization is due to an application domain being unloaded or to the CLR shutting down.</span></span>  
  
 <span data-ttu-id="eece9-1824">언로드 작업이 수행 하는 동안 종료 메서드에서 실행 중 static 필드로 참조 되 고 종료 메서드를 포함 하는 다른 개체에 액세스 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1824">While executing in your finalization method during domain unloading, you might want to access another object that is referenced by a static field and has a finalization method.</span></span> <span data-ttu-id="eece9-1825">그러나 수행할 수 없습니다 안정적으로 액세스 한 개체가 종료 이미 수 있으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1825">However, you cannot reliably do so because the accessed object might already have been finalized.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1826">이 규칙의 예외는 <xref:System.Console> 스트림 개체를 참조 하는 정적 필드가 포함 되어 있지만 항상 도메인을 언로드하거나 시스템을 종료 하는 동안에 시스템 콘솔에 쓸 수 있도록 특별히 구현 되는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1826">An exception to this rule is the <xref:System.Console> class, which contains static fields that reference stream objects, but is implemented specially so you can always write to the system console, even during domain unloading or system shutdown.</span></span>  
  
 <span data-ttu-id="eece9-1827">개체의 종료 메서드에 개체를 포함 하는 응용 프로그램 도메인이 언로드되고 있는지 여부를 확인 하려면이 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1827">Use this method in an object's finalization method to determine whether the application domain that contains the object is unloading.</span></span> <span data-ttu-id="eece9-1828">하는 경우 종료 메서드를 포함 하 고 static 필드로 참조 되는 모든 개체를 안정적으로 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1828">If that is the case, you cannot reliably access any object that has a finalization method and is referenced by a static field.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-1829">현재 응용 프로그램 도메인에 로드된 어셈블리가 완전 신뢰로 실행되는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1829">Gets a value that indicates whether assemblies that are loaded into the current application domain execute with full trust.</span></span></summary>
        <value><span data-ttu-id="eece9-1830">현재 응용 프로그램 도메인에 로드된 어셈블리가 완전 신뢰로 실행되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1830"><see langword="true" /> if assemblies that are loaded into the current application domain execute with full trust; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1831">이 메서드는 항상 반환 `true` 데스크톱에서 실행 되는 응용 프로그램의 기본 응용 프로그램 도메인에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1831">This method always returns `true` for the default application domain of an application that runs on the desktop.</span></span> <span data-ttu-id="eece9-1832">반환 `false` 를 사용 하 여 생성 된 샌드박스 응용 프로그램 도메인을 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 응용 프로그램 도메인에 부여 된 권한은 완전 신뢰와 동일 하지 않으면 메서드를 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1832">It returns `false` for a sandboxed application domain that was created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload, unless the permissions that are granted to the application domain are equivalent to full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1833">다음 예제는 <xref:System.AppDomain.IsFullyTrusted%2A> 속성 및 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 완전히 신뢰할 수 있는 고 부분적으로 신뢰할 수 있는 응용 프로그램 도메인을 사용 하 여 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1833">The following example demonstrates the <xref:System.AppDomain.IsFullyTrusted%2A> property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> property with fully trusted and partially trusted application domains.</span></span> <span data-ttu-id="eece9-1834">완전히 신뢰할 수 있는 응용 프로그램 도메인은 응용 프로그램에 대 한 기본 응용 프로그램 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1834">The fully trusted application domain is the default application domain for the application.</span></span> <span data-ttu-id="eece9-1835">부분적으로 신뢰할 수 있는 응용 프로그램 도메인을 사용 하 여 만들어집니다는 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1835">The partially trusted application domain is created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload.</span></span>  
  
 <span data-ttu-id="eece9-1836">이 예제에서는 사용을 `Worker` 에서 파생 된 클래스 <xref:System.MarshalByRefObject>이므로 응용 프로그램 도메인 경계를 넘어 마샬링될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1836">The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="eece9-1837">이 예에서는 만듭니다는 `Worker` 기본 응용 프로그램 도메인에 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1837">The example creates a `Worker` object in the default application domain.</span></span> <span data-ttu-id="eece9-1838">그런 다음 호출 하는 `TestIsFullyTrusted` 응용 프로그램 도메인 및 응용 프로그램 도메인에 로드 되는 두 어셈블리에 대 한 속성 값을 표시 하는 방법:.NET Framework 및 예제에서는 어셈블리의 일부인 인 mscorlib을 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1838">It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly.</span></span> <span data-ttu-id="eece9-1839">응용 프로그램 도메인이 완전히 신뢰할 수 있는 이므로 두 어셈블리는 완전히 신뢰 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1839">The application domain is fully trusted, so both assemblies are fully trusted.</span></span>  
  
 <span data-ttu-id="eece9-1840">이 예에서는 다른 만듭니다 `Worker` 샌드박스 응용 프로그램 도메인에 다시 호출 하는 개체는 `TestIsFullyTrusted` 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1840">The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method.</span></span> <span data-ttu-id="eece9-1841">부분적으로 신뢰할 수 있는 응용 프로그램 도메인 에서도 Mscorlib는 신뢰할 수 있으며 항상 이지만 예제 어셈블리가 부분적으로 신뢰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1841">Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.</span></span>  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-1842">응용 프로그램 도메인에 로드된 모든 어셈블리에 부여된 권한 집합이 현재 응용 프로그램 도메인에 있는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1842">Gets a value that indicates whether the current application domain has a set of permissions that is granted to all assemblies that are loaded into the application domain.</span></span></summary>
        <value><span data-ttu-id="eece9-1843">현재 응용 프로그램 도메인에 형식이 같은 권한 집합이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1843"><see langword="true" /> if the current application domain has a homogenous set of permissions; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1844">이 속성은 반환 `true` 를 사용 하 여 생성 된 샌드박스 응용 프로그램 도메인에 대 한는 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1844">This property returns `true` for sandboxed application domains that were created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="eece9-1845">샌드박스 응용 프로그램 도메인은을 형식이 같은 권한 집합이 있습니다. 즉, 응용 프로그램 도메인에 로드 되는 부분적으로 신뢰할 수 있는 모든 어셈블리에 동일한 사용 권한 집합이 부여 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1845">Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</span></span> <span data-ttu-id="eece9-1846">샌드박스 응용 프로그램 도메인에는 필요에 따라이 사용 권한을 설정 하 고 대신 완전 신뢰로 실행에서 제외 되는 강력한 이름의 어셈블리 목록이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1846">A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</span></span>  
  
 <span data-ttu-id="eece9-1847">완전히 신뢰 하는 코드를 사용할 수는 <xref:System.AppDomain.PermissionSet%2A> 샌드박스 응용 프로그램 도메인의 형식이 같은 권한 부여 집합을 결정 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1847">Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.</span></span>  
  
 <span data-ttu-id="eece9-1848">또한이 속성 반환 `true` 데스크톱 응용 프로그램을 기본 응용 프로그램 도메인에 대 한 해당 응용 프로그램 도메인은 모든 어셈블리에 완전 신뢰를 부여 하므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1848">This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="eece9-1849"><see cref="T:System.Reflection.Assembly" />를 이 용용 프로그램 도메인에 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1849">Loads an <see cref="T:System.Reflection.Assembly" /> into this application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="eece9-1850">내보낸 어셈블리가 포함된 COFF 기반 이미지인 <see langword="byte" /> 형식의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1850">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="eece9-1851">내보낸 <see cref="T:System.Reflection.Assembly" />가 들어 있는 COFF(Common Object File Format) 기반 이미지를 사용한 <see cref="T:System.Reflection.Assembly" />를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1851">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span></summary>
        <returns><span data-ttu-id="eece9-1852">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1852">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1853">부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)],이 메서드를 사용 하 여 로드 된 어셈블리의 신뢰 수준을 응용 프로그램 도메인의 신뢰 수준으로 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1853">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="eece9-1854">현재 응용 프로그램 도메인에 어셈블리를 로드에이 메서드를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1854">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="eece9-1855">이 메서드는 정적을 호출할 수 없습니다는 상호 운용성 호출자에 대 한 편의 기능으로 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1855">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="eece9-1856">다른 응용 프로그램 도메인에 어셈블리 로드를 사용 하 여 메서드 같은 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1856">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="eece9-1857">이 메서드의 모든 오버 로드에 공통 된 정보에 대 한 참조를 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1857">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1858">다음 샘플 원시 어셈블리를 로드 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1858">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="eece9-1859">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1859">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="eece9-1860">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1860">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1861"><paramref name="rawAssembly" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1861"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1862"><paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1862"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1863">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1863">-or-</span></span> 
<span data-ttu-id="eece9-1864">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1864">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1865">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1865">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1866">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1866">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1867">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1867">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="eece9-1868">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1868">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="eece9-1869">로드할 어셈블리를 설명하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1869">An object that describes the assembly to load.</span></span></param>
        <summary><span data-ttu-id="eece9-1870"><see cref="T:System.Reflection.AssemblyName" />이 지정된 <see cref="T:System.Reflection.Assembly" />를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1870">Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="eece9-1871">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1871">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1872">현재 응용 프로그램 도메인에 어셈블리를 로드에이 메서드를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1872">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="eece9-1873">이 메서드는 정적을 호출할 수 없습니다는 상호 운용성 호출자에 대 한 편의 기능으로 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1873">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="eece9-1874">다른 응용 프로그램 도메인에 어셈블리 로드를 사용 하 여 메서드 같은 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1874">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="eece9-1875">요청된 된 어셈블리의 버전을 이미 로드 되 면이 메서드는 서로 다른 버전이 필요한 경우에 로드 된 어셈블리를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1875">If a version of the requested assembly is already loaded, this method returns the loaded assembly, even if a different version is requested.</span></span>  
  
 <span data-ttu-id="eece9-1876">부분 어셈블리 이름을 제공 `assemblyRef` 권장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1876">Supplying a partial assembly name for `assemblyRef` is not recommended.</span></span> <span data-ttu-id="eece9-1877">(이름의 일부를 하나 이상의 culture, 버전 또는 공개 키 토큰을 생략 하는 데 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1877">(A partial name omits one or more of culture, version, or public key token.</span></span> <span data-ttu-id="eece9-1878">대신 문자열을 사용 하는 오버 로드에 대 한는 <xref:System.Reflection.AssemblyName> 개체 "MyAssembly, 버전 1.0.0.0 =" 이름의 일부 예가 및 "MyAssembly, 버전 1.0.0.0, Culture = neutral, PublicKeyToken = 18ab3442da84b47 ="은 예 전체 이름입니다.) 부분 이름을 사용 하 여 성능에 부정적인 영향을 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1878">For overloads that take a string instead of an <xref:System.Reflection.AssemblyName> object, "MyAssembly, Version=1.0.0.0" is an example of a partial name and "MyAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=18ab3442da84b47" is an example of a full name.) Using partial names has a negative effect on performance.</span></span> <span data-ttu-id="eece9-1879">또한 부분 어셈블리 이름을 로드할 수 어셈블리를 전역 어셈블리 캐시에서 응용 프로그램 기본 디렉터리에 있는 어셈블리의 정확한 복사본을 필요한 경우에 (<xref:System.AppDomain.BaseDirectory%2A> 또는 <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="eece9-1879">In addition, a partial assembly name can load an assembly from the global assembly cache only if there is an exact copy of the assembly in the application base directory (<xref:System.AppDomain.BaseDirectory%2A> or <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).</span></span>  
  
 <span data-ttu-id="eece9-1880">경우 현재 <xref:System.AppDomain> 개체는 응용 프로그램 도메인을 나타내면 `A`, 및 <xref:System.AppDomain.Load%2A> 메서드는 응용 프로그램 도메인에서 `B`, 어셈블리 두 응용 프로그램 도메인에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1880">If the current <xref:System.AppDomain> object represents application domain `A`, and the <xref:System.AppDomain.Load%2A> method is called from application domain `B`, the assembly is loaded into both application domains.</span></span> <span data-ttu-id="eece9-1881">예를 들어, 다음 코드 부하 `MyAssembly` 새 응용 프로그램 도메인에 `ChildDomain` 는 코드가 실행 되는 응용 프로그램 도메인으로도:</span><span class="sxs-lookup"><span data-stu-id="eece9-1881">For example, the following code loads `MyAssembly` into the new application domain `ChildDomain` and also into the application domain where the code executes:</span></span>  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 <span data-ttu-id="eece9-1882">때문에 어셈블리 두 도메인에 로드 됩니다 <xref:System.Reflection.Assembly> 에서 파생 되지 않습니다 <xref:System.MarshalByRefObject>, 따라서의 반환 값과는 <xref:System.AppDomain.Load%2A> 메서드 마샬링될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1882">The assembly is loaded into both domains because <xref:System.Reflection.Assembly> does not derive from <xref:System.MarshalByRefObject>, and therefore the return value of the <xref:System.AppDomain.Load%2A> method cannot be marshaled.</span></span> <span data-ttu-id="eece9-1883">대신, 공용 언어 런타임에서 어셈블리를 호출 하는 응용 프로그램 도메인이 로드 하려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1883">Instead, the common language runtime tries to load the assembly into the calling application domain.</span></span> <span data-ttu-id="eece9-1884">두 응용 프로그램 도메인에 로드 되는 어셈블리는 두 응용 프로그램 도메인에 대 한 경로 설정이 다른 경우 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1884">The assemblies that are loaded into the two application domains might be different if the path settings for the two application domains are different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-1885">모두를 <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> 속성 및 <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> 어셈블리를 로드 하려는 첫 번째 시도에서는 표시 이름으로 속성 설정 (반환한 버전, 문화권 및 등을 포함 하 여는 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 속성).</span><span class="sxs-lookup"><span data-stu-id="eece9-1885">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="eece9-1886">파일이 없는 경우는 <xref:System.Reflection.AssemblyName.CodeBase%2A> 속성 어셈블리를 검색 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1886">If the file is not found, the <xref:System.Reflection.AssemblyName.CodeBase%2A> property is used to search for the assembly.</span></span> <span data-ttu-id="eece9-1887">사용 하 여 어셈블리 있으면 <xref:System.Reflection.AssemblyName.CodeBase%2A>, 표시 이름을 어셈블리에 대해 일치 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1887">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="eece9-1888">검색이 실패 하는 경우는 <xref:System.IO.FileLoadException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1888">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1889"><paramref name="assemblyRef" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1889"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1890"><paramref name="assemblyRef" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1890"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1891"><paramref name="assemblyRef" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1891"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1892">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1892">-or-</span></span> 
<span data-ttu-id="eece9-1893">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyRef" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1893">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1894">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1894">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1895">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1895">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1896">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1896">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="eece9-1897">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1897">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="eece9-1898">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1898">The display name of the assembly.</span></span> <span data-ttu-id="eece9-1899"><see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-1899">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <summary><span data-ttu-id="eece9-1900">표시 이름이 지정된 <see cref="T:System.Reflection.Assembly" />를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1900">Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</span></span></summary>
        <returns><span data-ttu-id="eece9-1901">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1901">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1902">현재 응용 프로그램 도메인에 어셈블리를 로드에이 메서드를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1902">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="eece9-1903">이 메서드는 정적을 호출할 수 없습니다는 상호 운용성 호출자에 대 한 편의 기능으로 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1903">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="eece9-1904">다른 응용 프로그램 도메인에 어셈블리 로드를 사용 하 여 메서드 같은 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1904">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="eece9-1905">이 메서드의 모든 오버 로드에 공통 된 정보에 대 한 참조를 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1905">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1906"><paramref name="assemblyString" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1906"><paramref name="assemblyString" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1907"><paramref name="assemblyString" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1907"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1908"><paramref name="assemblyString" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1908"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1909">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1909">-or-</span></span> 
<span data-ttu-id="eece9-1910">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyString" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1910">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1911">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1911">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1912">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1912">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1913">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1913">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="eece9-1914">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1914">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1915">어셈블리를 로컬이 아닌 경우 어셈블리의 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1915">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="eece9-1916">내보낸 어셈블리가 포함된 COFF 기반 이미지인 <see langword="byte" /> 형식의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1916">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="eece9-1917">어셈블리의 기호를 나타내는 원시 바이트가 포함된 <see langword="byte" /> 형식의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1917">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="eece9-1918">내보낸 <see cref="T:System.Reflection.Assembly" />가 들어 있는 COFF(Common Object File Format) 기반 이미지를 사용한 <see cref="T:System.Reflection.Assembly" />를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1918">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span> <span data-ttu-id="eece9-1919"><see cref="T:System.Reflection.Assembly" />에 대한 기호를 나타내는 원시 바이트도 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1919">The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</span></span></summary>
        <returns><span data-ttu-id="eece9-1920">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1920">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1921">부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)],이 메서드를 사용 하 여 로드 된 어셈블리의 신뢰 수준을 응용 프로그램 도메인의 신뢰 수준으로 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1921">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="eece9-1922">현재 응용 프로그램 도메인에 어셈블리를 로드에이 메서드를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1922">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="eece9-1923">이 메서드는 정적을 호출할 수 없습니다는 상호 운용성 호출자에 대 한 편의 기능으로 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1923">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="eece9-1924">다른 응용 프로그램 도메인에 어셈블리 로드를 사용 하 여 메서드 같은 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1924">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="eece9-1925">이 메서드의 모든 오버 로드에 공통 된 정보에 대 한 참조를 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1925">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1926">다음 샘플 원시 어셈블리를 로드 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1926">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="eece9-1927">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1927">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="eece9-1928">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1928">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1929"><paramref name="rawAssembly" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1929"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1930"><paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1930"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1931">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1931">-or-</span></span> 
<span data-ttu-id="eece9-1932">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1932">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1933">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1933">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1934">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1934">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1935">"file://"로 시작 하지 않는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1935">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1936">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1936">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="eece9-1937">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1937">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="eece9-1938">로드할 어셈블리를 설명하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1938">An object that describes the assembly to load.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="eece9-1939">어셈블리 로드에 사용할 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1939">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="eece9-1940"><see cref="T:System.Reflection.AssemblyName" />이 지정된 <see cref="T:System.Reflection.Assembly" />를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1940">Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="eece9-1941">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1941">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1942">현재 응용 프로그램 도메인에 어셈블리를 로드에이 메서드를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1942">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="eece9-1943">이 메서드는 정적을 호출할 수 없습니다는 상호 운용성 호출자에 대 한 편의 기능으로 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1943">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="eece9-1944">다른 응용 프로그램 도메인에 어셈블리 로드를 사용 하 여 메서드 같은 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1944">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="eece9-1945">이 메서드의 모든 오버 로드에 공통 된 정보에 대 한 참조를 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1945">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1946"><paramref name="assemblyRef" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1946"><paramref name="assemblyRef" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1947"><paramref name="assemblyRef" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1947"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1948"><paramref name="assemblyRef" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1948"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1949">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1949">-or-</span></span> 
<span data-ttu-id="eece9-1950">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyRef" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1950">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1951">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1951">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1952">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1952">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1953">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1953">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="eece9-1954">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1954">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1955">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1955">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1956">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1956">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1957">"file://" 폼에 없는 경로 읽기 위한 또는 "\\\UNC\dir\\" 또는 "c:\\"입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1957">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="eece9-1958">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1958">The display name of the assembly.</span></span> <span data-ttu-id="eece9-1959"><see cref="P:System.Reflection.Assembly.FullName" />을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-1959">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="eece9-1960">어셈블리 로드에 사용할 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1960">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="eece9-1961">표시 이름이 지정된 <see cref="T:System.Reflection.Assembly" />를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1961">Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</span></span></summary>
        <returns><span data-ttu-id="eece9-1962">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1962">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1963">현재 응용 프로그램 도메인에 어셈블리를 로드에이 메서드를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1963">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="eece9-1964">이 메서드는 정적을 호출할 수 없습니다는 상호 운용성 호출자에 대 한 편의 기능으로 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1964">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="eece9-1965">다른 응용 프로그램 도메인에 어셈블리 로드를 사용 하 여 메서드 같은 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1965">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="eece9-1966">이 메서드의 모든 오버 로드에 공통 된 정보에 대 한 참조를 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1966">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1967"><paramref name="assemblyString" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1967"><paramref name="assemblyString" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="eece9-1968"><paramref name="assemblyString" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1968"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1969"><paramref name="assemblyString" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1969"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1970">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1970">-or-</span></span> 
<span data-ttu-id="eece9-1971">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyString" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1971">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1972">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1972">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1973">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1973">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-1974">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1974">to load an assembly with evidence.</span></span> <span data-ttu-id="eece9-1975">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-1975">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-1976">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1976">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="eece9-1977">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1977">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-1978">"file://" 폼에 없는 경로 읽기 위한 또는 "\\\UNC\dir\\" 또는 "c:\\"입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1978">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="eece9-1979">내보낸 어셈블리가 포함된 COFF 기반 이미지인 <see langword="byte" /> 형식의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1979">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="eece9-1980">어셈블리의 기호를 나타내는 원시 바이트가 포함된 <see langword="byte" /> 형식의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1980">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="eece9-1981">어셈블리 로드에 사용할 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1981">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="eece9-1982">내보낸 <see cref="T:System.Reflection.Assembly" />가 들어 있는 COFF(Common Object File Format) 기반 이미지를 사용한 <see cref="T:System.Reflection.Assembly" />를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1982">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span> <span data-ttu-id="eece9-1983"><see cref="T:System.Reflection.Assembly" />에 대한 기호를 나타내는 원시 바이트도 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1983">The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</span></span></summary>
        <returns><span data-ttu-id="eece9-1984">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1984">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-1985">부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)],이 메서드를 사용 하 여 로드 된 어셈블리의 신뢰 수준을 응용 프로그램 도메인의 신뢰 수준으로 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1985">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="eece9-1986">현재 응용 프로그램 도메인에 어셈블리를 로드에이 메서드를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1986">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="eece9-1987">이 메서드는 정적을 호출할 수 없습니다는 상호 운용성 호출자에 대 한 편의 기능으로 제공 됩니다 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-1987">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="eece9-1988">다른 응용 프로그램 도메인에 어셈블리 로드를 사용 하 여 메서드 같은 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1988">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="eece9-1989">이 메서드의 모든 오버 로드에 공통 된 정보에 대 한 참조를 <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1989">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-1990">다음 샘플 원시 어셈블리를 로드 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1990">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="eece9-1991">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1991">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="eece9-1992">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1992">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-1993"><paramref name="rawAssembly" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-1993"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="eece9-1994"><paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1994"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="eece9-1995">또는</span><span class="sxs-lookup"><span data-stu-id="eece9-1995">-or-</span></span> 
<span data-ttu-id="eece9-1996">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />이 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1996">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-1997">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1997">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="eece9-1998">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1998">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="eece9-1999"><paramref name="securityEvidence" />이 <see langword="null" />가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-1999"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span> <span data-ttu-id="eece9-2000">레거시 CAS 정책을 사용하지 않을 때는 <paramref name="securityEvidence" />는 <see langword="null" />이 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2000">When legacy CAS policy is not enabled, <paramref name="securityEvidence" /> should be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-2001">증명 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2001">to provide evidence.</span></span> <span data-ttu-id="eece9-2002">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="eece9-2002">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="eece9-2003">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2003">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-2004">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2004">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="eece9-2005">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2005">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="eece9-2006">"file://" 폼에 없는 경로 읽기 위한 또는 "\\\UNC\dir\\" 또는 "c:\\"입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2006">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-2007">현재 프로세스에 응용 프로그램 도메인의 CPU 및 메모리 모니터링을 사용할 수 있는지를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2007">Gets or sets a value that indicates whether CPU and memory monitoring of application domains is enabled for the current process.</span></span> <span data-ttu-id="eece9-2008">프로세스에 모니터링을 사용할 수 있는 경우 사용하지 못하도록 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2008">Once monitoring is enabled for a process, it cannot be disabled.</span></span></summary>
        <value><span data-ttu-id="eece9-2009">모니터링을 사용할 수 있으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2009"><see langword="true" /> if monitoring is enabled; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2010">이렇게 `static` 속성 (`Shared` 속성 Visual Basic) CPU 및 메모리 모니터링 프로세스의 모든 응용 프로그램 도메인을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2010">This `static` property (`Shared` property in Visual Basic) controls CPU and memory monitoring of all the application domains in the process.</span></span>  
  
 <span data-ttu-id="eece9-2011">이 속성을 설정 하려고 하면 `false`, <xref:System.ArgumentException> 예외가 throw 되는 속성의 현재 값은 경우에 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2011">If you attempt to set this property to `false`, a <xref:System.ArgumentException> exception is thrown, even if the current value of the property is `false`.</span></span>  
  
 <span data-ttu-id="eece9-2012">모니터링이 활성화 되 면 사용할 수는 <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>를 <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, 및 <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> 인스턴스 개별 응용 프로그램 도메인의 CPU 및 메모리 사용을 모니터링 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2012">Once monitoring is enabled, you can use the <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, and <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> instance properties to monitor CPU and memory use of individual application domains.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eece9-2013">현재 프로세스가 이 속성에 <see langword="false" /> 값을 할당하려 했습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2013">The current process attempted to assign the value <see langword="false" /> to this property.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2014">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2014">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2015">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2015">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="eece9-2016">응용 프로그램 도메인 리소스 모니터링</span><span class="sxs-lookup"><span data-stu-id="eece9-2016">Application Domain Resource Monitoring</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/02119ab6-1e91-448e-97ad-e7b2e5c4bbbd"><span data-ttu-id="eece9-2017">&lt;appdomainResourceMonitoring&gt; 요소</span><span class="sxs-lookup"><span data-stu-id="eece9-2017">&lt;appdomainResourceMonitoring&gt; Element</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-2018">현재 응용 프로그램 도메인에서 참조하도록 알려진 마지막 컬렉션 후에도 유지되는 바이트 수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2018">Gets the number of bytes that survived the last collection and that are known to be referenced by the current application domain.</span></span></summary>
        <value><span data-ttu-id="eece9-2019">유지되는 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2019">The number of surviving bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2020">각 가비지 컬렉션을 사용 하 여 통계 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2020">The statistics are updated with each garbage collection.</span></span> <span data-ttu-id="eece9-2021">그러나 전체 차단 컬렉션 이후에 정확 하 게 되도록 보장 됩니다. 즉, 수집 하는 동안 응용 프로그램을 중지 하는 모든 세대를 포함 하는 컬렉션에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2021">However, they are guaranteed to be accurate only after a full, blocking collection; that is, a collection that includes all generations and that stops the application while collection occurs.</span></span> <span data-ttu-id="eece9-2022">예를 들어를 <xref:System.GC.Collect?displayProperty=nameWithType> 메서드 오버 로드는 전체 차단 컬렉션을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2022">For example, the <xref:System.GC.Collect?displayProperty=nameWithType> method overload performs a full, blocking collection.</span></span> <span data-ttu-id="eece9-2023">(동시 컬렉션 백그라운드에서 발생 하며 응용 프로그램을 차단 하지 않습니다.)</span><span class="sxs-lookup"><span data-stu-id="eece9-2023">(Concurrent collection occurs in the background and does not block the application.)</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="eece9-2024"><see langword="static" />(Visual Basic의 경우 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 속성이 <see langword="false" />로 설정된 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2024">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2025">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2025">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2026">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2026">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="eece9-2027">응용 프로그램 도메인 리소스 모니터링</span><span class="sxs-lookup"><span data-stu-id="eece9-2027">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-2028">프로세스의 모든 응용 프로그램 도메인에 대한 마지막 컬렉션에서 유지된 총 바이트 수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2028">Gets the total bytes that survived from the last collection for all application domains in the process.</span></span></summary>
        <value><span data-ttu-id="eece9-2029">프로세스의 유지되는 총 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2029">The total number of surviving bytes for the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2030">전체 차단 컬렉션 후 바이트 수가 현재 보유 하 고 실시간으로이 번호 나타냅니다 힙을 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2030">After a full, blocking collection, this number represents the number of bytes currently held live on managed heaps.</span></span> <span data-ttu-id="eece9-2031">보고 된 수에 가까운 것을 <xref:System.GC.GetTotalMemory%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-2031">It should be close to the number reported by the <xref:System.GC.GetTotalMemory%2A> method.</span></span> <span data-ttu-id="eece9-2032">임시 수집 후이 숫자 바이트 수를 현재 보유 나타냅니다 임시 세대에서 실시간으로.</span><span class="sxs-lookup"><span data-stu-id="eece9-2032">After an ephemeral collection, this number represents the number of bytes currently held live in ephemeral generations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="eece9-2033"><see langword="static" />(Visual Basic의 경우 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 속성이 <see langword="false" />로 설정된 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2033">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2034">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2034">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2035">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2035">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="eece9-2036">응용 프로그램 도메인 리소스 모니터링</span><span class="sxs-lookup"><span data-stu-id="eece9-2036">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-2037">응용 프로그램 도메인이 만들어진 후 실행된 모든 메모리 할당의 총 크기(바이트)를 수집된 메모리의 크기를 제외하지 않고 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2037">Gets the total size, in bytes, of all memory allocations that have been made by the application domain since it was created, without subtracting memory that has been collected.</span></span></summary>
        <value><span data-ttu-id="eece9-2038">모든 메모리 할당의 총 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2038">The total size of all memory allocations.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="eece9-2039"><see langword="static" />(Visual Basic의 경우 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 속성이 <see langword="false" />로 설정된 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2039">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2040">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2040">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2041">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2041">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="eece9-2042">응용 프로그램 도메인 리소스 모니터링</span><span class="sxs-lookup"><span data-stu-id="eece9-2042">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-2043">프로세스가 시작된 후 현재 응용 프로그램 도메인에서 실행되는 동안 모든 스레드에서 사용된 총 프로세서 시간을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2043">Gets the total processor time that has been used by all threads while executing in the current application domain, since the process started.</span></span></summary>
        <value><span data-ttu-id="eece9-2044">현재 응용 프로그램 도메인의 총 프로세서 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2044">Total processor time for the current application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2045">응용 프로그램 도메인에 대 한 총 시간 보고 되는 각 스레드는 프로세스에서 해당 응용 프로그램 도메인에서 실행 하는 데 소요 된 시간을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2045">The total time that is reported for an application domain includes the time each thread in the process spent executing in that application domain.</span></span>  
  
 <span data-ttu-id="eece9-2046">비관리 코드를 호출 하는 스레드는 여전히 응용 프로그램 도메인을 사용 하 여 연결 하 고 프로세서 시간이 실행 비관리 코드에서 생성 되었으므로 호출 응용 프로그램 도메인에 대해 보고 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2046">A thread that calls into unmanaged code is still associated with an application domain, and the processor time spent executing the unmanaged code is reported for the application domain where the call was made.</span></span>  
  
 <span data-ttu-id="eece9-2047">스레드가 차단 또는 중지는 사용 하지 않습니다 프로세서 시간 경우.</span><span class="sxs-lookup"><span data-stu-id="eece9-2047">When a thread is blocked or sleeping, it does not consume processor time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="eece9-2048"><see langword="static" />(Visual Basic의 경우 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 속성이 <see langword="false" />로 설정된 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2048">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2049">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2049">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2050">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2050">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="eece9-2051">응용 프로그램 도메인 리소스 모니터링</span><span class="sxs-lookup"><span data-stu-id="eece9-2051">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-2052">샌드박스가 적용된 응용 프로그램 도메인의 권한 집합을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2052">Gets the permission set of a sandboxed application domain.</span></span></summary>
        <value><span data-ttu-id="eece9-2053">샌드박스가 적용된 응용 프로그램 도메인의 권한 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2053">The permission set of the sandboxed application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2054">사용 하 여 생성 된 샌드박스 응용 프로그램 도메인을 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 메서드 오버 로드는 형식이 같은 권한 집합이 있는 응용 프로그램 도메인에 로드 되는 부분적으로 신뢰할 수 있는 모든 어셈블리에 동일한 사용 권한 집합이 부여 됩니다,.</span><span class="sxs-lookup"><span data-stu-id="eece9-2054">Sandboxed application domains that were created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</span></span> <span data-ttu-id="eece9-2055">샌드박스 응용 프로그램 도메인에는 필요에 따라이 사용 권한을 설정 하 고 대신 완전 신뢰로 실행에서 제외 되는 강력한 이름의 어셈블리 목록이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2055">A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2056">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2056">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2057">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2057">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-2058">기본 응용 프로그램 도메인의 부모 프로세스가 종료하면 이 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2058">Occurs when the default application domain's parent process exits.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2059"><xref:System.EventHandler> 이 이벤트에서 파일 닫기와 같은 종료 작업을 수행할 수에 대 한 프로세스 종료 되기 전에 저장소를 등 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2059">The <xref:System.EventHandler> for this event can perform termination activities, such as closing files, releasing storage and so on, before the process ends.</span></span>  
  
 <span data-ttu-id="eece9-2060">.NET Framework 버전 2.0부터,이 이벤트는 이벤트 처리기를 등록 하는 각 응용 프로그램 도메인에서 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2060">Beginning with the .NET Framework version 2.0, this event is raised in each application domain that registers an event handler.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-2061">모두의 총 실행 시간 <xref:System.AppDomain.ProcessExit> 모든 종료자의 총 실행 시간 프로세스가 종료 될 때 제한 된 것 처럼 이벤트 처리기가 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2061">The total execution time of all <xref:System.AppDomain.ProcessExit> event handlers is limited, just as the total execution time of all finalizers is limited at process shutdown.</span></span> <span data-ttu-id="eece9-2062">기본값은 2 초입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2062">The default is two seconds.</span></span> <span data-ttu-id="eece9-2063">관리 되지 않는 호스트를 호출 하 여이 실행 시간을 변경할 수는 [iclrpolicymanager:: Settimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) 메서드를 [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) 열거형 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2063">An unmanaged host can change this execution time by calling the [ICLRPolicyManager::SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) method with the [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) enumeration value.</span></span>  
  
 <span data-ttu-id="eece9-2064">.NET Framework 버전 1.0 및 1.1에서는이 이벤트는 기본 응용 프로그램 도메인에만 발생 하 고 기본 응용 프로그램 도메인에는 이벤트 처리기가 등록 하는 경우에.</span><span class="sxs-lookup"><span data-stu-id="eece9-2064">In the .NET Framework versions 1.0 and 1.1, this event is raised only in the default application domain, and only if an event handler is registered in the default application domain.</span></span>  
  
 <span data-ttu-id="eece9-2065">이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2065">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="eece9-2066">이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="eece9-2066">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-2067">어셈블리 전용 컨텍스트에서 어셈블리 확인이 실패하면 이 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2067">Occurs when the resolution of an assembly fails in the reflection-only context.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2068">리플렉션 전용 컨텍스트에서 종속성 자동으로 확인 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2068">In the reflection-only context, dependencies are not resolved automatically.</span></span> <span data-ttu-id="eece9-2069">미리 로드 되거나이 이벤트 처리기에서 반환 될 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2069">They must be preloaded or returned by the handler for this event.</span></span> <span data-ttu-id="eece9-2070">이 이벤트는 어셈블리를 리플렉션 전용 컨텍스트에 로드 되지 않는 종속성에 있을 때 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2070">This event is raised when an assembly has a dependency that is not already loaded into the reflection-only context.</span></span> <span data-ttu-id="eece9-2071">누락 된 종속성으로 지정 된 된 <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2071">The missing dependency is specified by the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="eece9-2072"><xref:System.ResolveEventHandler> 이 이벤트는 종속성을 충족 하는 어셈블리를 반환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2072">The <xref:System.ResolveEventHandler> for this event must return an assembly that satisfies the dependency.</span></span> <span data-ttu-id="eece9-2073">반환 되는 어셈블리를 리플렉션 전용 컨텍스트에 로드 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2073">The assembly that is returned must be loaded into the reflection-only context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eece9-2074">리플렉션 전용 컨텍스트에 로드 되는 어셈블리의 종속성이 누락에 대해서만이 이벤트는 (사용 하 여 예를 들어를 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> 메서드).</span><span class="sxs-lookup"><span data-stu-id="eece9-2074">This event is raised only for missing dependencies of the assembly that you are loading into the reflection-only context (for example, by using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method).</span></span> <span data-ttu-id="eece9-2075">로드 되는 어셈블리를 찾을 수 없는 경우에 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2075">It is not raised if the assembly that you are loading cannot be found.</span></span>  
  
 <span data-ttu-id="eece9-2076">부터는 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> 속성 확인할 수 없습니다. 어셈블리 로드 요청 어셈블리를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2076">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property returns the assembly that requested the assembly load that could not be resolved.</span></span> <span data-ttu-id="eece9-2077">요청 하는 어셈블리의 id를 파악 하는 것은 올바른 버전의 종속성을 식별 하 여 둘 이상의 버전이 없으면 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2077">Knowing the identity of the requesting assembly might be useful in identifying the correct version of the dependency, if more than one version is available.</span></span> <span data-ttu-id="eece9-2078">자세한 내용은 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-2078">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="eece9-2079">이 이벤트는 <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> 속성 정책 적용 되기 전에 어셈블리 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2079">For this event, the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property returns the assembly name before policy is applied.</span></span>  
  
 <span data-ttu-id="eece9-2080">이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="eece9-2080">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2081">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2081">requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2082">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2082">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="eece9-2083">응용 프로그램 도메인의 리플렉션 전용 컨텍스트로 로드된 어셈블리를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2083">Returns the assemblies that have been loaded into the reflection-only context of the application domain.</span></span></summary>
        <returns><span data-ttu-id="eece9-2084">응용 프로그램 도메인의 리플렉션 전용 컨텍스트에 로드된 어셈블리를 나타내는 <see cref="T:System.Reflection.Assembly" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2084">An array of <see cref="T:System.Reflection.Assembly" /> objects that represent the assemblies loaded into the reflection-only context of the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2085">이 메서드는 리플렉션 전용 컨텍스트에 로드 된 어셈블리를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2085">This method returns the assemblies that have been loaded into the reflection-only context.</span></span> <span data-ttu-id="eece9-2086">실행에 대 한 로드 된 어셈블리를 사용 하 여를 <xref:System.AppDomain.GetAssemblies%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-2086">To get the assemblies that have been loaded for execution, use the <xref:System.AppDomain.GetAssemblies%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-2087">다음 코드 예제에서는 실행 컨텍스트에 이동한 후 리플렉션 전용 컨텍스트에 System.dll 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2087">The following code example loads the System.dll assembly into the execution context and then into the reflection-only context.</span></span> <span data-ttu-id="eece9-2088">합니다 <xref:System.AppDomain.GetAssemblies%2A> 고 <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> 메서드 각 컨텍스트에 로드 된 어셈블리를 표시 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2088">The <xref:System.AppDomain.GetAssemblies%2A> and <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> methods are used to display the assemblies loaded into each context.</span></span>  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-2089">언로드된 응용 프로그램 도메인에서 작업을 시도한 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2089">An operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-2090">어셈블리 확인자에서 전용 어셈블리를 조사할 기본 디렉터리 아래의 경로를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2090">Gets the path under the base directory where the assembly resolver should probe for private assemblies.</span></span></summary>
        <value><span data-ttu-id="eece9-2091">어셈블리 확인자에서 전용 어셈블리를 조사할 기본 디렉터리 아래의 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2091">The path under the base directory where the assembly resolver should probe for private assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2092">전용 어셈블리는 응용 프로그램과 동일한 디렉터리 구조에 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2092">Private assemblies are deployed in the same directory structure as the application.</span></span> <span data-ttu-id="eece9-2093">경로에서 지정 된 <xref:System.AppDomain.RelativeSearchPath%2A> 속성 아래에 없는 <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2093">If the path specified by the <xref:System.AppDomain.RelativeSearchPath%2A> property is not under <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, it is ignored.</span></span>  
  
 <span data-ttu-id="eece9-2094">이 속성 값을 사용 하 여 설정 반환 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2094">This property returns the value set using <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-2095">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2095">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="eece9-2096">경로 정보에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2096">for access to the path information.</span></span> <span data-ttu-id="eece9-2097">연관된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="eece9-2097">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-2098">리소스가 어셈블리에서 올바르게 링크되거나 포함된 리소스가 아니어서 리소스 확인이 실패하면 이 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2098">Occurs when the resolution of a resource fails because the resource is not a valid linked or embedded resource in the assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2099"><xref:System.ResolveEventHandler> 에이 이벤트는 리소스를 포함 하는 어셈블리를 찾아 반환 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2099">The <xref:System.ResolveEventHandler> for this event can attempt to locate the assembly containing the resource and return it.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eece9-2100">올바른 연결 된 리소스에 대 한 없는 파일을 찾을 수 없어서 확인이 실패 하는 경우에이 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2100">This event is not raised if resolution fails because no file can be found for a valid linked resource.</span></span> <span data-ttu-id="eece9-2101">개별 리소스 키를 찾을 수 없는 경우 발생 하지 않습니다 하지만 매니페스트 리소스 스트림을 찾을 수 없는 경우 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2101">It is raised if a manifest resource stream cannot be found, but it is not raised if an individual resource key cannot be found.</span></span>  
  
 <span data-ttu-id="eece9-2102">로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> 속성에 리소스를 요청한 어셈블리를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2102">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property contains the assembly that requested the resource.</span></span> <span data-ttu-id="eece9-2103">자세한 내용은 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-2103">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="eece9-2104">이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2104">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="eece9-2105">이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="eece9-2105">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2106">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2106">requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2107">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2107">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy"><span data-ttu-id="eece9-2108">보안 정책 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2108">The security policy level.</span></span></param>
        <summary><span data-ttu-id="eece9-2109">이 응용 프로그램 도메인의 보안 정책 수준을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2109">Establishes the security policy level for this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2110">어셈블리를 로드 하기 전에이 메서드를 호출 합니다 <xref:System.AppDomain> 보안 정책 적용 하기 위해에서.</span><span class="sxs-lookup"><span data-stu-id="eece9-2110">Call this method before an assembly is loaded into the <xref:System.AppDomain> in order for the security policy to have effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-2111">다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.AppDomain.SetAppDomainPolicy%2A> 응용 프로그램 도메인의 보안 정책 수준을 설정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2111">The following example demonstrates how to use the <xref:System.AppDomain.SetAppDomainPolicy%2A> method to set the security policy level of an application domain.</span></span>  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-2112"><paramref name="domainPolicy" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2112"><paramref name="domainPolicy" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Policy.PolicyException"><span data-ttu-id="eece9-2113">보안 정책 수준이 이미 설정되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2113">The security policy level has already been set.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-2114">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2114">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2115">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2115">requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2116">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2116">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="eece9-2117">섀도 복사본 위치에 대한 정규화된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2117">The fully qualified path to the shadow copy location.</span></span></param>
        <summary><span data-ttu-id="eece9-2118">지정한 디렉터리 경로를 어셈블리가 섀도 복사되는 위치로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2118">Establishes the specified directory path as the location where assemblies are shadow copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2119">캐시 경로 무시 됩니다는 <xref:System.AppDomainSetup.ApplicationName%2A> 속성이 설정 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2119">The cache path is ignored if the <xref:System.AppDomainSetup.ApplicationName%2A> property is not set.</span></span> <span data-ttu-id="eece9-2120"><xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> 속성을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-2120">See the <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="eece9-2121">섀도 복사에 대 한 자세한 내용은 참조 하세요 [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2121">For more information on shadow copying see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-2122">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2122">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2123">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2123">requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2124">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2124">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="eece9-2125">어셈블리 섀도 복사</span><span class="sxs-lookup"><span data-stu-id="eece9-2125">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="eece9-2126">응용 프로그램 도메인 속성에 값을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2126">Assigns a value to an application domain property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-2127">만들거나 변경할 사용자 정의 응용 프로그램 도메인 속성의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2127">The name of a user-defined application domain property to create or change.</span></span></param>
        <param name="data"><span data-ttu-id="eece9-2128">속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2128">The value of the property.</span></span></param>
        <summary><span data-ttu-id="eece9-2129">지정한 응용 프로그램 도메인 속성에 지정한 값을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2129">Assigns the specified value to the specified application domain property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2130">이 메서드를 사용 하 여 항목을 삽입 하거나이 인스턴스의 속성을 설명 하는 이름-데이터 쌍의 내부 캐시에 있는 항목의 값을 수정할 <xref:System.AppDomain>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2130">Use this method to insert an entry, or modify the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <xref:System.AppDomain>.</span></span>  
  
 <span data-ttu-id="eece9-2131">캐시는 자동으로 응용 프로그램 도메인이 만들어질 때 삽입 되는 미리 정의 된 시스템 항목을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2131">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="eece9-2132">삽입 하거나이 메서드를 사용 하 여 시스템 항목을 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2132">You cannot insert or modify system entries with this method.</span></span> <span data-ttu-id="eece9-2133">시스템 항목을 수정 하려고 하는 메서드 호출에 영향을 주지 않습니다. 메서드는 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2133">A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</span></span> <span data-ttu-id="eece9-2134">시스템 항목의 값을 검사할 수 있습니다 합니다 <xref:System.AppDomain.GetData%2A> 메서드 또는 해당 <xref:System.AppDomainSetup> 에 설명 된 속성 <xref:System.AppDomain.GetData%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2134">You can inspect the values of system entries with the <xref:System.AppDomain.GetData%2A> method, or the equivalent <xref:System.AppDomainSetup> properties described in <xref:System.AppDomain.GetData%2A>.</span></span>  
  
 <span data-ttu-id="eece9-2135">값으로 "REGEX_DEFAULT_MATCH_TIMEOUT" 공급 하 여 정규식 패턴을 평가 하는 것에 대 한 기본 시간 제한 간격의 값을 설정 하려면이 메서드를 호출할 수 있습니다 합니다 `name` 인수 및 <xref:System.TimeSpan> 제한 시간을 나타내는 값 간격 값으로는 `data` 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2135">You can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the `name` argument and a <xref:System.TimeSpan> value that represents the timeout interval as the value of the `data` argument.</span></span> <span data-ttu-id="eece9-2136">삽입 또는이 메서드를 사용 하 여 고유한 사용자 정의 이름-데이터 쌍을 수정 하 고 수도 있습니다 사용 하 여 해당 값을 검사할는 <xref:System.AppDomain.GetData%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-2136">You can also insert or modify your own user defined name-data pairs with this method and inspect their values with the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-2137">다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> 새 값 쌍을 만드는 방법.</span><span class="sxs-lookup"><span data-stu-id="eece9-2137">The following example demonstrates how to use the <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> method to create a new value pair.</span></span> <span data-ttu-id="eece9-2138">이 예제에서는 다음 사용을 <xref:System.AppDomain.GetData%2A> 값을 검색 하는 방법 콘솔에 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2138">The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.</span></span>  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-2139">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2139">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2140">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2140">requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2141">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2141">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="eece9-2142">만들거나 변경할 사용자 정의 응용 프로그램 도메인 속성의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2142">The name of a user-defined application domain property to create or change.</span></span></param>
        <param name="data"><span data-ttu-id="eece9-2143">속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2143">The value of the property.</span></span></param>
        <param name="permission"><span data-ttu-id="eece9-2144">속성을 검색할 때 호출자의 요청에 대한 권한입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2144">The permission to demand of the caller when the property is retrieved.</span></span></param>
        <summary><span data-ttu-id="eece9-2145">속성을 검색할 때 호출자의 요청에 대해 지정된 권한을 사용하여 지정한 응용 프로그램 도메인 속성에 지정한 값을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2145">Assigns the specified value to the specified application domain property, with a specified permission to demand of the caller when the property is retrieved.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2146">이 메서드를 사용 하 여를 삽입 하거나 응용 프로그램 도메인의 속성을 설명 하는 이름/데이터 쌍의 내부 캐시에 고유한 사용자 정의 항목을 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2146">Use this method to insert or modify your own user-defined entries in an internal cache of name/data pairs that describe properties of the application domain.</span></span> <span data-ttu-id="eece9-2147">항목을 삽입 하면 항목을 검색할 때 적용할 권한 요청을 지정할 수 있습니다. 또한 값으로 "REGEX_DEFAULT_MATCH_TIMEOUT" 공급 하 여 정규식 패턴을 평가 하는 것에 대 한 기본 시간 제한 간격의 값을 설정 하려면이 메서드를 호출할 수 있습니다 합니다 `name` 인수 및 <xref:System.TimeSpan> 를 나타내는 값을 제한 시간 간격 값으로는 `data` 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2147">When you insert an entry, you can specify a permission demand to enforce when the entry is retrieved.In addition, you can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the `name` argument and a <xref:System.TimeSpan> value that represents the timeout interval as the value of the `data` argument.</span></span>  
  
 <span data-ttu-id="eece9-2148">이 메서드를 사용 하 여 시스템 정의 속성 문자열을 보안 요청을 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2148">You cannot use this method to assign a security demand to a system-defined property string.</span></span>  
  
 <span data-ttu-id="eece9-2149">캐시는 자동으로 응용 프로그램 도메인이 만들어질 때 삽입 되는 미리 정의 된 시스템 항목을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2149">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="eece9-2150">삽입 하거나이 메서드를 사용 하 여 시스템 항목을 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2150">You cannot insert or modify system entries with this method.</span></span> <span data-ttu-id="eece9-2151">시스템 항목을 수정 하려고 하는 메서드 호출에 영향을 주지 않습니다. 메서드는 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2151">A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</span></span> <span data-ttu-id="eece9-2152">시스템 항목의 값을 검사할 수 있습니다 합니다 <xref:System.AppDomain.GetData%2A> 메서드 또는 해당 <xref:System.AppDomainSetup> 설명 섹션에 설명 된 속성을 <xref:System.AppDomain.GetData%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-2152">You can inspect the values of system entries with the <xref:System.AppDomain.GetData%2A> method or the equivalent <xref:System.AppDomainSetup> properties described in the Remarks section for the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-2153"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2153"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="eece9-2154"><paramref name="name" />이 시스템 정의 속성 문자열을 지정하고 <paramref name="permission" /> 값이 <see langword="null" />이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2154"><paramref name="name" /> specifies a system-defined property string and <paramref name="permission" /> is not <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2155">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2155">requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2156">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2156">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="eece9-2157">동적 어셈블리를 저장하는 하위 디렉터리의 기본 디렉터리인 정규화된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2157">The fully qualified path that is the base directory for subdirectories where dynamic assemblies are stored.</span></span></param>
        <summary><span data-ttu-id="eece9-2158">지정한 디렉터리 경로를 동적으로 생성된 파일을 저장하고 액세스하는 하위 디렉터리의 기본 디렉터리로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2158">Establishes the specified directory path as the base directory for subdirectories where dynamically generated files are stored and accessed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2159">이 메서드를 설정 합니다 <xref:System.AppDomainSetup.DynamicBase%2A> 속성 내부 <xref:System.AppDomainSetup> 이 인스턴스와 연결 된입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2159">This method sets the <xref:System.AppDomainSetup.DynamicBase%2A> property of the internal <xref:System.AppDomainSetup> associated with this instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-2160">이 메서드는 이제 이전 하며 새로운 개발에 쓰일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2160">This method is now obsolete, and should not be used for new development.</span></span> <span data-ttu-id="eece9-2161">다음 예제에서는 클래스 대신 사용 하는 방법의 <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2161">The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="eece9-2162">이 예의 설명에 대 한 참조를 <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> 속성 또는 <xref:System.AppDomain.DynamicDirectory%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="eece9-2162">For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-2163">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2163">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2164">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2164">requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2165">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2165">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy"><span data-ttu-id="eece9-2166">스레드에 연결할 Principal 개체의 형식을 지정하는 <see cref="T:System.Security.Principal.PrincipalPolicy" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2166">One of the <see cref="T:System.Security.Principal.PrincipalPolicy" /> values that specifies the type of the principal object to attach to threads.</span></span></param>
        <summary><span data-ttu-id="eece9-2167">이 응용 프로그램 도메인에서 실행되는 동안 스레드가 특정 보안 주체에 바인딩하려는 경우 Principal 개체 및 Identity 개체를 스레드에 연결하는 방법을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2167">Specifies how principal and identity objects should be attached to a thread if the thread attempts to bind to a principal while executing in this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2168">이 값을 설정할 사용 하기 전에 설정 하는 경우에 적용 됩니다만 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2168">Setting this value will only be effective if you set it before using the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="eece9-2169">예를 들어, 설정 하는 경우 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 지정 된 보안 주체 (예: 일반 사용자)를 사용 하 여는 <xref:System.AppDomain.SetPrincipalPolicy%2A> 설정 하는 방법의 <xref:System.Security.Principal.PrincipalPolicy> 에 <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, 현재 보안 주체에 일반 사용자 상태로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2169">For example, if you set <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> to a given principal (for example, a generic principal) and then use the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to set the <xref:System.Security.Principal.PrincipalPolicy> to <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, the current principal will remain the generic principal.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-2170">다음 예제에서는 스레드 사용에 대 한 영향을 <xref:System.AppDomain.SetPrincipalPolicy%2A> 응용 프로그램 도메인의 주 정책을 변경 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2170">The following example shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.</span></span> <span data-ttu-id="eece9-2171">또한를 사용한 결과를 보여 줍니다는 <xref:System.AppDomain.SetThreadPrincipal%2A> 응용 프로그램 도메인의 스레드에 연결 하는 데 사용할 수 있는 보안 주체를 변경 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2171">It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.</span></span>  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-2172">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2172">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-2173">보안 주체 개체를 조작 하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2173">for ability to manipulate the principal object.</span></span> <span data-ttu-id="eece9-2174">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></span><span class="sxs-lookup"><span data-stu-id="eece9-2174">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span> <span data-ttu-id="eece9-2175">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2175">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="eece9-2176">섀도 복사를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2176">Turns on shadow copying.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2177">섀도 복사에 대 한 자세한 내용은 참조 하세요. [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2177">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-2178">이 메서드는 이제 이전 하며 새로운 개발에 쓰일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2178">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-2179">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2179">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2180">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2180">requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2181">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2181">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="eece9-2182">어셈블리 섀도 복사</span><span class="sxs-lookup"><span data-stu-id="eece9-2182">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="eece9-2183">각 이름이 세미콜론으로 구분되는 디렉터리 이름 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2183">A list of directory names, where each name is separated by a semicolon.</span></span></param>
        <summary><span data-ttu-id="eece9-2184">지정한 디렉터리 경로를 어셈블리가 섀도 복사되는 위치로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2184">Establishes the specified directory path as the location of assemblies to be shadow copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2185">섀도 복사본을 기본적으로 검색을 통해 찾은 모든 어셈블리를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2185">By default, a shadow copy includes all assemblies found through probing.</span></span> <span data-ttu-id="eece9-2186">합니다 <xref:System.AppDomain.SetShadowCopyPath%2A> 메서드는 지정 된 디렉터리에서 어셈블리를 섀도 복사를 제한 `path`합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2186">The <xref:System.AppDomain.SetShadowCopyPath%2A> method restricts the shadow copy to the assemblies in the directories specified by `path`.</span></span>  
  
 <span data-ttu-id="eece9-2187"><xref:System.AppDomain.SetShadowCopyPath%2A> 메서드는 어셈블리에 대 한 검색할 추가 디렉터리를 지정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2187">The <xref:System.AppDomain.SetShadowCopyPath%2A> method does not specify additional directories to be searched for assemblies.</span></span> <span data-ttu-id="eece9-2188">어셈블리 섀도 복사를 이미 있어야 검색 경로에 예를 들어 아래 <xref:System.AppDomain.BaseDirectory%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2188">Assemblies to be shadow-copied must already be located in the search path, for example under <xref:System.AppDomain.BaseDirectory%2A>.</span></span> <span data-ttu-id="eece9-2189"><xref:System.AppDomain.SetShadowCopyPath%2A> 메서드는 검색 경로 섀도 복사 수를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2189">The <xref:System.AppDomain.SetShadowCopyPath%2A> method specifies which search paths are eligible to be shadow-copied.</span></span>  
  
 <span data-ttu-id="eece9-2190">이 메서드를 설정 합니다 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> 속성 내부 <xref:System.AppDomainSetup> 이 인스턴스와 연결 된입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2190">This method sets the <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> property of the internal <xref:System.AppDomainSetup> associated with this instance.</span></span>  
  
 <span data-ttu-id="eece9-2191">섀도 복사에 대 한 자세한 내용은 참조 하세요. [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2191">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-2192">이 메서드는 이제 이전 하며 새로운 개발에 쓰일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2192">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-2193">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2193">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2194">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2194">requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2195">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2195">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="eece9-2196">어셈블리 섀도 복사</span><span class="sxs-lookup"><span data-stu-id="eece9-2196">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal"><span data-ttu-id="eece9-2197">스레드에 연결할 Principal 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2197">The principal object to attach to threads.</span></span></param>
        <summary><span data-ttu-id="eece9-2198">이 응용 프로그램 도메인에서 실행되는 동안 스레드가 특정 보안 주체에 바인딩하려는 경우 스레드에 연결되는 기본 Principal 개체를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2198">Sets the default principal object to be attached to threads if they attempt to bind to a principal while executing in this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="eece9-2199">다음 예제를 사용 하 여 결과 보여 줍니다.는 <xref:System.AppDomain.SetThreadPrincipal%2A> 응용 프로그램 도메인에서 실행 중인 스레드를 연결 하는 데 사용할 수 있는 보안 주체를 변경 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2199">The following example shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads that are executing in the application domain.</span></span> <span data-ttu-id="eece9-2200">또한 사용 하는 스레드에서 효과 보여 줍니다는 <xref:System.AppDomain.SetPrincipalPolicy%2A> 응용 프로그램 도메인의 주 정책을 변경 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2200">It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.</span></span>  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-2201"><paramref name="principal" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2201"><paramref name="principal" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Policy.PolicyException"><span data-ttu-id="eece9-2202">스레드 보안 주체가 이미 설정되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2202">The thread principal has already been set.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-2203">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2203">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-2204">보안 주체 개체를 조작 하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2204">for ability to manipulate the principal object.</span></span> <span data-ttu-id="eece9-2205">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></span><span class="sxs-lookup"><span data-stu-id="eece9-2205">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span> <span data-ttu-id="eece9-2206">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2206">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-2207">이 인스턴스의 응용 프로그램 도메인 구성 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2207">Gets the application domain configuration information for this instance.</span></span></summary>
        <value><span data-ttu-id="eece9-2208">응용 프로그램 도메인 초기화 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2208">The application domain initialization information.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-2209">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2209">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-2210">응용 프로그램 도메인이 파일을 섀도 복사하도록 구성되어 있는지를 나타내는 표시를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2210">Gets an indication whether the application domain is configured to shadow copy files.</span></span></summary>
        <value><span data-ttu-id="eece9-2211">응용 프로그램 도메인이 파일을 섀도 복사하도록 구성되어 있으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2211"><see langword="true" /> if the application domain is configured to shadow copy files; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2212">자세한 내용은 <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> 하 고 [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2212">For more information, see <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-2213">언로드된 응용 프로그램 도메인에서 작업이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2213">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="eece9-2214">어셈블리 섀도 복사</span><span class="sxs-lookup"><span data-stu-id="eece9-2214">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="eece9-2215">나중에 사용하기 위해 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2215">Reserved for future use.</span></span> <span data-ttu-id="eece9-2216">IID_NULL이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2216">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="eece9-2217">매핑할 전달된 이름의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2217">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="eece9-2218">매핑할 이름의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2218">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="eece9-2219">이름을 해석할 로캘 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2219">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="eece9-2220">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2220">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="eece9-2221">이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2221">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2222">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2222">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="eece9-2223">에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2223">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="eece9-2224">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2224">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="eece9-2225">반환할 형식 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2225">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="eece9-2226">형식 정보의 로캘 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2226">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="eece9-2227">요청된 형식 정보 개체에 대한 포인터를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2227">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="eece9-2228">인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2228">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2229">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2229">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="eece9-2230">에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2230">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="eece9-2231">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2231">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="eece9-2232">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2232">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="eece9-2233">개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</span><span class="sxs-lookup"><span data-stu-id="eece9-2233">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2234">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2234">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="eece9-2235">에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2235">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="eece9-2236">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2236">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="eece9-2237">멤버를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2237">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="eece9-2238">나중에 사용하기 위해 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2238">Reserved for future use.</span></span> <span data-ttu-id="eece9-2239">IID_NULL이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2239">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="eece9-2240">인수를 해석할 로캘 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2240">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="eece9-2241">호출의 컨텍스트를 설명하는 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2241">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="eece9-2242">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2242">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="eece9-2243">결과를 저장할 위치에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2243">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="eece9-2244">예외 정보가 포함된 구조체에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2244">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="eece9-2245">오류가 있는 첫 번째 인수의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2245">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="eece9-2246">개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2246">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2247">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2247">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="eece9-2248">에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2248">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="eece9-2249">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2249">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="eece9-2250">응용 프로그램 도메인과 컨텍스트 정책의 이름이 포함된 문자열 표현을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2250">Obtains a string representation that includes the friendly name of the application domain and any context policies.</span></span></summary>
        <returns><span data-ttu-id="eece9-2251">리터럴 문자열 "이름:", 응용 프로그램 도메인의 이름 및 컨텍스트 정책의 문자열 표현 또는 "컨텍스트 정책이 없습니다." 문자열을 연결하여 구성되는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2251">A string formed by concatenating the literal string "Name:", the friendly name of the application domain, and either string representations of the context policies or the string "There are no context policies."</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="eece9-2252">다음 코드 예제에서는 반환 값을 표시 합니다 <xref:System.AppDomain.ToString%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="eece9-2252">The following code example displays the return value of the <xref:System.AppDomain.ToString%2A> method.</span></span>  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="eece9-2253">현재 <see cref="T:System.AppDomain" />으로 표시된 응용 프로그램 도메인이 언로드된 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2253">The application domain represented by the current <see cref="T:System.AppDomain" /> has been unloaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-2254">형식을 확인하지 못할 경우 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2254">Occurs when the resolution of a type fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2255"><xref:System.AppDomain.TypeResolve> 공용 언어 런타임은 요청된 된 형식을 만들 수 있는 어셈블리를 확인할 수 없을 때 이벤트 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2255">The <xref:System.AppDomain.TypeResolve> event occurs when the common language runtime is unable to determine the assembly that can create the requested type.</span></span> <span data-ttu-id="eece9-2256">이 동적 어셈블리에는 형식이 정의 또는 동적 어셈블리에 형식이 정의 되지 않은 되었지만 런타임 형식에 정의 된 어셈블리를 인식 하지 못합니다 하는 경우 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2256">This can occur if the type is defined in a dynamic assembly, or the type is not defined in a dynamic assembly but the runtime does not know which assembly the type is defined in.</span></span> <span data-ttu-id="eece9-2257">후자의 경우에 발생할 수 있습니다 때 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 형식 이름을 정규화 되지 않은 어셈블리 이름 사용 하 여 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2257">The latter situation can occur when <xref:System.Type.GetType%2A?displayProperty=nameWithType> is called with a type name that is not qualified with the assembly name.</span></span>  
  
 <span data-ttu-id="eece9-2258"><xref:System.ResolveEventHandler> 에이 이벤트를 찾아 형식을 만드는 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2258">The <xref:System.ResolveEventHandler> for this event can attempt to locate and create the type.</span></span>  
  
 <span data-ttu-id="eece9-2259">그러나는 <xref:System.AppDomain.TypeResolve> 런타임에서 특정 어셈블리에서 형식을 찾을 수 없는 경우에 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2259">However, the <xref:System.AppDomain.TypeResolve> event does not occur if the runtime knows it is not possible to find a type in certain assemblies.</span></span> <span data-ttu-id="eece9-2260">예를 들어, 런타임에서 형식을 정적 어셈블리에 동적으로 추가할 수 없습니다 때문에 형식을 정적 어셈블리에 없는 경우이 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2260">For example, this event does not occur if the type is not found in a static assembly because the runtime knows types cannot be added dynamically to static assemblies.</span></span>  
  
 <span data-ttu-id="eece9-2261">로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> 속성 형식을 요청 하는 어셈블리를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2261">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property contains the assembly that requested the type.</span></span> <span data-ttu-id="eece9-2262">자세한 내용은 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eece9-2262">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="eece9-2263">이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2263">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="eece9-2264">이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="eece9-2264">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-2265">다음 샘플을 참조 하십시오.는 <xref:System.AppDomain.TypeResolve> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2265">The following sample demonstrates the <xref:System.AppDomain.TypeResolve> event.</span></span>  
  
 <span data-ttu-id="eece9-2266">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2266">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="eece9-2267">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2267">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2268">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2268">requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2269">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2269">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eece9-2270">예외가 catch되지 않으면 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2270">Occurs when an exception is not caught.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2271">이 이벤트는 예외로 대 한 알림을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2271">This event provides notification of uncaught exceptions.</span></span> <span data-ttu-id="eece9-2272">응용 프로그램을 시스템 기본 처리기는 사용자에 게 예외를 보고 하 고 응용 프로그램을 종료 하기 전에 예외에 대 한 정보를 기록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2272">It allows the application to log information about the exception before the system default handler reports the exception to the user and terminates the application.</span></span> <span data-ttu-id="eece9-2273">응용 프로그램의 상태에 대 한 충분 한 정보가 경우 사용할 수 있습니다, 다른 작업을 수행할 수 있습니다-나중에 복구에 대 한 프로그램 데이터를 저장 하는 등입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2273">If sufficient information about the state of the application is available, other actions may be undertaken - such as saving program data for later recovery.</span></span> <span data-ttu-id="eece9-2274">예외 처리 되지 않은 프로그램 데이터 손상 될 수 있으므로 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2274">Caution is advised, because program data can become corrupted when exceptions are not handled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-2275">.NET Framework 버전 1.0 및 1.1에서는이 이벤트를 발생 시키려면 이후가 아닌 응용 프로그램 종료에 대 한 디버깅 옵션 사용자에 게 보고 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2275">In the .NET Framework versions 1.0 and 1.1, application termination and debugging options are reported to the user before this event is raised, rather than after.</span></span>  
  
 <span data-ttu-id="eece9-2276">모든 응용 프로그램 도메인에서이 이벤트를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2276">This event can be handled in any application domain.</span></span> <span data-ttu-id="eece9-2277">그러나 예외가 발생 하는 응용 프로그램 도메인 이벤트 반드시 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2277">However, the event is not necessarily raised in the application domain where the exception occurred.</span></span> <span data-ttu-id="eece9-2278">스레드에 대 한 전체 스택 정리 된 스레드가 시작 된 응용 프로그램 도메인에서 첫 번째 위치는 이벤트가 발생할 수 있습니다 이므로 적절 한 예외 처리기를 찾지 못하고 하는 경우에 예외가 처리 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2278">An exception is unhandled only if the entire stack for the thread has been unwound without finding an applicable exception handler, so the first place the event can be raised is in the application domain where the thread originated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-2279">.NET Framework 버전 1.0 및 1.1에서는이 이벤트는 응용 프로그램이 시작 될 때 시스템에서 생성 되는 기본 응용 프로그램 도메인에 대해서만 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2279">In the .NET Framework versions 1.0 and 1.1, this event occurs only for the default application domain that is created by the system when an application is started.</span></span> <span data-ttu-id="eece9-2280">응용 프로그램에서 추가 응용 프로그램 도메인을 만드는 경우 해당 응용 프로그램 도메인에서이 이벤트에 대 한 대리자를 지정 효과가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2280">If an application creates additional application domains, specifying a delegate for this event in those applications domains has no effect.</span></span>  
  
 <span data-ttu-id="eece9-2281">경우는 <xref:System.AppDomain.UnhandledException> 기본 응용 프로그램 도메인에서 이벤트를 처리, 처리 되지 않은 예외는 응용 프로그램 도메인에 관계 없이 모든 스레드에서 스레드가 시작에 대 한 있습니다 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2281">If the <xref:System.AppDomain.UnhandledException> event is handled in the default application domain, it is raised there for any unhandled exception in any thread, no matter what application domain the thread started in.</span></span> <span data-ttu-id="eece9-2282">에 대 한 이벤트 처리기가 응용 프로그램 도메인에서 스레드가 시작 하는 경우 <xref:System.AppDomain.UnhandledException>, 해당 응용 프로그램 도메인에서 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2282">If the thread started in an application domain that has an event handler for <xref:System.AppDomain.UnhandledException>, the event is raised in that application domain.</span></span> <span data-ttu-id="eece9-2283">해당 응용 프로그램 도메인에서 기본 응용 프로그램 도메인 아니며 기본 응용 프로그램 도메인 이벤트 처리기도가 이벤트 모두 응용 프로그램 도메인에서 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2283">If that application domain is not the default application domain, and there is also an event handler in the default application domain, the event is raised in both application domains.</span></span>  
  
 <span data-ttu-id="eece9-2284">예를 들어, 가정 스레드가 시작 응용 프로그램 도메인 "AD1", "AD2" 응용 프로그램 도메인에서 메서드를 호출 및 여기에서 메서드를 호출 응용 프로그램 도메인 "AD3"에서 예외가 throw 되 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2284">For example, suppose a thread starts in application domain "AD1", calls a method in application domain "AD2", and from there calls a method in application domain "AD3", where it throws an exception.</span></span> <span data-ttu-id="eece9-2285">첫 번째 응용 프로그램 도메인을 <xref:System.AppDomain.UnhandledException> 이벤트가 발생할 수 있습니다 "AD1" 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2285">The first application domain in which the <xref:System.AppDomain.UnhandledException> event can be raised is "AD1".</span></span> <span data-ttu-id="eece9-2286">해당 대화 상자가 기본 응용 프로그램 도메인이 아닌 경우에 해당 응용 프로그램 도메인 이벤트는 기본 응용 프로그램 도메인에도 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2286">If that application domain is not the default application domain, the event can also be raised in the default application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-2287">공용 언어 런타임 스레드 중단에 대 한 이벤트 처리기는 동안 일시 중단 된 <xref:System.AppDomain.UnhandledException> 이벤트를 실행 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2287">The common language runtime suspends thread aborts while event handlers for the <xref:System.AppDomain.UnhandledException> event are executing.</span></span>  
  
 <span data-ttu-id="eece9-2288">이벤트 처리기의 경우는 <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> 특성에 적절 한 플래그를 사용 하 여 이벤트 처리기는 제약이 있는 실행 영역으로 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2288">If the event handler has a <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute with the appropriate flags, the event handler is treated as a constrained execution region.</span></span>  
  
 <span data-ttu-id="eece9-2289">로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 스택 오버플로 같은 프로세스의 상태를 손상 또는 액세스 위반, 이벤트 처리기는 보안에 중요 하 고에 있어야 하는 예외에 대 한이 이벤트는 <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2289">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], this event is not raised for exceptions that corrupt the state of the process, such as stack overflows or access violations, unless the event handler is security-critical and has the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute.</span></span>  
  
 <span data-ttu-id="eece9-2290">.NET Framework 버전 1.0 및 1.1에서는 주 응용 프로그램 스레드가 아닌 스레드에서 발생 하는 처리 되지 않은 예외를 런타임이 포착 됩니다 및 따라서 응용 프로그램이 종료를 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2290">In the .NET Framework versions 1.0 and 1.1, an unhandled exception that occurs in a thread other than the main application thread is caught by the runtime and therefore does not cause the application to terminate.</span></span> <span data-ttu-id="eece9-2291">따라서 이기는 <xref:System.AppDomain.UnhandledException> 이벤트를 응용 프로그램을 종료 하지 않고 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2291">Thus, it is possible for the <xref:System.AppDomain.UnhandledException> event to be raised without the application terminating.</span></span> <span data-ttu-id="eece9-2292">.NET Framework 버전 2.0부터 자식 스레드의 처리 되지 않은 예외에 대 한이 백업을 제거 된 이러한 누적 효과 포함 성능이 저하 되 고 손상 된 데이터는 모두 하기가 어렵기 때문에 디버그 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2292">Starting with the .NET Framework version 2.0, this backstop for unhandled exceptions in child threads was removed, because the cumulative effect of such silent failures included performance degradation, corrupted data, and lockups, all of which were difficult to debug.</span></span> <span data-ttu-id="eece9-2293">런타임 종료 되지 않는 경우의 목록을 비롯 한 자세한 내용은 참조 하세요. [관리 되는 스레드의 예외](~/docs/standard/threading/exceptions-in-managed-threads.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2293">For more information, including a list of cases in which the runtime does not terminate, see [Exceptions in Managed Threads](~/docs/standard/threading/exceptions-in-managed-threads.md).</span></span>  
  
 <span data-ttu-id="eece9-2294">이 이벤트에 대 한 이벤트 처리기를 등록 하려면 필요한 사용 권한이 있어야 또는 <xref:System.Security.SecurityException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2294">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="eece9-2295">이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="eece9-2295">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
## <a name="other-events-for-unhandled-exceptions"></a><span data-ttu-id="eece9-2296">처리 되지 않은 예외에 대 한 다른 이벤트</span><span class="sxs-lookup"><span data-stu-id="eece9-2296">Other Events for Unhandled Exceptions</span></span>  
 <span data-ttu-id="eece9-2297">특정 응용 프로그램 모델은 <xref:System.AppDomain.UnhandledException> 이벤트 주 응용 프로그램 스레드에 처리 되지 않은 예외가 발생 하는 경우 다른 이벤트에 의해 선점 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2297">For certain application models, the <xref:System.AppDomain.UnhandledException> event can be preempted by other events if the unhandled exception occurs in the main application thread.</span></span>  
  
 <span data-ttu-id="eece9-2298">Windows Forms를 사용 하는 응용 프로그램에서 처리 되지 않은 주 응용 프로그램 스레드 원인에는 예외는 <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2298">In applications that use Windows Forms, unhandled exceptions in the main application thread cause the <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> event to be raised.</span></span> <span data-ttu-id="eece9-2299">이 이벤트가 처리 된 경우 기본 동작은 처리 되지 않은 예외가 응용 프로그램을 종료 되지 않도록 응용 프로그램은 알 수 없는 상태로 남아 있지만.</span><span class="sxs-lookup"><span data-stu-id="eece9-2299">If this event is handled, the default behavior is that the unhandled exception does not terminate the application, although the application is left in an unknown state.</span></span> <span data-ttu-id="eece9-2300">이런 경우는 <xref:System.AppDomain.UnhandledException> 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2300">In that case, the <xref:System.AppDomain.UnhandledException> event is not raised.</span></span> <span data-ttu-id="eece9-2301">응용 프로그램 구성 파일을 사용 하거나 사용 하 여이 동작을 변경할 수 있습니다 합니다 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> 모드를 변경 하는 방법 <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> 하기 전에 <xref:System.Windows.Forms.Application.ThreadException> 이벤트 처리기 후크 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2301">This behavior can be changed by using the application configuration file, or by using the <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> method to change the mode to <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> before the <xref:System.Windows.Forms.Application.ThreadException> event handler is hooked up.</span></span> <span data-ttu-id="eece9-2302">이 주 응용 프로그램 스레드에만 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2302">This applies only to the main application thread.</span></span> <span data-ttu-id="eece9-2303"><xref:System.AppDomain.UnhandledException> 다른 스레드에서 throw 된 처리 되지 않은 예외에 대 한 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2303">The <xref:System.AppDomain.UnhandledException> event is raised for unhandled exceptions thrown in other threads.</span></span>  
  
 <span data-ttu-id="eece9-2304">Microsoft Visual Studio 2005부터 Visual Basic 응용 프로그램 프레임 워크의 주 응용 프로그램 스레드에 처리 되지 않은 예외에 대 한 다른 이벤트를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2304">Starting with Microsoft Visual Studio 2005, the Visual Basic application framework provides another event for unhandled exceptions in the main application thread.</span></span> <span data-ttu-id="eece9-2305">참조 된 <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2305">See the <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="eece9-2306">이 이벤트는 이벤트 인수 개체에서 사용 하는 이벤트 인수 개체와 동일한 이름 가진 <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, 하지만 다른 속성을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2306">This event has an event arguments object with the same name as the event arguments object used by <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, but with different properties.</span></span> <span data-ttu-id="eece9-2307">특히이 이벤트 인수 개체에는 <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> 속성을 사용 하는 응용 프로그램 실행, 처리 되지 않은 예외를 무시 (및 응용 프로그램을 알 수 없는 상태로 유지)를 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2307">In particular, this event arguments object has an <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> property that allows the application to continue running, ignoring the unhandled exception (and leaving the application in an unknown state).</span></span> <span data-ttu-id="eece9-2308">이런 경우는 <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2308">In that case, the <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> event is not raised.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-2309">큐브가 방법을 보여 줍니다는 <xref:System.AppDomain.UnhandledException> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2309">The followingexample demonstrates the <xref:System.AppDomain.UnhandledException> event.</span></span> <span data-ttu-id="eece9-2310">이벤트 처리기를 정의 `MyHandler`, 기본 응용 프로그램 도메인에서 처리 되지 않은 예외가 throw 됩니다 될 때마다 호출 되는 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2310">It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain.</span></span> <span data-ttu-id="eece9-2311">다음 두 가지 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2311">It then throws two exceptions.</span></span> <span data-ttu-id="eece9-2312">첫 번째에서 처리 되는 **try/catch** 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2312">The first is handled by a **try/catch** block.</span></span> <span data-ttu-id="eece9-2313">두 번째는 처리 되지 않으며 호출을 `MyHandle` 루틴 응용 프로그램을 종료 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2313">The second is unhandled and invokes the `MyHandle` routine before the application terminates.</span></span>  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="eece9-2314">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2314">requires full trust for the immediate caller.</span></span> <span data-ttu-id="eece9-2315">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2315">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain"><span data-ttu-id="eece9-2316">언로드할 응용 프로그램 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2316">An application domain to unload.</span></span></param>
        <summary><span data-ttu-id="eece9-2317">지정한 응용 프로그램 도메인을 언로드합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2317">Unloads the specified application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eece9-2318">.NET Framework 버전 2.0에에서는 전용 스레드는 응용 프로그램 도메인 언로드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2318">In the .NET Framework version 2.0 there is a thread dedicated to unloading application domains.</span></span> <span data-ttu-id="eece9-2319">.NET Framework 호스트 되는 경우에 특히 안정성 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2319">This improves reliability, especially when the .NET Framework is hosted.</span></span> <span data-ttu-id="eece9-2320">호출 하면 스레드 <xref:System.AppDomain.Unload%2A>를 언로드하기 위한 대상 도메인이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2320">When a thread calls <xref:System.AppDomain.Unload%2A>, the target domain is marked for unloading.</span></span> <span data-ttu-id="eece9-2321">전용된 스레드가 도메인의 언로드 하 고 도메인의 모든 스레드가 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2321">The dedicated thread attempts to unload the domain, and all threads in the domain are aborted.</span></span> <span data-ttu-id="eece9-2322">없거나 실행 되는 스레드를 중단 하지 않습니다, 예를 들어 비관리 코드를 실행 하는 경우는 `finally` 블록 기간 후에 <xref:System.CannotUnloadAppDomainException> 원래 호출 스레드에서 throw 됩니다 <xref:System.AppDomain.Unload%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2322">If a thread does not abort, for example because it is executing unmanaged code, or because it is executing a `finally` block, then after a period of time a <xref:System.CannotUnloadAppDomainException> is thrown in the thread that originally called <xref:System.AppDomain.Unload%2A>.</span></span> <span data-ttu-id="eece9-2323">결과적으로 중단할 수 없는 하는 스레드가 종료 되는 경우에 대상 도메인은 언로드되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2323">If the thread that could not be aborted eventually ends, the target domain is not unloaded.</span></span> <span data-ttu-id="eece9-2324">.NET Framework 버전 2.0에 따라서 `domain` 실행 스레드를 종료할 수 수 있으므로 언로드 작업을 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2324">Thus, in the .NET Framework version 2.0 `domain` is not guaranteed to unload, because it might not be possible to terminate executing threads.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eece9-2325">일부 경우에 호출 <xref:System.AppDomain.Unload%2A> 즉시 발생할 <xref:System.CannotUnloadAppDomainException>예를 들어 종료자에서 호출 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2325">In some cases, calling <xref:System.AppDomain.Unload%2A> causes an immediate <xref:System.CannotUnloadAppDomainException>, for example if it is called in a finalizer.</span></span>  
  
 <span data-ttu-id="eece9-2326">스레드 `domain` 를 사용 하 여 종료 됩니다 합니다 <xref:System.Threading.Thread.Abort%2A> throw 하는 메서드를 <xref:System.Threading.ThreadAbortException> 스레드에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2326">The threads in `domain` are terminated using the <xref:System.Threading.Thread.Abort%2A> method, which throws a <xref:System.Threading.ThreadAbortException> in the thread.</span></span> <span data-ttu-id="eece9-2327">에 예측할 수 없는 기간 동안 실행을 계속할 수 스레드가 즉시 종료 되어야 하지만 `finally` 절.</span><span class="sxs-lookup"><span data-stu-id="eece9-2327">Although the thread should terminate promptly, it can continue executing for an unpredictable amount of time in a `finally` clause.</span></span>  
  
## <a name="version-compatibility"></a><span data-ttu-id="eece9-2328">버전 호환성</span><span class="sxs-lookup"><span data-stu-id="eece9-2328">Version Compatibility</span></span>  
 <span data-ttu-id="eece9-2329">.NET framework 버전 1.0 및 1.1 스레드를 호출 하는 경우 <xref:System.AppDomain.Unload%2A> 에서 실행 되 고 `domain`, 언로드 작업을 수행 하려면 다른 스레드가 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2329">In the .NET Framework version 1.0 and 1.1 if the thread that calls <xref:System.AppDomain.Unload%2A> is running in `domain`, another thread is started to perform the unload operation.</span></span> <span data-ttu-id="eece9-2330">경우 `domain` 언로드할 수 없으며를 <xref:System.CannotUnloadAppDomainException> 은 원래 스레드가 호출에 없는 해당 스레드에서 throw <xref:System.AppDomain.Unload%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2330">If `domain` cannot be unloaded, a <xref:System.CannotUnloadAppDomainException> is thrown in that thread, not in the original thread that called <xref:System.AppDomain.Unload%2A>.</span></span> <span data-ttu-id="eece9-2331">그러나 호출 하는 스레드가 <xref:System.AppDomain.Unload%2A> 외부에서 실행 되 `domain`, 스레드는 예외를 수신 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2331">However, if the thread that calls <xref:System.AppDomain.Unload%2A> is running outside `domain`, that thread receives the exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eece9-2332">다음 코드 예제에는 응용 프로그램 도메인을 언로드하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2332">The following code example shows how to unload an application domain.</span></span>  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eece9-2333"><paramref name="domain" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2333"><paramref name="domain" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.CannotUnloadAppDomainException"><span data-ttu-id="eece9-2334"><paramref name="domain" />을 언로드할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2334"><paramref name="domain" /> could not be unloaded.</span></span></exception>
        <exception cref="T:System.Exception"><span data-ttu-id="eece9-2335">언로드하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="eece9-2335">An error occurred during the unload process.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="eece9-2336">이 이벤트에 대 한 이벤트 처리기를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2336">to add an event handler for this event.</span></span> <span data-ttu-id="eece9-2337">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /></span><span class="sxs-lookup"><span data-stu-id="eece9-2337">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span></span> <span data-ttu-id="eece9-2338">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</span><span class="sxs-lookup"><span data-stu-id="eece9-2338">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>