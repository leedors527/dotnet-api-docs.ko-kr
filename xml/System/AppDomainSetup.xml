<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata><Meta Name="ms.openlocfilehash" Value="66e2e65213f206d2f372ce8b2f4c3348b3bd38c4" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57936864" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.AppDomain" />의 인스턴스에 추가할 수 있는 어셈블리 바인딩 정보를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성을 변경 프로그램 <xref:System.AppDomainSetup> 인스턴스가 기존에 영향을 주지 않습니다 <xref:System.AppDomain>합니다. 새 생성에만 영향을 줄 수 <xref:System.AppDomain>경우는 <xref:System.AppDomain.CreateDomain%2A> 메서드를 호출 합니다 <xref:System.AppDomainSetup> 인스턴스를 매개 변수로 합니다.  
  
 이 클래스는 <xref:System.IAppDomainSetup> 인터페이스를 구현합니다.  
  
> [!CAUTION]
>  기본값을 <xref:System.AppDomainSetup.DisallowCodeDownload%2A> 속성이 false입니다. 이 설정은 서비스에 대 한 안전 하지 않습니다. 부분적으로 신뢰할 수 있는 코드 다운로드에서 서비스를 방지 하려면이 속성이 true로 설정  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">방법: 애플리케이션 도메인 구성</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.AppDomainSetup" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.AppDomainSetup" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationContext">애플리케이션 도메인에 사용할 활성화 컨텍스트입니다.</param>
        <summary>애플리케이션 도메인의 매니페스트 기반 활성화에 사용하기 위해 지정된 활성화 컨텍스트를 사용하여 <see cref="T:System.AppDomainSetup" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ActivationContext> 에 대 한 지정 된 개체 `activationContext` 생성 하는 데 사용 되는 <xref:System.Runtime.Hosting.ActivationArguments> 새 응용 프로그램 도메인을 활성화 하는 데 필요한 정보를 포함 하는 개체입니다. 이렇게 <xref:System.Runtime.Hosting.ActivationArguments> 를 사용 하 여 개체에 액세스할 수는 <xref:System.AppDomainSetup.ActivationArguments%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationContext" />가 <see langword="null" />입니다.</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationArguments">새 애플리케이션 도메인의 매니페스트 기반 활성화에 필요한 정보를 지정하는 개체입니다.</param>
        <summary>애플리케이션 도메인의 매니페스트 기반 활성화에 필요한 지정된 활성화 인수를 사용하여 <see cref="T:System.AppDomainSetup" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 지정 된 개체 `activationArguments` 를 사용 하 여 액세스할 수는 <xref:System.AppDomainSetup.ActivationArguments%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationArguments" />가 <see langword="null" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션 도메인의 활성화에 대한 데이터를 가져오거나 설정합니다.</summary>
        <value>애플리케이션 도메인의 활성화에 대한 데이터가 들어 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 설정 된 경우 예외가 throw 되지 `null`합니다.  
  
 제공한 정보는 <xref:System.Runtime.Hosting.ActivationArguments> 개체가 매니페스트 기반 활성화를 지원 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">애플리케이션 ID가 <see cref="P:System.AppDomainSetup.ApplicationTrust" /> 속성이 반환한 <see cref="T:System.Security.Policy.ApplicationTrust" /> 개체의 애플리케이션 ID와 일치하지 않는 <see cref="T:System.Runtime.Hosting.ActivationArguments" /> 개체로 속성이 설정되어 있습니다. <see cref="P:System.AppDomainSetup.ApplicationTrust" /> 속성이 <see langword="null" />이면 예외가 발생하지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션 도메인이 초기화될 때 호출되는 콜백 메서드를 나타내는 <see cref="T:System.AppDomainInitializer" /> 대리자를 가져오거나 설정합니다.</summary>
        <value>애플리케이션 도메인이 초기화될 때 호출되는 콜백 메서드를 나타내는 대리자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정보를 콜백 메서드로 전달할 문자열의 배열을 할당 합니다 <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> 속성입니다. 배열은 콜백 메서드에 전달 될 때마다는 <xref:System.AppDomain> 초기화 됩니다.  
  
 콜백 메서드는 새로 만든된 응용 프로그램 도메인의 컨텍스트에서 실행 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 자식 응용 프로그램 도메인을 만듭니다 `ChildDomain`를 사용 하 여는 <xref:System.AppDomainSetup> 개체 및 기본 응용 프로그램 도메인 증명 정보입니다. 합니다 <xref:System.AppDomainSetup.AppDomainInitializer%2A> 콜백 메서드 속성 `AppDomainInit`, 자식 도메인이 초기화 될 때 호출 되는 합니다. 콜백 메서드에 대 한 인수에 할당 되는 문자열의 배열에 배치 됩니다는 <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> 속성입니다. 자식 도메인을 만든 경우 콜백 메서드는 단순히 문자열을 인쇄 합니다.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.AppDomainInitializer" /> 대리자가 나타내는 콜백 메서드로 전달되는 인수를 가져오거나 설정합니다. 콜백 메서드는 애플리케이션 도메인이 초기화될 때 호출됩니다.</summary>
        <value><see cref="T:System.AppDomain" />이 초기화되는 동안 콜백 메서드가 호출될 때 <see cref="T:System.AppDomainInitializer" /> 대리자가 나타내는 콜백 메서드로 전달되는 문자열 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.AppDomainSetup.AppDomainInitializer%2A> 속성을 지정 하는 동안 호출 되는 콜백 메서드 <xref:System.AppDomain> 초기화 합니다. 경우는 <xref:System.AppDomainSetup.AppDomainInitializer%2A> 속성이 설정 되지 않으면,이 속성에 할당 된 배열을 사용 되지 않습니다.  
  
 콜백 메서드는 새로 만든된 응용 프로그램 도메인의 컨텍스트에서 실행 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 명명 된 자식 응용 프로그램 도메인을 만듭니다 `ChildDomain`를 사용 하 여는 <xref:System.AppDomainSetup> 개체 및 기본 응용 프로그램 도메인 증명 정보입니다. 합니다 <xref:System.AppDomainSetup.AppDomainInitializer%2A> 콜백 메서드 속성 `AppDomainInit`, 자식 도메인이 초기화 될 때 호출 되는 합니다. 콜백 메서드에 대 한 인수에 할당 되는 문자열의 배열에 배치 됩니다는 <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> 속성입니다. 자식 도메인을 만든 경우 콜백 메서드는 단순히 문자열을 인쇄 합니다.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.AppDomainSetup" /> 개체를 사용하여 만든 애플리케이션 도메인에 대한 애플리케이션 도메인 관리자의 형식을 제공하는 어셈블리의 표시 이름을 가져오거나 설정합니다.</summary>
        <value>애플리케이션 도메인 관리자의 <see cref="T:System.Type" />을 제공하는 어셈블리의 표시 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램 도메인 관리자의 형식을 지정 하려면이 두 속성을 설정 하며 <xref:System.AppDomainSetup.AppDomainManagerType%2A> 속성입니다. 이러한 속성 중 하나를 설정 하지 않으면 다른 무시 됩니다.  
  
 형식이 제공 되지 않은, 경우 응용 프로그램 도메인 관리자를 부모 응용 프로그램 도메인으로 동일한 형식에서 만들어집니다 (즉, 응용 프로그램 도메인을는 <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> 메서드).  
  
 응용 프로그램 도메인 로드 되 면 <xref:System.TypeLoadException> 어셈블리에 지정 된 형식 없는 경우 또는 어셈블리가 없는 경우 throw 되는 <xref:System.AppDomainSetup.AppDomainManagerType%2A> 속성입니다. <xref:System.IO.FileLoadException> 어셈블리를 찾았지만 버전 정보가 일치 하지 않는 경우 throw 됩니다.  
  
 기본 응용 프로그램 도메인에 대 한 응용 프로그램 도메인 관리자를 설정 하려면 사용 합니다 [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) 및 [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) 요소에는 [ \<런타임 >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) 에 설명 된 환경 변수를 사용 하 여 응용 프로그램 구성 파일의 섹션 <xref:System.AppDomainManager>합니다.  
  
 이 기능은 완전 신뢰 응용 프로그램에 필요 합니다. (예를 들어, 데스크톱에서 실행 중인 응용 프로그램에 완전 신뢰) 응용 프로그램에 완전 신뢰가 없는 경우는 <xref:System.TypeLoadException> throw 됩니다.  
  
 형식의 어셈블리 표시 이름 지정 하 여는 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.AppDomainSetup" /> 개체를 사용하여 만든 애플리케이션 도메인에 대한 애플리케이션 도메인 관리자를 제공하는 형식의 전체 이름을 가져오거나 설정합니다.</summary>
        <value>네임스페이스를 포함한 형식의 전체 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램 도메인 관리자의 형식을 지정 하려면이 두 속성을 설정 하며 <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> 속성입니다. 이러한 속성 중 하나를 설정 하지 않으면 다른 무시 됩니다.  
  
 형식이 제공 되지 않은, 경우 응용 프로그램 도메인 관리자를 부모 응용 프로그램 도메인으로 동일한 형식에서 만들어집니다 (즉, 응용 프로그램 도메인을는 <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> 메서드).  
  
 응용 프로그램 도메인 로드 되 면 <xref:System.TypeLoadException> 어셈블리에서 지정 된 경우 throw 되는 <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> 속성이이 속성에 지정 된 형식이 포함 되지 않습니다.  
  
 기본 응용 프로그램 도메인에 대 한 응용 프로그램 도메인 관리자를 설정 하려면 사용 합니다 [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) 및 [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) 요소에는 [ \<런타임 >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) 에 설명 된 환경 변수를 사용 하 여 응용 프로그램 구성 파일의 섹션 <xref:System.AppDomainManager>합니다.  
  
 이 기능은 완전 신뢰 응용 프로그램에 필요 합니다. (예를 들어, 데스크톱에서 실행 중인 응용 프로그램에 완전 신뢰) 응용 프로그램에 완전 신뢰가 없는 경우는 <xref:System.TypeLoadException> throw 됩니다.  
  
 형식의 전체 이름의 형식을 지정 하 여는 <xref:System.Type.FullName%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램이 들어 있는 디렉터리의 이름을 가져오거나 설정합니다.</summary>
        <value>응용 프로그램 기준 위치 디렉터리의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램 기본 디렉터리는 여기서 어셈블리 manager 어셈블리에 대 한 조사를 시작 합니다.  
  
 <xref:System.AppDomainSetup.ApplicationBase%2A> 속성은 응용 프로그램 도메인에 부여 되는 권한에 영향을 줄 수 있습니다. 예를 들어, 일반적으로 로컬 컴퓨터에서 시작 된 응용 프로그램 도메인에는 원래 위치에 따라 완전 신뢰가 부여 합니다. 그러나 경우는 <xref:System.AppDomainSetup.ApplicationBase%2A> 속성의 <xref:System.AppDomain> 인트라넷 디렉터리의 전체 이름으로 설정 됩니다는 <xref:System.AppDomainSetup.ApplicationBase%2A> 설정은 부여 된 권한을 응용 프로그램 도메인 LocalIntranet 권한 부여에도 응용 프로그램 도메인 제한 실제로 로컬 컴퓨터에서 발생 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.AppDomainSetup.ApplicationBase%2A> 여기서 어셈블리 로더는 새 응용 프로그램 도메인에 로드 하는 어셈블리에 대 한 조사를 시작 위치를 설정 하는 속성입니다.  
  
> [!NOTE]
>  지정한 폴더가 있는지 확인 해야 합니다.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 정보에 액세스 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션의 이름을 가져오거나 설정합니다.</summary>
        <value>애플리케이션의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 설정 하는 방법의 <xref:System.AppDomainSetup.ApplicationName%2A> 새 응용 프로그램 도메인을 만들 때 속성입니다.  
  
 이 예제에서는 새 응용 프로그램 도메인을 만들고 호출 합니다는 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> 새 응용 프로그램 도메인에 예제에서는 어셈블리를 로드 한 인스턴스의 메서드를 `Worker` 클래스입니다. `Worker` 클래스는 상속 <xref:System.MarshalByRefObject>예제에서 반환 되는 프록시를 사용할 수 있으므로 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 호출 하는 `TestLoad` 메서드.  
  
 `TestLoad` 메서드 지정 하는 어셈블리를 로드 합니다. 유효한 정규화 된 어셈블리 이름을 지정 하거나 주석으로 처리 된 <xref:System.Reflection.Assembly.Load%28System.String%29> 메서드. `TestLoad` 메서드는 지정 된 어셈블리와 예제에서는 어셈블리 로드 되었음을 보여 주는 새 응용 프로그램 도메인에 로드 된 어셈블리를 나열 합니다.  
  
 이 예제에서는 사용을 <xref:System.LoaderOptimizationAttribute> 방법을 공유 하는 코드 응용 프로그램 도메인 간에 어셈블리 로더를 구별 하는 특성입니다.  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>보안과 신뢰 정보가 들어 있는 개체를 가져오거나 설정합니다.</summary>
        <value>보안과 신뢰 정보가 들어 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 `null` 경우는 <xref:System.AppDomainSetup> 만들어집니다. 변경 되 면 null 참조를 다시 설정할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">애플리케이션 ID가 <see cref="P:System.AppDomainSetup.ActivationArguments" /> 속성이 반환한 <see cref="T:System.Runtime.Hosting.ActivationArguments" /> 개체의 애플리케이션 ID와 일치하지 않는 <see cref="T:System.Security.Policy.ApplicationTrust" /> 개체로 속성이 설정되어 있습니다. <see cref="P:System.AppDomainSetup.ActivationArguments" /> 속성이 <see langword="null" />이면 예외가 발생하지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException">속성이 <see langword="null" />로 설정됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파일을 섀도 복사한 응용 프로그램 관련 영역의 이름을 가져오거나 설정합니다.</summary>
        <value>파일을 섀도 복사한 디렉터리 경로와 파일의 정규화된 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 적용 하기 위해는 <xref:System.AppDomainSetup.ApplicationName%2A> 속성도 설정 해야 합니다. 경우는 <xref:System.AppDomainSetup.ApplicationName%2A> 속성을 설정 하지 않으면는 <xref:System.AppDomainSetup.CachePath%2A> 속성이 무시 되 고 섀도 복사본 캐시 위치에 다운로드 캐시를 기본값으로 합니다.  
  
 섀도 복사에 대 한 자세한 내용은 참조 하세요. [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 정보에 액세스 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">어셈블리 섀도 복사</related>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션 도메인의 구성 파일 이름을 가져오거나 설정합니다.</summary>
        <value>구성 파일의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구성 파일에는 검색 규칙 및 응용 프로그램 도메인에 대 한 구성 데이터를 설명합니다. 응용 프로그램 도메인을 만든 호스트는 의미 있는 값은 상황에 다르므로이 데이터를 제공 하는 일을 담당 합니다.  
  
 예를 들어, 각 응용 프로그램, 사용자 및 컴퓨터에 대 한 실행 파일에 대 한 구성 데이터는 저장 하는 동안 각 응용 프로그램, 사이트 및 컴퓨터에 대 한 ASP.NET 응용 프로그램에 대 한 구성 데이터를 저장 됩니다. 호스트만 특정 상황에 대 한 구성 데이터의 세부 정보를 알고 있습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 정보에 액세스 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">런타임 설정 스키마</related>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>로드할 어셈블리를 검색할 때 응용 프로그램 기본 경로와 전용 이진 경로를 검색할지 여부를 지정합니다.</summary>
        <value>검색이 허용되지 않으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> 속성은 `true`의 값을 <xref:System.AppDomainSetup.ApplicationBase%2A> 속성은 무시 됩니다. 즉, 어셈블리가 없습니다에서 검색 하 여 지정 된 디렉터리는 <xref:System.AppDomainSetup.ApplicationBase%2A> 속성입니다. 또한 값을 <xref:System.AppDomainSetup.PrivateBinPath%2A> 속성 및 <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> 속성은 무시 됩니다. 어셈블리가 없는 지정 된 디렉터리에서 검색 된 <xref:System.AppDomainSetup.PrivateBinPath%2A> 속성입니다.  
  
 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> 속성은 로드 프로세스에 대 한 제어 강화 합니다. 로딩 시퀀스 일반 어셈블리, 응용 프로그램 기준이 하기 전에 조사 조사는 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 이벤트가 발생 합니다. 그러나 일부 응용 프로그램 문서 내에서 사용 되는 OLE 복합 파일 또는 어셈블리를 전역 어셈블리 캐시 또는 지정 된 디렉터리에 있는 고유 알려진된 위치에서 어셈블리를 로드 해야 할 수는 <xref:System.AppDomainSetup.ApplicationBase%2A> 고 <xref:System.AppDomainSetup.PrivateBinPath%2A> 속성입니다. 이러한 응용 프로그램에서 사용할 수는 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> 일반 검색로 인해 지연이 발생을 방지 하 고 정상적인 검색 경로에 있을 수 있습니다 하는 데 필요한 어셈블리의 복사본을 로드 하지 않도록 하려면 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 도메인에서 어셈블리 바인딩 리디렉션을 허용하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>어셈블리 리디렉션이 허용되지 않으면 <see langword="true" />이고, 허용되면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> 속성은 서비스 및 서버 응용 프로그램에서 사용할 수 있는 어셈블리 바인딩 리디렉션의 일부가 아닌 응용 프로그램 시나리오에 하도록 설계 되었습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 도메인에서 HTTP를 사용하여 어셈블리를 다운로드할 수 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>HTTP를 사용하여 어셈블리를 다운로드할 수 없으면 <see langword="true" />이고, 다운로드할 수 있으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowCodeDownload%2A> 속성은 서비스 및 서버 응용 프로그램에서 사용할 수 있는 인트라넷 또는 인터넷에서 다운로드 코드의 일부가 아닌 응용 프로그램 시나리오에 하도록 설계 되었습니다.  
  
> [!CAUTION]
>  기본값은 <xref:System.AppDomainSetup.DisallowCodeDownload%2A> 속성은 `false`합니다. 이 설정은 서비스에 대 한 안전 하지 않습니다. 서비스에서 부분적으로 신뢰할 수 있는 코드 다운로드를 방지 하려면이 속성을 설정 `true`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>구성 파일의 [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) 섹션이 애플리케이션 도메인에 적용되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>응용 프로그램 도메인에 대한 구성 파일의 <see langword="true" /> 섹션이 무시되면 <see langword="&lt;publisherPolicy&gt;" />이고, 적용되면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> 속성이 로컬로 로드 되는 웹 응용 프로그램에 특별히 적용 됩니다. 안전 모드에서 안전 하지 않은 웹 응용 프로그램을 실행 하려는 악의적인 시도 방지 하려면이 속성을 사용 합니다.  
  
 게시자 정책 무시 하는 방법에 대 한 자세한 내용은 참조는 [어셈블리 버전 리디렉션](~/docs/framework/configure-apps/redirect-assembly-versions.md) 항목입니다. 안전 모드에 대 한 자세한 내용은의 "구성 파일 검사" 섹션을 참조 합니다 [런타임 어셈블리를 찾는 방법](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md) 항목입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적으로 생성된 파일의 디렉터리가 있는 기본 디렉터리를 가져오거나 설정합니다.</summary>
        <value><see cref="P:System.AppDomain.DynamicDirectory" />가 위치한 디렉터리입니다.  

 <block subset="none" type="note"><para>  
 이 속성의 반환 값은 할당된 값과 다릅니다.
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 이 속성을 사용 하 여 새 응용 프로그램 도메인에 대 한 동적 디렉터리 배치 될 위치에 기본 디렉터리를 설정 합니다. 새 응용 프로그램 도메인에서 코드는 어셈블리, 어셈블리 확인을 로드 하는 경우 정상적인 검색 경로에서 첫 번째 찾습니다. 어셈블리를 찾지 못하면가 반환한 동적 디렉터리에서 검색 된 <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> 속성입니다. 로드 되 고 새 응용 프로그램 도메인에서 실행 하는 동적 어셈블리에 배치할 수 있습니다.  
  
 에 대 한 경로 할당 하는 경우는 <xref:System.AppDomainSetup.DynamicBase%2A> 속성을 추가 하위 디렉터리가 추가 되는이 하위 디렉터리의 이름에 할당 된 값의 해시 코드를 <xref:System.AppDomainSetup.ApplicationName%2A> 속성입니다. 따라서이 속성에 의해 반환 된 기본 디렉터리는 항상 할당 된 값과 다릅니다.  
  
> [!IMPORTANT]
>  이 속성에 값을 할당 하는 경우에 모든 디렉터리 생성 하지 않습니다. 디렉터리를 만들거나 사용 하는 코드에서 확인 해야 합니다.  
  
 동적 디렉터리의 하위 디렉터리가 <xref:System.AppDomainSetup.DynamicBase%2A>합니다. 단순 이름은 해당 값을 반환 합니다 <xref:System.AppDomainSetup.ApplicationName%2A> 속성을 해당 형식 이므로 *원래 경로*\\*해시 코드*\\*응용 프로그램 이름*.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.AppDomainSetup.DynamicBase%2A> 동적 어셈블리를 로드할 때 응용 프로그램 도메인 경로 설정 하려면 속성 검색 합니다.  
  
 이 예에서는 만듭니다는 <xref:System.AppDomainSetup> 개체 집합과 해당 <xref:System.AppDomainSetup.ApplicationName%2A> 속성을 "예" 고 <xref:System.AppDomainSetup.DynamicBase%2A> 속성을 "C:\DynamicAssemblyDir". 다음 예제의 <xref:System.AppDomainSetup.DynamicBase%2A> 응용 프로그램 이름의 해시 코드를 원래 할당 된 경로의 하위 디렉터리로 추가 되었는지는 표시할 속성입니다.  
  
> [!NOTE]
>  이 예제의 기본 디렉터리에 예제 응용 프로그램에 대 한 검색 경로 외부에 있을 것입니다. 다른 위치에 예제를 컴파일하려면 해야 합니다. 기본 디렉터리 및 모든 하위 디렉터리를 예제를 실행할 때마다 삭제 합니다.  
  
 이 예에서는 사용 하 여 새 응용 프로그램 도메인을 만듭니다는 <xref:System.AppDomainSetup> 개체입니다. 그런 다음 예제에서는 아직 없는 경우 동적 디렉터리를 만듭니다. 이 예제에서는 응용 프로그램 도메인을 사용 하지만 <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> 동적 디렉터리의 이름을 가져올 속성을이 간단 하 게 만들 수 디렉터리 미리 원래 경로 응용 프로그램 이름, 해시 코드를 연결 하 여 및 응용 프로그램 이름입니다.  
  
 이 예제에는 `GenerateDynamicAssembly` 이라는 어셈블리를 생성 하는 메서드 `DynamicHelloWorld.dll` 새 응용 프로그램 도메인의 동적 디렉터리에 저장 합니다. 동적 어셈블리를 포함 한 가지 형식만 `HelloWorld`, 정적 메서드가 (`Shared` Visual Basic에서 메서드) 라는 `HelloFromAD`합니다. 이 메서드를 호출 응용 프로그램 도메인의 이름을 표시 합니다.  
  
 `Example` 클래스에서 파생 되며 <xref:System.MarshalByRefObject>예제에서는 새 응용 프로그램 도메인 및 호출에서 클래스의 인스턴스를 만들 수 있으므로 해당 `Test` 메서드. 합니다 `Test` 메서드는 표시 이름을 사용 하 여 동적 어셈블리를 로드 하 고 정적 호출 `HelloFromAD` 메서드.  
  
 이라는 어셈블리에 대 한 코드를 작성 하 여 정상적인 검색 경로 후 동적 디렉터리 검색 됩니다 표시할 수 있습니다 `DynamicHelloWorld.dll` 및이 예제와 동일한 디렉터리에 컴파일. 어셈블리에 클래스가 있어야 `HelloWorld` 라는 정적 메서드를 사용 하 여 `HelloFromAD`입니다. 이 메서드를 예제;에 있는 것과 동일한 기능이 필요가 없습니다. 단순히 문자열을 콘솔에 표시할 수 있으며 어셈블리에도 있어야는 <xref:System.Reflection.AssemblyVersionAttribute> 버전 1.0.0.0으로 설정 하는 특성입니다. 예제를 실행 하는 경우 현재 디렉터리에 컴파일된 어셈블리가 동적 디렉터리를 검색 하기 전에 합니다.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">응용 프로그램 도메인의 응용 프로그램 이름이 <see langword="null" />이므로 이 속성을 설정할 수 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 정보에 액세스 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 메서드로 설정된 XML 구성 정보를 반환합니다. 이 구성 정보는 응용 프로그램의 XML 구성 정보를 재정의합니다.</summary>
        <returns><see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 메서드로 의해 설정된 XML 구성 정보가 들어 있는 배열이거나, <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 메서드가 호출되지 않았으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> 메서드는 새 응용 프로그램 도메인을 만들고 응용 프로그램의 구성 정보를 재정의 하는 방법을 제공 합니다. 구성 파일 정보 `value` 응용 프로그램에 대 한 구성 파일 정보를 재정의 합니다. 예를 들어 Example.exe 응용 프로그램을 새 응용 프로그램 도메인을 만들 때 처음에 확보 된 Example.exe.config 파일에서 구성 정보를 재정의할 수 있습니다.  
  
> [!IMPORTANT]
>  구성 파일에 대 한 정보의 일부 소비자는 저장 한 정보를 사용 하지 마십시오는 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> 메서드. 런타임에서이 적용 하지 않습니다. 사용을 보장 하기 위해 새 응용 프로그램 도메인에서 모든 구성 파일 정보를 재정의 하는 <xref:System.AppDomainSetup.ConfigurationFile%2A> 속성을 구성 파일을 지정 합니다. <xref:System.AppDomainSetup.SetConfigurationBytes%2A> 메서드 바인딩 어셈블리는 영향 을지 않습니다.  
  
 XML `value` 같습니다 일반적인 구성 파일에서 XML로 저장 되는 점을 제외 하 고는 <xref:System.Byte> 배열입니다.  
  
 응용 프로그램 도메인에 대 한 구성 바이트에 액세스 하려면 사용 하 여는 <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> 가져올 속성을 <xref:System.AppDomainSetup> 응용 프로그램 도메인에 대 한 개체를 사용 하 여는 <xref:System.AppDomainSetup.GetConfigurationBytes%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 도메인과 관련된 라이센스 파일의 위치를 가져오거나 설정합니다.</summary>
        <value>라이선스 파일의 위치 및 이름입니다.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 정보에 액세스 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>실행 파일을 로드하는 데 사용되는 최적화 정책을 지정합니다.</summary>
        <value><see cref="T:System.LoaderOptimizationAttribute" />와 함께 사용되는 열거형 상수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 동적 어셈블리를 만들고 디스크를 사용 하 여 다음에 저장 된 <xref:System.AppDomainSetup.LoaderOptimization%2A> 응용 프로그램 도메인에 어셈블리를 로드 하는 데 최적화 정책을 설정 하는 속성입니다.  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>샌드박스가 적용된 응용 프로그램 도메인에서 실행 중인 부분 신뢰 코드에 보이는 <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> 플래그로 표시된 어셈블리의 목록을 가져오거나 설정합니다.</summary>
        <value>각 부분 이름이 단순한 이름과 공개 키로 구성되는 부분 어셈블리 이름의 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]의 <xref:System.Security.AllowPartiallyTrustedCallersAttribute> 설정 하면 조건부 (APTCA) 특성을 지정할 수 있습니다 해당 <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> 속성을 <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>입니다. 으로 표시 되는 APTCA 어셈블리 <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> 해당 호스트 응용 프로그램 허용 하지 않는 경우 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.  
  
 샌드박스 응용 프로그램 도메인의 호스트는 단순한 이름 및 각 어셈블리의 공개 키를 포함 하는 배열을 만들고이 속성에 할당 하 여 조건부 APTCA 특성을 사용 하 여 어셈블리를 사용 하려면 응용 프로그램 도메인에서 코드를 허용 합니다. 예를 들어 배열의 요소 수는 다음과 같이 표시 됩니다. "MyAssembly, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad 0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9 "입니다.  
  
> [!IMPORTANT]
>  서브 클래스를 사용 하는 경우 <xref:System.AppDomainManager>를 정의 하는 어셈블리가 conditional APTCA 특성으로 표시 된 어셈블리에 종속를 전달 하는 목록에서 해당 어셈블리를 포함 해야 합니다 <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> 속성을 <xref:System.AppDomainSetup>사용 하 여 응용 프로그램 도메인을 만듭니다. 그렇지 않은 경우 조건부 APTCA 특성으로 표시 되는 어셈블리는 사용 되지 것입니다.  
  
> [!NOTE]
>  샌드박스 응용 프로그램 도메인에서 실행 중인 응용 프로그램을 디버깅 하는 경우 일부 <xref:System.Security.SecurityException> 메시지가 잘못 될 수 있습니다. 예를 들어, 메시지는 완전히 신뢰할 수 있는 어셈블리 중 하나에 제한 된 권한을 문제의 실제 원인을 샌드박스 응용 프로그램 도메인의 권한 부여 집합을 초과 하는 보안 요청을 경계를 전파 하는 경우 상태 수를 샌드박스 응용 프로그램 도메인 및 실패 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 기본 디렉터리 아래에 있는 전용 어셈블리를 검색할 디렉터리 목록을 가져오거나 설정합니다.</summary>
        <value>세미콜론으로 구분된 디렉터리 이름의 목록입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 전용 어셈블리는 응용 프로그램과 동일한 디렉터리 구조에 배포 됩니다. 에 대 한 디렉터리를 지정 하는 경우 <xref:System.AppDomainSetup.PrivateBinPath%2A> 아래에 있지 않으면 <xref:System.AppDomainSetup.ApplicationBase%2A>, 무시 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램의 검색 경로에서 <see cref="P:System.AppDomainSetup.ApplicationBase" />를 포함하거나 제외하고 <see cref="P:System.AppDomainSetup.PrivateBinPath" />만 검색하는 문자열을 가져오거나 설정합니다.</summary>
        <value>어셈블리를 검색할 때 응용 프로그램 기준 위치 경로를 포함하려면 Null 참조(Visual Basic의 경우 <see langword="Nothing" />)이고, 이 경로를 제외하려면 Null이 아닌 임의의 문자열 값입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 null이 아닌 문자열 값으로이 속성을 설정 포함 <xref:System.String.Empty?displayProperty=nameWithType> (""), 응용 프로그램 디렉터리 경로-즉, 제외할 <xref:System.AppDomainSetup.ApplicationBase%2A> -응용 프로그램 및 어셈블리를 검색할 검색 경로에서 에서만 <xref:System.AppDomainSetup.PrivateBinPath%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>각 호출에 대해 <c>QueryInterface</c>가 수행되도록 애플리케이션 도메인의 interop 호출에 대한 인터페이스 캐싱을 비활성화할지 여부를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>현재 <see cref="T:System.AppDomainSetup" /> 개체로 만든 응용 프로그램 도메인의 interop 호출에 대한 인터페이스 캐싱이 비활성화되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인터페이스 캐싱이 비활성화 interop 호출의 성능에 상당한 영향을 미칩니다.  
  
 이 멤버에 도입 된 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="switches">호환성 스위치를 지정하는 열거 가능한 문자열 값이거나 기존 호환성 스위치를 제거하는 <see langword="null" />입니다.</param>
        <summary>지정된 스위치를 설정하여 지정된 문제에 대해 이전 버전의 .NET Framework와 호환되는 애플리케이션 도메인을 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우에 따라 주요 버전의.NET Framework 이전 버전의 주요 변경 내용을 소개합니다. 예를 들어 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 소수의 주요 변경 내용에서 소개를 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]입니다. 사용 된 <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> 동작이 이전 버전의.NET Framework와 호환 되도록 응용 프로그램 도메인에 대 한 이러한 주요 변경 내용 중 하나 이상을 지정 하는 방법으로 롤백할 수 해야 합니다.  
  
 이 메서드를 호출할 때마다 기존 스위치 설정을 대체 합니다. 지정 설정을 지우려면 `null` 에 대 한는 `switches` 매개 변수입니다.  
  
 에 제공 하는 문자열 값 집합이 `switches` 배열 구현 하기 때문에 간단한 문자열 배열, 수를 <xref:System.Collections.IEnumerable> 인터페이스입니다.  
  
 다음 표에서.NET Framework의 이전 버전의 동작을 복원 하려면 설정할 수 있는 호환성 스위치의 예제를 제공 합니다.  
  
|스위치|의미|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|액세스 보안 (CA)에 대 한 코드는 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 이 응용 프로그램 도메인에서 사용 하도록 설정 됩니다. 참조 [ &lt;NetFx40_LegacySecurityPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)합니다.|  
|"NetFx40_Legacy20SortingBehavior"|문자열에 대 한 기본값을 정렬 된 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 이 응용 프로그램 도메인에서 활성화 됩니다. 레거시 정렬 동작을 복원 했습니다. 로컬 시스템에서 사용 가능 하도록 sort00001000.dll 동적 링크 라이브러리도 필요 합니다. 참조 [ &lt;CompatSortNLSVersion&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)합니다.|  
|"NetFx40_Legacy40SortingBehavior"|문자열에 대 한 기본값을 정렬 된 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 유니코드 5.0이 응용 프로그램 도메인에서 사용 되 고 있습니다. Sort00060101.dll 동적 연결 라이브러리를 로컬 시스템에서 사용할 수 있어야 했습니다. 레거시 정렬 동작을 복원 합니다.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> 서식 지정에 대 한 동작을 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 이 응용 프로그램 도메인에서 사용 하도록 설정 됩니다. 참조 [ &lt;TimeSpan_LegacyFormatMode&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) 및 "레거시 TimeSpan 서식 복원" 섹션을 <xref:System.TimeSpan> 항목입니다.|  
|"UseRandomizedStringHashAlgorithm"|문자열에 대 한 해시 코드를 계산 하는 런타임에 응용 프로그램 도메인 간에 일관 된 해시 코드를 생성 하는 단일 해싱 알고리즘을 사용 하는 대신 응용 프로그램 도메인 별로 합니다. 참조 [ &lt;UseRandomizedStringHashAlgorithm&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)합니다.|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/07132b9c-4a72-4710-99d7-e702405e02d4">&lt;NetFx40_LegacySecurityPolicy&gt; 요소</related>
        <related type="Article" href="https://msdn.microsoft.com/library/782cc82e-83f7-404a-80b7-6d3061a8b6e3">&lt;CompatSortNLSVersion&gt; 요소</related>
        <related type="Article" href="https://msdn.microsoft.com/library/865e7207-d050-4442-b574-57ea29d5e2d6">&lt;TimeSpan_LegacyFormatMode&gt; 요소</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; 요소</related>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">응용 프로그램 도메인에 사용할 XML 구성 정보가 들어 있는 배열입니다.</param>
        <summary>응용 프로그램 도메인에 XML 구성 정보를 제공하여 응용 프로그램의 XML 구성 정보를 바꿉니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> 메서드는 새 응용 프로그램 도메인을 만들고 응용 프로그램의 구성 정보를 대체 하는 방법을 제공 합니다. 구성 파일 정보 `value` 응용 프로그램에 대 한 구성 파일 정보를 대체 합니다. 예를 들어 직전인 Example.exe 응용 프로그램을 새 응용 프로그램 도메인을 만들 때 처음에 확보 된 Example.exe.config 파일에서 구성 정보를 교체할 수 있습니다.  
  
> [!IMPORTANT]
>  구성 파일에 대 한 정보의 일부 소비자는 저장 한 정보를 사용 하지 마십시오는 <xref:System.AppDomainSetup.SetConfigurationBytes%2A> 메서드. 런타임에서이 적용 하지 않습니다. 새 응용 프로그램 도메인에서 모든 구성 파일 정보는 대체를 사용 하 여는 <xref:System.AppDomainSetup.ConfigurationFile%2A> 속성을 구성 파일을 지정 합니다. <xref:System.AppDomainSetup.SetConfigurationBytes%2A> 메서드 바인딩 어셈블리는 영향 을지 않습니다.  
  
 XML `value` 같습니다 일반적인 구성 파일에서 XML로 저장 되는 점을 제외 하 고는 <xref:System.Byte> 배열입니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">런타임 설정 스키마</related>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionVersion" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionPointer" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="functionName">재정의할 문자열 비교 함수의 이름입니다.</param>
        <param name="functionVersion">함수 버전입니다. [!INCLUDE[net_v45](~/includes/net-v45-md.md)]의 경우 값은 1 이상이어야 합니다.</param>
        <param name="functionPointer"><paramref name="functionName" />을 재정의하는 함수에 대한 포인터입니다.</param>
        <summary>공용 언어 런타임에 문자열 비교 함수의 대체 구현을 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 문자열 비교 및 정렬 방법으로 재정의할 수 있습니다는 <xref:System.AppDomainSetup.SetNativeFunction%2A> 메서드:  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 이러한 함수에 대 한 자세한 내용은 [국가별 언어 지원 기능](https://go.microsoft.com/fwlink/?LinkId=228134)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="functionName" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="functionVersion" />가 1 이상입니다.  
  
또는 
 <paramref name="functionPointer" />가 <see cref="F:System.IntPtr.Zero" />입니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>섀도 복사할 어셈블리가 들어 있는 디렉터리의 이름을 가져오거나 설정합니다.</summary>
        <value>세미콜론으로 구분된 디렉터리 이름의 목록입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본값은 모든 어셈블리가; 검색을 통해 검색 하는 섀도 복사본을 섀도 복사를 사용 하는 경우 즉, 디렉터리에 의해 지정 된 <xref:System.AppDomainSetup.PrivateBinPath%2A> 및 <xref:System.AppDomainSetup.ApplicationBase%2A> 속성. 합니다 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> 속성에서 지정 된 디렉터리에서 어셈블리를 섀도 복사를 제한 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>합니다.  
  
 문자열을 할당 하지 않으면를 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> 속성을이 속성을 설정 하는 경우 또는 `null`, 지정 된 디렉터리의 모든 어셈블리를 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 속성은 섀도 복사 합니다.  
  
> [!IMPORTANT]
>  세미콜론은 구분 기호 문자이므로 디렉터리 경로에 세미콜론을 포함하면 안 됩니다. 세미콜론에 대한 이스케이프 문자는 없습니다.  
  
 섀도 복사에 적용 되 면 어셈블리를 로드 하기 전에 어셈블리 파일을 다른 위치로 복사 됩니다. 업데이트할 수 있도록 원래 어셈블리 파일 잠겨 있지 않습니다. 섀도 복사에 대 한 자세한 내용은 참조 하세요. [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 정보에 액세스 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">어셈블리 섀도 복사</related>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>섀도 복사를 설정하거나 해제할지 여부를 나타내는 문자열을 가져오거나 설정합니다.</summary>
        <value>섀도 복사가 설정되었음을 나타내려면 문자열 값 "true"이고, 섀도 복사가 해제되었음을 나타내려면 "false"입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 섀도 복사에 대 한 자세한 내용은 참조 하세요. [어셈블리 섀도 복사](~/docs/framework/app-domains/shadow-copy-assemblies.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">어셈블리 섀도 복사</related>
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" /> 생성자가 구문 분석할 수 있는 형식으로 응용 프로그램에 대한 .NET Framework의 대상 버전 및 프로필을 지정하는 문자열을 가져오거나 설정합니다.</summary>
        <value>.NET Framework의 대상 버전 및 프로필입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 실행 중인 버전의.NET Framework 응용 프로그램 도메인 로드 대상 버전 및 프로필에 대 한 컴파일된 어셈블리를 실행 하는이 속성을 설정 합니다. 현재 실행 중인 버전의.NET Framework 대상 버전을 사용 하 여 컴파일된 코드의 호환성에 영향을 주는 선택적 동작에 사용 하도록 설정 하거나 적절 하 게 호환성을 개선 하기 위해 이러한 동작을 사용 하지 않도록 설정 있습니다. 이 기능은 응용 프로그램에서 별도 응용 프로그램 도메인에서 실행 하 여 여러 버전의.NET Framework를 사용 하 여 컴파일된 추가 기능을 지 원하는 경우에 유용할 수 있습니다.  
  
 클라이언트 응용 프로그램의 경우 값을 <xref:System.AppDomainSetup.TargetFrameworkName%2A> 속성에서 유추 되는 <xref:System.Runtime.Versioning.TargetFrameworkAttribute> 특성. [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] 프로젝트의 설정에 따라 자동으로 어셈블리에이 특성을 추가 하는 나중에, 및 **대상 프레임 워크** 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>