<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="17dc71087e58ed347b4efbbe71e747eb91676656" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52200588" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>대리자는 정적 메서드 또는 클래스 인스턴스 및 해당 클래스의 인스턴스 메서드를 참조하는 데이터 구조입니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate> 클래스는 대리자 형식에 대 한 기본 클래스입니다. 그러나 시스템 및 컴파일러에서 명시적으로 파생할 수는 <xref:System.Delegate> 클래스 또는 <xref:System.MulticastDelegate> 클래스입니다. 것도 대리자 형식에서 새 형식을 파생할 수입니다. <xref:System.Delegate> 클래스 대리자 형식으로 간주 되지 않으면 대리자 형식을 파생 하는 데 사용 하는 클래스입니다.  
  
 대부분의 언어를 구현를 `delegate` 키워드 및 해당 언어 컴파일러에서 파생 시킬 수 있습니다 합니다 <xref:System.MulticastDelegate> 클래스; 따라서 사용자가 사용 해야는 `delegate` 언어에서 제공 하는 키워드입니다.  
  
> [!NOTE]
>  공용 언어 런타임에서 제공는 `Invoke` 대리자와 동일한 서명 사용 하 여 각 대리자 형식에 대 한 메서드. 컴파일러는 자동으로 호출 하므로 C#, Visual Basic 또는 Visual c + +에서이 메서드를 명시적으로 호출할 필요가 없습니다. 합니다 `Invoke` 메서드는에서 유용 [리플렉션](~/docs/framework/reflection-and-codedom/reflection.md) 대리자 형식 시그니처를 찾으려는 경우.  
  
 공용 언어 런타임에서 제공 각 대리자 형식과 `BeginInvoke` 및 `EndInvoke` 메서드를 대리자의 비동기 호출을 사용 하도록 설정 합니다. 이러한 방법에 대 한 자세한 내용은 참조 하세요. [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)합니다.  
  
 하나 이상의 메서드의 서명을 지정 하는 계약을 설정 하는 대리자 형식 선언 합니다. 대리자는에 대 한 참조 된 대리자 형식의 인스턴스입니다.  
  
-   형식과 해당 형식에 할당할 수 있는 대상 개체의 인스턴스 메서드  
  
-   숨겨진 된 형식의 인스턴스 메서드인 `this` 정식 매개 변수 목록에서 노출 하는 매개 변수입니다. 열려 있는 인스턴스 대리자를 대리자 라고 합니다.  
  
-   정적 메서드입니다.  
  
-   정적 메서드와 메서드의 첫 번째 매개 변수에 할당할 수 있는 대상 개체입니다. 대리자는 첫 번째 인수에 대해 닫혀 있는 것으로 간주 됩니다.  
  
 대리자 바인딩에 대 한 자세한 내용은 참조는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 메서드 오버 로드 합니다.  
  
> [!NOTE]
>  .NET Framework 버전 1.0 및 1.1에서는 대리자 메서드 서명의 정확 하 게 시그니처와 일치 하는 대리자 형식으로 지정 하는 경우에 메서드를 나타낼 수 있습니다. 따라서 앞의 목록에서 첫 번째 및 세 번째 글머리 지원 하며 첫 번째 글머리 기호 형식이 정확히 일치 하는 합니다.  
  
 첫 번째 인수 (가장 일반적인 경우)에 대해 닫혀 인스턴스 메서드를 나타내는 대리자를 대리자 저장 메서드의 진입점에 대 한 참조 및 호출 대상에 정의 된 형식에 할당할 수 있는 형식의 개체에 대 한 참조는 메서드입니다. 대리자가 열려 있는 인스턴스 메서드를 나타내는 경우 메서드 진입점에 대 한 참조를 저장 합니다. 대리자 시그니처는 숨겨진 있어야 합니다. `this` 매개 변수는 정식 매개 변수 목록의 경우 대리자에는 대상 개체에 대 한 참조가 없는 및 대리자를 호출할 때 대상 개체를 제공 해야 합니다.  
  
 대리자는 정적 메서드를 나타내는 경우 대리자 메서드의 진입점에 대 한 참조를 저장 합니다. 대리자에서 첫 번째 인수에 대해 닫혀 정적 메서드를 나타내는 경우 대리자 메서드의 진입점에 대 한 참조 및 메서드의 첫 번째 인수의 형식에 할당할 수 있는 대상 개체에 대 한 참조를 저장 합니다. 대리자 호출 되 면 정적 메서드의 첫 번째 인수는 대상 개체를 받습니다.  
  
 대리자의 호출 목록은 순서가 지정 된 집합은 목록의 각 요소가 정확히 하나를 호출 대리자가 나타내는 메서드의 대리자입니다. 호출 목록을 중복 메서드를 포함할 수 있습니다. 메서드는 호출 하는 동안 호출 목록에 나타나는 순서 대로 호출 됩니다. 대리자는 호출 목록의 모든 메서드를 호출 하려고 합니다. 중복 된 각 시간에 대 한 호출 목록에 표시 되 면 호출 됩니다. 대리자는 변경할 수 없습니다. 를 만든 후에 대리자의 호출 목록이 변경 되지 않습니다.  
  
 대리자 라고 멀티 캐스트 또는 결합할 대리자 하나 이상의 메서드를 호출할 수 작업을 결합 하 여 사용 될 수 있으므로 합니다.  
  
 와 같은 작업을 결합 <xref:System.Delegate.Combine%2A> 고 <xref:System.Delegate.Remove%2A>, 기존 대리자를 변경 하지 않습니다. 이러한 작업에서 변경 되지 않은 대리자를 작업의 결과 포함 하는 새 대리자를 반환 하는 대신 또는 `null`합니다. 결합 작업을 반환 합니다 `null` 경우 작업의 결과 하나 이상의 메서드를 참조 하지 않는 대리자입니다. 결합 작업을 요청한 작업에 영향을 주지 않습니다 경우는 변경 되지 않은 대리자를 반환 합니다.  
  
> [!NOTE]
>  언어 사용을 관리 합니다 <xref:System.Delegate.Combine%2A> 및 <xref:System.Delegate.Remove%2A> 대리자 작업을 구현 하는 방법입니다. 예를 들어 합니다 `AddHandler` 및 `RemoveHandler` Visual Basic의 선언문 및 + = 및-= 연산자를 대리자 C#의 형식입니다.  
  
 부터 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 제네릭 대리자 형식에서 variant 형식 매개 변수를 가질 수 있습니다. 반공 변 형식 매개 변수는 대리자의 매개 변수 형식으로 사용할 수 및 반환 형식으로 공변 (covariant) 형식 매개 변수를 사용할 수 있습니다. 이 기능을 사용 하면 제네릭 대리자에 설명 된 대로 해당 형식 인수가 상속 관계를 사용 하 여 참조 형식이 면 대입과 호환 되도록 동일한 제네릭 형식 정의에서 생성 되는 형식을 [공변성 (covariance) 및 반 공변성](~/docs/standard/generics/covariance-and-contravariance.md)합니다.  
  
> [!NOTE]
>  제네릭 대리자의 할당 호환 분산으로 인해 없는 결합할 수 있는 것은 아닙니다. 결합할 수 있으려면 형식을 정확 하 게 일치 해야 합니다. 예를 들어 라는 클래스를 가정 `Derived` 라는 클래스에서 파생 된 `Base`합니다. 형식의 대리자 `Action<Base>` (`Action(Of Base)` Visual Basic에서) 형식의 변수에 할당할 수 있습니다 `Action<Derived>`, 하지만 두 대리자 형식이 정확히 일치 하지 않기 때문에 함께 사용할 수 없습니다.  
  
 호출한 메서드가 예외를 throw 하는 경우 메서드 실행을 중지, 대리자의 호출자에 게 전달 될 예외 및 호출 목록에 남아 있는 메서드는 호출 되지 않습니다. 호출자에 예외를 catch 하는 경우에이 동작은 변경 되지 않습니다.  
  
 반환 값을 포함 하는 대리자를 호출한 메서드 서명의 경우 대리자 호출 목록에서 마지막 요소의 반환 값을 반환 합니다. 서명을 참조로 전달 되는 매개 변수를 포함 하는 경우 매개 변수의 최종 값 순차적으로 실행 하 고 매개 변수의 값을 업데이트 호출 목록의 모든 메서드의 결과입니다.  
  
 C 또는 c + +에서 대리자의 가장 가까운 해당 함수 포인터입니다. 대리자는 정적 메서드 또는 인스턴스 메서드를 나타낼 수 있습니다. 대리자가 인스턴스 메서드를 나타내는 경우 대리자 메서드의 진입점에 대 한 참조 뿐만 아니라 클래스 인스턴스에 대 한 참조를 저장 합니다. 함수 포인터와 달리 대리자는 개체 지향적 이며 형식 안전.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 대리자를 정의 하는 방법을 보여 줍니다 `myMethodDelegate`합니다. 이 대리자의 인스턴스를 중첩 된의 정적 메서드와 인스턴스 메서드를 만들 `mySampleClass` 클래스입니다. 인스턴스 메서드에 대 한 대리자의 인스턴스가 필요 `mySampleClass`합니다. 합니다 `mySampleClass` 인스턴스는 명명 된 변수에 저장 `mySC`합니다.  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">동기 메서드를 비동기 방식으로 호출</related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">대리자(C# 프로그래밍 가이드)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">대리자(Visual Basic)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">방법: 대리자 정의 및 사용(C++/CLI)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">이벤트 처리 및 발생</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>새 대리자를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">대리자가 <paramref name="method" />를 호출하는 클래스 인스턴스입니다.</param>
        <param name="method">대리자가 나타내는 인스턴스 메서드의 이름입니다.</param>
        <summary>지정된 클래스 인스턴스에서 지정된 인스턴스 메서드를 호출하는 대리자를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 응용 프로그램 코드에서 사용할 수 없습니다. 인스턴스 메서드의 이름을 지정 하 여 대리자를 만들려는 오버 로드를 사용 합니다 <xref:System.Delegate.CreateDelegate%2A> 메서드 이름 및 대상 개체를 지정 하는 방법입니다. 예를 들어를 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> 메서드 오버 로드는 지정 된 이름의 인스턴스 메서드의 대리자를 만듭니다.  
  
 이 생성자 대리자 예를 들어만 메서드를 만듭니다. 클래스의 인스턴스와 연결 된 메서드가 인스턴스 메서드 정적 메서드는 클래스 자체에 연결 되는 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">대상 메서드에 바인딩할 때 오류가 발생한 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <paramref name="method" />를 정의하는 클래스를 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="method">대리자가 나타내는 정적 메서드의 이름입니다.</param>
        <summary>지정된 클래스에서 지정된 정적 메서드를 호출하는 대리자를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 응용 프로그램 코드에서 사용할 수 없습니다. 정적 메서드 이름을 지정 하 여 대리자를 만들려는 오버 로드를 사용 합니다 <xref:System.Delegate.CreateDelegate%2A> 메서드 메서드 이름을 지정 하지만 대상 개체를 지정 하지 않습니다. 예를 들어를 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> 메서드 오버 로드는 지정 된 이름의 메서드에 대 한 정적 대리자를 만듭니다.  
  
 이 생성자는 정적 메서드만 대 한 대리자를 만듭니다. 클래스의 인스턴스와 연결 된 메서드가 인스턴스 메서드 정적 메서드는 클래스 자체에 연결 되는 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
또는 
 <paramref name="target" />이 개방형 제네릭 형식을 나타내는 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>대리자의 부분 복사본을 만듭니다.</summary>
        <returns>대리자의 부분 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복사본은 동일한 <xref:System.Type>, 원래 대리자로 대상, 메서드 및 호출 목록입니다.  
  
 단순 복사본을 원래 개체와 동일한 형식의 새 인스턴스를 만듭니다 및 그런 다음 원래 개체의 비정적 필드에 복사 합니다. 필드 값 형식이 면 필드를 비트 단위로 복사가 수행 됩니다. 필드 참조 형식이 면 참조가 복사 되 고 이지만 참조 된 개체는 없습니다. 따라서 원래 개체에 대 한 참조 및 복제본에 대 한 참조는 동일한 개체를 가리킵니다. 반대로 개체의 전체 복사본을 직접 또는 간접적으로 참조 개체의 필드를 통해 모든 항목을 복제 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 결합할 수 있는 멀티캐스트 대리자의 호출 목록을 연결합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">결합할 대리자의 배열입니다.</param>
        <summary>대리자 배열의 호출 목록을 연결합니다.</summary>
        <returns>
          <paramref name="delegates" /> 배열의 대리자 호출 목록을 연결하는 호출 목록이 있는 새 대리자입니다. <paramref name="delegates" />가 <see langword="null" />이거나 <paramref name="delegates" />에 요소가 없거나 <paramref name="delegates" />의 모든 항목이 <see langword="null" />인 경우 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 `delegates` 배열에 있는 항목이 포함 되어 있습니다. `null`, 이러한 항목은 무시 됩니다.  
  
 호출 목록에 있는 중복 항목을 포함할 수 있습니다. 즉, 같은 개체에 동일한 메서드를 참조 하는 항목입니다.  
  
> [!NOTE]
>  제네릭 대리자의 할당 호환 분산으로 인해 없는 결합할 수 있는 것은 아닙니다. 결합할 수 있으려면 형식을 정확 하 게 일치 해야 합니다. 예를 들어 라는 클래스를 가정 `Derived` 라는 클래스에서 파생 된 `Base`합니다. 형식의 대리자 `Action<Base>` (`Action(Of Base)` Visual Basic의) 형식의 변수에 할당할 수 있습니다 `Action<Derived>`에 설명 되어 있듯이 [공변성 (covariance) 및 반 공변성](~/docs/standard/generics/covariance-and-contravariance.md), 형식을 수행 하므로 두 대리자를 결합할 수 없습니다 있지만 정확히 일치 하지 않습니다.  
  
 <xref:System.Delegate.Combine%2A> 때마다 이벤트를 다중 메서드 호출에서 발생 하는 이벤트 처리기를 만드는 데 유용 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegates" />의 null이 아닌 모든 항목이 동일한 대리자 형식의 인스턴스인 것은 아닙니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">해당 호출 목록이 처음에 나오는 대리자입니다.</param>
        <param name="b">해당 호출 목록이 마지막에 나오는 대리자입니다.</param>
        <summary>두 대리자의 호출 목록을 연결합니다.</summary>
        <returns>호출 목록 <paramref name="a" />와 <paramref name="b" />를 순서대로 연결하는 호출 목록을 가진 새 대리자입니다. <paramref name="b" />가 <see langword="null" />이면 <paramref name="a" />를 반환하고, <paramref name="a" />가 null 참조이면 <paramref name="b" />를 반환하며, <paramref name="a" />와 <paramref name="b" />가 모두 null 참조이면 null 참조를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 목록에 있는 중복 항목을 포함할 수 있습니다. 즉, 같은 개체에 동일한 메서드를 참조 하는 항목입니다.  
  
> [!NOTE]
>  제네릭 대리자의 할당 호환 분산으로 인해 없는 결합할 수 있는 것은 아닙니다. 결합할 수 있으려면 형식을 정확 하 게 일치 해야 합니다. 예를 들어 라는 클래스를 가정 `Derived` 라는 클래스에서 파생 된 `Base`합니다. 형식의 대리자 `Action<Base>` (`Action(Of Base)` Visual Basic의) 형식의 변수에 할당할 수 있습니다 `Action<Derived>`에 설명 되어 있듯이 [공변성 (covariance) 및 반 공변성](~/docs/standard/generics/covariance-and-contravariance.md), 형식을 수행 하므로 두 대리자를 결합할 수 없습니다 있지만 정확히 일치 하지 않습니다.  
  
 <xref:System.Delegate.Combine%2A> 때마다 이벤트를 다중 메서드 호출에서 발생 하는 이벤트 처리기를 만드는 데 유용 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="a" /> 및 <paramref name="b" /> 모두 <see langword="null" />이 아니며, <paramref name="a" /> 및 <paramref name="b" />가 동일한 대리자 형식의 인스턴스가 아닙니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">현재 결합할 수 있는 멀티캐스트 대리자의 호출 목록의 끝에 덧붙일 호출 목록을 가진 결합할 수 있는 멀티캐스트 대리자입니다.</param>
        <summary>지정된 결합할 수 있는 멀티캐스트 대리자와 현재 결합할 수 있는 멀티캐스트 대리자의 호출 목록을 연결합니다.</summary>
        <returns>현재 결합할 수 있는 멀티캐스트 대리자의 호출 목록과 <paramref name="d" />의 호출 목록을 연결하는 호출 목록을 가진 새로운 결합할 수 있는 멀티캐스트 대리자이거나, <paramref name="d" />가 <see langword="null" />인 경우 현재 결합할 수 있는 멀티캐스트 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 대리자가 멀티 캐스트 하는 경우에 적용 됩니다. 결합할 수 있습니다.  
  
 현재 구현은 단순히 throw를 <xref:System.MulticastNotSupportedException>입니다.  
  
 호출 목록에 있는 중복 항목을 포함할 수 있습니다. 즉, 같은 개체에 동일한 메서드를 참조 하는 항목입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">항상 throw됩니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 형식의 대리자를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="method">대리자가 나타내는 정적 또는 인스턴스 메서드를 설명하는 <see cref="T:System.Reflection.MethodInfo" />입니다. .NET Framework 버전 1.0 및 1.1에서는 정적 메서드만 지원됩니다.</param>
        <summary>지정된 정적 메서드를 나타내기 위해서 지정된 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 정적 메서드를 나타내기 위한 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 버전 1.0 및 1.1에서는이 메서드 오버 로드는 정적 메서드만 대 한 대리자를 만듭니다. .NET framework 버전 2.0에서이 메서드 오버 로드 만들 수도 있습니다 열린 인스턴스 메서드가 대리자 활용입니다. 즉, 대리자의 숨겨진된 첫 번째 인수를 명시적으로 제공 하는 인스턴스 메서드. 자세한 내용은 참조는 보다 일반적인 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> 메서드 오버 로드를 모든 조합을 열림 또는 닫힘 대리자 인스턴스 또는 정적 메서드를 만들고 필요에 따라 첫 번째 인수를 지정할 수 있습니다.  
  
> [!NOTE]
>  이 메서드 오버 로드 때 사용할 대리자의 첫 번째 인수에 대해 닫혀 있지 않으면 이므로 좀 더 빠른 경우.  
  
 이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 메서드 오버 로드 하 고 지정 `true` 에 대 한 `throwOnBindFailure`합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 메서드의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
## <a name="compatible-parameter-types-and-return-type"></a>호환 되는 매개 변수 형식 및 반환 형식  
 .NET framework 버전 2.0에서 매개 변수 형식 및이 메서드 오버 로드를 사용 하 여 만든 대리자의 반환 형식은 매개 변수 형식과 대리자가 나타내는; 메서드의 반환 형식은 호환 되어야 합니다. 형식을 정확 하 게 일치 하지 않아도 됩니다. .NET framework 버전 1.0 및 1.1에서는 형식이 정확히 일치 해야 바인딩 동작을 완화를 나타냅니다.  
  
 대리자 매개 변수의 형식이 메서드 매개 변수의 형식보다 제한적인 경우 대리자의 매개 변수는 메서드의 해당 매개 변수와 호환됩니다. 이 경우 대리자로 전달된 인수를 안전하게 메서드로 전달할 수 있습니다.  
  
 마찬가지로 메서드의 반환 형식이 대리자의 반환 형식보다 제한적인 경우 대리자의 반환 형식은 메서드의 반환 형식과 호환됩니다. 이 경우 메서드의 반환 값을 안전하게 대리자의 반환 형식으로 캐스팅할 수 있습니다.  
  
 예를 들어, 형식의 매개 변수를 사용 하 여 대리자 <xref:System.Collections.Hashtable> 의 반환 형식이 <xref:System.Object> 형식의 매개 변수를 사용 하 여 메서드를 나타낼 수 있습니다 <xref:System.Object> 형식의 반환 값 및 <xref:System.Collections.Hashtable>합니다.  
  
   
  
## Examples  
 이 섹션에는 두 코드 예제가 있습니다. 첫 번째 예제에서는 두 종류의이 메서드 오버 로드를 사용 하 여 만들 수 있는 대리자를 보여 줍니다.: 인스턴스 메서드를 통해 열고 정적 메서드에 대해 엽니다.  
  
 두 번째 코드 예제에서는 호환 매개 변수 형식을 보여 줍니다 및 형식을 반환 합니다.  
  
 **예제 1**  
  
 다음 코드 예제는 두 가지 방법으로이 오버 로드를 사용 하 여 대리자를 만들 수 있습니다는 <xref:System.Delegate.CreateDelegate%2A> 메서드.  
  
> [!NOTE]
>  두 가지 오버 로드의는 <xref:System.Delegate.CreateDelegate%2A> 지정 하는 메서드를 <xref:System.Reflection.MethodInfo> 첫 번째 인수가 아닌; 해당 기능을 바인딩하려는 경우 실패 시 throw 할 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다. 이 코드 예제에서는 두 오버 로드를 사용 합니다.  
  
 클래스를 선언 하는 예제 `C` 정적 메서드를 사용 하 여 `M2` 및 인스턴스 메서드 `M1`, 두 대리자 형식이: `D1` 의 인스턴스를 사용 하 `C` 및 문자열 및 `D2` 문자열을 사용 합니다.  
  
 두 번째 클래스가 `Example` 는 대리자를 만드는 코드를 포함 합니다.  
  
-   형식의 대리자 `D1`열려 있는 인스턴스 메서드를 나타내는, 인스턴스 메서드 만들어집니다 `M1`합니다. 대리자가 호출 되 면 인스턴스를 전달 되어야 합니다.  
  
-   형식의 대리자 `D2`열려 있는 정적 메서드를 나타내는, 정적 메서드에 대 한 만들어집니다 `M2`합니다.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **예제 2**  
  
 다음 코드 예제에서는 매개 변수 형식 호환성을 보여 줍니다 및 형식을 반환 합니다.  
  
 코드 예제에서는 라는 기본 클래스를 정의 `Base` 라는 클래스 `Derived` 에서 파생 되는 `Base`합니다. 파생된 클래스에는 `static` (`Shared` Visual basic에서) 라는 메서드 `MyMethod` 형식의 매개 변수 하나를 사용 하 여 `Base` 의 반환 형식이 `Derived`합니다. 코드 예제에서는 또한 라는 대리자를 정의 `Example` 형식의 매개 변수 `Derived` 의 반환 형식이 `Base`합니다.  
  
 코드 예제에서는 대리자를 지정 하는 방법을 보여 줍니다 `Example` 메서드를 나타내는 데 사용할 수 있습니다 `MyMethod`합니다. 때문에 메서드를 대리자에 바인딩할 수 있습니다.  
  
-   대리자의 매개 변수 형식 (`Derived`) 매개 변수 형식 보다 더 제한적인 `MyMethod` (`Base`)를 항상 안전 하 게 대리자의 인수를 전달 하는, `MyMethod`합니다.  
  
-   반환 형식은 `MyMethod` (`Derived`) 대리자의 매개 변수 형식 보다 더 제한적인 (`Base`)는 항상 대리자의 반환 형식 메서드의 반환 형식을 캐스팅 하지 않아도 안전 합니다.  
  
 코드 예제에는 출력이 없습니다.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
또는 
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
또는 
 <paramref name="method" />가 정적 메서드가 아니며 .NET Framework 버전이 1.0 또는 1.1입니다.  
  
또는 
 <paramref name="method" />를 바인딩할 수 없습니다.  
  
또는 
 <paramref name="method" />가 <see langword="RuntimeMethodInfo" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="firstArgument">대리자가 바인드되는 개체이거나, <paramref name="method" />를 <see langword="static" />(Visual Basic의 경우 <see langword="Shared" />)으로 처리하는 경우 <see langword="null" />입니다.</param>
        <param name="method">대리자가 나타내는 정적 또는 인스턴스 메서드를 설명하는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <summary>지정한 첫 번째 인수를 사용하여 지정한 정적 또는 인스턴스 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 정적 또는 인스턴스 메서드를 나타내는 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 메서드 오버 로드 하 고 지정 `true` 에 대 한 `throwOnBindFailure`합니다. 이러한 두 오버 로드는 대리자를 만들 수 있는 가장 유연한 방법을 제공 합니다. 대리자에 대 한 정적 또는 인스턴스 메서드를 만들고 필요에 따라 첫 번째 인수를 지정 하 고를 사용할 수 있습니다.  
  
> [!NOTE]
>  첫 번째 인수를 제공 하지 않는 경우 사용 된 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 성능 향상을 위해 메서드 오버 로드 합니다.  
  
 대리자 형식 및 메서드의 호환 반환 형식이 있어야 합니다. 반환 형식, 즉 `method` 의 반환 형식에 할당할 수 있어야 `type`합니다.  
  
 하는 경우 `firstArgument` 가 제공에 전달한 `method` 될 때마다 대리자가 호출 됩니다. `firstArgument` 대리자에 바인딩될 것 이라고 대리자는 첫 번째 인수에 대해 닫혀 있는 것으로 간주 합니다. 경우 `method` 은 `static` (`Shared` Visual basic에서)의 경우 대리자를 호출할 때 제공 하는 목록; 첫 번째를 제외한 모든 매개 변수를 포함 하는 인수 `method` 인스턴스 메서드 이면 `firstArgument` 숨겨진 인스턴스에 전달 됩니다 매개 변수 (나타낸 `this` C# 또는 `Me` Visual basic에서).  
  
 경우 `firstArgument` 제공 됩니다의 첫 번째 매개 변수 `method` 는 참조 형식 이어야 하 고 `firstArgument` 해당 형식과 호환 되어야 합니다.  
  
> [!IMPORTANT]
>  경우 `method` 됩니다 `static` (`Shared` Visual Basic에서) 해당 첫 번째 매개 변수는 형식 및 <xref:System.Object> 또는 <xref:System.ValueType>, 다음 `firstArgument` 값 형식일 수 있습니다. 이 경우 `firstArgument` 자동으로 boxed 형식이 있습니다. C# 또는 Visual Basic 함수에서 호출 하는 것 처럼 다른 인수에 대 한 자동 boxing 발생 하지 않습니다.  
  
 하는 경우 `firstArgument` 가 null 참조 하 고 `method` 인스턴스 메서드는 결과 서명이 대리자 형식에 따라 달라 집니다 `type` 및 `method`:  
  
-   경우 서명의 `type` 의 첫 번째 숨겨진된 매개 변수를 명시적으로 포함 `method`, 열려 있는 인스턴스 메서드를 나타내는 대리자 라고 합니다. 대리자가 호출 인수 목록의 첫 번째 인수의 숨겨진된 인스턴스에 매개 변수에 전달 됩니다 `method`합니다.  
  
-   경우 서명을 `method` 및 `type` 일치 (즉, 모든 매개 변수 형식이 호환 되는) 경우 대리자는 null 참조 닫혀 있는 것으로 간주 합니다. 대리자를 호출 하는 것은 그다지 유용한 작업이 수행 되지 않는 null 인스턴스에서 인스턴스 메서드를 호출 비슷합니다.  
  
 하는 경우 `firstArgument` 가 null 참조 하 고 `method` 는 정적 결과에 따라 달라 집니다 서명이 대리자 형식의 `type` 및 `method`:  
  
-   경우 서명의 `method` 및 `type` 일치 (즉, 모든 매개 변수 형식이 호환 되는) 경우 열려 있는 정적 메서드를 나타내는 대리자 라고 합니다. 이것이 정적 메서드에 대 한 가장 일반적인 경우입니다. 사용 하 여 약간 더 나은 성능을 얻을 수는 경우에 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 메서드 오버 로드 합니다.  
  
-   경우 서명의 `type` 의 두 번째 매개 변수를 사용 하 여 시작 `method` 나머지 매개 변수 형식과 호환 되 고 대리자는 null 참조에 대해 닫혀 있는 것으로 간주 합니다. 첫 번째 매개 변수는 null 참조가 전달 되는 대리자를 호출 하는 경우 `method`합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 메서드의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
## <a name="compatible-parameter-types-and-return-type"></a>호환 되는 매개 변수 형식 및 반환 형식  
 매개 변수 형식 및 대리자의 반환 형식은 매개 변수 형식 및 대리자가 나타내는; 메서드의 반환 형식을 사용 하 여 호환 되어야 합니다. 형식을 정확 하 게 일치 하지 않아도 됩니다.  
  
> [!NOTE]
>  .NET framework 버전 1.0 및 1.1에서 형식을 정확 하 게 일치 해야 합니다.  
  
 대리자 매개 변수의 형식이 메서드 매개 변수의 형식보다 제한적인 경우 대리자의 매개 변수는 메서드의 해당 매개 변수와 호환됩니다. 이 경우 대리자로 전달된 인수를 안전하게 메서드로 전달할 수 있습니다.  
  
 마찬가지로 메서드의 반환 형식이 대리자의 반환 형식보다 제한적인 경우 대리자의 반환 형식은 메서드의 반환 형식과 호환됩니다. 이 경우 메서드의 반환 값을 안전하게 대리자의 반환 형식으로 캐스팅할 수 있습니다.  
  
 예를 들어, 형식의 매개 변수를 사용 하 여 대리자 <xref:System.Collections.Hashtable> 의 반환 형식이 <xref:System.Object> 형식의 매개 변수를 사용 하 여 메서드를 나타낼 수 있습니다 <xref:System.Object> 형식의 반환 값 및 <xref:System.Collections.Hashtable>합니다.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>메서드를 결정 하는 대리자 나타낼 수 있습니다.  
 또 다른 유용한 방법은이 오버 로드에서 제공 하는 유연성을 생각할 <xref:System.Delegate.CreateDelegate%2A> 모든 지정 된 대리자 메서드 시그니처 및 메서드 종류 (정적 및 인스턴스)의 4 가지 다른 조합을 나타낼 수 있다는 것입니다. 대리자 형식이 있다고 가정 `D` 인수 형식 중 하나를 사용 하 여 `C`입니다. 다음 방법을 설명 합니다. `D` 항상에서 일치 해야 하므로 반환 형식은 무시 하 고 나타낼 수 있습니다.  
  
-   `D` 형식의 인수를 하나만 있는 모든 인스턴스 메서드를 나타낼 수 있습니다 `C`인스턴스 메서드가 속하는 형식을에 관계 없이 합니다. 때 <xref:System.Delegate.CreateDelegate%2A> 가 호출 `firstArgument` 형식의 인스턴스인 `method` 속한 결과로 얻은 대리자는 해당 인스턴스가 닫혀 있는 것으로 간주 합니다. (일반적으로, `D` 하는 경우 null 참조에 대해 닫을 수도 있습니다 `firstArgument` 가 null 참조입니다.)  
  
-   `D` 인스턴스 메서드를 나타낼 수 있습니다 `C` 는 인수가 없는 합니다. 때 <xref:System.Delegate.CreateDelegate%2A> 가 호출 `firstArgument` 가 null 참조입니다. 결과로 얻은 대리자 열려 있는 인스턴스 메서드를 나타내고 인스턴스의 `C` 는 호출할 때마다 제공 해야 합니다.  
  
-   `D` 형식의 인수 하나를 사용 하는 정적 메서드를 나타낼 수 있습니다 `C`, 및 메서드는 모든 형식에 속할 수 있습니다. 때 <xref:System.Delegate.CreateDelegate%2A> 가 호출 `firstArgument` 가 null 참조입니다. 열려 있는 정적 메서드 및 인스턴스의 결과 대리자가 나타내는 `C` 는 호출할 때마다 제공 해야 합니다.  
  
-   `D` 입력 속한 정적 메서드를 나타낼 수 있습니다 `F` 형식의 두 인수를 포함 하 고 `F` 유형과 `C`합니다. 때 <xref:System.Delegate.CreateDelegate%2A> 가 호출 `firstArgument` 의 인스턴스가 `F`합니다. 결과로 얻은 대리자의 해당 인스턴스에 대해 닫혀 있는 정적 메서드를 나타냅니다. `F`합니다. 대/소문자에서 위치 `F` 및 `C` 동일한 형식은 정적 메서드는 두 인수입니다. (이 예에서 `D` 하는 경우 null 참조에 대해 닫혀 `firstArgument` 가 null 참조입니다.)  
  
   
  
## Examples  
 이 섹션에는 세 가지 코드 예제가 있습니다. 첫 번째 예제에서는 만들 수 있는 대리자의 네 가지 종류: 정적 메서드에 대해 닫은 인스턴스 메서드를 정적 메서드를 통해 열기 인스턴스 메서드를 통해 열기에 대해 닫혀 있습니다.  
  
 두 번째 코드 예제에서는 호환 매개 변수 형식을 보여 줍니다 및 형식을 반환 합니다.  
  
 세 번째 코드 예제에서는 단일 대리자 형식을 정의 하 고 모든 메서드를 대리자 형식을 나타낼 수를 보여 줍니다.  
  
 **예제 1**  
  
 다음 코드 예제에서는이 오버 로드를 사용 하 여 대리자를 만들 수 있습니다 네 가지 방법을 보여 줍니다는 <xref:System.Delegate.CreateDelegate%2A> 메서드.  
  
> [!NOTE]
>  두 개의 오버 로드가 있습니다 합니다 <xref:System.Delegate.CreateDelegate%2A> 메서드를 지정 하는 `firstArgument` 및 <xref:System.Reflection.MethodInfo>; 해당 기능을 바인딩하려는 경우 실패 시 throw 할 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다. 이 코드 예제에서는 두 오버 로드를 사용 합니다.  
  
 이 예제에서는 클래스를 선언 `C` 정적 메서드를 사용 하 여 `M2` 및 인스턴스 메서드 `M1`, 대리자 형식이 세: `D1` 의 인스턴스를 사용 하 `C` 및 문자열 `D2` 문자열, 그리고 `D3`인수가 없습니다.  
  
 두 번째 클래스가 `Example` 는 대리자를 만드는 코드를 포함 합니다.  
  
-   형식의 대리자 `D2`인스턴스에 대해 닫혀 `C`, 인스턴스 메서드가 만들어집니다 `M1`합니다. 바인딩된 인스턴스를 표시 하는 다른 문자열을 사용 하 여 호출 `C` 항상 사용 됩니다.  
  
-   형식의 대리자 `D1`열려 있는 인스턴스 메서드를 나타내는, 인스턴스 메서드 만들어집니다 `M1`합니다. 대리자가 호출 되 면 인스턴스를 전달 되어야 합니다.  
  
-   형식의 대리자 `D2`열려 있는 정적 메서드를 나타내는, 정적 메서드에 대 한 만들어집니다 `M2`합니다.  
  
-   마지막으로, 형식의 대리자 `D3`문자열에 대해 닫혀, 정적 메서드에 대해 생성 됩니다 `M2`합니다. 메서드는 바인딩된 문자열을 사용 하기를 나타내기 위해 호출 됩니다.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **예제 2**  
  
 다음 코드 예제에서는 매개 변수 형식 호환성을 보여 줍니다 및 형식을 반환 합니다.  
  
> [!NOTE]
>  이 코드 예제에서는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 메서드 오버 로드 합니다. 다른 사용 오버 <xref:System.Reflection.MethodInfo> 비슷합니다.  
  
 코드 예제에서는 라는 기본 클래스를 정의 `Base` 라는 클래스 `Derived` 에서 파생 되는 `Base`합니다. 파생된 클래스에는 `static` (`Shared` Visual basic에서) 라는 메서드 `MyMethod` 형식의 매개 변수 하나를 사용 하 여 `Base` 의 반환 형식이 `Derived`합니다. 코드 예제에서는 또한 라는 대리자를 정의 `Example` 형식의 매개 변수 `Derived` 의 반환 형식이 `Base`합니다.  
  
 코드 예제에서는 대리자를 지정 하는 방법을 보여 줍니다 `Example` 메서드를 나타내는 데 사용할 수 있습니다 `MyMethod`합니다. 때문에 메서드를 대리자에 바인딩할 수 있습니다.  
  
-   대리자의 매개 변수 형식 (`Derived`) 매개 변수 형식 보다 더 제한적인 `MyMethod` (`Base`)를 항상 안전 하 게 대리자의 인수를 전달 하는, `MyMethod`합니다.  
  
-   반환 형식은 `MyMethod` (`Derived`) 대리자의 매개 변수 형식 보다 더 제한적인 (`Base`)는 항상 대리자의 반환 형식 메서드의 반환 형식을 캐스팅 하지 않아도 안전 합니다.  
  
 코드 예제에는 출력이 없습니다.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **예제 3**  
  
 다음 코드 예제에서는 메서드를 보여 줍니다 모든 단일 대리자 형식을 사용 하 여 나타낼 수는 <xref:System.Delegate.CreateDelegate%2A> 대리자를 만드는 방법.  
  
> [!NOTE]
>  두 개의 오버 로드가 있습니다 합니다 <xref:System.Delegate.CreateDelegate%2A> 메서드를 지정 하는 `firstArgument` 및 <xref:System.Reflection.MethodInfo>; 해당 기능을 바인딩하려는 경우 실패 시 throw 할 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다. 이 코드 예제에서는 두 오버 로드를 사용 합니다.  
  
 코드 예제에서는 두 개의 클래스를 정의 `C` 하 고 `F`, 및 대리자 형식이 `D` 인수 형식 중 하나를 사용 하 여 `C`입니다. 클래스는 동일한 정적 메서드와 인스턴스 메서드 `M1`, `M3`, 및 `M4`, 및 클래스 `C` 인스턴스 메서드도 있습니다 `M2` 는 인수가 없는 합니다.  
  
 라는 세 번째 클래스 `Example` 는 대리자를 만드는 코드를 포함 합니다.  
  
-   대리자가 인스턴스 메서드 `M1` 형식의 `C` 유형과 `F`; 각 해당 형식의 인스턴스에 대해 닫혀 있습니다. 메서드 `M1` 형식의 `C` 표시는 `ID` 인수 및 바인딩된 인스턴스의 속성입니다.  
  
-   메서드에 대 한 대리자가 만들어진 `M2` 형식의 `C`합니다. 인스턴스 열기 대리자를 대리자의 인수는 인스턴스 메서드에 숨겨진된 첫 번째 인수를 나타내는입니다. 메서드는 다른 인수가 없습니다. 정적 메서드인 것 처럼 호출 됩니다.  
  
-   대리자가 정적 메서드에 대 한 `M3` 형식의 `C` 유형과 `F`; 이러한 대리자는 정적 대리자입니다.  
  
-   마지막으로, 대리자가 정적 메서드 `M4` 형식의 `C` 유형과 `F`각 메서드에 첫 번째 인수로 선언 형식이 고 형식의 인스턴스 제공 되므로 대리자를 해당 인수에 대해 닫혀 . 메서드 `M4` 형식의 `C` 표시는 `ID` 인수 및 바인딩된 인스턴스의 속성입니다.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
또는 
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
또는 
 <paramref name="method" />를 바인딩할 수 없습니다.  
  
또는 
 <paramref name="method" />가 <see langword="RuntimeMethodInfo" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="target">
          <paramref name="method" />가 호출되는 클래스 인스턴스입니다.</param>
        <param name="method">대리자가 나타내는 인스턴스 메서드의 이름입니다.</param>
        <summary>지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 대리자 예를 들어만 메서드를 만듭니다. 클래스의 인스턴스와 연결 된 메서드가 인스턴스 메서드 정적 메서드는 클래스 자체에 연결 되는 메서드.  
  
 이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드를 지정 하 `false` 에 대 한 `ignoreCase` 하 고 `true` 에 대 한 `throwOnBindFailure`합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 메서드의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="target" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
또는 
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
또는 
 <paramref name="method" />는 인스턴스 메서드가 아닙니다.  
  
또는 
 예를 들어 <paramref name="method" />는 찾을 수 없기 때문에 바인딩할 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="method">대리자가 나타내는 정적 또는 인스턴스 메서드를 설명하는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="throwOnBindFailure">
          <paramref name="method" />를 바인딩할 수 없습니다. 예외가 발생하면 <see langword="true" />이고, 예외가 발생하지 않으면 <see langword="false" />입니다.</param>
        <summary>바인딩 실패 시 지정한 동작을 기반으로 지정한 정적 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 정적 메서드를 나타내기 위한 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드를 open 정적 메서드가 대리자를 만드는 인스턴스 메서드가 대리자를 열고-즉, 대리자의 숨겨진된 첫 번째 인수를 노출 하는 인스턴스 메서드. 자세한 내용은 참조는 보다 일반적인 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 정적 메서드 또는 메서드 오버 로드를 예를 들어 모든 조합을 열림 또는 닫힘 대리자를 만들 수 있습니다.  
  
> [!NOTE]
>  이 메서드 오버 로드 때 사용할 대리자의 첫 번째 인수에 대해 닫혀 있지 않으면 이므로 좀 더 빠른 경우.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 메서드의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
## <a name="compatible-parameter-types-and-return-type"></a>호환 되는 매개 변수 형식 및 반환 형식  
 매개 변수 형식 및 대리자의 반환 형식은 매개 변수 형식 및 대리자가 나타내는; 메서드의 반환 형식을 사용 하 여 호환 되어야 합니다. 형식을 정확 하 게 일치 하지 않아도 됩니다.  
  
> [!NOTE]
>  .NET framework 버전 1.0 및 1.1에서 형식을 정확 하 게 일치 해야 합니다.  
  
 대리자 매개 변수의 형식이 메서드 매개 변수의 형식보다 제한적인 경우 대리자의 매개 변수는 메서드의 해당 매개 변수와 호환됩니다. 이 경우 대리자로 전달된 인수를 안전하게 메서드로 전달할 수 있습니다.  
  
 마찬가지로 메서드의 반환 형식이 대리자의 반환 형식보다 제한적인 경우 대리자의 반환 형식은 메서드의 반환 형식과 호환됩니다. 이 경우 메서드의 반환 값을 안전하게 대리자의 반환 형식으로 캐스팅할 수 있습니다.  
  
 예를 들어, 형식의 매개 변수를 사용 하 여 대리자 <xref:System.Collections.Hashtable> 의 반환 형식이 <xref:System.Object> 형식의 매개 변수를 사용 하 여 메서드를 나타낼 수 있습니다 <xref:System.Object> 형식의 반환 값 및 <xref:System.Collections.Hashtable>합니다.  
  
   
  
## Examples  
 이 섹션에는 두 코드 예제가 있습니다. 첫 번째 예제에서는 두 종류의이 메서드 오버 로드를 사용 하 여 만들 수 있는 대리자를 보여 줍니다.: 인스턴스 메서드를 통해 열고 정적 메서드에 대해 엽니다.  
  
 두 번째 코드 예제에서는 호환 매개 변수 형식을 보여 줍니다 및 형식을 반환 합니다.  
  
 **예제 1**  
  
 다음 코드 예제는 두 가지 방법으로이 오버 로드를 사용 하 여 대리자를 만들 수 있습니다는 <xref:System.Delegate.CreateDelegate%2A> 메서드.  
  
> [!NOTE]
>  두 가지 오버 로드의는 <xref:System.Delegate.CreateDelegate%2A> 지정 하는 메서드를 <xref:System.Reflection.MethodInfo> 첫 번째 인수가 아닌; 해당 기능을 바인딩하려는 경우 실패 시 throw 할 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다. 이 코드 예제에서는 두 오버 로드를 사용 합니다.  
  
 클래스를 선언 하는 예제 `C` 정적 메서드를 사용 하 여 `M2` 및 인스턴스 메서드 `M1`, 두 대리자 형식이: `D1` 의 인스턴스를 사용 하 `C` 및 문자열 및 `D2` 문자열을 사용 합니다.  
  
 두 번째 클래스가 `Example` 는 대리자를 만드는 코드를 포함 합니다.  
  
-   형식의 대리자 `D1`열려 있는 인스턴스 메서드를 나타내는, 인스턴스 메서드 만들어집니다 `M1`합니다. 대리자가 호출 되 면 인스턴스를 전달 되어야 합니다.  
  
-   형식의 대리자 `D2`열려 있는 정적 메서드를 나타내는, 정적 메서드에 대 한 만들어집니다 `M2`합니다.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **예제 2**  
  
 다음 코드 예제에서는 매개 변수 형식 호환성을 보여 줍니다 및 형식을 반환 합니다.  
  
> [!NOTE]
>  이 코드 예제에서는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 메서드 오버 로드 합니다. 다른 사용 오버 <xref:System.Reflection.MethodInfo> 비슷합니다.  
  
 코드 예제에서는 라는 기본 클래스를 정의 `Base` 라는 클래스 `Derived` 에서 파생 되는 `Base`합니다. 파생된 클래스에는 `static` (`Shared` Visual basic에서) 라는 메서드 `MyMethod` 형식의 매개 변수 하나를 사용 하 여 `Base` 의 반환 형식이 `Derived`합니다. 코드 예제에서는 또한 라는 대리자를 정의 `Example` 형식의 매개 변수 `Derived` 의 반환 형식이 `Base`합니다.  
  
 코드 예제에서는 대리자를 지정 하는 방법을 보여 줍니다 `Example` 메서드를 나타내는 데 사용할 수 있습니다 `MyMethod`합니다. 때문에 메서드를 대리자에 바인딩할 수 있습니다.  
  
-   대리자의 매개 변수 형식 (`Derived`) 매개 변수 형식 보다 더 제한적인 `MyMethod` (`Base`)를 항상 안전 하 게 대리자의 인수를 전달 하는, `MyMethod`합니다.  
  
-   반환 형식은 `MyMethod` (`Derived`) 대리자의 매개 변수 형식 보다 더 제한적인 (`Base`)는 항상 대리자의 반환 형식 메서드의 반환 형식을 캐스팅 하지 않아도 안전 합니다.  
  
 코드 예제에는 출력이 없습니다.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
또는 
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
또는 
 <paramref name="method" />를 바인딩할 수 없으므로 <paramref name="throwOnBindFailure" />가 <see langword="true" />입니다.  
  
또는 
 <paramref name="method" />가 <see langword="RuntimeMethodInfo" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="target">
          <paramref name="method" />를 구현하는 클래스를 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="method">대리자가 나타내는 정적 메서드의 이름입니다.</param>
        <summary>지정된 클래스의 지정된 정적 메서드를 나타내는 지정된 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 클래스의 지정된 정적 메서드를 나타내는 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 정적 메서드만 대 한 대리자를 만듭니다. 클래스의 인스턴스와 연결 된 메서드가 인스턴스 메서드 정적 메서드는 클래스 자체에 연결 되는 메서드.  
  
 이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드를 지정 하 `false` 에 대 한 `ignoreCase` 하 고 `true` 에 대 한 `throwOnBindFailure`합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 메서드의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="target" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
또는 
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
또는 
 <paramref name="target" />가 <see langword="RuntimeType" />가 아닌 경우  
  
또는 
 <paramref name="target" />이 개방형 제네릭 형식인 경우. 즉, 해당 <see cref="P:System.Type.ContainsGenericParameters" /> 속성이 <see langword="true" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="static" /> 메서드(Visual Basic의 경우 <see langword="Shared" /> 메서드)가 아닌 경우  
  
또는 
 예를 들어 찾을 수 없고 <paramref name="throwOnBindFailure" />가 <see langword="true" />이기 때문에 <paramref name="method" />를 바인딩할 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">만들 디자이너 형식을 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="firstArgument">대리자가 나타내는 메서드의 첫 번째 인수인 <see cref="T:System.Object" />입니다. 인스턴스 메서드의 경우 인스턴스 형식과 호환되어야 합니다.</param>
        <param name="method">대리자가 나타내는 정적 또는 인스턴스 메서드를 설명하는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="throwOnBindFailure">
          <paramref name="method" />를 바인딩할 수 없습니다. 예외가 발생하면 <see langword="true" />이고, 예외가 발생하지 않으면 <see langword="false" />입니다.</param>
        <summary>지정한 첫 번째 인수와 바인딩 실패 시 지정한 동작을 기반으로 지정한 정적 또는 인스턴스 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</summary>
        <returns>지정한 정적 또는 인스턴스 메서드를 나타내는 지정한 형식의 대리자이거나, <paramref name="throwOnBindFailure" />가 <see langword="false" />이고 대리자를 <paramref name="method" />에 바인딩할 수 없으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드 및 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> 메서드 오버 로드를 항상 바인딩 실패 시 throw, 대리자를 만드는 가장 유연한 방법을 제공 합니다. 첫 번째 인수 없이 대리자 중 정적 또는 인스턴스 메서드를 만들려면 사용할 수 있습니다.  
  
> [!NOTE]
>  첫 번째 인수를 제공 하지 않는 경우 사용 된 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 성능 향상을 위해 메서드 오버 로드 합니다.  
  
 대리자 형식 및 메서드의 호환 반환 형식이 있어야 합니다. 반환 형식, 즉 `method` 의 반환 형식에 할당할 수 있어야 `type`합니다.  
  
 하는 경우 `firstArgument` 가 제공에 전달한 `method` 될 때마다 대리자가 호출 됩니다. `firstArgument` 대리자에 바인딩될 것 이라고 대리자는 첫 번째 인수에 대해 닫혀 있는 것으로 간주 합니다. 경우 `method` 은 `static` (`Shared` Visual basic에서)의 경우 대리자를 호출할 때 제공 하는 목록; 첫 번째를 제외한 모든 매개 변수를 포함 하는 인수 `method` 인스턴스 메서드 이면 `firstArgument` 숨겨진 인스턴스에 전달 됩니다 매개 변수 (나타낸 `this` C# 또는 `Me` Visual basic에서).  
  
 경우 `firstArgument` 제공 됩니다의 첫 번째 매개 변수 `method` 는 참조 형식 이어야 하 고 `firstArgument` 해당 형식과 호환 되어야 합니다.  
  
> [!IMPORTANT]
>  경우 `method` 됩니다 `static` (`Shared` Visual Basic에서) 해당 첫 번째 매개 변수는 형식 및 <xref:System.Object> 또는 <xref:System.ValueType>, 다음 `firstArgument` 값 형식일 수 있습니다. 이 경우 `firstArgument` 자동으로 boxed 형식이 있습니다. C# 또는 Visual Basic 함수에서 호출 하는 것 처럼 다른 인수에 대 한 자동 boxing 발생 하지 않습니다.  
  
 하는 경우 `firstArgument` 가 null 참조 하 고 `method` 인스턴스 메서드는 결과 서명이 대리자 형식에 따라 달라 집니다 `type` 및 `method`:  
  
-   경우 서명의 `type` 의 첫 번째 숨겨진된 매개 변수를 명시적으로 포함 `method`, 열려 있는 인스턴스 메서드를 나타내는 대리자 라고 합니다. 대리자가 호출 인수 목록의 첫 번째 인수의 숨겨진된 인스턴스에 매개 변수에 전달 됩니다 `method`합니다.  
  
-   경우 서명을 `method` 및 `type` 일치 (즉, 모든 매개 변수 형식이 호환 되는) 경우 대리자는 null 참조 닫혀 있는 것으로 간주 합니다. 대리자를 호출 하는 것은 그다지 유용한 작업이 수행 되지 않는 null 인스턴스에서 인스턴스 메서드를 호출 비슷합니다.  
  
 하는 경우 `firstArgument` 가 null 참조 하 고 `method` 는 정적 결과에 따라 달라 집니다 서명이 대리자 형식의 `type` 및 `method`:  
  
-   경우 서명의 `method` 및 `type` 일치 (즉, 모든 매개 변수 형식이 호환 되는) 경우 열려 있는 정적 메서드를 나타내는 대리자 라고 합니다. 이것이 정적 메서드에 대 한 가장 일반적인 경우입니다. 사용 하 여 약간 더 나은 성능을 얻을 수는 경우에 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 메서드 오버 로드 합니다.  
  
-   경우 서명의 `type` 의 두 번째 매개 변수를 사용 하 여 시작 `method` 나머지 매개 변수 형식과 호환 되 고 대리자는 null 참조에 대해 닫혀 있는 것으로 간주 합니다. 첫 번째 매개 변수는 null 참조가 전달 되는 대리자를 호출 하는 경우 `method`합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 메서드의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
## <a name="compatible-parameter-types-and-return-type"></a>호환 되는 매개 변수 형식 및 반환 형식  
 매개 변수 형식 및 대리자의 반환 형식은 매개 변수 형식 및 대리자가 나타내는; 메서드의 반환 형식을 사용 하 여 호환 되어야 합니다. 형식을 정확 하 게 일치 하지 않아도 됩니다.  
  
> [!NOTE]
>  .NET Framework 버전 1.0 및 1.1의에서 형식이 정확 하 게 일치 해야 합니다.  
  
 대리자 매개 변수의 형식이 메서드 매개 변수의 형식보다 제한적인 경우 대리자의 매개 변수는 메서드의 해당 매개 변수와 호환됩니다. 이 경우 대리자로 전달된 인수를 안전하게 메서드로 전달할 수 있습니다.  
  
 마찬가지로 메서드의 반환 형식이 대리자의 반환 형식보다 제한적인 경우 대리자의 반환 형식은 메서드의 반환 형식과 호환됩니다. 이 경우 메서드의 반환 값을 안전하게 대리자의 반환 형식으로 캐스팅할 수 있습니다.  
  
 예를 들어, 형식의 매개 변수를 사용 하 여 대리자 <xref:System.Collections.Hashtable> 의 반환 형식이 <xref:System.Object> 형식의 매개 변수를 사용 하 여 메서드를 나타낼 수 있습니다 <xref:System.Object> 형식의 반환 값 및 <xref:System.Collections.Hashtable>합니다.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>메서드를 결정 하는 대리자 나타낼 수 있습니다.  
 또 다른 유용한 방법은이 오버 로드에서 제공 하는 유연성을 생각할 <xref:System.Delegate.CreateDelegate%2A> 모든 지정 된 대리자 메서드 시그니처 및 메서드 종류 (정적 및 인스턴스)의 4 가지 다른 조합을 나타낼 수 있다는 것입니다. 대리자 형식이 있다고 가정 `D` 인수 형식 중 하나를 사용 하 여 `C`입니다. 다음 방법을 설명 합니다. `D` 항상에서 일치 해야 하므로 반환 형식은 무시 하 고 나타낼 수 있습니다.  
  
-   `D` 형식의 인수를 하나만 있는 모든 인스턴스 메서드를 나타낼 수 있습니다 `C`인스턴스 메서드가 속하는 형식을에 관계 없이 합니다. 때 <xref:System.Delegate.CreateDelegate%2A> 가 호출 `firstArgument` 형식의 인스턴스인 `method` 속한 결과로 얻은 대리자는 해당 인스턴스가 닫혀 있는 것으로 간주 합니다. (일반적으로, `D` 하는 경우 null 참조에 대해 닫을 수도 있습니다 `firstArgument` 는 `null`.)  
  
-   `D` 인스턴스 메서드를 나타낼 수 있습니다 `C` 는 인수가 없는 합니다. 때 <xref:System.Delegate.CreateDelegate%2A> 가 호출 `firstArgument` 가 null 참조입니다. 결과로 얻은 대리자 열려 있는 인스턴스 메서드를 나타내고 인스턴스의 `C` 는 호출할 때마다 제공 해야 합니다.  
  
-   `D` 형식의 인수 하나를 사용 하는 정적 메서드를 나타낼 수 있습니다 `C`, 및 메서드는 모든 형식에 속할 수 있습니다. 때 <xref:System.Delegate.CreateDelegate%2A> 가 호출 `firstArgument` 가 null 참조입니다. 열려 있는 정적 메서드 및 인스턴스의 결과 대리자가 나타내는 `C` 는 호출할 때마다 제공 해야 합니다.  
  
-   `D` 입력 속한 정적 메서드를 나타낼 수 있습니다 `F` 형식의 두 인수를 포함 하 고 `F` 유형과 `C`합니다. 때 <xref:System.Delegate.CreateDelegate%2A> 가 호출 `firstArgument` 의 인스턴스가 `F`합니다. 결과로 얻은 대리자의 해당 인스턴스에 대해 닫혀 있는 정적 메서드를 나타냅니다. `F`합니다. 대/소문자에서 위치 `F` 및 `C` 동일한 형식은 정적 메서드는 두 인수입니다. (이 예에서 `D` 하는 경우 null 참조에 대해 닫혀 `firstArgument` 는 `null`.)  
  
   
  
## Examples  
 이 섹션에는 세 가지 코드 예제가 있습니다. 첫 번째 예제에서는 만들 수 있는 대리자의 네 가지 종류: 정적 메서드에 대해 닫은 인스턴스 메서드를 정적 메서드를 통해 열기 인스턴스 메서드를 통해 열기에 대해 닫혀 있습니다.  
  
 두 번째 코드 예제에서는 호환 매개 변수 형식을 보여 줍니다 및 형식을 반환 합니다.  
  
 세 번째 코드 예제에서는 단일 대리자 형식을 정의 하 고 모든 메서드를 대리자 형식을 나타낼 수를 보여 줍니다.  
  
 **예제 1**  
  
 다음 코드 예제에서는이 오버 로드를 사용 하 여 대리자를 만들 수 있습니다 네 가지 방법을 보여 줍니다는 <xref:System.Delegate.CreateDelegate%2A> 메서드.  
  
> [!NOTE]
>  두 개의 오버 로드가 있습니다 합니다 <xref:System.Delegate.CreateDelegate%2A> 메서드를 지정 하는 `firstArgument` 및 <xref:System.Reflection.MethodInfo>; 해당 기능을 바인딩하려는 경우 실패 시 throw 할 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다. 이 코드 예제에서는 두 오버 로드를 사용 합니다.  
  
 이 예제에서는 클래스를 선언 `C` 정적 메서드를 사용 하 여 `M2` 및 인스턴스 메서드 `M1`, 대리자 형식이 세: `D1` 의 인스턴스를 사용 하 `C` 및 문자열 `D2` 문자열, 그리고 `D3`인수가 없습니다.  
  
 두 번째 클래스가 `Example` 는 대리자를 만드는 코드를 포함 합니다.  
  
-   형식의 대리자 `D2`인스턴스에 대해 닫혀 `C`, 인스턴스 메서드가 만들어집니다 `M1`합니다. 바인딩된 인스턴스를 표시 하는 다른 문자열을 사용 하 여 호출 `C` 항상 사용 됩니다.  
  
-   형식의 대리자 `D1`열려 있는 인스턴스 메서드를 나타내는, 인스턴스 메서드 만들어집니다 `M1`합니다. 대리자가 호출 되 면 인스턴스를 전달 되어야 합니다.  
  
-   형식의 대리자 `D2`열려 있는 정적 메서드를 나타내는, 정적 메서드에 대 한 만들어집니다 `M2`합니다.  
  
-   마지막으로, 형식의 대리자 `D3`문자열에 대해 닫혀, 정적 메서드에 대해 생성 됩니다 `M2`합니다. 메서드는 바인딩된 문자열을 사용 하기를 나타내기 위해 호출 됩니다.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **예제 2**  
  
 다음 코드 예제에서는 매개 변수 형식 호환성을 보여 줍니다 및 형식을 반환 합니다.  
  
> [!NOTE]
>  이 코드 예제에서는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 메서드 오버 로드 합니다. 다른 사용 오버 <xref:System.Reflection.MethodInfo> 비슷합니다.  
  
 코드 예제에서는 라는 기본 클래스를 정의 `Base` 라는 클래스 `Derived` 에서 파생 되는 `Base`합니다. 파생된 클래스에는 `static` (`Shared` Visual basic에서) 라는 메서드 `MyMethod` 형식의 매개 변수 하나를 사용 하 여 `Base` 의 반환 형식이 `Derived`합니다. 코드 예제에서는 또한 라는 대리자를 정의 `Example` 형식의 매개 변수 `Derived` 의 반환 형식이 `Base`합니다.  
  
 코드 예제에서는 대리자를 지정 하는 방법을 보여 줍니다 `Example` 메서드를 나타내는 데 사용할 수 있습니다 `MyMethod`합니다. 때문에 메서드를 대리자에 바인딩할 수 있습니다.  
  
-   대리자의 매개 변수 형식 (`Derived`) 매개 변수 형식 보다 더 제한적인 `MyMethod` (`Base`)를 항상 안전 하 게 대리자의 인수를 전달 하는, `MyMethod`합니다.  
  
-   반환 형식은 `MyMethod` (`Derived`) 대리자의 매개 변수 형식 보다 더 제한적인 (`Base`)는 항상 대리자의 반환 형식 메서드의 반환 형식을 캐스팅 하지 않아도 안전 합니다.  
  
 코드 예제에는 출력이 없습니다.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **예제 3**  
  
 다음 코드 예제에서는 단일 대리자 형식이 나타낼 수는 모든 메서드를 보여 줍니다.  
  
> [!NOTE]
>  두 개의 오버 로드가 있습니다 합니다 <xref:System.Delegate.CreateDelegate%2A> 메서드를 지정 하는 `firstArgument` 및 <xref:System.Reflection.MethodInfo>; 해당 기능을 바인딩하려는 경우 실패 시 throw 할 것인지를 지정할 수 있습니다 하나 인수가 있다는 점을 제외 하면 동일 합니다. 이 코드 예제에서는 두 오버 로드를 사용 합니다.  
  
 코드 예제에서는 두 개의 클래스를 정의 `C` 하 고 `F`, 및 대리자 형식이 `D` 인수 형식 중 하나를 사용 하 여 `C`입니다. 클래스는 동일한 정적 메서드와 인스턴스 메서드 `M1`, `M3`, 및 `M4`, 및 클래스 `C` 인스턴스 메서드도 있습니다 `M2` 는 인수가 없는 합니다.  
  
 라는 세 번째 클래스 `Example` 는 대리자를 만드는 코드를 포함 합니다.  
  
-   대리자가 인스턴스 메서드 `M1` 형식의 `C` 유형과 `F`; 각 해당 형식의 인스턴스에 대해 닫혀 있습니다. 메서드 `M1` 형식의 `C` 표시는 `ID` 인수 및 바인딩된 인스턴스의 속성입니다.  
  
-   메서드에 대 한 대리자가 만들어진 `M2` 형식의 `C`합니다. 인스턴스 열기 대리자를 대리자의 인수는 인스턴스 메서드에 숨겨진된 첫 번째 인수를 나타내는입니다. 메서드는 다른 인수가 없습니다.  
  
-   대리자가 정적 메서드에 대 한 `M3` 형식의 `C` 유형과 `F`; 이러한 대리자는 정적 대리자입니다.  
  
-   마지막으로, 대리자가 정적 메서드 `M4` 형식의 `C` 유형과 `F`각 메서드에 첫 번째 인수로 선언 형식이 고 형식의 인스턴스 제공 되므로 대리자를 해당 인수에 대해 닫혀 . 메서드 `M4` 형식의 `C` 표시는 `ID` 인수 및 바인딩된 인스턴스의 속성입니다.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
또는 
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
또는 
 <paramref name="method" />를 바인딩할 수 없으므로 <paramref name="throwOnBindFailure" />가 <see langword="true" />입니다.  
  
또는 
 <paramref name="method" />가 <see langword="RuntimeMethodInfo" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="target">
          <paramref name="method" />가 호출되는 클래스 인스턴스입니다.</param>
        <param name="method">대리자가 나타내는 인스턴스 메서드의 이름입니다.</param>
        <param name="ignoreCase">메서드의 이름을 비교할 때 대/소문자 구분을 무시할지를 나타내는 부울입니다.</param>
        <summary>지정된 대/소문자 구분 여부를 기반으로 지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 대리자 예를 들어만 메서드를 만듭니다. 클래스의 인스턴스와 연결 된 메서드가 인스턴스 메서드 정적 메서드는 클래스 자체에 연결 되는 메서드.  
  
 이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드를 지정 하 `true` 에 대 한 `throwOnBindFailure`합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 메서드의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="target" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
또는 
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
또는 
 <paramref name="method" />는 인스턴스 메서드가 아닙니다.  
  
또는 
 예를 들어 <paramref name="method" />는 찾을 수 없기 때문에 바인딩할 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="target">
          <paramref name="method" />를 구현하는 클래스를 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="method">대리자가 나타내는 정적 메서드의 이름입니다.</param>
        <param name="ignoreCase">메서드의 이름을 비교할 때 대/소문자 구분을 무시할지를 나타내는 부울입니다.</param>
        <summary>지정한 대/소문자 구분 여부를 기반으로 지정한 클래스의 지정한 정적 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 클래스의 지정된 정적 메서드를 나타내는 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 정적 메서드만 대 한 대리자를 만듭니다. 클래스의 인스턴스와 연결 된 메서드가 인스턴스 메서드 정적 메서드는 클래스 자체에 연결 되는 메서드.  
  
 이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드를 지정 하 `true` 에 대 한 `throwOnBindFailure`합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 메서드의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="target" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
또는 
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
또는 
 <paramref name="target" />가 <see langword="RuntimeType" />가 아닌 경우  
  
또는 
 <paramref name="target" />이 개방형 제네릭 형식인 경우. 즉, 해당 <see cref="P:System.Type.ContainsGenericParameters" /> 속성이 <see langword="true" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="static" /> 메서드(Visual Basic의 경우 <see langword="Shared" /> 메서드)가 아닌 경우  
  
또는 
 예를 들어 <paramref name="method" />는 찾을 수 없기 때문에 바인딩할 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="target">
          <paramref name="method" />가 호출되는 클래스 인스턴스입니다.</param>
        <param name="method">대리자가 나타내는 인스턴스 메서드의 이름입니다.</param>
        <param name="ignoreCase">메서드의 이름을 비교할 때 대/소문자 구분을 무시할지를 나타내는 부울입니다.</param>
        <param name="throwOnBindFailure">
          <paramref name="method" />를 바인딩할 수 없습니다. 예외가 발생하면 <see langword="true" />이고, 예외가 발생하지 않으면 <see langword="false" />입니다.</param>
        <summary>지정한 대/소문자 구분과 바인딩 실패 시 지정한 동작을 기반으로 지정한 클래스 인스턴스에서 호출하는 지정한 인스턴스 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 클래스 인스턴스에서 호출하는 지정된 인스턴스 메서드를 나타내는 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 대리자 예를 들어만 메서드를 만듭니다. 클래스의 인스턴스와 연결 된 메서드가 인스턴스 메서드 정적 메서드는 클래스 자체에 연결 되는 메서드.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 메서드의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="target" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
또는 
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
또는 
 <paramref name="method" />는 인스턴스 메서드가 아닙니다.  
  
또는 
 예를 들어 찾을 수 없고 <paramref name="throwOnBindFailure" />가 <see langword="true" />이기 때문에 <paramref name="method" />를 바인딩할 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">만들 대리자의 <see cref="T:System.Type" />입니다.</param>
        <param name="target">
          <paramref name="method" />를 구현하는 클래스를 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="method">대리자가 나타내는 정적 메서드의 이름입니다.</param>
        <param name="ignoreCase">메서드의 이름을 비교할 때 대/소문자 구분을 무시할지를 나타내는 부울입니다.</param>
        <param name="throwOnBindFailure">
          <paramref name="method" />를 바인딩할 수 없습니다. 예외가 발생하면 <see langword="true" />이고, 예외가 발생하지 않으면 <see langword="false" />입니다.</param>
        <summary>지정한 대/소문자 구분과 바인딩 실패 시 지정한 동작을 기반으로 지정한 클래스의 지정한 정적 메서드를 나타내는 지정한 형식의 대리자를 만듭니다.</summary>
        <returns>지정된 클래스의 지정된 정적 메서드를 나타내는 지정된 형식의 대리자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 정적 메서드만 대 한 대리자를 만듭니다. 클래스의 인스턴스와 연결 된 메서드가 인스턴스 메서드 정적 메서드는 클래스 자체에 연결 되는 메서드.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를 호출자에 게 부여 된 경우 public이 아닌 메서드에 액세스 하려면이 메서드를 사용할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 메서드의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="target" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />은 <see cref="T:System.MulticastDelegate" />를 상속하지 않습니다.  
  
또는 
 <paramref name="type" />가 <see langword="RuntimeType" />가 아닌 경우 [리플렉션의 런타임 형식](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)을 참조하세요.  
  
또는 
 <paramref name="target" />가 <see langword="RuntimeType" />가 아닌 경우  
  
또는 
 <paramref name="target" />이 개방형 제네릭 형식인 경우. 즉, 해당 <see cref="P:System.Type.ContainsGenericParameters" /> 속성이 <see langword="true" />인 경우  
  
또는 
 <paramref name="method" />가 <see langword="static" /> 메서드(Visual Basic의 경우 <see langword="Shared" /> 메서드)가 아닌 경우  
  
또는 
 예를 들어 찾을 수 없고 <paramref name="throwOnBindFailure" />가 <see langword="true" />이기 때문에 <paramref name="method" />를 바인딩할 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException">
          <paramref name="type" />의 <see langword="Invoke" /> 메서드를 찾을 수 없습니다.</exception>
        <exception cref="T:System.MethodAccessException">호출자에게 <paramref name="method" />에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">현재 대리자가 나타내는 메서드로 전달할 인수인 개체의 배열입니다.  
  
또는 
 현재 대리자가 나타내는 메서드에 인수가 필요하지 않으면 <see langword="null" />입니다.</param>
        <summary>현재 대리자가 나타내는 메서드를 동적으로 호출(런타임에 바인딩)합니다.</summary>
        <returns>대리자가 나타내는 메서드에서 반환되는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Delegate.DynamicInvokeImpl%2A> 메서드를 호출합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)  
  
또는 
<paramref name="args" />에 열거된 매개 변수의 개수, 순서, 형식이 유효하지 않은 경우</exception>
        <exception cref="T:System.ArgumentException">대리자가 나타내는 메서드가 해당 메서드를 지원하지 않는 개체 또는 클래스에서 호출되는 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">대리자가 나타내는 메서드가 인스턴스 메서드이고 대상 개체가 <see langword="null" />인 경우  
  
또는 
캡슐화된 메서드 중 하나에서 예외를 throw하는 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">현재 대리자가 나타내는 메서드로 전달할 인수인 개체의 배열입니다.  
  
또는 
 현재 대리자가 나타내는 메서드에 인수가 필요하지 않으면 <see langword="null" />입니다.</param>
        <summary>현재 대리자가 나타내는 메서드를 동적으로 호출(런타임에 바인딩)합니다.</summary>
        <returns>대리자가 나타내는 메서드에서 반환되는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Delegate.DynamicInvoke%2A> 메서드를 구현합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)  
  
또는 
<paramref name="args" />에 열거된 매개 변수의 개수, 순서, 형식이 유효하지 않은 경우</exception>
        <exception cref="T:System.ArgumentException">대리자가 나타내는 메서드가 해당 메서드를 지원하지 않는 개체 또는 클래스에서 호출되는 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">대리자가 나타내는 메서드가 인스턴스 메서드이고 대상 개체가 <see langword="null" />인 경우  
  
또는 
캡슐화된 메서드 중 하나에서 예외를 throw하는 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">현재 대리자와 비교할 개체입니다.</param>
        <summary>지정한 개체와 현재 대리자가 같은 형식이고 같은 대상, 메서드 및 호출 목록을 공유하는지를 확인합니다.</summary>
        <returns>
          <paramref name="obj" />와 현재 대리자가 같은 대상, 메서드 및 호출 목록을 가지면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동일한 형식의 두 대리자를 없으면 같은 간주 되지는 않습니다.  
  
> [!IMPORTANT]
>  .NET framework 버전 1.0 및 1.1에서 두 명의 대리자가 다른 형식의 해당 대상, 메서드 및 호출 목록을 같으면 고려 되었습니다.  
  
 메서드 및 대상에 같음에 대 한 다음과 같은 비교 됩니다.  
  
-   비교 되는 두 가지 방법 모두 정적 같은 클래스에 있는 같은 메서드를 메서드는 같다고 간주 됩니다 및 대상도 같다고 간주 됩니다.  
  
-   비교할 두 메서드는 인스턴스 메서드, 동일한 개체의 동일한 메서드에 경우 메서드는 같다고 간주 됩니다 및 대상도 같다고 간주 됩니다.  
  
-   이 고, 그렇지 메서드 같다고 간주 되지 않습니다 및 대상도 하다 고 간주 되지 같아야 합니다.  
  
 동일한 순서 있는 메서드 및 대상이 동일한 두 목록의 해당 요소가 나타내는 경우에 두 호출 목록은 동일한 것으로 간주 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>대리자의 해시 코드를 반환합니다.</summary>
        <returns>대리자의 해시 코드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드의 반환 값을 두 가지 이유로 유지 되지 해야 합니다. 먼저 이전 해시 함수에서 값을 쓸모 향상 된 분포를 생성 하려면 클래스의 해시 함수를 변경할 수 있습니다. 둘째,이 클래스의 기본 구현은 동일한 값이 서로 다른 인스턴스에서 반환 될을 보장 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>대리자의 호출 목록을 반환합니다.</summary>
        <returns>현재 대리자의 호출 목록을 나타내는 대리자의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배열의 각 대리자는 정확히 하나의 메서드를 나타냅니다.  
  
 배열의 대리자의 순서가 현재 대리자가 해당 대리자가 나타내는 메서드를 호출 하는 순서와 동일 합니다.  
  
   
  
## Examples  
 다음 예제에서는 대리자에 세 가지 메서드를 할당합니다. 그런 다음 호출 하는 <xref:System.Delegate.GetInvocationList%2A> "File" 대리자를 역순으로 실행 하 고 이름이 부분 문자열이 없는 메서드를 실행 하는 대리자에 할당할 메서드의 총 개수를 가져올 방법입니다.  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 대리자가 나타내는 정적 메서드를 가져옵니다.</summary>
        <returns>현재 대리자가 나타내는 정적 메서드를 설명하는 <see cref="T:System.Reflection.MethodInfo" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 대리자가 나타내는 정적 메서드의 경우에 적용 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">지원되지 않습니다.</param>
        <param name="context">지원되지 않습니다.</param>
        <summary>지원되지 않습니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 지원되지 않습니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>대리자가 나타내는 메서드를 가져옵니다.</summary>
        <value>대리자가 나타내는 메서드를 설명하는 <see cref="T:System.Reflection.MethodInfo" />입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">비교할 첫째 대리자입니다.</param>
        <param name="d2">비교할 둘째 대리자입니다.</param>
        <summary>지정된 대리자가 같은지를 확인합니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="d1" />와 같으면 <paramref name="d2" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 같은 대상, 메서드 및 호출 목록을 가진 같은 형식의 두 대리자는 같은 것으로 간주 됩니다.  
  
 동일한 형식의 두 대리자를 없으면 같은 간주 되지는 않습니다.  
  
> [!IMPORTANT]
>  .NET framework 버전 1.0 및 1.1에서 두 명의 대리자가 다른 형식의 해당 대상, 메서드 및 호출 목록을 같으면 고려 되었습니다.  
  
 메서드 및 대상에 같음에 대 한 다음과 같은 비교 됩니다.  
  
-   비교 되는 두 가지 방법 모두 정적 같은 클래스에 있는 같은 메서드를 메서드는 같다고 간주 됩니다 및 대상도 같다고 간주 됩니다.  
  
-   비교할 두 메서드는 인스턴스 메서드, 동일한 개체의 동일한 메서드에 경우 메서드는 같다고 간주 됩니다 및 대상도 같다고 간주 됩니다.  
  
-   이 고, 그렇지 메서드 같다고 간주 되지 않습니다 및 대상도 하다 고 간주 되지 같아야 합니다.  
  
 두 호출 목록은 순서 같고 메서드 및 대상이 동일한 두 목록의 해당 요소가 나타내는 같다고 간주 됩니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">비교할 첫째 대리자입니다.</param>
        <param name="d2">비교할 둘째 대리자입니다.</param>
        <summary>지정된 대리자가 다른지를 확인합니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="d1" />와 다르면 <paramref name="d2" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 두 명의 대리자는 것으로 간주 하거나 다양 한 방법, 다양 한 대상에 또는 다른 호출 목록을 가지 서로 다른 형식의 경우.  
  
 동일한 형식의 두 대리자를 없으면 같은 간주 되지는 않습니다.  
  
> [!IMPORTANT]
>  .NET framework 버전 1.0 및 1.1에서 두 대리자는 서로 다른 형식의 해당 대상, 메서드 및 호출 목록을 같으면 간주 됩니다.  
  
 메서드 및 대상에 같음에 대 한 다음과 같은 비교 됩니다.  
  
-   비교 되는 두 가지 방법 모두 정적 같은 클래스에 있는 같은 메서드를 메서드는 같다고 간주 됩니다 및 대상도 같다고 간주 됩니다.  
  
-   비교할 두 메서드는 인스턴스 메서드, 동일한 개체의 동일한 메서드에 경우 메서드는 같다고 간주 됩니다 및 대상도 같다고 간주 됩니다.  
  
-   이 고, 그렇지 메서드 같다고 간주 되지 않습니다 및 대상도 하다 고 간주 되지 같아야 합니다.  
  
 다르게 정렬 하는 경우 다양 한 크기가는 경우 또는 메서드 또는 다른 목록의 해당 요소가 나타내는 다른 대상 하나 목록에서 하나 이상의 요소를 나타내는 경우에 호출 목록을 가지 두은 같지 않습니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">
          <paramref name="value" />의 호출 목록을 제거하는 대리자입니다.</param>
        <param name="value">
          <paramref name="source" />의 호출 목록에서 제거할 호출 목록을 제공하는 대리자입니다.</param>
        <summary>한 대리자의 호출 목록에 있는 마지막 항목을 다른 대리자의 호출 목록에서 제거합니다.</summary>
        <returns>
          <paramref name="source" />의 호출 목록이 <paramref name="value" />의 호출 목록에 있는 경우, <paramref name="value" />의 호출 목록을 가져오고 <paramref name="source" />의 호출 목록에 있는 마지막 항목을 제거해서 만들어진 호출 목록을 가진 새로운 대리자입니다. <paramref name="source" />가 <see langword="null" />이거나 <paramref name="value" />의 호출 목록이 <paramref name="value" />의 호출 목록에 없는 경우 <paramref name="source" />를 반환합니다. <paramref name="value" />의 호출 목록이 <paramref name="source" />의 호출 목록과 같거나 <paramref name="source" />가 null 참조인 경우 null 참조를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우의 호출 목록이 `value` 연속 호출 목록에서 요소 집합을 매칭합니다 `source`, 다음의 호출 목록이 `value` 의 호출 목록 내에서 발생 한다고 `source`. 하는 경우의 호출 목록이 `value` 의 호출 목록에서 두 번 이상 발생 `source`, 마지막으로 제거 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</exception>
        <exception cref="T:System.ArgumentException">대리자 형식이 일치하지 않는 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">
          <paramref name="value" />의 호출 목록을 제거하는 대리자입니다.</param>
        <param name="value">
          <paramref name="source" />의 호출 목록에서 제거할 호출 목록을 제공하는 대리자입니다.</param>
        <summary>한 대리자의 호출 목록에 있는 모든 항목을 다른 대리자의 호출 목록에서 제거합니다.</summary>
        <returns>
          <paramref name="source" />의 호출 목록이 <paramref name="value" />의 호출 목록에 있는 경우, <paramref name="value" />의 호출 목록을 가져오고 <paramref name="source" />의 호출 목록에 있는 모든 항목을 제거해서 만들어진 호출 목록을 가진 새로운 대리자입니다. <paramref name="source" />가 <see langword="null" />이거나 <paramref name="value" />의 호출 목록이 <paramref name="value" />의 호출 목록에 없는 경우 <paramref name="source" />를 반환합니다. <paramref name="value" />의 호출 목록이 <paramref name="source" />의 호출 목록과 같거나 <paramref name="source" />에 <paramref name="value" />의 호출 목록과 같은 일련의 호출 목록만 있거나 <paramref name="source" />가 null 참조인 경우 null 참조를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우의 호출 목록이 `value` 연속 호출 목록에서 요소 집합을 매칭합니다 `source`, 다음의 호출 목록이 `value` 의 호출 목록 내에서 발생 한다고 `source`. 하는 경우의 호출 목록이 `value` 의 호출 목록에서 두 번 이상 발생 `source`, 모든 항목이 제거 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</exception>
        <exception cref="T:System.ArgumentException">대리자 형식이 일치하지 않는 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">현재 대리자의 호출 목록에서 제거할 호출 목록을 제공하는 대리자입니다.</param>
        <summary>한 대리자의 호출 목록을 다른 대리자의 호출 목록에서 제거합니다.</summary>
        <returns>
          <paramref name="value" />의 호출 목록이 현재 대리자의 호출 목록에 있는 경우, 현재 대리자의 호출 목록을 가져오고 <paramref name="value" />의 호출 목록을 제거해서 만들어진 호출 목록을 가진 새로운 대리자입니다. <paramref name="value" />가 <see langword="null" />이거나 <paramref name="value" />의 호출 목록이 현재 대리자의 호출 목록에 없는 경우 현재 대리자를 반환합니다. <paramref name="value" />의 호출 목록이 현재 대리자의 호출 목록과 같으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우의 호출 목록이 `value` 의 호출 목록이 현재 대리자의 호출 목록에 요소 집합과 연속 일치 `value` 현재 대리자의 호출 목록 내에서 발생 한다고 합니다. 하는 경우의 호출 목록이 `value` 두 번 이상 발생 현재 대리자의 호출 목록에서 마지막으로 제거 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">호출자에게 대리자가 나타내는 메서드에 대한 액세스 권한이 없는 경우(예를 들어 메서드가 private인 경우)</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 대리자가 인스턴스 메서드를 호출하는 클래스 인스턴스를 가져옵니다.</summary>
        <value>대리자가 인스턴스 메서드를 나타내는 경우 현재 대리자가 인스턴스 메서드를 호출하는 개체이고, 대리자가 정적 메서드를 나타내는 경우 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스의 인스턴스와 연결 된 메서드가 인스턴스 메서드 정적 메서드는 클래스 자체에 연결 되는 메서드.  
  
 하나 이상의 인스턴스 메서드를 호출 하는 대리자 호출 목록에서 마지막 인스턴스 메서드의 대상이이 속성에 반환 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>