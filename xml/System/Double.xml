<Type Name="Double" FullName="System.Double">
  <Metadata><Meta Name="ms.openlocfilehash" Value="716fa381c88651fb2acad8c2ecb941f2bc21dc8d" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58713760" /></Metadata><TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IConvertible, IEquatable(Of Double), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>배정밀도 부동 소수점 숫자를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Double> 값 형식은 음수 1.79769313486232e308부터 양수 또는 음수 0, 뿐만 아니라 양수 1.79769313486232e308 범위의 값을 사용 하 여 배정밀도 64 비트 숫자를 나타냅니다 <xref:System.Double.PositiveInfinity>, <xref:System.Double.NegativeInfinity>, 및 (not-a-number<xref:System.Double.NaN>). (예: 행성 또는 은하계 간 거리) 매우 큰 수 또는 매우 작은 (킬로그램에서 물질의 분자 mass)와 종종 는지 않습니다 (예: 지구 까지의 거리 다른 태양계), 정확한 값을 나타내는 것은 <xref:System.Double> 형식은 IEC 60559: 1989 (IEEE 754) 이진 부동 소수점 연산에 대 한 표준 준수 합니다.  
  
 이 항목은 다음 섹션으로 구성되어 있습니다.  
  
-   [부동 소수점 표현 및 전체 자릿수](#Precision)  
  
-   [같음에 대 한 테스트](#Equality)  
  
-   [부동 소수점 값 및 예외](#Exceptions)  
  
-   [형식 변환 및 Double 구조체](#Conversions)  
  
-   [부동 소수점 기능](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>부동 소수점 표현 및 전체 자릿수  
 <xref:System.Double> 데이터 형식은 다음 표에 나와 있는 것 처럼 이진 형식으로 64 비트 배정밀도 부동 소수점 값을 저장 합니다.  
  
|파트|비트|  
|----------|----------|  
|기호나 유효 숫자 또는 수|0-51|  
|지 수|52-62|  
|로그인 (0 = 1 양수, 음수 =)|63|  
  
 소수 일부 소수 자릿수 값을 정확 하 게 표현할 수 없는 경우와 마찬가지로 (1/3 같은 또는 <xref:System.Math.PI?displayProperty=nameWithType>), 이진 분수 일부 소수 자릿수 값을 나타내는 수. 예를 들어, 1/10, 소수 부분으로.1에서 정확 하 게 표현 되는 패턴 "0011" 반복으로 무한대로 사용 하 여 이진 소수로.001100110011으로 표시 됩니다. 이 경우 부동 소수점 값에는 표시 되는 개수는 정확 하지 않은 표현을 제공 합니다. 추가 수치 연산은 원래 부동 소수점 값을 자주 수행 정밀도 부족 증가 하는 경향이 있습니다. 예를 들어,.1에서 10을 곱한 결과 비교 하 고.1을.1 9 번에 추가할 것을 볼는 또한 8 더 많은 작업 관련에 있기 때문 경우 덜 정확한 결과 생성 했습니다. 이 차이로 인해는 두 개의 표시 하는 경우에 그렇습니다 <xref:System.Double> "R"을 사용 하 여 값 [표준 숫자 서식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md)는 필요한 지 자릿수 17 자리를 모두 표시 하는 경우는 <xref:System.Double> 형식입니다.  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 일부 숫자는 소수 이진 값으로 정확히 나타낼 수 없는, 때문에 대략적인 실수 부동 소수점 숫자에 수 있습니다.  
  
 모든 부동 소수점 숫자에는 또한 제한 된 수의 유효 자릿수도 부동 소수점 값을 근사치 실수를 계산 하는 얼마나 정확한 지를 결정 하는 경우   <xref:System.Double> 값에 최대 15 개의 10 진수 자리의 정밀도 내부적으로 최대 17 자리가 유지 합니다. 즉, 부동 소수점 연산 부동 변경 하려면 전체 자릿수를 없는 경우도 점 값입니다. 다음 예제에서 이에 대해 설명합니다. 매우 큰 부동 소수점 값을 정의 하 고 추가한 다음 제품의 <xref:System.Double.Epsilon?displayProperty=nameWithType> 및 1, 000 조 되도록 합니다. 그러나 제품에는 원래 부동 소수점 값을 수정 하려면 너무 작습니다. 반면 제품의 최대 유효 자릿수는 10 최하위 해당 숫자는 1/1000 초<sup>-309</sup>합니다.  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 제한 된 정밀도 부동 소수점 숫자의 몇 가지 결과가 발생 합니다.  
  
-   특정 전체 자릿수에서 동일 하 게 나타나는 두 부동 소수점 숫자 수 비교 하 여 같지 최소 유효 자릿수가 다르므로 합니다. 다음 예제에서는 일련의 숫자를 더한 하 고 해당 합계는 예상 되는 전체를 사용 하 여 비교 됩니다. 마찬가지로 호출 될 것으로 나타나지만 두 값을 `Equals` 메서드 않은지를 나타냅니다.  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     형식 항목을 변경 하는 경우는 <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> 에서 문을 `{0}` 및 `{1}` 하 `{0:R}` 및 `{1:R}` 두 유효 자릿수가 모두 표시 하려면 <xref:System.Double> 값 라는 사실은 의심할 두 값이 같지 않은지 때문에 또한 작업 중 전체 자릿수의 손실입니다. 이 경우 호출 하 여 문제를 해결할 수 있습니다 합니다 <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> 반올림할 메서드는 <xref:System.Double> 비교를 수행 하기 전에 원하는 정밀도 값입니다.  
  
-   부동 소수점 숫자를 사용 하는 수치 또는 비교 작업을 생성 하지 동일한 결과 10 진수를 사용 하는 경우 이진 부동 소수점 숫자는 10 진수과 같지 않을 때문입니다. 앞의 예제는이.1 시간을 추가 하 고.1에서 10을 곱한 결과 표시 하 여 보여 줍니다.  
  
     소수 자릿수 값을 사용 하 여 숫자 작업의 정확도 중요 한 경우 사용할 수는 <xref:System.Decimal> 대신 <xref:System.Double> 형식입니다. 때 범위를 벗어난 정수 값을 사용 하 여 숫자 작업의 정확도 <xref:System.Int64> 또는 <xref:System.UInt64> 사용 하 여 형식을 반드시는 <xref:System.Numerics.BigInteger> 형식입니다.  
  
-   값에 부동 소수점 숫자가 포함 된 경우 라운드트립되지 않을 수 있습니다. 작업이 다른 폼에는 원래 부동 소수점 숫자를 변환, 역 작업이 변환 된 폼 부동 소수점 숫자로 다시 변환 및 최종 부동 소수점 숫자가 원래 같지 않은 경우 값을 라운드트립 하 라고 부동 소수점 수입니다. 하나 이상의 최소 유효 자릿수가 손실 되거나 변환에서 변경 때문에 대 한 왕복은 실패할 수 있습니다. 다음 예제에서는 세 가지 <xref:System.Double> 값을 문자열로 변환 되 고 파일에 저장 합니다. 하지만 결과 같이, 값을 동일 하 게 표시 하는 경우에 복원 된 값을 원래 값과 같지 않습니다.  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     이 경우에 값은 성공적으로 라운드트립 "G17"를 사용 하 여 [표준 숫자 서식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 의 전체 자릿수를 유지 하기 위해 <xref:System.Double> 다음 예제와 같이 값입니다.  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  와 함께 사용할 경우는 <xref:System.Double> 값, 일부 경우에 "R" 서식 지정자는 원래 값을 성공적으로 라운드트립 실패 합니다. 되도록 <xref:System.Double> "G17" 형식 지정자를 사용 하는 값 성공적으로 라운드트립 합니다.

-   <xref:System.Single> 값에 보다 적은 전체 자릿수가 <xref:System.Double> 값입니다. A <xref:System.Single> 겉보기 해당 하는 변환 된 값 <xref:System.Double> 종종와 같지 않습니다는 <xref:System.Double> 값 정밀도에 차이가 있기 때문입니다. 다음 예제에서는 동일한 나누기 작업의 결과에 할당 되는 <xref:System.Double> 및 <xref:System.Single> 값입니다. 후 합니다 <xref:System.Single> 값으로 캐스팅 됩니다는 <xref:System.Double>, 두 값의 비교는 서로 다른 지 보여 줍니다.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     이 문제를 방지 하려면 하나를 사용 합니다 <xref:System.Double> 대신를 <xref:System.Single> 데이터 형식 또는 사용 하 여는 <xref:System.Math.Round%2A> 메서드 값이 모두 동일한 전체 자릿수를 갖도록 합니다.  
  
 또한 사용 하 여 산술 연산 및 할당 작업의 결과 <xref:System.Double> 값이 다른 약간 플랫폼에서의 정밀도 손실로 인해는 <xref:System.Double> 형식입니다. 예를 들어, 리터럴을 할당 하는 결과 <xref:System.Double> 값 32 비트 및 64 비트 버전의.NET Framework에서 다를 수 있습니다. 다음 예제에서는이 때 그 차이 리터럴 값-4.42330604244772 e-값인-4.42330604244772 e 변수와 305-305에 할당 된는 <xref:System.Double> 변수입니다. 결과 <xref:System.Double.Parse%28System.String%29> 메서드가 경우 정밀도 손실에서 발생 하지 않습니다.  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>같음에 대 한 테스트  
 값이 같고 간주 되기 위해 두 <xref:System.Double> 값에 동일한 값을 나타내야 합니다. 그러나 정밀도 값 차이로 인해 또는 하나 또는 두 값에 따라 정밀도 손실 때문에 종종 동일한 것으로 예상 되는 부동 소수점 값 판명 최소 유효 자릿수가에 차이가 있으므로 동일 하지 않은 것입니다. 결과적으로, 호출을 <xref:System.Double.Equals%2A> 두 값이 같은지를 확인 하는 메서드 또는 호출을 <xref:System.Double.CompareTo%2A> 간 관계를 결정 하는 방법 <xref:System.Double> 값에는 종종 예기치 않은 결과가 발생할 합니다. 이 다음 예제에서 분명 한 두 개 보이는 같아야 <xref:System.Double> 낮으므로 첫 번째 15 자리의 전체 자릿수를 두 번째는 17 같지 않은 것으로 판명 된 값입니다.  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 계산 된 값을 서로 다른 코드 경로 따르는 및 종종 서로 다른 방식으로 조작 하는 같지 않은 것으로 입증 합니다. 다음 예제에서는 하나의 <xref:System.Double> 값, 값을 제곱 하 고 원래 값을 복원 하기 위해 제곱근 계산 되는 다음입니다. 두 번째 <xref:System.Double> 3.51으로 곱하고 원래 값을 복원 하는 3.51 나눈 결과의 제곱근 전에 제곱 됩니다. 두 값을 동일 하 게 표시 되지만 호출 된 <xref:System.Double.Equals%28System.Double%29> 메서드는 서로 다른 지를 나타냅니다. 두 번째 값.0000000000001 임을 보여주고 "R" 표준 서식 문자열을 사용 하 여 각 Double 값의 모든 유효 자릿수가 표시 하는 결과 문자열을 반환 하도록 첫 번째 미만입니다.  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 비교의 결과 영향을 줄 가능성이 높은 정밀도 손실 인 경우에 호출 하는 다음 방법 중 하나 채택할 수 있습니다 합니다 <xref:System.Double.Equals%2A> 또는 <xref:System.Double.CompareTo%2A> 메서드:  
  
-   호출 된 <xref:System.Math.Round%2A?displayProperty=nameWithType> 값이 모두 동일한 전체 자릿수를 갖도록 하는 방법입니다. 다음 예제에서는 두 소수 자릿수 값이 같으면 되도록이 방법을 사용 하려면 앞의 예제를 수정 합니다.  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     Note, 그러나 자릿수 문제 중간점 값이 반올림에 계속 적용 되도록 합니다. 자세한 내용은 <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType> 메서드를 참조하세요.  
  
-   대략적인 같음 테스트를 일치 하는 대신 합니다. 이렇게 하려면 절대 중 하나를 정의 하는 크기는 두 값 수 다르지만 여전히 같아야 또는 더 작은 값을 더 큰 값에서 분기 수는 상대 크기를 정의 하는 합니다.  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType> 두 거리에 대 한 절대 수단으로 사용 하는 경우도 <xref:System.Double> 값 일치 여부를 테스트 하는 경우.  그러나 <xref:System.Double.Epsilon?displayProperty=nameWithType> 를 추가 하거나에서 뺄 수 있는 가장 작은 가능한 값을 측정 한 <xref:System.Double> 값이 0 인 합니다. 대부분의 양수 및 음수 <xref:System.Double> 값, 값 <xref:System.Double.Epsilon?displayProperty=nameWithType> 검색할 하기에 너무 작습니다. 따라서 크기가 0 인 값을 제외 하 고 바람직하지 않습니다 같은지 여부를 테스트에 사용 합니다.  
  
     다음 예제에서는 후자의 방법을 사용 하 여 정의 `IsApproximatelyEqual` 두 값 간의 상대적 차이 테스트 하는 메서드. 에 대 한 호출의 결과 또한 대조 합니다 `IsApproximatelyEqual` 메서드 및 <xref:System.Double.Equals%28System.Double%29> 메서드.  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>부동 소수점 값 및 예외  
 정수 계열 형식의 경우 0으로 오버플로 또는 나누기와 같은 잘못 된 작업의 경우에서 예외를 throw, 작업과 달리 부동 소수점 값을 사용 하 여 작업 예외를 throw 하지 않습니다. 대신 예외 상황 부동 소수점 연산의 결과 0, 양의 무한대, 음의 무한대 또는 (nan 숫자가) 숫자가 아님:  
  
-   부동 소수점 연산의 결과가 너무 작아서 대상 형식에 대 한 인 경우 결과 0입니다. 다음 예제와 같이 두 가지 매우 작은 수를 곱할 때 발생할 수 있습니다.  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   작업의 결과 대상 형식의 범위를 초과 하는 부동 소수점 연산 결과의 크기가 <xref:System.Double.PositiveInfinity> 또는 <xref:System.Double.NegativeInfinity>, 결과의 부호에 적합 하 게 합니다. 오버플로 하는 작업의 결과 <xref:System.Double.MaxValue?displayProperty=nameWithType> 은 <xref:System.Double.PositiveInfinity>, 및를 오버플로 하는 작업의 결과 <xref:System.Double.MinValue?displayProperty=nameWithType> 는 <xref:System.Double.NegativeInfinity>다음 예제와 같이 합니다.  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity> 또한 양의 피제수를 사용 하 여 0으로 나누기에서 결과 및 <xref:System.Double.NegativeInfinity> 음수 피제수를 사용 하 여 0으로 나누기에서 발생 합니다.  
  
-   작업의 결과 부동 소수점 연산 올바르지 않으면 <xref:System.Double.NaN>합니다. 예를 들어 <xref:System.Double.NaN> 는 다음 작업에서 발생 합니다.  
  
    -   0 피제수를 사용 하 여 0으로 나누었습니다. 참고에서 결과 0으로 나누기의 경우 다른 <xref:System.Double.PositiveInfinity> 또는 <xref:System.Double.NegativeInfinity>합니다.  
  
-   잘못 된 입력을 사용 하 여 모든 부동 소수점 작업입니다. 예를 들어 호출를 <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> 음수 값을 가진 메서드가 반환 <xref:System.Double.NaN>호출와 마찬가지로는 <xref:System.Math.Acos%2A?displayProperty=nameWithType> 개 이하의 보다 크면 음수 1 하는 값을 사용 하 여 메서드.  
  
-   값이 인수를 사용 하 여 모든 작업 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>형식 변환 및 Double 구조체  
 <xref:System.Double> 구조는 모든 명시적 또는 암시적 변환 연산자를 정의 하지 않습니다; 대신 변환 컴파일러에 의해 구현 됩니다.  
  
 모든 기본 숫자 유형 값의 변환이 <xref:System.Double> 확대 변환 하 고 따라서 있고이 명시적 캐스트 연산자는 컴파일러에서 명시적으로 필요한 경우가 아니면 변환 메서드를 호출 합니다. C# 컴파일러에서 변환에 대 한 캐스팅 연산자를 요구 하는 예를 들어 <xref:System.Decimal> 에 <xref:System.Double>반면 Visual Basic 컴파일러는 하지 않습니다. 다음 예제에서는 다른 기본 숫자 형식의 최소값 또는 최대값 값 변환 된 <xref:System.Double>합니다.  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 또한 합니다 <xref:System.Single> 값 <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, 및 <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> 에 변환 <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, 및 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>각각.  
  
 일부 숫자 형식의 값을 변환 된 <xref:System.Double> 값 정밀도 손실 될 수 있습니다. 변환할 때 정밀도 손실 불가능 예제와 같이 <xref:System.Decimal>, <xref:System.Int64>를 <xref:System.Single>, 및 <xref:System.UInt64> 값을 <xref:System.Double> 값입니다.  
  
 변환 된 <xref:System.Double> 값을 다른 기본 숫자 데이터 형식의 값은 축소 변환 하며 캐스트 연산자 (C#에서), (Visual Basic의 경우)의 변환 메서드 호출이 나를 <xref:System.Convert> 메서드. 대상 형식에 의해 정의 된 대상 데이터 형식의 범위를 벗어나는 값 `MinValue` 고 `MaxValue` 속성을 다음 표에 나와 있는 것 처럼 동작 합니다.  
  
|대상 형식|결과|  
|-----------------|------------|  
|모든 정수 형식|<xref:System.OverflowException> 변환 확인 된 컨텍스트에서 발생 하는 경우는 예외입니다.<br /><br /> 변환이 변환 작업은 성공 하지만 값이 오버플로되면 (C#의 기본값), unchecked 컨텍스트에서 발생 합니다.|  
|<xref:System.Decimal>|<xref:System.OverflowException> 예외입니다.|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType> 음수 값입니다.<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> 양수 값입니다.|  
  
 또한 <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, 및 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> throw는 <xref:System.OverflowException> checked 컨텍스트에서 있지만 unchecked 컨텍스트에서 정수로 변환 하는 경우 이러한 값 오버플로 정수로 변환 합니다. 로 변환을 <xref:System.Decimal>, 항상 throw는 <xref:System.OverflowException>합니다. 로 변환을 <xref:System.Single>를 변환할 <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, 및 <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, 각각.  
  
 정밀도 손실 변환에서 발생할 수 있는 참고를 <xref:System.Double> 값을 다른 숫자 형식입니다. 비정 변환의 경우 <xref:System.Double> 값을 예제의 출력에서 볼 수 있듯이 소수 손실 되는 경우는 <xref:System.Double> 값은 반올림 됩니다 (예: Visual Basic) 또는 (예: C#) 잘립니다. 로 변환을 <xref:System.Decimal> 하 고 <xref:System.Single> 값을는 <xref:System.Double> 값이 정확한 표시 대상 데이터 형식에 없을 수도 있습니다.  
  
 다음 예제에서는 다양 한 변환 <xref:System.Double> 값을 다른 여러 숫자 형식입니다. Visual Basic (기본값) 및 C#의 checked 컨텍스트에서 변환이 발생할 (때문에 합니다 [체크](~/docs/csharp/language-reference/keywords/checked.md) 키워드). 예제의 출력에서 선택 된 변환에 대 한 결과 보여 줍니다. unchecked 컨텍스트. 사용 하 여 컴파일하면 Visual Basic에서는 unchecked 컨텍스트에서 변환을 수행할 수 있습니다 합니다 `/removeintchecks+` 컴파일러 스위치 및 C# 주석는 `checked` 문입니다.  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 숫자 형식 변환에 대 한 자세한 내용은 참조 하세요. [.NET Framework의 형식 변환](~/docs/standard/base-types/type-conversion.md) 하 고 [형식 변환 표](~/docs/standard/base-types/conversion-tables.md)합니다.  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>부동 소수점 기능  
 <xref:System.Double> 구조 및 관련된 형식은 다음 영역에서 작업을 수행 하는 메서드를 제공 합니다.  
  
-   **값 비교**합니다. 호출할 수 있습니다 합니다 <xref:System.Double.Equals%2A> 두 여부를 확인 하는 방법 <xref:System.Double> 값이 같으면 또는 <xref:System.Double.CompareTo%2A> 두 값 간의 관계를 확인 하는 방법입니다.  
  
     <xref:System.Double> 구조는 또한 비교 연산자의 전체 집합을 지원 합니다. 예를 들어 같음 또는 같지 않음을 테스트할 수도 있고 하나의 값 보다 크거나 같은 다른 인지 확인할 수 있습니다. 피연산자 중 하나는 숫자 이외의 형식인 경우는 <xref:System.Double>를 변환할를 <xref:System.Double> 비교를 수행 하기 전에 합니다.  
  
    > [!WARNING]
    >  전체 자릿수의 차이로 인해 두 <xref:System.Double> 간주 해야 하는 값 수 그런데 같지 않은 것 비교의 결과 영향을 합니다. 참조 된 [같은지 테스트](#Equality) 두 개를 비교 하는 방법에 대 한 자세한 내용은 섹션 <xref:System.Double> 값입니다.  
  
     호출할 수도 있습니다는 <xref:System.Double.IsNaN%2A>, <xref:System.Double.IsInfinity%2A>를 <xref:System.Double.IsPositiveInfinity%2A>, 및 <xref:System.Double.IsNegativeInfinity%2A> 이러한 특수 한 값을 테스트 하는 방법입니다.  
  
-   **수학 연산을**합니다. 더하기, 빼기, 곱하기 및 나누기 등의 일반적인 산술 연산으로 언어 컴파일러 및 중간 언어 (CIL (공용) 지침을 대신 하 여 구현 됩니다 <xref:System.Double> 메서드. 수학 연산에서 피연산자 중 하나는 숫자 이외의 형식인 경우는 <xref:System.Double>를 변환할를 <xref:System.Double> 작업을 수행 하기 전에 합니다. 작업의 결과 이기도 한 <xref:System.Double> 값입니다.  
  
     기타 수학 연산을 호출 하 여 수행할 수 있습니다 `static` (`Shared` Visual Basic에서)의 메서드는 <xref:System.Math?displayProperty=nameWithType> 클래스입니다. 연산에 대해 일반적으로 사용 하는 추가 메서드를 포함 하는 것 (같은 <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, 및 <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), 기 하 도형 (같은 <xref:System.Math.Cos%2A?displayProperty=nameWithType> 및 <xref:System.Math.Sin%2A?displayProperty=nameWithType>), 및 계산법 (같은 <xref:System.Math.Log%2A?displayProperty=nameWithType>).  
  
     개별 비트를 조작할 수도 있습니다는 <xref:System.Double> 값입니다. 합니다 <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> 메서드 유지는 <xref:System.Double> 값의 패턴은 64 비트 정수 비트입니다. <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType> 메서드 바이트 배열에서 해당 비트 패턴을 반환 합니다.  
  
-   **반올림**합니다. 반올림는 대개 기술로 서 부동 소수점 표현 및 전체 자릿수의 문제로 인해 발생 하는 값 사이의 차이의 영향을 줄이기 위한 합니다. 반올림할 수를 <xref:System.Double> 를 호출 하 여 값을 <xref:System.Math.Round%2A?displayProperty=nameWithType> 메서드.  
  
-   **서식 지정**합니다. 변환할 수 있습니다는 <xref:System.Double> 값을 호출 하 여 해당 문자열 표현 된 <xref:System.Double.ToString%2A> 메서드 또는 복합 서식 지정 기능을 사용 하 여 합니다. 형식 문자열에서 부동 소수점 값의 문자열 표현을 제어 하는 방법에 대 한 자세한 참조를 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md) 항목.  
  
-   **문자열 구문 분석**합니다. 부동 소수점 값의 문자열 표현으로 변환할 수는 <xref:System.Double> 중 하나를 호출 하 여 값을 <xref:System.Double.Parse%2A> 또는 <xref:System.Double.TryParse%2A> 메서드. 구문 분석 작업이 실패 하는 경우는 <xref:System.Double.Parse%2A> 메서드는 예외를 throw 하는 반면 합니다 <xref:System.Double.TryParse%2A> 메서드가 반환 되는 `false`합니다.  
  
-   **형식 변환**합니다. <xref:System.Double> 구조에 대 한 명시적 인터페이스 구현을 제공 합니다 <xref:System.IConvertible> 인터페이스를 두 표준.NET Framework 데이터 형식 간의 변환만 지원 합니다. 언어 컴파일러는 또한 다른 모든 표준 숫자 형식에 값의 암시적 변환이 지원 <xref:System.Double> 값입니다. 모든 표준 숫자 유형 값의 변환 된 <xref:System.Double> 확대 변환 및 사용자에 캐스팅 연산자나 변환 메서드를 사용할 필요가 없습니다  
  
     그러나 변환 <xref:System.Int64> 고 <xref:System.Single> 값 정밀도 손실 될 수 있습니다. 다음 표에서 이러한 각 형식에 대 한 전체 자릿수의 차이점을 나열합니다.  
  
    |형식|최대 전체 자릿수|내부적인 전체 자릿수|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|10 진수는 19 자리|10 진수는 19 자리|  
    |<xref:System.Single>|소수 자릿수 7|9 10 진수|  
  
     전체 자릿수의 문제가 영향을 미치는 가장 자주 <xref:System.Single> 값으로 변환 <xref:System.Double> 값입니다. 다음 예제에서는 동일한 나누기 연산에 의해 발생 하는 두 값 같지 변환할 단 정밀도 부동 소수점 값 이므로 값 중 하나는 <xref:System.Double>합니다.  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double>:  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 유형의 모든 멤버는 스레드로부터 안전 합니다. 인스턴스 상태를 수정 하려면 표시 되는 멤버는 실제로 새 값을 사용 하 여 초기화 된 새 인스턴스를 반환 합니다. 으로 다른 형식을 사용 하 여이 형식의 인스턴스를 포함 하는 공유 변수를 읽고 쓰는로 보호 되어야 스레드로부터 안전을 보장 하려면 잠금.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">샘플: .NET Framework 4 서식 유틸리티</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스를 지정된 개체나 <see cref="T:System.Double" /> 개체와 비교하고 이 인스턴스의 값이 지정된 개체나 <see cref="T:System.Double" /> 개체의 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(double value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : double -&gt; int&#xA;override this.CompareTo : double -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">비교할 배정밀도 부동 소수점 숫자입니다.</param>
        <summary>이 인스턴스를 지정된 배정밀도 부동 소수점 숫자와 비교하고 이 인스턴스의 값이 지정된 배정밀도 부동 소수점 숫자 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
        <returns>이 인스턴스와 <paramref name="value" />의 상대 값을 나타내는 부호 있는 숫자입니다.  
  
 <list type="table"><listheader><term> 반환 값 
 </term><description> 설명 
 </description></listheader><item><term> 0보다 작음 
 </term><description> 이 인스턴스는 <paramref name="value" />보다 작습니다.  
  
또는 
이 인스턴스는 Not-a-Number(<see cref="F:System.Double.NaN" />)이고 <paramref name="value" />는 숫자입니다.  
  
 </description></item><item><term> 0 
 </term><description> 이 인스턴스는 <paramref name="value" />와 같습니다.  
  
또는 
이 인스턴스와 <paramref name="value" />가 모두 Not-a-Number(<see cref="F:System.Double.NaN" />), <see cref="F:System.Double.PositiveInfinity" /> 또는 <see cref="F:System.Double.NegativeInfinity" />입니다.  
  
 </description></item><item><term> 0보다 큼 
 </term><description> 이 인스턴스는 <paramref name="value" />보다 큽니다.  
  
또는 
이 인스턴스는 숫자이고 <paramref name="value" />는 Not-a-Number(<see cref="F:System.Double.NaN" />)입니다.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값으로 간주 될 동일 해야 합니다. 부동 소수점 값에 여러 개의 산술 연산을 의존 하는 경우에 특히 최하위 유효 자릿수를 제외 하 고 거의 동일 하 게 해당 값 및 정밀도 떨어질 수에 대 한 일반적인 것입니다. 반환 값이로 인해는 <xref:System.Double.CompareTo%2A> 메서드 때때로 있습니다 점이 의외로 생각 합니다. 예를 들어 곱하기 같은 값으로 나누기 뒤에 특정 값으로 원래 값을 생성 해야 합니다. 그러나 다음 예에서 계산 된 값으로 원래 값 보다 커야 합니다. "R"을 사용 하 여 두 값의 유효 자릿수가 모두 표시 [표준 숫자 서식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 최소 유효 자릿수가 해당 원래 값에서 계산 된 값이 다른 것을 나타냅니다. 이러한 비교를 처리에 대 한 내용은의 설명 섹션을 참조 합니다 <xref:System.Double.Equals%28System.Double%29> 메서드.  
  
 [!code-csharp[System.Double.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 이 메서드를 구현 하는 <xref:System.IComparable%601?displayProperty=nameWithType> 인터페이스 및 수행 보다 조금 더 나은 <xref:System.Double.CompareTo%2A?displayProperty=nameWithType> 메서드 변환할 필요가 없기 때문에 `value` 개체에 대 한 매개 변수.  
  
 없지만 값인 개체 <xref:System.Double.NaN> 값이 다른 개체와 같으면 간주 되지 않습니다 <xref:System.Double.NaN> (자체 포함)을, 합니다 <xref:System.IComparable%601> 인터페이스에서는 `A.CompareTo(A)` 0을 반환 합니다.  
  
## <a name="widening-conversions"></a>확대 변환  
 프로그래밍 언어에 따라 코딩할 수 있습니다는 <xref:System.Double.CompareTo%2A> 메서드 매개 변수 형식은 비트 수가 적은 보다 인스턴스 형식입니다. 일부 프로그래밍 언어 매개 변수를 나타내는 형식으로 비트 수 인스턴스로 암시적 확대 변환을 수행 하기 때문에 이것이 가능 합니다.  
  
 예를 들어, 인스턴스 유형이 <xref:System.Double> 매개 변수 형식이 고 <xref:System.Int32>입니다. Microsoft C# 컴파일러는 매개 변수의 값을 표시 하는 명령을 생성을 <xref:System.Double> 개체를 만든 다음 생성 된 <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> 인스턴스의 값과 확대 표현의 매개 변수를 비교 하는 메서드.  
  
 해당 컴파일러에서 숫자 형식의 암시적 확대 변환은 수행 하는지 확인 하려면 프로그래밍 언어의 설명서를 참조 하세요. 자세한 내용은 참조는 [형식 변환 표](~/docs/standard/base-types/conversion-tables.md) 항목입니다.  
  
## <a name="precision-in-comparisons"></a>정확 하 게 비교  
 문서화 된 전체 자릿수를 초과 하는 부동 소수점 숫자의 전체 자릿수 구현 및.NET Framework의 버전에 따라 다릅니다. 결과적으로 두 개의 특정 숫자 비교를 전체 자릿수 숫자의 내부 표현이 변경 될 수 있으므로.NET Framework의 버전 간에 변경 될 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 제네릭 및 제네릭이 아닌 버전을 보여 줍니다.는 <xref:System.Double.CompareTo%2A> 여러 값 및 참조 형식에 대 한 메서드.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">비교할 개체 또는 <see langword="null" />입니다.</param>
        <summary>이 인스턴스를 지정된 개체와 비교하고 이 인스턴스의 값이 지정된 개체의 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
        <returns>이 인스턴스와 <paramref name="value" />의 상대 값을 나타내는 부호 있는 숫자입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 설명 
 </description></listheader><item><term> 음의 정수 
 </term><description> 이 인스턴스는 <paramref name="value" />보다 작습니다.  
  
또는 
이 인스턴스는 Not-a-Number(<see cref="F:System.Double.NaN" />)이고 <paramref name="value" />는 숫자입니다.  
  
 </description></item><item><term> 0 
 </term><description> 이 인스턴스는 <paramref name="value" />와 같습니다.  
  
또는 
이 인스턴스와 <paramref name="value" />가 모두 <see langword="Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> 또는 <see cref="F:System.Double.NegativeInfinity" />입니다.</description></item><item><term> 양의 정수 
 </term><description> 이 인스턴스는 <paramref name="value" />보다 큽니다.  
  
또는 
이 인스턴스는 숫자이고 <paramref name="value" />는 Not-a-Number(<see cref="F:System.Double.NaN" />)입니다.  
  
또는 
 <paramref name="value" />가 <see langword="null" />입니다.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `value` 매개 변수 여야 합니다 `null` 인스턴스나 `Double`고, 그렇지 않으면 예외가 throw 됩니다. 인스턴스에도 <xref:System.Double>, 해당 값에 관계 없이 보다 큰 것으로 간주 됩니다 `null`합니다.  
  
 값으로 간주 될 동일 해야 합니다. 부동 소수점 값에 여러 개의 산술 연산을 의존 하는 경우에 특히 최하위 유효 자릿수를 제외 하 고 거의 동일 하 게 해당 값 및 정밀도 떨어질 수에 대 한 일반적인 것입니다. 반환 값이로 인해는 <xref:System.Double.CompareTo%2A> 메서드 때때로 있습니다 점이 의외로 생각 합니다. 예를 들어 곱하기 같은 값으로 나누기 뒤에 특정 값으로 원래 값을 생성 해야 합니다. 그러나 다음 예에서 계산 된 값으로 원래 값 보다 커야 합니다. "R"을 사용 하 여 두 값의 유효 자릿수가 모두 표시 [표준 숫자 서식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 최소 유효 자릿수가 해당 원래 값에서 계산 된 값이 다른 것을 나타냅니다. 이러한 비교를 처리에 대 한 내용은의 설명 섹션을 참조 합니다 <xref:System.Double.Equals%28System.Double%29> 메서드.  
  
 [!code-csharp[System.Double.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 지원 하기 위해이 메서드는 구현 된 <xref:System.IComparable> 인터페이스입니다. 없지만 <xref:System.Double.NaN> 같은 다른 것으로 간주 되지 않습니다 <xref:System.Double.NaN> (자체 포함)을, 합니다 <xref:System.IComparable> 인터페이스에서는 `A.CompareTo(A)` 0을 반환 합니다.  
  
## <a name="precision-in-comparisons"></a>정확 하 게 비교  
 문서화 된 전체 자릿수를 초과 하는 부동 소수점 숫자의 전체 자릿수 구현 및.NET Framework의 버전에 따라 다릅니다. 결과적으로 두 개의 특정 숫자 비교를 전체 자릿수 숫자의 내부 표현이 변경 될 수 있으므로.NET Framework의 버전 간에 변경 될 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제는 사용 방법을 보여 줍니다 `CompareTo` 컨텍스트에서 `Double`합니다.  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" />가 <see cref="T:System.Double" />가 아닌 경우</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Double  = 4.94065645841247E-324" />
      <MemberSignature Language="C++ CLI" Value="public: double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : double" Usage="System.double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>0보다 큰 양의 최소 <see cref="T:System.Double" /> 값을 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값을 <xref:System.Double.Epsilon> 속성은 가장 작은 양수를 반영 <xref:System.Double> 수치 연산 또는 비교에서 중요 한 값 때 값을 <xref:System.Double> 인스턴스가 0. 예를 들어, 다음 코드와 0 및 <xref:System.Double.Epsilon> 반면 같지 않은 값으로 간주 됩니다 및 절반 값 <xref:System.Double.Epsilon> 것으로 간주 됩니다.  
  
 [!code-csharp[System.Double.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 부동 보다 정확 하 게 기호를, 52 비트가 수 또는 significand, 및 11 비트 지 수 형식으로 구성 하는 지점입니다. 다음 예제와 같이 0의가 수 및-1022의 지수가 0에 있습니다. <xref:System.Double.Epsilon> 에 1의가 수 및-1022의 지 수 있습니다. 즉 <xref:System.Double.Epsilon> 는 가장 작은 양수 <xref:System.Double> 0 보다 큰 값 및 사용할 수 있는 최소값을 나타내고 가능한 가장 작은 증가값을 <xref:System.Double> 인 지 수는-1022입니다.  
  
 [!code-csharp[System.Double.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 그러나를 <xref:System.Double.Epsilon> 속성의 전체 자릿수의 일반 측정값이 아닌 합니다 <xref:System.Double> 형식에 적용 됩니다 <xref:System.Double> 값이 0 또는-1022의 지 수 있는 인스턴스.  
  
> [!NOTE]
>  값을 <xref:System.Double.Epsilon> 속성 부동 소수점 산술 연산에서 반올림으로 인해 상대 오차의 상한을 나타내는 컴퓨터 엡실론 동일 하지 않습니다.  
  
 이 상수의 값이 4.94065645841247 e-324입니다.  
  
 두 명백히 같은 부동 소수점 숫자 수 비교 하 여 같지 최소 유효 자릿수가에 차이가 있기 때문입니다. 예를 들어 C# 식 `(double)1/3 == (double)0.33333`를 비교 하지는 않습니다 동일한 나누기 연산의 왼쪽에서 오른쪽에 있는 상수는 지정 된 자릿수로 정확 하 게 하는 동안 최대 전체 자릿수에 있으므로. 알고리즘의 값에 기반 하는 두 개의 부동 소수점 숫자 수 고려해 야 하는지 여부 같은 결정 하는 사용자 지정 알고리즘을 만드는 경우이 방법은 권장 되지 않습니다는 <xref:System.Double.Epsilon> 소수점에 대 한 차분 차수를 설정 하는 상수 두 값으로 간주 될입니다.  (일반적으로 차이의 여백이 보다 많이 <xref:System.Double.Epsilon>.) 두 개의 배정밀도 부동 소수점 값을 비교 하는 방법에 대 한 내용은 <xref:System.Double> 고 <xref:System.Double.Equals%28System.Double%29>입니다.  
  
## <a name="platform-notes"></a>플랫폼 참고 사항  
 ARM 시스템에서는 값을 <xref:System.Double.Epsilon> 상수 감지 너무 작아서 이므로 0과 같습니다. 2.2250738585072014 e는 대체 엡실론 값을 정의할 수 있습니다-308 대신 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Double" />의 두 인스턴스가 같은 값을 표시하는지를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(double obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : double -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">이 인스턴스와 비교할 <see cref="T:System.Double" /> 개체입니다.</param>
        <summary>이 인스턴스의 값과 지정된 <see cref="T:System.Double" /> 개체의 값이 같은지를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />가 이 인스턴스와 같으면 <paramref name="obj" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 구현 하는 <xref:System.IEquatable%601?displayProperty=nameWithType> 인터페이스 및 수행 보다 조금 더 나은 <xref:System.Double.Equals%2A> 변환할 필요가 없기 때문에 `obj` 개체에 대 한 매개 변수.  
  
## <a name="widening-conversions"></a>확대 변환  
 프로그래밍 언어에 따라 코딩할 수 있습니다는 <xref:System.Double.Equals%2A> 메서드 매개 변수 형식은 비트 수가 적은 보다 인스턴스 형식입니다. 일부 프로그래밍 언어 매개 변수를 나타내는 형식으로 비트 수 인스턴스로 암시적 확대 변환을 수행 하기 때문에 이것이 가능 합니다.  
  
 예를 들어, 인스턴스 유형이 <xref:System.Double> 매개 변수 형식이 고 <xref:System.Int32>입니다. Microsoft C# 컴파일러는 매개 변수의 값을 표시 하는 명령을 생성을 <xref:System.Double> 개체를 만든 다음 생성 된 <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> 인스턴스의 값과 확대 표현의 매개 변수를 비교 하는 메서드.  
  
 해당 컴파일러에서 숫자 형식의 암시적 확대 변환은 수행 하는지 확인 하려면 프로그래밍 언어의 설명서를 참조 하세요. 자세한 내용은 참조는 [형식 변환 표](~/docs/standard/base-types/conversion-tables.md) 항목입니다.  
  
## <a name="precision-in-comparisons"></a>정확 하 게 비교  
 <xref:System.Double.Equals%2A> 값 같으면 두 값의 정밀도 차이 수 있기 때문에 메서드를 주의 해 서 사용 해야 합니다. 다음 예제에서는 보고 하는 <xref:System.Double> .333333 값 및 <xref:System.Double> 1 3으로 분할 하 여 반환 값이 다른 지.  
  
 [!code-csharp[System.Double.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 동일한 지 비교 하는 대신 하나 정의 하는 방법을 두 값 간의 차이의 허용 되는 상대 여백 (같은. 001%의 값 중 하나). 두 값 간의 차이의 절대값 보다 작거나 동일한 경우 차이점은 전체 자릿수의 차이가 있기 때문일 가능성이 않으며, 따라서 값과 같아야 합니다. 다음 예제에서는이 기술을 사용 하 여 33333과 1/3, 두 비교 <xref:System.Double> 같지 않은 것으로 이전 코드 예제에 있는 값입니다. 이 경우 값이 같으면 합니다.  
  
 [!code-csharp[System.Double.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  때문에 <xref:System.Double.Epsilon> 최소 식을 정의 된 범위는 0에 가까운 양수 값의 비슷한 두 값 사이의 차이 보다 커야 <xref:System.Double.Epsilon>합니다. 일반적으로 여러 번 보다 크면 <xref:System.Double.Epsilon>합니다. 이 인해 사용 하지 않는 권장 <xref:System.Double.Epsilon> 비교할 때 <xref:System.Double> 같음에 대 한 값입니다.  
  
 두 번째 방법은 일부 절대 값을 사용 하 여 두 부동 소수점 숫자의 차이 비교 해야 합니다. 차이를 절대 값 보다 작거나 같은 경우에 숫자 같습니다. 클 경우 숫자 두 개체가 다릅니다. 한 가지 대안은 절대 값을 임의로 선택 하는 것입니다. 하지만이 문제가 될 수 있습니다 차이점의 허용 되는 여백 크기에 따라 달라 지므로 <xref:System.Double> 값입니다. 두 번째 대안 부동 소수점 형식의 디자인 기능을 활용 합니다. 두 부동 소수점 값의 정수 표현 간의 차이점을 구분 하는 가능한 부동 소수점 값의 수를 나타냅니다. 예를 들어, 0.0 사이의 차이 및 <xref:System.Double.Epsilon> 있으므로 1 <xref:System.Double.Epsilon> 는 표현할 수 있는 가장 작은 값으로 작업할 때를 <xref:System.Double> 값이 0 인 합니다. 다음 예제에서는이 기술을 사용 하 여 두 가지 33333과 1/3 비교 <xref:System.Double> 값을 사용 하 여 이전 코드 예제는 <xref:System.Double.Equals%28System.Double%29> 메서드 같지를 찾을 수 합니다. 예제를 사용 하는 참고를 <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> 배정밀도 부동 소수점 값을 정수 표현으로 변환 하는 방법입니다.  
  
 [!code-csharp[System.Double.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 문서화 된 전체 자릿수를 초과 하는 부동 소수점 숫자의 전체 자릿수 구현 및.NET Framework의 버전에 따라 다릅니다. 결과적으로 두 개의 특정 숫자 비교를 전체 자릿수 숫자의 내부 표현이 변경 될 수 있으므로.NET Framework의 버전 간에 변경 될 수 있습니다.  
  
 두 <xref:System.Double.NaN?displayProperty=nameWithType> 를 호출 하 여 값이 같은지 테스트 합니다 <xref:System.Double.Equals%2A> 메서드, 메서드가 반환 `true`합니다. 그러나 두 <xref:System.Double.NaN> 연산자를 반환 값을 같음 연산자를 사용 하 여 같은지 테스트할 `false`합니다. 확인 하려는 경우 여부를 값을 <xref:System.Double> (NaN), 숫자가 아닙니다. 대신 호출 하는 것을 <xref:System.Double.IsNaN%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>컴파일러 오버 로드 확인 두 동작에는 명백한 차이점에 대 한 계정 수 <see cref="M:System.Double.Equals(System.Object)" /> 메서드 오버 로드 합니다. 간에 암시적 변환이 발생 하는 경우는 <paramref name="obj" /> 인수 및 <see cref="T:System.Double" /> 정의 된 인수로 형식화 되지 않은 하 고는 <see cref="T:System.Object" />, 컴파일러는 암시적 변환 및 호출을 수행할 수 있습니다는 <see cref="M:System.Double.Equals(System.Double)" /> 메서드. 호출이 고, 그렇지 합니다 <see cref="M:System.Double.Equals(System.Object)" /> 메서드를 항상 반환 <see langword="false" /> 경우 해당 <paramref name="obj" /> 인수가 아닙니다를 <see cref="T:System.Double" /> 값. 다음 예제에서는 두 개의 메서드 오버 로드 간의 동작 차이 보여 줍니다. 제외 하 고 모든 기본 숫자 형식의 경우 <see cref="T:System.Decimal" /> C#에서 첫 번째 비교 반환 <see langword="true" /> 컴파일러가 확대 변환 및 호출에 자동으로 수행 하기 때문에 <see cref="M:System.Double.Equals(System.Double)" /> 메서드를 반면 두 번째 비교 반환 <see langword="false" /> 컴파일러를 호출 하기 때문에 <see cref="M:System.Double.Equals(System.Object)" /> 메서드.  
  
[! 코드 csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! 코드 vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">이 인스턴스와 비교할 개체입니다.</param>
        <summary>이 인스턴스가 지정된 개체와 같은지를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />가 <paramref name="obj" />의 인스턴스이고 이 인스턴스의 값과 같으면 <see cref="T:System.Double" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.Equals%2A> 값 같으면 두 값의 정밀도 차이 수 있기 때문에 메서드를 주의 해 서 사용 해야 합니다. 다음 예제를 보고 하는 합니다 <xref:System.Double> .3333 값 및 <xref:System.Double> 나누어 반환 1에서 3 같지 않습니다.  
  
 [!code-csharp[System.Double.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 호출에 대 한 대안에 대 한 합니다 <xref:System.Double.Equals%2A> 메서드를 설명서를 참조 하십시오는 <xref:System.Double.Equals%28System.Double%29> 오버 로드 합니다.  
  
> [!NOTE]
>  때문에 <xref:System.Double.Epsilon> 최소 식을 정의 된 범위는 0에 가까운 양수 값의 비슷한 두 값 사이의 차이 보다 커야 <xref:System.Double.Epsilon>합니다. 일반적으로 여러 번 보다 크면 <xref:System.Double.Epsilon>합니다.  
  
 문서화 된 전체 자릿수를 초과 하는 부동 소수점 숫자의 전체 자릿수 구현 및.NET Framework의 버전에 따라 다릅니다. 결과적으로 두 개의 특정 숫자 비교를 전체 자릿수 숫자의 내부 표현이 변경 될 수 있으므로.NET Framework의 버전 간에 변경 될 수 있습니다.  
  
 두 <xref:System.Double.NaN?displayProperty=nameWithType> 를 호출 하 여 값이 같은지 테스트 합니다 <xref:System.Double.Equals%2A> 메서드, 메서드가 반환 `true`합니다. 그러나 두 <xref:System.Double.NaN> 연산자를 반환 값을 같음 연산자를 사용 하 여 같은지 테스트할 `false`합니다. 확인 하려는 경우 여부를 값을 <xref:System.Double> (NaN), 숫자가 아닙니다. 대신 호출 하는 것을 <xref:System.Double.IsNaN%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>컴파일러 오버 로드 확인 두 동작에는 명백한 차이점에 대 한 계정 수 <see cref="M:System.Double.Equals(System.Object)" /> 메서드 오버 로드 합니다. 간에 암시적 변환이 발생 하는 경우는 <paramref name="obj" /> 인수 및 <see cref="T:System.Double" /> 정의 된 인수로 형식화 되지 않은 하 고는 <see cref="T:System.Object" />, 컴파일러는 암시적 변환 및 호출을 수행할 수 있습니다는 <see cref="M:System.Double.Equals(System.Double)" /> 메서드. 호출이 고, 그렇지 합니다 <see cref="M:System.Double.Equals(System.Object)" /> 메서드를 항상 반환 <see langword="false" /> 경우 해당 <paramref name="obj" /> 인수가 아닙니다를 <see cref="T:System.Double" /> 값. 다음 예제에서는 두 개의 메서드 오버 로드 간의 동작 차이 보여 줍니다. 제외 하 고 모든 기본 숫자 형식의 경우 <see cref="T:System.Decimal" /> C#에서 첫 번째 비교 반환 <see langword="true" /> 컴파일러가 확대 변환 및 호출에 자동으로 수행 하기 때문에 <see cref="M:System.Double.Equals(System.Double)" /> 메서드를 반면 두 번째 비교 반환 <see langword="false" /> 컴파일러를 호출 하기 때문에 <see cref="M:System.Double.Equals(System.Object)" /> 메서드.  
  
[! 코드 csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! 코드 vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="double.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 해시 코드를 반환합니다.</summary>
        <returns>부호 있는 32비트 정수 해시 코드입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="double.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.TypeCode" /> 값 형식에 대한 <see cref="T:System.Double" />를 반환합니다.</summary>
        <returns>열거형 상수인 <see cref="F:System.TypeCode.Double" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsFinite(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(double d);" />
      <MemberSignature Language="F#" Value="static member IsFinite : double -&gt; bool" Usage="System.double.IsFinite d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : double -&gt; bool" Usage="System.double.IsInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">배정밀도 부동 소수점 숫자입니다.</param>
        <summary>지정된 숫자가 음의 무한대로 계산되는지 양의 무한대로 계산되는지를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="d" />가 <see cref="F:System.Double.PositiveInfinity" /> 또는 <see cref="F:System.Double.NegativeInfinity" />로 계산되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부동 소수점 <xref:System.Double.PositiveInfinity> 또는 <xref:System.Double.NegativeInfinity> 오버플로 조건을 알립니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.IsInfinity%2A>:  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(double d);" />
      <MemberSignature Language="F#" Value="static member IsNaN : double -&gt; bool" Usage="System.double.IsNaN d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">배정밀도 부동 소수점 숫자입니다.</param>
        <summary>지정된 값이 숫자가 아닌지(<see cref="F:System.Double.NaN" />) 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="d" />가 <see cref="F:System.Double.NaN" />으로 계산되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부동 소수점 <xref:System.Double.NaN> 신호 연산의 결과가 정의 되지 않습니다. 예를 들어, 0.0으로 0.0 나눈 결과 <xref:System.Double.NaN>합니다.  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A> 반환 `false` 경우는 <xref:System.Double> 값은 <xref:System.Double.PositiveInfinity> 또는 <xref:System.Double.NegativeInfinity>합니다. 이러한 값을 테스트 하려면 사용 합니다 <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, 및 <xref:System.Double.IsNegativeInfinity%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.IsNaN%2A>:  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegative(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegative : double -&gt; bool" Usage="System.double.IsNegative d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : double -&gt; bool" Usage="System.double.IsNegativeInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">배정밀도 부동 소수점 숫자입니다.</param>
        <summary>지정된 숫자가 음의 무한대로 계산되는지를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="d" />가 <see cref="F:System.Double.NegativeInfinity" />으로 계산되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부동 소수점 <xref:System.Double.NegativeInfinity> 오버플로 조건을 알립니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.IsNegativeInfinity%2A>:  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsNormal : double -&gt; bool" Usage="System.double.IsNormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : double -&gt; bool" Usage="System.double.IsPositiveInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">배정밀도 부동 소수점 숫자입니다.</param>
        <summary>지정된 숫자가 양의 무한대로 계산되는지를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="d" />가 <see cref="F:System.Double.PositiveInfinity" />으로 계산되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부동 소수점 <xref:System.Double.PositiveInfinity> 오버플로 조건을 알립니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.IsPositiveInfinity%2A>:  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsSubnormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : double -&gt; bool" Usage="System.double.IsSubnormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Double  = 1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : double" Usage="System.double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.79769313486232E+308</MemberValue>
      <Docs>
        <summary><see cref="T:System.Double" />의 가능한 최대값을 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 상수의 값은 양의 1.7976931348623157 e + 308입니다.  
  
 초과 하는 작업의 결과 <xref:System.Double.MaxValue?displayProperty=nameWithType> 는 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다. 다음 예에서 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 결과 초과 하는 경우 더하기, 곱하기 및 지 수 연산에서 결과 <xref:System.Double.MaxValue?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Double.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.MaxValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Double  = -1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : double" Usage="System.double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.79769313486232E+308</MemberValue>
      <Docs>
        <summary><see cref="T:System.Double" />의 최소값을 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 상수의 값은 음수 1.7976931348623157 e + 308입니다.  
  
 작업의 결과 보다 작은 <xref:System.Double.MinValue?displayProperty=nameWithType> 는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다. 다음 예에서 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 결과가 빼기 및 곱하기 연산에서 결과 보다 작은 <xref:System.Double.MinValue?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Double.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.MinValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Double  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: double NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : double" Usage="System.double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>숫자가 아닌 값을 나타냅니다(<see langword="NaN" />). 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드 또는 연산자 반환 <xref:System.Double.NaN> 경우 연산의 결과가 정의 되지 않습니다. 예를 들어 0으로 나눈 결과 <xref:System.Double.NaN>다음 예제와 같이 합니다. (하지만 반환 된 0이 아닌 숫자를 0으로 나눈 <xref:System.Double.PositiveInfinity> 또는 <xref:System.Double.NegativeInfinity>제 수의 부호에 따라 합니다.)  
  
 [!code-csharp[System.Double.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 사용 하 여 메서드를 호출 하는 또한을 <xref:System.Double.NaN> 값인지에 대 한 작업을 <xref:System.Double.NaN> 반환 값 <xref:System.Double.NaN>다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Double.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 사용 된 <xref:System.Double.IsNaN%2A> 값 숫자 인지를 확인 하는 방법입니다. <xref:System.Double.op_Equality%2A> 연산자는 두 개의 것으로 간주 <xref:System.Double.NaN> 값이 서로 같아야 합니다. 일반적으로 <xref:System.Double> 연산자를 사용 하 여 비교할 수 없습니다 <xref:System.Double.NaN?displayProperty=nameWithType> 상호 <xref:System.Double> 하지만 값 비교 메서드 (같은 <xref:System.Double.Equals%2A> 및 <xref:System.Double.CompareTo%2A>) 수 있습니다. 다음 예제에서는 간의 동작 차이 보여 줍니다. <xref:System.Double> 비교 연산자와 메서드.  
  
 [!code-csharp[System.Double.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## Examples  
 다음 예제는 <xref:System.Double.NaN>의 사용 방법을 보여 줍니다.  
  
 [!code-cpp[System.Double#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Double  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : double" Usage="System.double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>음의 무한대를 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 상수의 값은 음수를 0으로 나눈 결과입니다.  
  
 작업의 결과이 상수가 반환 됩니다 보다 작은 <xref:System.Double.MinValue>합니다.  
  
 사용 하 여 <xref:System.Double.IsNegativeInfinity%2A> 값 음의 무한대로 계산 되는지 여부를 확인 하려면.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.NegativeInfinity>:  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : double * double -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 두 <see cref="T:System.Double" /> 값이 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />과 <paramref name="right" />가 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Double.op_Equality%2A> 메서드 정의 대 한 같음 연산자 <xref:System.Double> 값입니다.  
  
 두 <xref:System.Double.NaN?displayProperty=nameWithType> 값을 같음 연산자를 사용 하 여 같은지 테스트할 이면 결과 `false`두; <xref:System.Double.NaN?displayProperty=nameWithType> 값 간주 됩니다. 확장 저장 프로시저를 호출 하 여 같은지 테스트 되는 경우는 <xref:System.Double.Equals%2A> 메서드를 결과 `true`합니다.  확인 하려는 경우 여부를 값을 <xref:System.Double> (NaN), 숫자가 아닙니다. 대신 호출 하는 것을 <xref:System.Double.IsNaN%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : double * double -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 <see cref="T:System.Double" /> 값이 지정된 다른 <see cref="T:System.Double" /> 값보다 큰지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Double.op_GreaterThan%2A> 메서드 정의 큼 연산의-연산자에 대 한 보다 <xref:System.Double> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : double * double -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 <see cref="T:System.Double" /> 값이 지정된 다른 <see cref="T:System.Double" /> 값보다 크거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />가 <paramref name="right" />보다 크거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Double.op_GreaterThanOrEqual%2A> 크거나 같음 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Double> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : double * double -&gt; bool" Usage="System.double.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 두 <see cref="T:System.Double" /> 값이 같지 않은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Double.op_Inequality%2A> 메서드 정의 대 한 같지 않음 연산자 <xref:System.Double> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : double * double -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 <see cref="T:System.Double" /> 값이 지정된 다른 <see cref="T:System.Double" /> 값보다 작은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />가 <paramref name="right" />보다 작으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Double.op_LessThan%2A> 덜 작업을 정의 하는 메서드-에 대 한 연산자 보다 <xref:System.Double> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : double * double -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>지정된 <see cref="T:System.Double" /> 값이 지정된 다른 <see cref="T:System.Double" /> 값보다 작거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />가 <paramref name="right" />보다 작거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Double.op_LessThanOrEqual%2A> 작거나 같음 연산자의 작업을 정의 하는 메서드 <xref:System.Double> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>숫자의 문자열 표현을 같은 값의 배정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; double" Usage="System.double.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <summary>숫자의 문자열 표현을 같은 값의 배정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <returns><paramref name="s" />에 지정된 숫자 값 또는 기호에 해당하는 배정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `s` 매개 변수는 현재 문화권의 포함 될 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>를 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>, 또는 폼의 문자열:  
  
 [*ws*][*sign*][*integral-digits*[*,*]]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|일련의 공백 문자입니다.|  
|*sign*|음수 기호를 기호 (-) 또는 양수 부호 기호 (+). 선행 기호를 사용할 수 있습니다.|  
|*integral-digits*|일련의 0에서 숫자의 정수 부분을 지정 하는 9 까지의 숫자입니다. 실행 *정수 계열 숫자* 그룹 구분 기호 별로 분할할 수 있습니다. 예를 들어, 일부 문화권에서는 쉼표 (,) 개의 그룹을 구분 합니다. *정수 계열 숫자* 요소 문자열일 수 없는 경우에는 포함 합니다 *소수 자릿수* 요소입니다.|  
|,|문화권별 천 단위 구분 기호입니다.|  
|.|Culture 별 소수점 기호입니다.|  
|*fractional-digits*|일련의 0에서 숫자의 소수 부분을 지정 하는 9 까지의 숫자입니다.|  
|E|"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다.|  
|*exponential-digits*|일련의 0에서 지 수를 지정 하는 9 까지의 숫자입니다.|  
  
 `s` 매개 변수를 조합 하 여 해석 되는 <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다. 즉, 공백이 고 천 단위 구분 기호 허용 되는 예를 들어, 통화 기호는 없습니다. 에 대 한 보다 세밀 하 게 제어 요소에서 허용 되는 스타일 `s` 구문 분석 작업이 성공 하기 위해 호출 합니다 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> 또는 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 합니다 `s` 매개 변수에서 서식 지정 정보를 사용 하 여 해석 됩니다는 <xref:System.Globalization.NumberFormatInfo> 현재 스레드 문화권에 대 한 초기화 되는 개체입니다. 자세한 내용은 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>를 참조하십시오. 다른 문화권의 서식 지정 정보를 사용 하 여 문자열 구문 분석을 호출 합니다 <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 또는 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 일반적으로 전달 하는 경우는 <xref:System.Double.Parse%2A?displayProperty=nameWithType> 메서드를 호출 하 여 만든 문자열을 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 메서드를 원래 <xref:System.Double> 값이 반환 됩니다. 그러나 정밀도의 손실, 인해 값 아닐 같은 합니다. 또한의 문자열 표현을 구문 분석 하려고 <xref:System.Double.MinValue> 나 <xref:System.Double.MaxValue> throw는 <xref:System.OverflowException>다음 예제와 같이, 합니다.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 구분 기호에서 발견 되는 `s` 구문 분석 작업을 하 고 해당 통화 또는 10 진수 수 중에 매개 변수 및 그룹 구분 기호는 동일, 구문 분석 작업이 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>를 <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Double.Parse%28System.String%29> 메서드를 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[Double Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException"><paramref name="s" />가 유효한 형식의 숫자를 나타내지 않는 경우</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" />는 <see cref="F:System.Double.MinValue" />보다 작거나 <see cref="F:System.Double.MaxValue" />보다 큰 숫자를 나타냅니다.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">.NET에서 숫자 문자열 구문 분석</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; double" Usage="System.double.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="style"><paramref name="s" />에 나타날 수 있는 스타일 요소를 나타내는 열거형 값의 비트 조합입니다. 지정할 일반적인 값은 <see cref="F:System.Globalization.NumberStyles.AllowThousands" />와 결합되는 <see cref="F:System.Globalization.NumberStyles.Float" />의 조합입니다.</param>
        <summary>지정된 스타일의 숫자에 대한 문자열 표현을 해당하는 배정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <returns><paramref name="s" />에 지정된 숫자 값 또는 기호에 해당하는 배정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `style` 스타일 요소를 정의 하는 매개 변수 (공백, 1000 단위와 같은 구분 기호 및 통화 기호)에 허용 되는 `s` 구문 분석 작업이 성공 하기 위해 매개 변수입니다. 비트 플래그 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다. 다음 <xref:System.Globalization.NumberStyles> 멤버가 지원 되지 않습니다.  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 합니다 `s` 매개 변수는 현재 문화권의 포함 될 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>를 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, 또는 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>합니다. 값에 따라 `style`, 형태를 취할 수도 있습니다.  
  
 [*ws*][*$*][*sign*][*integral-digits*[*,*]]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|일련의 공백 문자입니다. 맨 앞에 공백이 나타날 수 `s` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그입니다.|  
|$|Culture 별 통화 기호입니다. 문자열에 해당 위치는 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 현재 문화권의 속성입니다. 현재 문화권의 통화 기호에 나타날 수 있습니다 `s` 하는 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그 합니다.|  
|*sign*|음수 기호를 기호 (-) 또는 양수 부호 기호 (+). 부호의 시작 부분에 나타날 수 있습니다 `s` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그 합니다. 괄호를 사용할 수 있습니다 `s` 경우 음수 값을 나타내는 데 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.|  
|*integral-digits*|일련의 0에서 숫자의 정수 부분을 지정 하는 9 까지의 숫자입니다. *정수 계열 숫자* 요소 문자열일 수 없는 경우에는 포함 합니다 *소수 자릿수* 요소입니다.|  
|,|Culture 별 그룹 구분 기호입니다. 현재 문화권의 그룹 구분 기호에 나타날 수 있습니다 `s` 하는 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그|  
|.|Culture 별 소수점 기호입니다. 현재 문화권의 소수점 기호에 나타날 수 있습니다 `s` 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|*fractional-digits*|일련의 0에서 숫자의 소수 부분을 지정 하는 9 까지의 숫자입니다. 소수 자릿수에 나타날 수 있습니다 `s` 하는 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|E|"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다. `s` 매개 변수는 경우 지 수 표기법으로 숫자를 나타낼 수 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그.|  
|*exponential-digits*|일련의 0에서 지 수를 지정 하는 9 까지의 숫자입니다.|  
  
> [!NOTE]
> 종료 NUL (U + 0000)에 임의 문자를 `s` 의 값에 관계 없이 구문 분석 작업에서 무시 되는 `style` 인수입니다.

 숫자만 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 스타일) 항상 성공적으로 구문 분석 합니다. 나머지 <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> 멤버가 있을 수 있지만 입력된 문자열에 나타날 수 필요가 없습니다 요소를 제어할 수 있습니다. 다음 표에서 개별 <xref:System.Globalization.NumberStyles> 플래그에 나타날 수 있는 요소에 영향을 줄 `s`합니다.  
  
|NumberStyles 값|허용 되는 요소 `s` 숫자 외에도|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|합니다 *정수 계열 숫자* 요소에만 합니다.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|소수점 (*합니다.*) 및 *소수 자릿수* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" 또는 "E" 문자를 지 수 표기법을 나타냅니다. 자체적으로이 플래그는 폼의 값을 지원 *자릿수*E*자릿수*추가; 플래그 양수 또는 음수 기호 및 소수점 기호 등의 요소를 사용 하 여 문자열을 구문 분석 하는 데 필요한 합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|합니다 *ws* 맨 앞에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|합니다 *ws* 의 끝에 있는 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|합니다 *sign* 맨 앞에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|합니다 *sign* 의 끝에 있는 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|합니다 *기호* 형식의 숫자 값을 묶는 괄호는 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|1000 단위 구분 기호 (,) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|통화 ($) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Currency>|모든 요소입니다. 그러나 `s` 16 진수 또는 지 수 표기법으로 숫자를에서 나타낼 수 없습니다.|  
|<xref:System.Globalization.NumberStyles.Float>|합니다 *ws* 시작과 끝 요소 `s`, *로그인* 맨 앞에 `s`, 및 소수점 (.). `s` 매개 변수 지 수 표기법을 사용할 수도 있습니다.|  
|<xref:System.Globalization.NumberStyles.Number>|합니다 `ws`, `sign`, 천 단위 구분 기호 (,) 및 소수점 (.) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Any>|모든 요소입니다. 그러나 `s` 16 진수 숫자를 나타낼 수 없습니다.|  
  
 `s` 매개 변수에서 서식 지정 정보를 사용 하 여 구문 분석 되는 <xref:System.Globalization.NumberFormatInfo> 현재 시스템 문화권에 대 한 초기화 되는 개체입니다. 자세한 내용은 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>를 참조하십시오.  
  
 일반적으로 전달 하는 경우는 <xref:System.Double.Parse%2A?displayProperty=nameWithType> 메서드를 호출 하 여 만든 문자열을 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 메서드를 원래 <xref:System.Double> 값이 반환 됩니다. 그러나 정밀도의 손실, 인해 값 아닐 같은 합니다. 또한의 문자열 표현을 구문 분석 하려고 <xref:System.Double.MinValue> 나 <xref:System.Double.MaxValue> throw는 <xref:System.OverflowException>다음 예제와 같이, 합니다.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 구분 기호에서 발견 되는 `s` 구문 분석 작업을 하 고 해당 통화 또는 10 진수 수 중에 매개 변수 및 그룹 구분 기호는 동일, 구문 분석 작업이 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>를 <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> 의 문자열 표현을 구문 분석 방법 <xref:System.Double> EN-US 문화권을 사용 하 여 값입니다.  
  
 [!code-csharp[System.Double.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" />가 유효한 형식의 숫자를 나타내지 않는 경우</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" />는 <see cref="F:System.Double.MinValue" />보다 작거나 <see cref="F:System.Double.MaxValue" />보다 큰 숫자를 나타냅니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.  
  
또는 
 <paramref name="style" />에 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 값이 포함되어 있습니다.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">.NET에서 숫자 문자열 구문 분석</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; double" Usage="System.double.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="provider"><paramref name="s" />에 대한 문화권별 형식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 문화권별 형식의 숫자에 대한 문자열 표현을 해당하는 배정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <returns><paramref name="s" />에 지정된 숫자 값 또는 기호에 해당하는 배정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드 된 <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> 메서드는 다양 한 방법으로 서식을 지정할 수 있는 텍스트 변환 데 일반적으로 <xref:System.Double> 값입니다. 예를 들어 숫자 값으로는 HTML 텍스트 상자에 사용자가 입력 된 텍스트를 변환할 사용 수 있습니다.  
  
 `s` 매개 변수를 조합 하 여 해석 되는 <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다. `s` 매개 변수를 포함할 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, 또는 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> 에 지정 된 문화권에 대 한 `provider`, 형식의 문자열을 포함할 수 있습니다.  
  
 [*ws*][*sign*]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 선택적 요소를 대괄호로 묶여 있습니다 ([및]). "숫자" 용어를 포함 하는 요소는 0에서 9 까지의 숫자 문자의 일련의 구성 됩니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|일련의 공백 문자입니다.|  
|*sign*|음수 기호를 기호 (-) 또는 양수 부호 기호 (+).|  
|*integral-digits*|일련의 0에서 숫자의 정수 부분을 지정 하는 9 까지의 숫자입니다. 실행 *정수 계열 숫자* 그룹 구분 기호 별로 분할할 수 있습니다. 예를 들어, 일부 문화권에서는 쉼표 (,) 개의 그룹을 구분 합니다. *정수 계열 숫자* 요소 문자열일 수 없는 경우에는 포함 합니다 *소수 자릿수* 요소입니다.|  
|.|Culture 별 소수점 기호입니다.|  
|*fractional-digits*|일련의 0에서 숫자의 소수 부분을 지정 하는 9 까지의 숫자입니다.|  
|E|"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다.|  
|*exponential-digits*|일련의 0에서 지 수를 지정 하는 9 까지의 숫자입니다.|  
  
 숫자 형식에 대 한 자세한 내용은 참조는 [형식](~/docs/standard/base-types/formatting-types.md) 항목입니다.  
  
 `provider` 매개 변수는는 <xref:System.IFormatProvider> 구현입니다 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 형식의 해석에 사용 되는 문화권별 정보를 제공 하는 개체 `s`. 일반적으로 <xref:System.Globalization.NumberFormatInfo> 또는 <xref:System.Globalization.CultureInfo> 개체입니다. 하는 경우 `provider` 됩니다 `null` 또는 <xref:System.Globalization.NumberFormatInfo> 를 가져올 수 없으며 서식 지정 정보를 현재 시스템 문화권에서 사용 됩니다.  
  
 일반적으로 전달 하는 경우는 <xref:System.Double.Parse%2A?displayProperty=nameWithType> 메서드를 호출 하 여 만든 문자열을 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 메서드를 원래 <xref:System.Double> 값이 반환 됩니다. 그러나 정밀도의 손실, 인해 값 아닐 같은 합니다. 또한의 문자열 표현을 구문 분석 하려고 <xref:System.Double.MinValue> 나 <xref:System.Double.MaxValue> throw는 <xref:System.OverflowException>다음 예제와 같이, 합니다.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 구분 기호에서 발견 되는 `s` 구문 분석 작업을 하 고 해당 통화 또는 10 진수 수 중에 매개 변수 및 그룹 구분 기호는 동일, 구문 분석 작업이 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>를 <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 단추 클릭을 웹 폼의 이벤트 처리기입니다. 반환 된 배열을 사용 하 여는 <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> 속성을 사용자의 로캘을 결정 합니다. 그런 다음는 <xref:System.Globalization.CultureInfo> 해당 로캘에 해당 하는 개체입니다. <xref:System.Globalization.NumberFormatInfo> 는 속해 있는 개체 <xref:System.Globalization.CultureInfo> 개체를 전달 합니다를 <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> 에 사용자를 변환 하는 방법의 입력을 <xref:System.Double> 값.  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" />가 유효한 형식의 숫자를 나타내지 않는 경우</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" />는 <see cref="F:System.Double.MinValue" />보다 작거나 <see cref="F:System.Double.MaxValue" />보다 큰 숫자를 나타냅니다.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">.NET에서 숫자 문자열 구문 분석</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Double" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="style"><paramref name="s" />에 나타날 수 있는 스타일 요소를 나타내는 열거형 값의 비트 조합입니다. 지정할 일반적인 값은 <see cref="F:System.Globalization.NumberStyles.AllowThousands" />와 결합되는 <see cref="F:System.Globalization.NumberStyles.Float" />입니다.</param>
        <param name="provider"><paramref name="s" />에 대한 문화권별 형식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 스타일 및 문화권별 형식의 숫자에 대한 문자열 표현을 같은 값의 배정밀도 부동 소수점 숫자로 변환합니다.</summary>
        <returns><paramref name="s" />에 지정된 숫자 값 또는 기호에 해당하는 배정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `style` 스타일 요소를 정의 하는 매개 변수 (공백, 1000 단위와 같은 구분 기호 및 통화 기호)에 허용 되는 `s` 구문 분석 작업이 성공 하기 위해 매개 변수입니다. 비트 플래그 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다. 다음 <xref:System.Globalization.NumberStyles> 멤버가 지원 되지 않습니다.  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 합니다 `s` 매개 변수를 포함할 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>를 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, 또는 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> 에 지정 된 문화권에 대 한 `provider`합니다. 값에 따라 `style`, 형태를 취할 수도 있습니다.  
  
 [*ws*] [*$*] [*sign*][*integral-digits*,]*integral-digits*[.[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 대괄호 ([및])는 선택 사항에 포함 하는 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|일련의 공백 문자입니다. 맨 앞에 공백이 나타날 수 `s` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그입니다.|  
|$|Culture 별 통화 기호입니다. 문자열에 해당 위치는 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 현재 문화권의 속성입니다. 현재 문화권의 통화 기호에 나타날 수 있습니다 `s` 하는 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그 합니다.|  
|*sign*|음수 기호를 기호 (-) 또는 양수 부호 기호 (+). 부호의 시작 부분에 나타날 수 있습니다 `s` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그 합니다. 괄호를 사용할 수 있습니다 `s` 경우 음수 값을 나타내는 데 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.|  
|*integral-digits*|일련의 0에서 숫자의 정수 부분을 지정 하는 9 까지의 숫자입니다. *정수 계열 숫자* 요소 문자열일 수 없는 경우에는 포함 합니다 *소수 자릿수* 요소입니다.|  
|,|Culture 별 그룹 구분 기호입니다. 현재 문화권의 그룹 구분 기호에 나타날 수 있습니다 `s` 하는 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그|  
|.|Culture 별 소수점 기호입니다. 현재 문화권의 소수점 기호에 나타날 수 있습니다 `s` 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|*fractional-digits*|일련의 0에서 숫자의 소수 부분을 지정 하는 9 까지의 숫자입니다. 소수 자릿수에 나타날 수 있습니다 `s` 하는 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|E|"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다. `s` 매개 변수는 경우 지 수 표기법으로 숫자를 나타낼 수 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그.|  
|*exponential-digits*|일련의 0에서 지 수를 지정 하는 9 까지의 숫자입니다.|  
  
> [!NOTE]
> 종료 NUL (U + 0000)에 임의 문자를 `s` 의 값에 관계 없이 구문 분석 작업에서 무시 되는 `style` 인수입니다.

 숫자만 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 스타일) 항상 성공적으로 구문 분석 합니다. 나머지 <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> 멤버가 있을 수 있지만 입력된 문자열에 나타날 수 필요가 없습니다 요소를 제어할 수 있습니다. 다음 표에서 개별 <xref:System.Globalization.NumberStyles> 플래그에 나타날 수 있는 요소에 영향을 줄 `s`합니다.  
  
|NumberStyles 값|허용 되는 요소 `s` 숫자 외에도|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|합니다 *정수 계열 숫자* 요소에만 합니다.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|소수점 (*합니다.*) 및 *소수 자릿수* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" 또는 "E" 문자를 지 수 표기법을 나타냅니다. 자체적으로이 플래그는 폼의 값을 지원 *자릿수*E*자릿수*추가; 플래그 양수 또는 음수 기호 및 소수점 기호 등의 요소를 사용 하 여 문자열을 구문 분석 하는 데 필요한 합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|합니다 *ws* 맨 앞에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|합니다 *ws* 의 끝에 있는 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|합니다 *sign* 맨 앞에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|합니다 *sign* 의 끝에 있는 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|합니다 *기호* 형식의 숫자 값을 묶는 괄호는 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|1000 단위 구분 기호 (,) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|통화 ($) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Currency>|모든 요소입니다. 그러나 `s` 16 진수 또는 지 수 표기법으로 숫자를에서 나타낼 수 없습니다.|  
|<xref:System.Globalization.NumberStyles.Float>|합니다 *ws* 시작과 끝 요소 `s`, *로그인* 맨 앞에 `s`, 및 소수점 (.). `s` 매개 변수 지 수 표기법을 사용할 수도 있습니다.|  
|<xref:System.Globalization.NumberStyles.Number>|합니다 `ws`, `sign`, 천 단위 구분 기호 (,) 및 소수점 (.) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Any>|모든 요소입니다. 그러나 `s` 16 진수 숫자를 나타낼 수 없습니다.|  
  
 `provider` 매개 변수는는 <xref:System.IFormatProvider> 구현입니다 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 형식의 해석에 사용 되는 문화권별 정보를 제공 하는 개체 `s`. 일반적으로 <xref:System.Globalization.NumberFormatInfo> 또는 <xref:System.Globalization.CultureInfo> 개체입니다. 하는 경우 `provider` 됩니다 `null` 또는 <xref:System.Globalization.NumberFormatInfo> 를 가져올 수 없으며 서식 지정 정보를 현재 시스템 문화권에서 사용 됩니다.  
  
 일반적으로 전달 하는 경우는 <xref:System.Double.Parse%2A?displayProperty=nameWithType> 메서드를 호출 하 여 만든 문자열을 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 메서드를 원래 <xref:System.Double> 값이 반환 됩니다. 그러나 정밀도의 손실, 인해 값 아닐 같은 합니다. 또한의 문자열 표현을 구문 분석 하려고 <xref:System.Double.MinValue> 나 <xref:System.Double.MaxValue> throw는 <xref:System.OverflowException>다음 예제와 같이, 합니다.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 구분 기호에서 발견 되는 `s` 구문 분석 작업을 하 고 해당 통화 또는 10 진수 수 중에 매개 변수 및 그룹 구분 기호는 동일, 구문 분석 작업이 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>를 <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제를 사용 합니다 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 온도 값의 문자열 표현을 여러 할당 메서드를 `Temperature` 개체.  
  
 [!code-csharp[System.Double.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" />가 숫자 값을 나타내지 않는 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.  
  
또는 
 <paramref name="style" />이 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 값입니다.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" />는 <see cref="F:System.Double.MinValue" />보다 작거나 <see cref="F:System.Double.MaxValue" />보다 큰 숫자를 나타냅니다.</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">.NET에서 숫자 문자열 구문 분석</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Double  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : double" Usage="System.double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>양의 무한대를 나타냅니다. 이 필드는 상수입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 상수의 값은 양수 값을 0으로 나눈 결과입니다.  
  
 작업의 결과 보다 크면이 상수가 반환 됩니다 <xref:System.Double.MaxValue>합니다.  
  
 사용 하 여 <xref:System.Double.IsPositiveInfinity%2A> 값이 양의 무한대로 계산 되는지 여부를 확인 하려면.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Double.PositiveInfinity>:  
  
 [!code-cpp[System.Double#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 인스턴스의 값이 0이 아니면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns><see cref="T:System.Byte" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 변환은 지원되지 않습니다. 이 메서드를 사용하려고 하면 <see cref="T:System.InvalidCastException" />이 throw됩니다.</summary>
        <returns>이 변환은 지원되지 않습니다. 값이 반환되지 않습니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">모든 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 변환은 지원되지 않습니다. 이 메서드를 사용하려고 하면 <see cref="T:System.InvalidCastException" />이 throw됩니다.</summary>
        <returns>이 변환은 지원되지 않습니다. 값이 반환되지 않습니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">모든 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns><see cref="T:System.Decimal" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>변경되지 않은 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns><see cref="T:System.Int16" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns><see cref="T:System.Int32" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns><see cref="T:System.Int64" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns><see cref="T:System.SByte" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns><see cref="T:System.Single" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">이 <see cref="T:System.Double" /> 값을 변환할 대상 형식입니다.</param>
        <param name="provider">반환된 값의 형식에 대한 문화권별 정보를 제공하는 <see cref="T:System.IFormatProvider" /> 구현입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />를 참조하세요.</summary>
        <returns><paramref name="type" />으로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것을 `static` (`Shared` Visual Basic에서) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns><see cref="T:System.UInt16" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns><see cref="T:System.UInt32" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns><see cref="T:System.UInt64" />로 변환된 현재 인스턴스의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Double> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="double.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</summary>
        <returns>이 인스턴스 값의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Double.ToString> 메서드 형식을 <xref:System.Double> 현재 문화권의 형식 ("G" 또는 일반) 기본 값입니다. 다른 오버 로드를 사용 하 여 다른 형식으로, 전체 자릿수 또는 문화권을 지정 하려는 경우는 <xref:System.Double.ToString%2A> 메서드를 다음과 같이 합니다.  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 합니다.|  
|-------------------|-----------------|----------------------|  
|기본 ("G") 형식|특정 문화권|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|특정 형식 또는 전체 자릿수|기본 (현재) 문화권|<xref:System.Double.ToString%28System.String%29>|  
|특정 형식 또는 전체 자릿수|특정 문화권|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 반환 값이 될 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, 또는 폼의 문자열:  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 선택적 요소를 대괄호로 묶여 있습니다 ([및]). "숫자" 용어를 포함 하는 요소는 0에서 9 까지의 숫자 문자의 일련의 구성 됩니다. 다음 표에 나열 된 요소가 지원 됩니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*sign*|음수 기호 또는 양수 부호 기호입니다.|  
|*integral-digits*|일련의 숫자는 숫자의 정수 부분을 지정 합니다. 정수 계열 숫자 수 없어야 경우 소수 자릿수입니다.|  
|'*.*'|Culture 별 소수점 기호입니다.|  
|*fractional-digits*|일련의 숫자는 숫자의 소수 부분을 지정 합니다.|  
|'*e*'|소문자 'e', 지 수 (과학적 표기법) 표기법을 나타내는입니다.|  
|*exponential-digits*|일련의 진수 지 수를 지정 합니다.|  
  
 반환 값의 예로 "100", "-123456789", "123.45 e + 6", "500", "3.1416", "600", "-0.123" 및 "-Infinity"입니다.  
  
 다음 서식 항목에서 자세히 설명 되어 광범위 한 형식 지정 지원을 제공 하는.NET Framework:  
  
-   숫자 서식 지정자에 대 한 자세한 내용은 참조 하세요. [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   형식에 대 한 자세한 내용은 참조 하세요. [형식](~/docs/standard/base-types/formatting-types.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 <xref:System.Double.ToString?displayProperty=nameWithType> 의 숫자의 문자열 표현을 표시 하는 메서드 <xref:System.Double> 값입니다.  
  
 [!code-csharp[System.Double.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 다음 예제에서는 <xref:System.Double.ToString%2A>합니다.  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="double.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 문화권별 형식 정보를 사용하여 이 인스턴스의 숫자 값을 해당 문자열 표현으로 변환합니다.</summary>
        <returns>이 인스턴스의 값을 <paramref name="provider" />에 지정된 내용에 따라 나타낸 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Double.ToString%28System.IFormatProvider%29> 메서드 형식을 <xref:System.Double> 지정된 된 문화권의 형식 ("G" 또는 일반) 기본 값입니다. 다른 형식으로 또는 문화권을 지정 하려는 경우 사용 하 여 다른 오버 로드는 <xref:System.Double.ToString%2A> 메서드를 다음과 같이:  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 합니다.|  
|-------------------|-----------------|----------------------|  
|기본 ("G") 형식|기본 (현재)|<xref:System.Double.ToString>|  
|특정 형식 또는 전체 자릿수|기본 (현재) 문화권|<xref:System.Double.ToString%28System.String%29>|  
|특정 형식 또는 전체 자릿수|특정 문화권|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 반환 값이 될 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, 또는 폼의 문자열:  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 선택적 요소를 대괄호로 묶여 있습니다 ([및]). "숫자" 용어를 포함 하는 요소는 0에서 9 까지의 숫자 문자의 일련의 구성 됩니다. 다음 표에 나열 된 요소가 지원 됩니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*sign*|음수 기호 또는 양수 부호 기호입니다.|  
|*integral-digits*|일련의 숫자는 숫자의 정수 부분을 지정 합니다. 정수 계열 숫자 수 없어야 경우 소수 자릿수입니다.|  
|'*.*'|Culture 별 소수점 기호입니다.|  
|*fractional-digits*|일련의 숫자는 숫자의 소수 부분을 지정 합니다.|  
|'*e*'|소문자 'e', 지 수 (과학적 표기법) 표기법을 나타내는입니다.|  
|*exponential-digits*|일련의 진수 지 수를 지정 합니다.|  
  
 반환 값의 예로 "100", "-123456789", "123.45 e + 6", "500", "3.1416", "600", "-0.123" 및 "-Infinity"입니다.  
  
 이 인스턴스의 일반 숫자 서식 지정자 ("G")를 사용 하 여 지정 됩니다.  
  
 다음 서식 항목에서 자세히 설명 되어 광범위 한 형식 지정 지원을 제공 하는.NET Framework:  
  
-   숫자 서식 지정자에 대 한 자세한 내용은 참조 하세요. [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   형식에 대 한 자세한 내용은 참조 하세요. [형식](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 `provider` 매개 변수는는 <xref:System.IFormatProvider> 구현입니다 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 개체. 일반적으로 `provider` 되는 <xref:System.Globalization.CultureInfo> 개체 또는 <xref:System.Globalization.NumberFormatInfo> 개체입니다. `provider` 매개 변수는 서식 지정에 사용 되는 문화권별 정보를 제공 합니다. 하는 경우 `provider` 됩니다 `null`, 반환 값을 사용 하 여 형식이 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 문자열 표현을 <xref:System.Double> 값을 사용 하 여 <xref:System.Globalization.CultureInfo> 몇 가지 다른 문화권을 나타내는 개체입니다.  
  
 [!code-csharp[System.Double.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 다음 예제에서는의 사용을 보여 줍니다 <xref:System.Double.ToString%2A>해를 <xref:System.String> 및 <xref:System.IFormatProvider> 매개 변수로 합니다.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="double.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">숫자 서식 문자열입니다.</param>
        <summary>지정된 형식을 사용하여 이 인스턴스의 숫자 값을 해당 문자열 표현으로 변환합니다.</summary>
        <returns>이 인스턴스의 값을 <paramref name="format" />에 지정된 내용에 따라 나타낸 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Double.ToString%28System.String%29> 메서드 형식을 <xref:System.Double> 현재 문화권의 규칙을 사용 하 여 지정 된 형식의 값입니다. 다른 형식으로 또는 문화권을 지정 하려는 경우 사용 하 여 다른 오버 로드는 <xref:System.Double.ToString%2A> 메서드를 다음과 같이:  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 합니다.|  
|-------------------|-----------------|----------------------|  
|기본 ("G") 형식|기본 (현재) 문화권|<xref:System.Double.ToString>|  
|기본 ("G") 형식|특정 문화권|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|특정 형식 또는 전체 자릿수|특정 문화권|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 반환 값이 될 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>를 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, 또는 지정 된 대로 숫자의 문자열 표현을 `format`합니다.  
  
 `format` 매개 변수 D 및 X를 제외한 모든 유효한 표준 숫자 서식 지정자 및 사용자 지정 숫자 서식 지정자의 조합이 될 수 있습니다. 하는 경우 `format` 는 `null` 이거나 빈 문자열인 경우 반환 값은 일반 숫자 서식 지정자 ("G")를 사용 하 여 지정 됩니다.  
  
 다음 서식 항목에서 자세히 설명 되어 광범위 한 형식 지정 지원을 제공 하는.NET Framework:  
  
-   숫자 서식 지정자에 대 한 자세한 내용은 참조 하세요. [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   형식에 대 한 자세한 내용은 참조 하세요. [형식](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 기본적으로 반환 값만 포함 15 자리의 전체 자릿수 내부적으로 최대 17 자리가 유지 합니다. 이 인스턴스의 값이 15 자리 보다 크면 <xref:System.Double.ToString%2A> 반환 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> 또는 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> 를 초과 합니다. 자세한 정밀도 필요로 하는 경우 지정 `format` 항상 17 자리 전체 자릿수, 또는 "R"을 반환 하는 "G17" 형식 지정 반환 하는 15 자리 수만 할 수 있으면 해당 전체 자릿수 또는 17 자리 수를 나타낼 수 있는 경우 최대 전체 자릿수를 사용 하 여 표시 합니다.  
  
   
  
## Examples  
 다음 예에서는 숫자 값을 정의 및 서식을 통화 값으로 "C" 표준 숫자 서식 문자열을 사용 하 여 및 소수 자릿수 세 자리로 숫자 값으로 "N" 표준 숫자 서식 문자열을 사용 하 여 합니다. 결과 문자열은 EN-US 문화권의 규칙을 사용 하 여 서식이 지정 됩니다. 숫자 형식 문자열에 대 한 자세한 내용은 참조 하세요. [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 다음 예제에서는 여러 <xref:System.Double> 세 개의 사용자 지정 숫자 서식 문자열 함께 지원 되는 표준 숫자 서식 지정자를 사용 하 여 값입니다. 채우는 방법을 보여 줍니다 이러한 사용자 지정 형식 문자열 중 하나는 <xref:System.Single> 값 앞에 오는 0을 사용 합니다. 또한이 예제에서는 "R" 제외 하 고 각 표준 형식 지정자를 사용 하 여 전체 자릿수 지정자를 사용합니다. 전체 자릿수 지정자 범위는 0에서 3 값입니다. 문자열을 숫자 값으로 변환 하려면이 예제에서는 EN-US 문화권의 서식 규칙을 사용 합니다.  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" />이 잘못되었습니다.</exception>
        <block subset="none" type="usage"><para><see langword="/platform:x64" /> 또는 <see langword="/platform:anycpu" /> 스위치를 사용하여 컴파일되고 64비트 시스템에서 실행되는 경우 "R" 표준 숫자 형식 문자열로 형식이 지정된 <see cref="T:System.Double" /> 값이 성공적으로 라운드트립되지 않는 경우가 있습니다. 이 문제를 해결하려면 "G17" 표준 숫자 형식 문자열을 사용하여 <see cref="T:System.Double" /> 값의 형식을 지정할 수 있습니다. 다음 예제에서는 성공적으로 라운드트립되지 않는 <see cref="T:System.Double" /> 값에 "R" 형식 문자열을 사용하고 "G17" 형식 문자열도 사용하여 원래 값을 성공적으로 라운드트립합니다.  
  
[! 코드 csharp[System.Double.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex2.cs#6)] [! 코드 vb[System.Double.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex2.vb#6)]</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">방법: 숫자 앞에 0으로 채우기</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="double.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">숫자 서식 문자열입니다.</param>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 형식 및 문화권별 형식 정보를 사용하여 이 인스턴스의 숫자 값을 해당 문자열 표현으로 변환합니다.</summary>
        <returns><paramref name="format" /> 및 <paramref name="provider" />로 지정된 이 인스턴스 값의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> 메서드 형식을 <xref:System.Double> 지정 된 형식으로 지정된 된 문화권의 값입니다. 다른 형식으로 또는 문화권을 지정 하려는 경우 사용 하 여 다른 오버 로드는 <xref:System.Double.ToString%2A> 메서드를 다음과 같이:  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 합니다.|  
|-------------------|-----------------|----------------------|  
|기본 ("G") 형식|기본 (현재) 문화권|<xref:System.Double.ToString>|  
|기본 ("G") 형식|특정 문화권|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|특정 형식 또는 전체 자릿수|기본 (현재) 문화권|<xref:System.Double.ToString%28System.String%29>|  
  
 반환 값이 될 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>를 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, 또는 지정 된 대로 숫자의 문자열 표현을 `format`합니다.  
  
 `format` 매개 변수 D 및 X를 제외한 모든 유효한 표준 숫자 서식 지정자 및 사용자 지정 숫자 서식 지정자의 조합이 될 수 있습니다. 하는 경우 `format` 는 `null` 이거나 빈 문자열인 경우 반환 값이이 인스턴스에 대 한 일반 숫자 서식 지정자 ("G")를 사용 하 여 지정 됩니다.  
  
 다음 서식 항목에서 자세히 설명 되어 광범위 한 형식 지정 지원을 제공 하는.NET Framework:  
  
-   숫자 서식 지정자에 대 한 자세한 내용은 참조 하세요. [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   형식에 대 한 자세한 내용은 참조 하세요. [형식](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 `provider` 매개 변수는는 <xref:System.IFormatProvider> 구현입니다 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 개체. 일반적으로 `provider` 되는 <xref:System.Globalization.CultureInfo> 개체 또는 <xref:System.Globalization.NumberFormatInfo> 개체입니다. `provider` 매개 변수는 서식 지정에 사용 되는 문화권별 정보를 제공 합니다. 하는 경우 `provider` 됩니다 `null`, 반환 값을 사용 하 여 형식이 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 개체입니다.  
  
 기본적으로 반환 값만 포함 15 자리의 전체 자릿수 내부적으로 최대 17 자리가 유지 합니다. 이 인스턴스의 값이 15 자리 보다 크면 <xref:System.Double.ToString%2A> 반환 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> 또는 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> 를 초과 합니다. 자세한 정밀도 필요로 하는 경우 지정 `format` 항상 17 자리 전체 자릿수, 또는 "R"을 반환 하는 "G17" 형식 지정 반환 하는 15 자리 수만 할 수 있으면 해당 전체 자릿수 또는 17 자리 수를 나타낼 수 있는 경우 최대 전체 자릿수를 사용 하 여 표시 합니다.  
  
   
  
## Examples  
 다음 예제에서는 표시를 <xref:System.Double> 각 지원 되는 표준 숫자 서식 지정자를 사용 하 여 몇 가지 다른 문화권에 대 한 값입니다.  
  
 [!code-cpp[System.Double.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 다음 예제에서는의 사용을 보여 줍니다 <xref:System.Double.ToString%2A>해를 <xref:System.String> 및 <xref:System.IFormatProvider> 매개 변수로 합니다.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><see langword="/platform:x64" /> 또는 <see langword="/platform:anycpu" /> 스위치를 사용하여 컴파일되고 64비트 시스템에서 실행되는 경우 "R" 표준 숫자 형식 문자열로 형식이 지정된 <see cref="T:System.Double" /> 값이 성공적으로 라운드트립되지 않는 경우가 있습니다. 이 문제를 해결하려면 "G17" 표준 숫자 형식 문자열을 사용하여 <see cref="T:System.Double" /> 값의 형식을 지정할 수 있습니다. 다음 예제에서는 성공적으로 라운드트립되지 않는 <see cref="T:System.Double" /> 값에 "R" 형식 문자열을 사용하고 "G17" 형식 문자열도 사용하여 원래 값을 성공적으로 라운드트립합니다.  
  
[! 코드 csharp[System.Double.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex1.cs#5)] [! 코드 vb[System.Double.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex1.vb#5)]</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">방법: 숫자 앞에 0으로 채우기</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">샘플: .NET Framework 4 서식 유틸리티</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="double.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>숫자의 문자열 표현을 같은 값의 배정밀도 부동 소수점 숫자로 변환합니다. 반환 값은 변환이 성공했는지 아니면 실패했는지를 나타냅니다.</summary>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="result">이 메서드는 변환이 성공한 경우 <paramref name="s" /> 매개 변수의 배정밀도 부동 소수점 숫자를 반환하고 변환이 실패한 경우 0을 반환합니다. <paramref name="s" /> 매개 변수가 <see langword="null" /> 또는 <see cref="F:System.String.Empty" />이거나 올바른 형식의 숫자가 아니거나, <see cref="F:System.Double.MinValue" />보다 작거나 <see cref="F:System.Double.MaxValue" />보다 큰 숫자를 나타내는 경우 변환이 실패합니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다. 원래 <paramref name="result" />에 제공된 모든 값을 덮어쓰게 됩니다.</param>
        <summary>숫자의 문자열 표현을 같은 값의 배정밀도 부동 소수점 숫자로 변환합니다. 반환 값은 변환이 성공했는지 아니면 실패했는지를 나타냅니다.</summary>
        <returns><see langword="true" />가 성공적으로 변환되었으면 <paramref name="s" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다른이 오버 로드는 <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> 메서드 구문 분석된 된 숫자 값을 반환 하는 대신 구문 분석 작업이 성공 했는지를 나타내는 부울 값을 반환 합니다. 테스트 하기 위해 예외 처리를 사용할 필요가 한 <xref:System.FormatException> 이벤트에 `s` 잘못 되었으며 성공적으로 구문 분석할 수 없습니다.  
  
 합니다 `s` 매개 변수는 현재 문화권의 포함 될 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>를 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> (문자열 비교는 대/소문자 구분) 또는 폼의 문자열:  
  
 [ws][sign][integral-digits,]integral-digits[.[fractional-digits]][e[sign]exponential-digits][ws]  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|일련의 공백 문자입니다.|  
|*sign*|음수 기호 또는 양수 부호 기호입니다.|  
|*integral-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 정수 부분을 지정 합니다. 정수 계열 숫자 수 없어야 경우 소수 자릿수입니다.|  
|*,*|Culture 별 그룹 구분 기호입니다.|  
|*.*|Culture 별 소수점 기호입니다.|  
|*fractional-digits*|일련의 숫자 0에서 하는 9 사이의 숫자의 소수 부분을 지정 합니다.|  
|*E*|대 / 소문자 구분 문자가 'e'를 지 수 (과학적 표기법) 표기법을 나타냅니다.|  
|*exponential-digits*|일련의 0에서 9 지 수를 지정 하는 위치 까지의 숫자입니다.|  
  
 숫자 형식에 대 한 자세한 내용은 참조 하세요. [형식](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 `s` 매개 변수를 함께 사용 하 여 해석 되는 <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다. 즉, 공백이 고 천 단위 구분 기호는 사용할 수 있지만 통화 기호는 없습니다. 요소를 명시적으로 정의 하려면 (통화 기호, 1000 단위와 같은 구분 기호 및 공백을)에 나타날 수 있는 `s`를 사용 하 여를 <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> 메서드 오버 로드.  
  
 `s` 매개 변수에서 서식 지정 정보를 사용 하 여 구문 분석 되는 <xref:System.Globalization.NumberFormatInfo> 현재 시스템 문화권에 대 한 초기화 되는 개체입니다. 자세한 내용은 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>를 참조하십시오. 문자열 구문 분석 하는 문화권 지정 된 다른 서식 지정 정보를 사용 하 여, 사용 된 <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> 메서드 오버 로드 합니다.  
  
 일반적으로 전달 하는 경우는 <xref:System.Double.TryParse%2A?displayProperty=nameWithType> 메서드를 호출 하 여 만든 문자열을 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 메서드를 원래 <xref:System.Double> 값이 반환 됩니다. 그러나 정밀도의 손실, 인해 값 아닐 같은 합니다. 또한의 문자열 표현을 구문 분석 하려고 <xref:System.Double.MinValue> 나 <xref:System.Double.MaxValue> throw는 <xref:System.OverflowException>다음 예제와 같이, 합니다.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 구분 기호에서 발견 되는 `s` decimal 및 그룹 구분 기호 및 구문 분석 작업을 하는 동안 매개 변수는 동일한, 구문 분석 작업이 구분 기호는 그룹 구분 기호가 아니라는 소수 구분 기호로 간주 합니다. 구분 기호에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>를 <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> 숫자 값의 문자열 표현으로 변환할 방법이 <xref:System.Double> 값입니다. 해당 EN-US가 현재 문화권이 가정 합니다.  
  
 [!code-csharp[System.Double.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">.NET에서 숫자 문자열 구문 분석</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">샘플: .NET Framework 4 서식 유틸리티</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="style"><see cref="T:System.Globalization.NumberStyles" />에 사용할 수 있는 형식을 나타내는 <paramref name="s" /> 값의 비트 조합입니다. 지정할 일반적인 값은 <see cref="F:System.Globalization.NumberStyles.AllowThousands" />와 결합되는 <see cref="F:System.Globalization.NumberStyles.Float" />입니다.</param>
        <param name="provider"><paramref name="s" />에 대한 문화권별 서식 지정 정보를 제공하는 <see cref="T:System.IFormatProvider" />입니다.</param>
        <param name="result">이 메서드는 변환이 성공한 경우 <paramref name="s" />에 포함된 숫자 값이나 기호의 배정밀도 부동 소수점 숫자를 반환하며 변환이 실패한 경우 0을 반환합니다. <paramref name="s" /> 매개 변수가 <see langword="null" /> 또는 <see cref="F:System.String.Empty" />이거나, <paramref name="style" />과 규격 형식이 아니거나, <see cref="F:System.SByte.MinValue" />보다 작거나 <see cref="F:System.SByte.MaxValue" />보다 큰 숫자를 나타내거나, <paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 열거형 상수의 유효한 조합이 아닌 경우 변환이 실패합니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다. 원래 <paramref name="result" />에 제공된 모든 값을 덮어쓰게 됩니다.</param>
        <summary>지정된 스타일 및 문화권별 형식의 숫자에 대한 문자열 표현을 같은 값의 배정밀도 부동 소수점 숫자로 변환합니다. 반환 값은 변환이 성공했는지 아니면 실패했는지를 나타냅니다.</summary>
        <returns><see langword="true" />가 성공적으로 변환되었으면 <paramref name="s" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Double.TryParse%2A> 메서드와 비슷합니다는 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 메서드와이 메서드가 변환에 실패 하면 예외를 throw 하지 않습니다. 변환이 성공 하는 경우 반환 값은 `true` 하며 `result` 변환의 결과 매개 변수는 설정입니다. 변환에 실패 하는 경우 반환 값은 `false` 하며 `result` 매개 변수는 0으로 설정 됩니다. 테스트 하기 위해 예외 처리를 사용할 필요가 없습니다이 <xref:System.FormatException> 이벤트에 `s` 잘못 되었으며 성공적으로 구문 분석할 수 없습니다.  
  
 합니다 `style` 의 허용 되는 형식을 정의 하는 매개 변수는 `s` 구문 분석 작업이 성공 하기 위해 매개 변수입니다. 비트 플래그 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다. 다음 <xref:System.Globalization.NumberStyles> 멤버가 지원 되지 않습니다.  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 합니다 `s` 매개 변수를 포함할 수 있습니다 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, 또는 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> 하 여 지정 된 문화권 `provider`합니다. 값에 따라 뿐만 `style`, `s` 매개 변수는 다음 요소가 포함 될 수 있습니다.  
  
 [ws] [$] [sign][integral-digits,]integral-digits[.fractional-digits][e[sign]exponential-digits][ws]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|선택적 공백입니다. 맨 앞에 공백이 나타날 수 `s` 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 플래그입니다. 끝에 나타날 수 있습니다 `s` 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그입니다.|  
|*$*|Culture 별 통화 기호입니다. 문자열의 해당 위치에서 정의 됩니다는 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> 또는 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 의 속성을 <xref:System.Globalization.NumberFormatInfo> 에서 반환 된 개체를 <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 메서드의 `provider` 매개 변수. 통화 기호에 나타날 수 있습니다 `s` 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그입니다.|  
|*sign*|가 선택적 부호입니다. 부호의 시작 부분에 나타날 수 있습니다 `s` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `s` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그 합니다. 괄호를 사용할 수 있습니다 `s` 경우 음수 값을 나타내는 데 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.|  
|*integral-digits*|일련의 0에서 숫자의 정수 부분을 지정 하는 9 까지의 숫자입니다. 정수 계열 숫자 수 없어야 경우 소수 자릿수입니다.|  
|*,*|문화권별 천 단위 구분 기호입니다. 현재 문화권의 천 단위 구분 기호에 나타날 수 있습니다 `s` 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다.|  
|*.*|Culture 별 소수점 기호입니다. 현재 문화권의 소수점 기호에 나타날 수 있습니다 `s` 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|*fractional-digits*|일련의 0에서 숫자의 소수 부분을 지정 하는 9 까지의 숫자입니다. 소수 자릿수에 나타날 수 있습니다 `s` 하는 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|*e*|E 또는 E 문자는 나타내는 `s` 지 수 표기법을 사용 하 여 숫자를 나타낼 수 있습니다. 합니다 `s` 매개 변수 스타일을 포함 하는 경우 지 수 표기법으로 숫자를 나타낼 수는 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그입니다.|  
|*exponential-digits*|일련의 0에서 지 수를 지정 하는 9 까지의 숫자입니다.|  
  
> [!NOTE]
> 종료 NUL (U + 0000)에 임의 문자를 `s` 의 값에 관계 없이 구문 분석 작업에서 무시 되는 `style` 인수입니다.

 숫자만 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 스타일) 항상 성공적으로 구문 분석 합니다. 나머지 <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> 멤버 수 있지만 입력된 문자열에 있이 필요가 없습니다 있는 요소를 제어 합니다. 다음 표에서 개별 <xref:System.Globalization.NumberStyles> 플래그에 나타날 수 있는 요소에 영향을 줄 `s`합니다.  
  
|NumberStyles 값|숫자 외에도 s에 허용 되는 요소|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|합니다 *정수 계열 숫자* 요소에만 합니다.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|*.* 및 *소수 자릿수* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s` 매개 변수 지 수 표기법을 사용할 수도 있습니다. 자체적으로이 플래그는 폼 값을 지원 하며 *정수 자릿수*E*자리 지 수 백오프*추가; 플래그와 같은 요소를 사용 하 여 지 수 표기법에서 문자열을 구문 분석 하는 데 필요한 양수 또는 음수 기호를 소수점 기호|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|합니다 *ws* 맨 앞에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|합니다 *ws* 의 끝에 있는 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|합니다 *sign* 맨 앞에 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|합니다 *sign* 의 끝에 있는 요소 `s`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|합니다 *기호* 형식의 숫자 값을 묶는 괄호는 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|합니다 *,* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|합니다 *$* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Currency>|모두. `s` 매개 변수를 16 진수 또는 지 수 표기법으로 숫자를에서 나타낼 수 없습니다.|  
|<xref:System.Globalization.NumberStyles.Float>|*ws* 시작과 끝 요소 `s`, *로그인* 의 시작 부분 `s`, 및 *합니다.* 기호입니다. `s` 매개 변수 지 수 표기법을 사용할 수도 있습니다.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, 천 단위 구분 기호 (*,),* 및 소수점 (*.*) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Any>|모든 스타일을 제외 하 고 `s` 16 진수 숫자를 나타낼 수 없습니다.|  
  
 합니다 `provider` 매개 변수는를 <xref:System.IFormatProvider> 구현 같은 <xref:System.Globalization.NumberFormatInfo> 또는 <xref:System.Globalization.CultureInfo> 개체입니다. `provider` 매개 변수 구문 분석에 사용 되는 문화권별 정보를 제공 합니다. 하는 경우 `provider` 됩니다 `null` 또는 <xref:System.Globalization.NumberFormatInfo> 개체를 가져올 수 없습니다, 현재 문화권의 형식 정보를 사용 합니다.  
  
 경우 변환이 실패 합니다 `s` 매개 변수는 `null` 또는 숫자 값이 아닌,는 `provider` 매개 변수를 생성 하지 않습니다는 <xref:System.Globalization.NumberFormatInfo> 개체 또는 `style` 매개 변수에서 비트 플래그의 조합이 아닙니다.는 <xref:System.Globalization.NumberStyles> 열거형입니다.  
  
 일반적으로 전달 하는 경우는 <xref:System.Double.TryParse%2A?displayProperty=nameWithType> 메서드를 호출 하 여 만든 문자열을 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 메서드를 원래 <xref:System.Double> 값이 반환 됩니다. 그러나 정밀도의 손실, 인해 값 아닐 같은 합니다. 또한의 문자열 표현을 구문 분석 하려고 <xref:System.Double.MinValue> 나 <xref:System.Double.MaxValue> throw는 <xref:System.OverflowException>다음 예제와 같이, 합니다.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 구분 기호에서 발견 되는 `s` 구문 분석 작업을 하 고 해당 통화 또는 10 진수 수 중에 매개 변수 및 그룹 구분 기호는 동일, 구문 분석 작업이 구분 기호는 그룹 보다는 소수 구분 기호로 간주 구분 기호입니다. 구분 기호에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>를 <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, 및 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 된 <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> 특정 스타일 및 서식을 특정 문화권의 규칙을 사용 하는 숫자의 문자열 표현을 구문 분석 하는 방법입니다.  
  
 [!code-csharp[System.Double.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.  
  
또는 
 <paramref name="style" />에 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 값이 포함되어 있습니다.</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">.NET에서 숫자 문자열 구문 분석</related>
      </Docs>
    </Member>
  </Members>
</Type>