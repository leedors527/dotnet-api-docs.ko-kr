<Type Name="Exception" FullName="System.Exception">
  <Metadata><Meta Name="ms.openlocfilehash" Value="941ce6ec902db92558c052227196f17b68b2f254" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58725196" /></Metadata><TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>애플리케이션을 실행할 때 나타나는 오류를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 클래스는 모든 예외에 대 한 기본 클래스입니다. 오류가 발생 하는 시스템 또는 현재 실행 중인 응용 프로그램 오류에 대 한 정보를 포함 하는 예외를 throw 하 여 보고 합니다. 예외가 throw 되 면 응용 프로그램에서 또는 기본 예외 핸들러에서 처리 됩니다.  
  
 섹션 내용  
  
 [오류 및 예외](#Errors)   
 [Try/catch 블록](#TryCatch)   
 [예외 형식 기능](#Features)   
 [예외 클래스 속성](#Properties)   
 [성능 고려 사항](#Performance)   
 [예외 다시 throw](#Rethrow)   
 [표준 예외를 선택합니다.](#Standard)   
 [사용자 지정 예외를 구현합니다.](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>오류 및 예외  
 런타임 오류는 다양 한 이유로 발생할 수 있습니다. 그러나 일부 오류 코드에서 예외로 처리 되어야 합니다. 적절 하 게 응답할 수 런타임에 발생할 수 있는 오류의 몇 가지 범주는 다음과 같습니다.  
  
-   **사용 오류입니다.** 사용 오류를 예외가 발생할 수 있는 프로그램 논리에서 오류를 나타냅니다. 그러나 예외 처리를 통해 없습니다 있지만 잘못 된 코드를 수정 하 여 오류를 해결 해야 합니다. 예를 들어 재정의는 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 가정 다음 예제에서 메서드는 `obj` 인수에 null이 아닌 여야 합니다.  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     <xref:System.NullReferenceException> 발생 하는 예외 때 `obj` 은 `null` 명시적으로 호출 하기 전에 null 인지 테스트할 소스 코드를 수정 하 여 제거할 수 있습니다는 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 재정의 및 다시 컴파일입니다. 다음 예제에서는 처리 하는 수정 된 소스 코드를 포함 한 `null` 인수입니다.  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     예외 사용 오류에 대 한 처리를 사용 하는 대신 사용할 수는 <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> 디버그 빌드에서 사용 오류를 식별 하는 방법 및 <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> 디버그와 릴리스 사용 오류를 식별 하는 메서드를 작성 합니다. 자세한 내용은 [관리 코드에 어설션](/visualstudio/debugger/assertions-in-managed-code)합니다.  
  
-   **프로그램 오류가 발생 했습니다.** 프로그램 오류에는 반드시 버그 없는 코드를 작성 하 여 방지할 수 없는 런타임 오류가입니다.  
  
     일부 경우에 프로그램 오류는 예상 또는 일상적인 오류 조건이 반영할 수 있습니다. 이 경우 다음 예외 처리를 사용 하 여 프로그램 오류를 처리 하 고 대신 작업을 다시 시도를 방지 하는 것이 좋습니다. 예를 들어, 사용자는 특정 형식으로 날짜를 입력 해야 하는 경우 구문 분석할 수 있습니다 날짜 문자열을 호출 하 여 합니다 <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> 반환 하는 메서드를 <xref:System.Boolean> 구문 분석 작업이 성공 했는지를 나타내는, 합니다 사용하는대신값<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>throw 하는 메서드를 <xref:System.FormatException> 날짜 문자열을 변환할 수 없는 경우 예외를 <xref:System.DateTime> 값입니다. 마찬가지로, 사용자가 존재 하지 않는 파일을 열고 하려고 하는 경우 먼저 호출 된 <xref:System.IO.File.Exists%2A?displayProperty=nameWithType> 여부 파일 존재 하 고 확인을 하지 않는 경우 사용자 만드시겠습니까 하려고 하는지 여부를 확인 하는 방법.  
  
     다른 경우에 프로그램 오류 코드에서 처리할 수 있는 예기치 않은 오류 조건을 반영 합니다. 예를 들어 파일이 있는지 확인 하려면를 선택한 경우에이 삭제 될 수 있습니다를 열 수 있도록 전이나 손상 되었을 수 있습니다. 인스턴스화하여 파일을 열려고 할 경우는 <xref:System.IO.StreamReader> 개체나 호출 합니다 <xref:System.IO.File.Open%2A> 메서드가 throw 할 수 있습니다는 <xref:System.IO.FileNotFoundException> 예외입니다. 이러한 경우에 오류를 복구 하는 예외 처리를 사용 해야 합니다.  
  
-   **시스템 오류입니다.** 시스템 오류에 의미 있는 방식으로 프로그래밍 방식으로 처리할 수 없는 런타임 오류입니다. 예를 들어, 모든 메서드가 throw 할 수는 <xref:System.OutOfMemoryException> 공용 언어 런타임에서 추가 메모리를 할당할 수 없는 경우 예외입니다. 일반적으로 시스템 오류 예외 처리를 사용 하 여 처리 되지 않습니다. 대신,와 같은 이벤트를 사용할 수 있습니다 <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> 호출을 <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> 예외 정보를 기록 하 고 응용 프로그램을 종료 하기 전에 실패의 사용자에 게 알릴 방법입니다.  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Try/catch 블록  
 공용 언어 런타임 예외 개체의 표현 및 프로그램 코드 및 예외 처리 코드를 분리를 기반으로 하는 예외 처리 모델을 제공 `try` 블록 및 `catch` 블록입니다. 하나 이상의 수 `catch` 각각은 특정 형식의 예외 또는 다른 블록 보다 구체적인 예외를 catch 하는 데 사용 하기 위한 처리 차단 합니다.  
  
 내 코드에 존재 해야 응용 프로그램의 응용 프로그램 코드 블록을 실행 하는 동안 발생 하는 예외를 처리 하는 경우는 `try` 문 이라고는 `try` 블록입니다. throw 된 예외를 처리 하는 응용 프로그램 코드를 `try` 블록 내에 배치 됩니다는 `catch` 문 라고는 `catch` 블록입니다. 0 개 이상의 `catch` 와 연결 된 블록을 `try` 블록 및 각 `catch` 블록을 처리 하는 예외의 형식을 결정 하는 형식 필터를 포함 합니다.  
  
 예외가 발생 하는 경우는 `try` 블록에 시스템 연결 된 검색 `catch` 블록을 찾을 때까지 응용 프로그램 코드에 나타나는 순서에는 `catch` 예외를 처리 하는 블록입니다. A `catch` 형식의 예외를 처리 하는 블록 `T` catch 블록의 형식 필터를 지정 하는 경우 `T` 있는 모든 형식이 또는 `T` 에서 파생 됩니다. 시스템 중지 후 첫 번째를 찾으면 검색 `catch` 예외를 처리 하는 블록입니다. 이러한 이유로 응용 프로그램 코드를 `catch` 전에 형식을 처리 하는 블록을 지정 해야 합니다는 `catch` 이 섹션에 나오는 예제에서 설명한 것 처럼 해당 기본 형식으로 처리 하는 블록. 처리 하는 catch 블록 `System.Exception` 마지막에 지정 됩니다.  
  
 없으면를 `catch` 현재 연결 된 블록 `try` 블록에서 예외를 및 현재 처리 `try` 내 다른 블록에 중첩 `try` 현재 호출에서 차단는 `catch` 다음와 연결 된 블록 바깥쪽 `try` 블록 검색 됩니다. 없으면 `catch` 예외에 대 한 블록을 찾지 못하면, 시스템은 현재 호출의 이전 중첩 수준을 검색 합니다. 없으면 `catch` 차단 예외가 있으면 현재 호출, 예외 호출 스택 위로 전달 됩니다 및은 이전 스택 프레임 검색 되는 `catch` 예외를 처리 하는 블록입니다. 호출 스택 검색에는 예외를 처리 하거나 호출 스택에서 더 이상의 프레임이 없을 때까지 계속 됩니다. 찾지 못한 채 호출 스택의 위쪽에 도달 하면는 `catch` 기본 예외 핸들러가 예외를 처리 하는 블록을 처리 하 고 응용 프로그램을 종료 합니다.  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>예외 형식 기능  
 예외 형식에는 다음 기능을 지원 합니다.  
  
-   오류를 설명 하는 사람이 읽을 수 있는 텍스트입니다. 런타임은 예외가 발생 하면 문제를 해결 하는 오류의 특성의 사용자에 게 알려 및 작업을 제안 사용 가능한 텍스트 메시지입니다. 이 텍스트 메시지에 보유 됩니다는 <xref:System.Exception.Message%2A> 예외 개체의 속성입니다. 예외 개체를 만드는 동안 해당 특정 예외의 세부 정보를 설명 하는 생성자를 텍스트 문자열을 전달할 수 있습니다. 오류 메시지 인수가 없을 생성자에 제공 하면 기본 오류 메시지 사용 됩니다. 자세한 내용은 <xref:System.Exception.Message%2A> 속성을 참조하세요.  
  
-   예외가 throw 되었을 때 호출 스택의 상태입니다. <xref:System.Exception.StackTrace%2A> 속성은 코드에서 오류가 발생 하는 위치를 결정 하는 스택 추적을 제공 합니다. 스택 추적 호출된 되는 모든 메서드가 및 호출이 수행 되는 소스 파일의 줄 번호를 나열 합니다.  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>예외 클래스 속성  
 <xref:System.Exception> 클래스에는 다양 한 코드 위치, 유형, 도움말 파일 및 예외에 대 한 이유를 식별 하는 속성이 포함 되어 있습니다.: <xref:System.Exception.StackTrace%2A>를 <xref:System.Exception.InnerException%2A>, <xref:System.Exception.Message%2A>를 <xref:System.Exception.HelpLink%2A>를 <xref:System.Exception.HResult%2A>, <xref:System.Exception.Source%2A>, <xref:System.Exception.TargetSite%2A>, 및 <xref:System.Exception.Data%2A>합니다.  
  
 두 개 이상의 예외와 인과 관계에 있는 경우는 <xref:System.Exception.InnerException%2A> 속성은이 정보를 유지 합니다. 이 내부 예외에 대 한 응답에서 외부 예외가 발생 합니다. 외부 예외를 처리 하는 코드 이전 내부 예외의 정보를 사용 하 여 오류를 보다 적절 하 게 처리할 수 있습니다. 키/값 쌍의 컬렉션인 예외에 대 한 보충 정보를 저장할 수 있습니다는 <xref:System.Exception.Data%2A> 속성입니다.  
  
 예외 개체를 만드는 동안 생성자에 전달 되는 오류 메시지 문자열을 지역화 해야 하 고 사용 하 여 리소스 파일에서 지정할 수는 <xref:System.Resources.ResourceManager> 클래스입니다. 지역화 된 리소스에 대 한 자세한 내용은 참조는 [위성 어셈블리 만들기](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) 하 고 [리소스 패키징 및 배포](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) 항목입니다.  
  
 예외 발생 원인을 하는 방법에 대 한 광범위 한 정보를 사용 하 여 사용자를 제공 하는 <xref:System.Exception.HelpLink%2A> 속성이 도움말 파일 URL (또는 URN)를 포함할 수 있습니다.  
  
 <xref:System.Exception> 클래스 값 0x80131500 HRESULT COR_E_EXCEPTION를 사용 합니다.  
  
 인스턴스의 초기 속성 값의 목록을 합니다 <xref:System.Exception> 클래스를 참조 하십시오는 <xref:System.Exception.%23ctor%2A> 생성자입니다.  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>성능 고려 사항  
 Throw 되거나 예외를 처리는 상당한 양의 시스템 리소스 및 실행 시간을 소비 합니다. 예측 가능한 이벤트를 처리 또는 흐름 제어 정말 비정상적인 상태를 처리에 예외를 throw 합니다. 예를 들어, 클래스 라이브러리를 개발 하는 경우와 같은 일부 경우에서 하다 메서드 인수를 유효 하지 않은 경우, 올바른 매개 변수를 사용 하 여 호출할 메서드를 기대 하기 때문에 예외를 throw 합니다. 잘못 된 메서드 인수로 사용 오류를의 결과가 아닌 경우 경우에 특별 한 문제가 발생 했음을 의미 합니다. 반대로, 사용자 입력 유효 하지 않은 경우, 종종 잘못 된 데이터를 입력 하는 작업을 할 수 있으므로 예외를 throw 하지 않습니다. 대신, 유효한 입력을 입력할 수 있도록 재시도 메커니즘을 제공 합니다. 또는 사용 오류를 처리 하려면 예외를 사용 해야 합니다. 대신 [어설션을](/visualstudio/debugger/assertions-in-managed-code) 식별 하 고 사용 오류를 수정 합니다.  
  
 반환 코드를; 충분 한 경우 예외를 throw 하지 않는 또한 예외가; 반환 코드를 변환 하지 않습니다 수행 하지 정기적으로 catch 예외, 무시 및 다음 처리를 계속 합니다.  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>예외 다시 throw  
 에서는 대부분의 경우 예외 처리기 단순히가 호출자에 게는 예외를 전달 합니다. 이 대부분에서 자주 발생 합니다.  
  
-   클래스 라이브러리를.NET Framework 클래스 라이브러리 또는 다른 클래스 라이브러리의 메서드 호출을 래핑합니다.  
  
-   응용 프로그램 또는 심각한 예외를 발생 하는 라이브러리입니다. 예외 처리기는 예외를 기록 하 고 예외 다시 throw 할 수 있습니다.  
  
 다시 예외를 throw 하는 권장된 방법은 사용 하기만 하면 되는 [throw](~/docs/csharp/language-reference/keywords/throw.md) C#의 문은 하며 [Throw](~/docs/visual-basic/language-reference/statements/throw-statement.md) 식을 포함 하지 않고 Visual Basic의 문입니다. 이렇게 하면 호출자에 게 예외 전파 될 때 모든 호출 스택 정보가 유지 합니다. 다음은 이에 대한 예입니다. 문자열 확장 메서드를 `FindOccurrences`에 대 한 하나 이상의 호출을 래핑합니다 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> 미리 인수 유효성 검사 없이 합니다.  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 호출자가 호출 `FindOccurrences` 두 번입니다. 두 번째 호출에서 `FindOccurrences`를 호출자에 게 전달을 `null` 사례 검색 문자열로 합니다 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> throw 하는 방법은 <xref:System.ArgumentNullException> 예외입니다. 이 예외를 처리 하는 `FindOccurrences` 메서드와 호출자에 게 다시 전달된 합니다. Throw 문 식 없이 사용 되므로 호출 스택을 유지 됩니다 예제의 출력이 보여 줍니다.  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 반대로, 사용 하 여 다시 예외가 발생 합니다  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 문, 전체 호출 스택을 유지 되지 및 예제에서는 다음과 같은 출력이 생성 됩니다.  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 다소 번거로운 방법은 새 예외를 throw 하는 데 내부 예외가 원래 예외의 호출 스택 정보를 유지 합니다. 호출자에 게 새 예외를 사용할 수 있습니다 <xref:System.Exception.InnerException%2A> 스택 프레임 및 원래 예외에 대 한 기타 정보를 검색할 속성입니다. 이 경우에 throw 문을 다음과 같습니다.  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 알고 있어야 하는 예외를 처리 하는 사용자 코드에는 <xref:System.Exception.InnerException%2A> 다음 예외 처리기에서 볼 수 있듯이 속성 원래 예외에 대 한 정보를 포함 합니다.  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>표준 예외를 선택합니다.  
 예외를 throw 하는 경우 사용자 지정 예외를 구현 하는 대신.NET Framework의 기존 예외 형식을 자주 사용할 수 있습니다. 이러한 두 가지 조건에 표준 예외 형식을 사용 해야 합니다.  
  
-   사용 현황 오류로 인해 발생 하는 예외를 throw 하는 (즉, 메서드를 호출 하는 개발자가 변경한 프로그램 논리의 오류로 인해). 일반적으로 예외를 throw 할와 같은 <xref:System.ArgumentException>, <xref:System.ArgumentNullException>를 <xref:System.InvalidOperationException>, 또는 <xref:System.NotSupportedException>합니다. 예외 개체를 인스턴스화하는 오류를 설명 개발자가 문제를 해결할 수 있도록 하는 경우 예외 개체의 생성자에 제공 하는 문자열입니다. 자세한 내용은 <xref:System.Exception.Message%2A> 속성을 참조하세요.  
  
-   기존.NET Framework 예외를 사용 하 여 호출자에 게 전달 될 수 있는 오류를 처리 하는 합니다. 가능 하면 가장 많이 파생 된 예외를 throw 해야 합니다. 예를 들어 메서드 인수로 열거형의 유효한 멤버에 필요한 경우 throw 해야는 <xref:System.ComponentModel.InvalidEnumArgumentException> (가장 클래스를 파생 하는 데 사용) 아닌 <xref:System.ArgumentException>합니다.  
  
 다음 표에서 일반적인 예외 형식과 되는 사용자가 throw 할 조건을 나열 합니다.  
  
|예외|조건|  
|---------------|---------------|  
|<xref:System.ArgumentException>|메서드에 전달 되는 null이 아닌 인수가 올바르지 않습니다.|  
|<xref:System.ArgumentNullException>|메서드에 전달 되는 인수가 `null`합니다.|  
|<xref:System.ArgumentOutOfRangeException>|인수가 유효한 값의 범위를 벗어납니다.|  
|<xref:System.IO.DirectoryNotFoundException>|디렉터리 경로의 앞쪽 부분은 올바르지 않습니다.|  
|<xref:System.DivideByZeroException>|정수는 분모 또는 <xref:System.Decimal> 나누기 작업은 0입니다.|  
|<xref:System.IO.DriveNotFoundException>|드라이브를 사용할 수 없거나 존재 하지 않습니다.|  
|<xref:System.IO.FileNotFoundException>|파일이 존재 하지 않습니다.|  
|<xref:System.FormatException>|값을 변환할 문자열에서 변환 메서드 같은 적절 한 형식이 아닙니다. `Parse`합니다.|  
|<xref:System.IndexOutOfRangeException>|인덱스 배열 또는 컬렉션의 범위를 벗어납니다.|  
|<xref:System.InvalidOperationException>|메서드 호출이 개체의 현재 상태에서 올바르지 않습니다.|  
|<xref:System.Collections.Generic.KeyNotFoundException>|컬렉션의 멤버에 액세스 하는 것에 대 한 지정된 된 키를 찾을 수 없습니다.|  
|<xref:System.NotImplementedException>|메서드 또는 연산이 구현 되지 됩니다.|  
|<xref:System.NotSupportedException>|메서드 또는 작업이 지원 되지 않습니다.|  
|<xref:System.ObjectDisposedException>|삭제 된 개체에는 작업이 수행 됩니다.|  
|<xref:System.OverflowException>|산술, 캐스팅 또는 변환 작업 결과로 오버플로가 발생 합니다.|  
|<xref:System.IO.PathTooLongException>|경로나 파일 이름에는 시스템 정의 최대 길이 초과합니다.|  
|<xref:System.PlatformNotSupportedException>|작업은 현재 플랫폼에서 지원 되지 않습니다.|  
|<xref:System.RankException>|차원 수가 잘못 된 배열은 메서드에 전달 됩니다.|  
|<xref:System.TimeoutException>|작업에 할당 된 시간 간격이 만료 되었습니다.|  
|<xref:System.UriFormatException>|잘못 된 리소스 URI (Uniform Identifier)가 사용 됩니다.|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>사용자 지정 예외를 구현합니다.  
 다음 경우는 오류 조건을 처리 하기 위해 기존.NET Framework 예외를 사용 하 여 적합 하지 않습니다.  
  
-   경우 예외는 기존.NET Framework 예외를 매핑할 수 없는 고유한 프로그램 오류를 반영 합니다.  
  
-   예외는 기존.NET Framework 예외 나 예외에 대 한 적절 한 처리와에서 다르면 처리가 필요한 경우에 유사한 예외가에서 명확히 구분 해야 합니다. 예를 들어, throw 되는 경우는 <xref:System.ArgumentOutOfRangeException> 대상 정수 계열 형식의 범위를 벗어났습니다 하는 문자열의 숫자 값을 구문 분석할 때 예외를 하지 하려는 호출자에 게 제공 안 함에서 생성 되는 오류에 대 한 동일한 예외를 사용 합니다 적절 한 제한 메서드를 호출할 때 값입니다.  
  
 <xref:System.Exception> 클래스는.NET Framework의 모든 예외의 기본 클래스입니다. 여러 파생된 클래스 멤버의 상속 된 동작에 의존 합니다 <xref:System.Exception> 클래스의 멤버를 재정의 하지 않습니다 <xref:System.Exception>, 고유한 멤버를 정의할 것입니다.  
  
 사용자 고유의 예외 클래스를 정의 합니다.  
  
1.  상속 되는 클래스를 정의 <xref:System.Exception>합니다. 필요한 경우 클래스는 예외에 대 한 추가 정보를 제공 하는 데 필요한 고유 멤버를 정의 합니다. 예를 들어를 <xref:System.ArgumentException> 클래스에 포함 되어는 <xref:System.ArgumentException.ParamName%2A> 인수에서 예외를 발생 시킨 매개 변수의 이름을 지정 하는 속성 및 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 속성을 포함를 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A> 시간 제한 간격을 나타내는 속성입니다.  
  
2.  필요한 경우 모든 상속 된 멤버 변경 하거나 수정 하려면 해당 기능을 재정의 합니다. 대부분의 기존 클래스의 파생 된 <xref:System.Exception> 상속 된 멤버의 동작을 재정의 하지 않습니다.  
  
3.  사용자 지정 예외 개체는 직렬화 할 수 있는지 여부를 결정 합니다. Serialization 예외에 대 한 정보를 저장할 수 있습니다 및 예외 정보를 원격 컨텍스트에서 서버 및 클라이언트 프록시를 공유할 수를 허용 합니다. 예외 개체를 직렬화 할 수 있도록 표시 하는 <xref:System.SerializableAttribute> 특성입니다.  
  
4.  예외 클래스의 생성자를 정의 합니다. 일반적으로 예외 클래스에 다음 생성자 중 하나 이상의:  
  
    -   <xref:System.Exception.%23ctor>에 새 예외 개체의 속성을 초기화 하려면 기본값을 사용 하 합니다.  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>에 지정된 된 오류 메시지를 사용 하 여 새 예외 개체를 초기화 합니다.  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>에 지정 된 오류 메시지와 내부 예외를 사용 하 여 새 예외 개체를 초기화 합니다.  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>에를 `protected` serialize 된 데이터에서 새 예외 개체를 초기화 하는 생성자입니다. 예외 개체를 직렬화 할 수 있도록 선택한 경우이 생성자를 구현 해야 합니다.  
  
 다음 예제에서는 사용자 지정 예외 클래스의 사용을 보여 줍니다. 정의 `NotPrimeException` 클라이언트 소수가 아닌는 시작 숫자를 지정 하 여 소수의 시퀀스를 검색 하려고 할 때 throw 되는 예외입니다. 새 속성을 정의 하는 예외 `NonPrime`는 소수 숫자가 아닌 예외를 발생 시킨 반환 합니다. 매개 변수가 없는 생성자는 protected 생성자 및 사용 하는 생성자를 구현 하는 것 외에도 <xref:System.Runtime.Serialization.SerializationInfo> 하 고 <xref:System.Runtime.Serialization.StreamingContext> serialization에 대 한 매개 변수를 `NotPrimeException` 지원 하기 위해 세 가지 추가 생성자를 정의 하는 클래스를 `NonPrime` 속성.  각 생성자의 여 소수 숫자가 아닌 값을 유지 하는 것 외에도 기본 클래스 생성자를 호출 합니다. 합니다 `NotPrimeException` 클래스도 표시 되는 <xref:System.SerializableAttribute> 특성입니다.  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 `PrimeNumberGenerator` 다음 예와에서 같이 클래스 에라토스테네스의 체를 사용 하 여 해당 클래스 생성자 호출에서 클라이언트가 지정한 제한 2에서 소수 시퀀스를 계산 합니다. 합니다 `GetPrimesFrom` 메서드 지정된 하한값 보다 크거나 같은 경우에 모든 소수를 반환 하지만 throw를 `NotPrimeException` 해당 하한값 소수 없는 경우.  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 두 번 호출 하는 다음 예제는 `GetPrimesFrom` 메서드 사용 하 여 소수가 아닌 숫자를 응용 프로그램 도메인 경계를 교차 하는 중입니다. 두 경우에는 예외가 throw 되 고 클라이언트 코드에서 성공적으로 처리 합니다.  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows 런타임 및 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] 에 대 한 [!INCLUDE[win8](~/includes/win8-md.md)],.NET Framework 이외의 스택 프레임을 통해 예외가 전파 될 때 몇 가지 예외 정보에는 일반적으로 손실 됩니다. 로 시작 합니다 [!INCLUDE[net_v451](~/includes/net-v451-md.md)] 및 [!INCLUDE[win81](~/includes/win81-md.md)], 공용 언어 런타임에서 계속 원래 사용 <xref:System.Exception> 해당 예외는.NET Framework 이외의 스택 프레임에서 수정 된 경우가 아니면 throw 된 개체를 합니다.  
  
   
  
## Examples  
 다음 예제는 `catch` 처리 하도록 정의 된 블록 <xref:System.ArithmeticException> 오류입니다. 이 `catch` catch 블록도 <xref:System.DivideByZeroException> 오류 때문에 <xref:System.DivideByZeroException> 에서 파생 <xref:System.ArithmeticException> 되며 없습니다 `catch` 블록에 대해 명시적으로 정의 된 <xref:System.DivideByZeroException> 오류입니다.  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md">예외 처리 및 Throw</related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">데스크톱 응용 프로그램의 리소스 패키징 및 배포</related>
    <related type="Article" href="https://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1">관리 코드에 어설션 사용</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Exception" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Exception" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 새 인스턴스의 <xref:System.Exception.Message%2A> 속성을 현재 시스템 문화권에 기반하여 해당 오류를 설명하는 시스템 제공 메시지로 초기화합니다.  
  
 모든 파생된 클래스는이 기본 생성자를 제공 해야 합니다. 다음 표에서는 <xref:System.Exception> 인스턴스의 초기 속성 값을 보여 줍니다.  
  
|속성|값|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|null 참조(Visual Basic의 경우 `Nothing`)|  
|<xref:System.Exception.Message%2A>|시스템이 제공하는 지역화된 설명입니다.|  
  
   
  
## Examples  
 다음 코드 예제에서는 파생 되는 `Exception` 미리 정의 된 메시지를 사용 하는 합니다. 코드에는 기본 및 파생된 클래스에 대 한 매개 변수가 없는 생성자의 사용 방법을 보여 줍니다. `Exception` 클래스입니다.  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">오류를 설명하는 메시지입니다.</param>
        <summary>지정된 오류 메시지를 사용하여 <see cref="T:System.Exception" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.Exception.Message%2A> 를 사용 하 여 새 인스턴스의 속성을 `message` 매개 변수입니다. 경우는 `message` 매개 변수가 `null`를 호출할 때와 동일 합니다 <xref:System.Exception.%23ctor%2A> 생성자.  
  
 다음 표에서는 <xref:System.Exception> 인스턴스의 초기 속성 값을 보여 줍니다.  
  
|속성|값|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|null 참조(Visual Basic의 경우 `Nothing`)|  
|<xref:System.Exception.Message%2A>|오류 메시지 문자열입니다.|  
  
   
  
## Examples  
 다음 코드 예제에서는 파생 되는 `Exception` 특정 조건에 대 한 합니다. 코드에는 기본 및 파생된 클래스에 대 한 매개 변수로 호출자가 지정한 메시지를 사용 하는 생성자의 사용 방법을 보여 줍니다. `Exception` 클래스입니다.  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">throw되는 예외에 대해 serialize된 개체 데이터를 보유하는 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</param>
        <param name="context">소스 또는 대상에 대한 컨텍스트 정보를 포함하는 <see cref="T:System.Runtime.Serialization.StreamingContext" />입니다.</param>
        <summary>serialize된 데이터를 사용하여 <see cref="T:System.Exception" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 deserialization을 수행하는 동안 이 생성자를 호출하여 스트림을 통해 전송될 예외 개체를 다시 구성합니다. 자세한 내용은 [XML 및 SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파생 된 정의 serializable `Exception` 클래스입니다. 코드를 0으로 나누기 오류를 강제로 사용 하 여 파생된 예외 인스턴스를 만든 후 합니다 (<xref:System.Runtime.Serialization.SerializationInfo>, <xref:System.Runtime.Serialization.StreamingContext>) 생성자입니다. 코드 파일에 인스턴스를 serialize, 새 예외를 throw 하는 파일을 deserialize 한 다음를 catch 하 예외 데이터를 표시 합니다.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">클래스 이름이 <see langword="null" />이거나 <see cref="P:System.Exception.HResult" />가 0인 경우</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">XML 및 SOAP Serialization</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">예외에 대한 이유를 설명하는 오류 메시지입니다.</param>
        <param name="innerException">현재 예외를 발생시킨 예외입니다. 내부 예외를 지정하지 않은 경우 null 참조(Visual Basic의 경우 <see langword="Nothing" />)입니다.</param>
        <summary>지정된 오류 메시지와 해당 예외의 원인인 내부 예외에 대한 참조를 사용하여 <see cref="T:System.Exception" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이전 예외의 직접적인 결과로 throw되는 예외의 <xref:System.Exception.InnerException%2A> 속성에는 이전 예외에 대한 참조가 들어 있어야 합니다. <xref:System.Exception.InnerException%2A> 속성은 생성자에 전달된 값과 같은 값을 반환하거나 `Nothing` 속성이 생성자에 내부 예외 값을 제공하지 않는 경우에는 null 참조(Visual Basic의 경우 <xref:System.Exception.InnerException%2A>)를 반환합니다.  
  
 다음 표에서는 <xref:System.Exception> 인스턴스의 초기 속성 값을 보여 줍니다.  
  
|속성|값|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|내부 예외 참조입니다.|  
|<xref:System.Exception.Message%2A>|오류 메시지 문자열입니다.|  
  
   
  
## Examples  
 다음 코드 예제에서는 파생 되는 `Exception` 특정 조건에 대 한 합니다. 코드에는 메시지와 내부 예외를 파생된 된 클래스 및 기본 모두에 대 한 매개 변수로 사용 하는 생성자의 사용 방법을 보여 줍니다. `Exception` 클래스입니다.  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>예외에 대한 사용자 정의 추가 정보를 제공하는 키/값 쌍의 컬렉션을 가져옵니다.</summary>
        <value><see cref="T:System.Collections.IDictionary" /> 인터페이스를 구현하며 사용자 정의 키/값 쌍의 컬렉션을 포함하는 개체입니다. 기본값은 빈 컬렉션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Collections.IDictionary?displayProperty=nameWithType> 에서 반환 된 개체는 <xref:System.Exception.Data%2A> 속성을 저장 하 고 예외와 관련 된 보충 정보를 검색 합니다. 정보는 임의 개수의 사용자 정의 키/값 쌍의 형태로 됩니다. 쌍의 값 구성 요소 개체의 형식일 수 있지만 각 키/값 쌍의 핵심 구성 요소는 일반적으로 문자열을 식별 합니다.  
  
## <a name="keyvalue-pair-security"></a>키/값 쌍 보안  
 반환한 컬렉션에 저장 된 키/값 쌍을 <xref:System.Exception.Data%2A> 속성은 안전 하지 않습니다. 응용 프로그램이 중첩 된 일련의 루틴을 호출 하는 경우 예외 처리기를 포함 하는 각 루틴 결과 호출 스택의 해당 예외 처리기의 계층 구조를 포함 합니다. 하위 수준 루틴에서 예외를 throw 하는 경우 호출 스택 계층 구조의 모든 상위 수준 예외 처리기 읽거나 다른 예외 처리기에서 컬렉션에 저장 된 키/값 쌍을 수정할 수 있습니다. 즉, 키/값 쌍의 정보는 기밀 및 응용 프로그램의 키/값 쌍에서 정보를 손상 된 경우 제대로 작동 되도록 해야 합니다.  
  
## <a name="key-conflicts"></a>키 충돌  
 키 충돌 하는 다른 예외 처리기는 키/값 쌍에 액세스 하려면 동일한 키를 지정 하는 경우 발생 합니다. 키 충돌의 결과 하위 수준의 예외 처리기 더 높은 수준의 예외 처리기를 사용 하 여 실수로 통신할 수 있고이 통신에는 미묘한 프로그램 오류가 발생할 수 있습니다 되었기 때문에 응용 프로그램을 개발 하는 경우에 주의 해야 합니다. 그러나 기울인다면 응용 프로그램을 강화 하기 위해 키 충돌을 사용할 수 있습니다.  
  
## <a name="avoiding-key-conflicts"></a>키 충돌을 방지  
 키/값 쌍에 대 한 고유 키를 생성 하는 명명 규칙을 채택 하 여 키 충돌을 방지 합니다. 예를 들어, 응용 프로그램의 마침표로 구분 된 이름으로 구성 된 키, 쌍 및 고유 식별자에 대 한 보충 정보를 제공 하는 메서드 명명 규칙을 생성할 수 있습니다.  
  
 두 응용 프로그램 제품 및 공급 업체 라는 가정 각각에 Sales 라는 메서드가 있습니다. 제품 응용 프로그램에서 Sales 메서드는 제품의 id 번호 (stock keeping unit 또는 SKU)를 제공 합니다. 공급 업체 응용 프로그램에서 Sales 메서드 id 번호 또는 공급자의 SID를 제공합니다. 따라서이 예제에 대 한 명명 규칙 "Products.Sales.SKU" 및 "Suppliers.Sales.SID" 키를 생성합니다.  
  
## <a name="exploiting-key-conflicts"></a>키 충돌을 악용  
 처리를 제어 하려면 하나 이상의 특수 한 푸시합니다 키의 존재를 사용 하 여 키 충돌을 악용 합니다. 가정 시나리오 중 하나를 호출 스택 계층 구조에서 가장 높은 수준의 예외 처리기는 하위 수준의 예외 처리기에서 throw 된 모든 예외를 catch 합니다. 높은 수준의 예외 처리기에서 나머지 키/값 쌍 형식는 특수 키를 사용 하 여 키/값 쌍이 있는 경우는 <xref:System.Collections.IDictionary> 일부 비표준 방식에서 개체 나머지 키/값 쌍을 몇 가지 일반적인 방식으로 서식이 지정 된이 고, 그렇지 합니다.  
  
 이제 예를 들어, 다른 시나리오에서는 호출 스택의 계층 구조의 각 수준에서 예외 처리기를 다음 하위 수준의 예외 핸들러에 의해 throw 된 예외를 catch 합니다. 각 예외 처리기에서 반환 된 컬렉션을 인식 하는 또한는 <xref:System.Exception.Data%2A> 속성 푸시합니다 키 집합을 사용 하 여 액세스할 수 있는 키/값 쌍의 집합을 포함 합니다.  
  
 각 예외 핸들러에서 예외 처리기로 고유한 정보를 사용 하 여 해당 키/값 쌍의 값 구성 요소를 업데이트 하려면 푸시합니다 키 집합을 사용 합니다. 업데이트 프로세스를 완료 한 후 예외 처리기는 다음 더 높은 수준의 예외 처리기로 예외를 throw 합니다. 마지막으로 가장 높은 수준의 예외 처리기는 키/값 쌍에 액세스 하 고 모든 하위 수준의 예외 처리기의 통합된 업데이트 정보가 표시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 추가 하 고 사용 하 여 정보를 검색 합니다 <xref:System.Exception.Data%2A> 속성입니다.  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되었을 때, 하나 이상의 후속 예외의 근본 원인이 되는 <see cref="T:System.Exception" />을 반환합니다.</summary>
        <returns>예외의 체인에서 throw된 첫째 예외입니다. 현재 예외의 <see cref="P:System.Exception.InnerException" /> 속성이 null 참조(Visual Basic에서는 <see langword="Nothing" />)인 경우, 이 속성은 현재 예외를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 체인의 각 예외에서 참조 되는 예외의 직접적인 결과로 throw 된 예외의 체인 구성 예외 집합을 해당 `InnerException` 속성입니다. 주어진된 체인에서 체인의 다른 모든 예외의 근본 원인인 예외를 하나만 있을 수 있습니다. 이 예외는 기본 예외 호출 되 고 `InnerException` 속성은 항상 null 참조를 포함 합니다.  
  
 예외 체인의 모든 예외에 대 한는 `GetBaseException` 메서드 (기본 예외) 동일한 개체를 반환 해야 합니다.  
  
 사용 된 `GetBaseException` 메서드 예외의 근본 원인을 찾으려고 하지만 현재 예외와 첫 번째 예외 간에 발생할 수 있는 예외에 대 한 정보가 필요 하지 않은 경우.  
  
   
  
## Examples  
 다음 코드 예제에서는 파생 된 두 개의 정의 `Exception` 클래스입니다. 예외를 강제로 수행 하 고 각 파생된 클래스를 사용 하 여 다시 throw 합니다. 코드의 사용을 보여 줍니다.는 `GetBaseException` 원래 예외를 검색 하는 방법입니다.  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see langword="GetBaseException" /> 예외 내용 또는 형식이 제어할 필요가 있는 클래스에서 메서드를 재정의 합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">throw되는 예외에 대해 serialize된 개체 데이터를 보유하는 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</param>
        <param name="context">소스 또는 대상에 대한 컨텍스트 정보를 포함하는 <see cref="T:System.Runtime.Serialization.StreamingContext" />입니다.</param>
        <summary>파생 클래스에서 재정의될 때, 예외에 관한 정보를 <see cref="T:System.Runtime.Serialization.SerializationInfo" />에 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObjectData`는 serialization을 위해 대상으로 하는 모든 예외 개체 데이터를 사용하여 <xref:System.Runtime.Serialization.SerializationInfo>를 설정합니다. deserialization을 수행하는 동안 스트림을 통해 전송된 `SerializationInfo`에서 예외가 다시 구성됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파생 된 정의 serializable `Exception` 클래스를 구현 하는 `GetObjectData`, 두 개의 속성에 사소한 변경 그러면 및 다음 호출 기본 클래스를 직렬화를 수행 합니다. 이 예제에서는 0으로 나누기 오류를 강제로 파생 예외 인스턴스를 만든 후 합니다. 코드 파일에 인스턴스를 serialize, 새 예외를 throw 하는 파일을 deserialize 한 다음를 catch 하 예외 데이터를 표시 합니다.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" />매개 변수가 null 참조(Visual Basic에서는 <see langword="Nothing" />)인 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 인스턴스의 런타임 형식을 가져옵니다.</summary>
        <returns>현재 인스턴스의 정확한 런타임 형식을 나타내는 <see cref="T:System.Type" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Exception.GetType%2A> 메서드는.NET Framework 인프라를 지원 하기 위해 존재 하 고 내부적으로 기본 메서드를 호출 <xref:System.Object.GetType%2A?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 예외와 연결된 도움말 파일에 대한 링크를 가져오거나 설정합니다.</summary>
        <value>URN(Uniform Resource Name)이거나, URL(Uniform Resource Locator)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 값은 도움말 파일을 나타내며 URN 또는 URL입니다. 예를 들어를 `HelpLink` 값일 수 있습니다.  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 다음 코드 예제에서는 throw는 `Exception` 로 설정 하는 `HelpLink` 생성자 및 다음 catch 된 예외와 표시 속성 `HelpLink`합니다.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>특정 예외에 할당된 코드화된 숫자 값인 HRESULT를 가져오거나 설정합니다.</summary>
        <value>HRESULT 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULT는 32 비트 값, 다른 세 가지 필드로 구분: 심각도 코드, 기능 코드, 및 오류 코드입니다. 심각도 코드는 반환 값 정보, 경고 또는 오류를 나타내는지 여부를 나타냅니다. 기능 코드 오류에 대 한 시스템 영역을 식별 합니다. 오류 코드는 예외를 표시에 할당 된 고유 번호입니다. 각 예외는 고유한 HRESULT에 매핑됩니다. 관리 코드에서 예외를 throw 하는 경우 런타임 HRESULT를 COM 클라이언트에 전달 합니다. 관리 되지 않는 코드 오류를 반환 하는 경우 다음 런타임에 의해 throw 되는 예외를 HRESULT 변환 됩니다. HRESULT 값과 해당 해당.NET Framework 예외에 대 한 정보를 참조 하세요. [방법: Hresult 및 예외 매핑](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)합니다. 참조 [일반적인 HRESULT 값](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx) 발생할 가능성이 가장 높은 값의 목록은 Windows 문서에서입니다.  
  
 부터 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Exception.HResult%2A> 반면 해당 getter는 공용 속성의 setter 보호 됩니다.  .NET Framework의 이전 버전에서는 getter 및 setter를 모두 보호 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파생 된 정의 `Exception` 설정 하는 클래스는 `HResult` 속성을 생성자의 사용자 지정 값입니다.  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9">방법: HRESULT 및 예외 매핑</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx">일반적인 HRESULT 값</related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 예외를 발생시킨 <see cref="T:System.Exception" /> 인스턴스를 가져옵니다.</summary>
        <value>현재 예외를 발생시키는 오류를 설명하는 개체입니다. <see cref="P:System.Exception.InnerException" /> 속성은 <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> 생성자로 전달된 것과 동일한 값을 반환하거나 생성자에 내부 예외 값을 제공하지 않은 경우 <see langword="null" />을 반환합니다. 이 속성은 읽기 전용입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 예외가 `X` 이전 예외의 직접 결과로 throw 되는 `Y`의 <xref:System.Exception.InnerException%2A> 속성을 `X` 에 대 한 참조를 포함 해야 `Y`합니다.  
  
 현재 예외의 원인이 된 예외 집합을 얻으려면 <xref:System.Exception.InnerException%2A> 속성을 사용합니다.  
  
 이전 예외를 catch 하는 새 예외를 만들 수 있습니다. 예외를 처리는 두 번째 수를 사용 하 여 이전 예외에서 추가 정보를 보다 적절 하 게 오류를 처리 하는 코드입니다.  
  
 파일을 읽고 해당 파일에서 데이터의 형식을 지정 하는 함수 임을 가정 합니다. 이 예제에서는 코드 파일을 읽을 하려고로는 <xref:System.IO.IOException> throw 됩니다. 함수를 catch 합니다 <xref:System.IO.IOException> throw를 <xref:System.IO.FileNotFoundException>입니다. <xref:System.IO.IOException> 에 저장 될 수는 <xref:System.Exception.InnerException%2A> 의 속성을 <xref:System.IO.FileNotFoundException>를 catch 하는 코드를 사용 하도록 설정는 <xref:System.IO.FileNotFoundException> 초기 오류의 원인을 검토 하 합니다.  
  
 <xref:System.Exception.InnerException%2A> , 내부 예외에 대 한 참조를 보유 하는 속성은 예외 개체를 초기화 합니다.  
  
   
  
## Examples  
 다음 예제에서는 throw 및 내부 예외를 참조 하는 예외를 catch 하는 방법을 보여 줍니다.  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 예외를 설명하는 메시지를 가져옵니다.</summary>
        <value>예외의 원인을 설명하는 오류 메시지 또는 빈 문자열("").입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오류 메시지는 예외를 처리 하는 개발자를 대상입니다. 텍스트는 <xref:System.Exception.Message%2A> 속성 오류를 완벽 하 게 설명 해야 하 고, 가능한 경우 오류를 수정 하는 방법에 설명도 해야 합니다. 최상위 예외 처리기 문법적으로 올바른 것 및 메시지의 각 문장의 마침표로 끝나는 해야 하므로, 최종 사용자에 게 메시지를 표시할 수 있습니다. 물음표 또는 느낌표를 사용 하지 마세요. 응용 프로그램에서 지역화 된 예외 메시지를 사용 하는 경우 정확 하 게 변환 하는 것이 해야 합니다.  
  
> [!IMPORTANT]
>  적절 한 권한을 확인 하지 않고 예외 메시지에 중요 한 정보를 공개 하지 않습니다.  
  
 값을 <xref:System.Exception.Message%2A> 속성에서 반환 된 정보에 포함 되어 <xref:System.Exception.ToString%2A>입니다. 합니다 <xref:System.Exception.Message%2A> 만들 때에 속성이 설정 되어를 <xref:System.Exception>입니다. 메시지를 현재 인스턴스에 대 한 생성자에 제공 하는 경우 시스템 현재 시스템 문화권을 사용 하 여 서식이 지정 된 기본 메시지를 제공 합니다.  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows 런타임 및 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 로 시작 합니다 [!INCLUDE[net_v451](~/includes/net-v451-md.md)] 및 [!INCLUDE[win81](~/includes/win81-md.md)], Windows 런타임 형식 및.NET Framework의 일부분이 아닌 멤버에서 전파 되는 예외에서 오류 메시지의 정확도 향상 됩니다. Visual c + + 구성 요소 확장에서 예외 메시지 특히, (C + + /cli CX) 이제.NET Framework에 다시 전파 됩니다 <xref:System.Exception> 개체입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 throw 및 catch 합니다는 <xref:System.Exception> 예외 예외 텍스트를 표시 하 고 사용 하 여 메시지를 <xref:System.Exception.Message%2A> 속성입니다.
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>속성에서 예외를 throw 하 고 텍스트에 참조 해야 할 경우 <see cref="P:System.Exception.Message" /> 설정 또는 가져오기 속성 인수, 속성 인수 이름으로 "value"를 사용 합니다.</para></block>
        <block subset="none" type="overrides"><para><see cref="P:System.Exception.Message" /> 속성 메시지 내용 또는 형식이 제어할 필요가 있는 클래스에서 재정의 됩니다. 일반적으로 응용 프로그램 코드는 예외 발생 했습니다에 대 한 정보를 표시 해야 할 경우이 속성을 액세스 합니다.  
  
오류 메시지를 지역화 해야 합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>예외에 대한 serialize된 데이터가 들어 있는 예외 상태 개체가 만들어지도록 예외가 serialize될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예외 상태 개체를 구현 하는 <xref:System.Runtime.Serialization.ISafeSerializationData> 인터페이스입니다.  
  
 경우는 <xref:System.Exception.SerializeObjectState> 이벤트를 구독, 예외는 역직렬화 되 고 빈 예외로 생성 합니다. 예외의 생성자를 실행 되지 않습니다 및 예외 상태를 역직렬화 할 수도 있습니다. <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A> 예외 상태 개체의 콜백 메서드는 빈 예외를 deserialize 된 데이터를 푸시 수 있도록 다음 알림이 전송 됩니다.  
  
 <xref:System.Exception.SerializeObjectState> 이벤트 예외 데이터 직렬화 및 역직렬화를 투명 하 게 예외 형식을 사용 하도록 설정 합니다. 투명 코드 수 내에서 작동 하는 권한 집합의 범위 내에서 명령을 실행 하지만 없습니다 실행, 호출, 컨트롤에서 파생 또는 중요 한 코드를 포함 합니다.  
  
 경우는 <xref:System.Exception.SerializeObjectState> 이벤트는 구독 하지 않는, 사용 하 여 일반적인 방식으로 deserialization이 발생 합니다 <xref:System.Exception.%23ctor%2A> 생성자입니다.  
  
 일반적으로 대 한 처리기를 <xref:System.Exception.SerializeObjectState> 이벤트는 serialization을 위해 제공 하는 예외의 생성자에 추가 됩니다. 생성자가 없기 때문에 있지만 될 때 실행 되는 <xref:System.Exception.SerializeObjectState> 이벤트 처리기가 실행, 직렬화 deserialize 된 예외를 throw 할 수 있습니다를 <xref:System.Runtime.Serialization.SerializationException> 예외를 deserialize 하려는 동안 예외가 발생 합니다. 이 방지 하려면 추가 해야에 대 한 처리기를 <xref:System.Exception.SerializeObjectState> 이벤트에는 <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> 메서드. 예시 "예" 섹션을 참조 하세요.  
  
   
  
## Examples  
 다음 예제에서는 정의 `BadDivisionException` 처리 하는 <xref:System.Exception.SerializeObjectState> 이벤트. 또한 중첩 된 상태 개체를 포함 라는 구조 `BadDivisionExceptionState` 구현 하는 <xref:System.Runtime.Serialization.ISafeSerializationData> 인터페이스입니다.  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 `BadDivisionException` 0으로 부동 소수점 나누기가 발생 하는 경우 예외가 throw 됩니다. 이 예제에서는 0으로 첫 번째 나누기에서 하는 동안 인스턴스화합니다를 `BadDivisionException` 개체를 serialize 하 고 예외를 throw 합니다. 후속 부서 0으로 발생 하는 경우이 예제에서는 이전에 serialize 된 개체를 역직렬화, reserializes, 및 예외를 throw 개체 serialization, deserialization, reserialization, 및 역직렬화를 제공 하려면이 예제에서는 추가 합니다 <xref:System.Exception.SerializeObjectState> 이벤트 처리기 모두에 `BadDivisionException` 클래스 생성자 및를 <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> 구현 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>이 이벤트 구독을 사용 하는 경우 모든 파생된 형식에 상속 계층 구조에 따라 동일한 serialization 메커니즘을 구현 해야 합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>오류를 발생시키는 애플리케이션 또는 개체의 이름을 가져오거나 설정합니다.</summary>
        <value>오류를 발생시키는 애플리케이션 또는 개체의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Exception.Source%2A> 속성이 명시적으로 설정 되지 않은, 런타임 예외가 발생 한 어셈블리의 이름으로 설정 자동으로 합니다.  
  
   
  
## Examples  
 다음 예제에서는 throw를 `Exception` 로 설정 하는 `Source` 생성자 및 다음 catch 된 예외와 표시 속성 `Source`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">개체는 런타임 <see cref="N:System.Reflection" /> 개체여야 합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>호출 스택의 직접 실행 프레임에 대한 문자열 표현을 가져옵니다.</summary>
        <value>호출 스택의 직접 실행 프레임을 설명하는 문자열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 실행 스택은 특정 시점에 실행 중인 모든 메서드를 추적합니다. 메서드 호출을 추적하는 것을 스택 추적이라고 합니다. 스택 추적 목록은 예외가 발생 메서드의 줄 번호로 호출 스택을 따를 수가 있습니다.  
  
 <xref:System.Exception.StackTrace%2A> 속성은 예외가 throw 된 위치에서 발생 하는 호출 스택의 프레임을 반환 합니다. 새 인스턴스를 만들어 호출 스택에서 추가 프레임에 대 한 정보를 얻을 수 있습니다 합니다 <xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> 클래스 및 사용 하 여 해당 <xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType> 메서드.  
  
 응용 프로그램 코드에서 예외가 발생 될 때마다 스택 추적을 업데이트 하는 CLR (공용 언어 런타임) (사용 하 여는 `throw` 키워드). 예외는 다른 방법 보다 원래 발생 하는 메서드에서 throw 된, 스택 추적 있으면 여기서 예외가 throw 된 원래, 메서드에서 위치와 메서드에서 예외가 있는 위치 다시 throw 합니다. 예외는 throw 되 고 나중에 다시 throw를 동일한 메서드에서 스택 추적은 예외가 다시 throw 된 예외 및 예외가 throw 된 원래 위치에 없는 위치만 포함 됩니다.  
  
 <xref:System.Exception.StackTrace%2A> 속성 수와 같은 코드 변환으로 인해 예상 만큼 많은 메서드 호출을 보고 하지 인라인 처리를 최적화 하는 동안 발생 하는 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 throw를 `Exception` 한 후 catch 하 여 스택 추적을 표시 합니다 `StackTrace` 속성입니다.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see langword="StackTrace" /> 속성 스택 추적 내용 또는 형식이 제어할 필요가 있는 클래스에서 재정의 됩니다.  
  
기본적으로 스택 추적을 예외 개체가 throw 되기 직전 캡처됩니다. 사용 하 여 <see cref="P:System.Environment.StackTrace" /> 예외가 throw 되는 경우 스택 추적 정보를 가져오려고 합니다.</para></block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 예외를 throw하는 메서드를 가져옵니다.</summary>
        <value>현재 예외를 throw하는 <see cref="T:System.Reflection.MethodBase" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스택 추적이 null 참조가 아닌 경우 및이 예외를 throw 하는 메서드를 사용할 수 없는 경우 (`Nothing` Visual basic에서), <xref:System.Exception.TargetSite%2A> 스택 추적에서 메서드를 가져옵니다. 스택 추적이 null 참조인 경우 <xref:System.Exception.TargetSite%2A>도 null 참조를 반환합니다.  
  
> [!NOTE]
>  <xref:System.Exception.TargetSite%2A> 속성 예외 처리기에서 응용 프로그램 도메인 경계를 넘어 예외를 처리 하는 경우 예외가 throw 된 메서드의 이름을 정확 하 게 보고할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 throw를 `Exception` 한 후 catch 하는 원래 메서드를 사용 하 여 표시 된 `TargetSite` 속성.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 예외에 대한 문자열 표현을 만들고 반환합니다.</summary>
        <returns>현재 예외에 대한 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A> 사용자가 이해할 수에 현재 예외에 대 한 표현을 반환 합니다. 문자열 표현을 반환한 문화권 구분 데이터를 포함 하는 예외, 여기서 `ToString` 현재 시스템 문화권을 고려해 야 할 필요 합니다. 반환된 된 문자열의 형식에 대 한 정확한 요구 없습니다 있지만, 사용자가 인식된 된 개체의 값을 반영 하도록 시도해 야 합니다.  
  
 기본 구현의 <xref:System.Exception.ToString%2A> 현재 예외, 메시지, 호출의 결과 발생 시킨 클래스의 이름을 가져옵니다 <xref:System.Exception.ToString%2A> 내부 예외를 호출 하는 결과에 <xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>입니다. 이러한 멤버 중 하나라도 `null`, 값은 반환된 된 문자열에 포함 되지 않습니다.  
  
 오류 메시지가 없는 경우 또는 빈 문자열인 경우 (""), 오류 메시지가 반환 됩니다. 내부 예외 및 스택 추적의 이름을 하지 않은 경우에 반환 됩니다 `null`합니다.  
  
 이 메서드는 <xref:System.Object.ToString%2A?displayProperty=nameWithType>를 재정의합니다.  
  
   
  
## Examples  
 다음 예제에서는 예외를 발생 하 고 호출의 결과 표시 <xref:System.Exception.ToString%2A> 는 예외입니다. 유의 합니다 <xref:System.Exception.ToString%2A?displayProperty=nameWithType> 메서드는 예외 클래스 인스턴스를 사용 하는 인수 목록에 표시 되 면 암시적으로 호출 됩니다는 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 메서드.  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>