<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0107f34042bafd33bffc1d75b077e1fc01fccfa2" /><Meta Name="ms.sourcegitcommit" Value="8c966994f39ffe6e7c21611e9ec1b91247a68500" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="01/26/2019" /><Meta Name="ms.locfileid" Value="55084722" /></Metadata><TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <TypeSignature Language="F#" Value="type Lazy&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">느리게 초기화되는 개체의 형식입니다.</typeparam>
    <summary>초기화 지연에 대한 지원을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이러한 생성 또는 실행 프로그램의 수명 동안 발생 하지 않는 경우에 특히 대규모 또는 리소스를 많이 사용 개체를 생성 하거나 리소스 집약적인 작업을 실행을 지연 시키려면 지연 초기화를 사용 합니다.  
  
 만든 인스턴스의 초기화 지연에 대 한 준비가 <xref:System.Lazy%601>합니다. 형식 인수는 <xref:System.Lazy%601> 만든 개체는 초기화 지연 하려는 개체의 형식을 지정 합니다. 만드는 데 사용할 수 있는 생성자는 <xref:System.Lazy%601> 개체 초기화의 특징을 결정 합니다. 처음으로 <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> 속성에 액세스할 때 초기화 지연이 발생합니다.  
  
 대부분의 경우에서이 두 질문에 답변에 따라 달라 집니다 생성자를 선택 합니다.  
  
-   지연 초기화 된 개체는 둘 이상의 스레드에서 액세스할 수 있습니까? 그렇다면는 <xref:System.Lazy%601> 개체 모든 스레드에서 만들 수 있습니다. 기본 동작은 스레드로부터 안전한을 만들려면 해당 하는 간단한 생성자 중 하나를 사용할 수 있습니다 <xref:System.Lazy%601> 개체 이므로 지연 인스턴스화된 개체의 인스턴스를 하나만 스레드 수를 액세스 하려고 하는 관계 없이 만들어집니다. 만들려는 <xref:System.Lazy%601> 스레드로부터 안전 하지 않은 개체에 없는 스레드로부터의 안전성을 지정할 수 있도록 하는 생성자를 사용 해야 합니다.  
  
    > [!CAUTION]
    >  만들기는 <xref:System.Lazy%601> 개체 스레드로부터 안전한 지연 초기화 된 개체를 보호 하지 않습니다. 여러 스레드가 지연 초기화 된 개체에 액세스 하는 경우 해야 해당 속성과 메서드에 다중 스레드 액세스에 대 한 안전 합니다.  
  
-   초기화 지연 코드의 많은 필요가 지연 초기화 된 개체에 필요 하 고 예외를 throw 하지 않습니다 모든 작업을 수행 하는 기본 생성자가 있는지 여부 초기화 코드를 작성 해야 할 경우 또는 예외를 처리 해야 하는 경우, 팩터리 메서드를 사용 하는 생성자 중 하나를 사용 합니다. 팩터리 메서드에 초기화 코드를 작성 합니다.  
  
 다음 표에서 이러한 두 가지 요인에 기반을 선택 하는 생성자를 보여 줍니다.  
  
|개체에 액세스|초기화 코드 없이 필요한 경우 (기본 생성자)를 사용 하 여|사용 하 여 초기화 코드가 필요한 경우|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|여러 스레드|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|스레드 하나|<xref:System.Lazy%601.%23ctor%28System.Boolean%29> 사용 하 여 `isThreadSafe` 로 `false`합니다.|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> 사용 하 여 `isThreadSafe` 로 `false`합니다.|  
  
 팩터리 메서드를 지정 하는 람다 식을 사용할 수 있습니다. 이렇게 하면 한 곳에서 모든 초기화 코드가 있습니다. 람다 식 지연 초기화 된 개체의 생성자에 전달할 인수를 포함 하는 컨텍스트를 캡처합니다.  
  
 **예외 캐싱을** 팩터리 메서드를 사용 하는 경우 예외가 캐시 됩니다. 즉, 팩터리 메서드 시간을 첫 번째 예외를 throw 하는 경우 스레드 액세스를 시도 합니다 <xref:System.Lazy%601.Value%2A> 속성의는 <xref:System.Lazy%601> 개체를 이후의 모든 시도에서 동일한 예외가 throw 됩니다. 이렇게 하면 모든 호출을 <xref:System.Lazy%601.Value%2A> 속성 동일한 결과 생성 하 고 다른 스레드가 다른 결과 얻을 경우 발생할 수 있는 사소한 오류를 방지 합니다. 합니다 <xref:System.Lazy%601> 대신 실제 `T` 는 그렇지 않은 경우는 초기화 된 후 이전 특정 시점에 시작 하는 동안 일반적으로 합니다. 이전 이때 오류는 일반적으로 치명적입니다. 복구 가능한 오류가 발생할 경우 초기화 지연을 사용 하지 않는 경우와 마찬가지로 재시도 논리 (이 예제의 경우 팩터리 메서드), 초기화 루틴을 작성 하는 것이 좋습니다.  
  
 **잠금 대신** 상황에서 오버 헤드를 방지 하려는 <xref:System.Lazy%601> 개체의 기본 잠금 동작 합니다. 드문 경우에서 교착 상태가 발생할 수 있습니다. 이러한 경우에 사용할 수 있습니다 합니다 <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> 또는 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> 생성자를 지정 하 고 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>입니다. 이 통해 합니다 <xref:System.Lazy%601> 스레드를 호출 하는 경우 여러 스레드를 각 지연 초기화 된 개체의 복사본을 만드는 개체는 <xref:System.Lazy%601.Value%2A> 속성 동시에 합니다. <xref:System.Lazy%601> 개체 하면 모든 스레드가 지연 초기화 된 개체의 동일한 인스턴스를 사용 하는 사용 되지 않는 인스턴스를 삭제 합니다. 따라서 잠금 오버 헤드를 줄이는 비용은 프로그램 만들기 및 비용이 많이 드는 개체의 추가 복사본을 삭제 경우도 있습니다. 대부분의 경우에서 가능성은 없습니다. 에 대 한 예제는 <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> 고 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> 생성자가이 동작을 보여 줍니다.  
  
> [!IMPORTANT]
>  지정 하는 경우 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, 예외는 되지 캐시 팩터리 메서드를 지정 하는 경우에 합니다.  
  
 **해당 생성자** 사용 하도록 설정 하는 것 외에도 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>서 <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> 및 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> 생성자는 다른 생성자의 기능을 복제할 수 있습니다. 다음 표에서 해당 동작을 생성 하는 매개 변수 값을 보여 줍니다.  
  
|만들려는 <xref:System.Lazy%601> 개체|생성자에는 `LazyThreadSafetyMode` `mode` 매개 변수를 설정 `mode` 를|부울 생성자에 대 한 `isThreadSafe` 매개 변수를 설정 `isThreadSafe` 를|스레드 안전성 매개 변수가 없는 생성자|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|완벽 하 게 스레드로부터 안전 합니다. 해당 스레드가 하나만 있도록 잠금을 사용 하 여 값을 초기화 합니다.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|이러한 모든 생성자는 완벽 하 게 스레드로부터 안전 합니다.|  
|스레드로부터 안전 하지 않습니다.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|해당 사항 없음.|  
|완벽 하 게 스레드로부터 안전 합니다. 스레드 경합 값을 초기화 합니다.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|해당 사항 없음.|해당 사항 없음.|  
  
 **다른 기능** 사용에 대 한 자세한 <xref:System.Lazy%601> thread 정적 필드 또는 속성에 대 한 백업 저장소로 참조 [초기화 지연](~/docs/framework/performance/lazy-initialization.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 된 <xref:System.Lazy%601> 여러 스레드로부터의 액세스를에서 사용 하 여 지연 초기화를 제공 하는 클래스입니다.  
  
> [!NOTE]
>  이 예제에서는 사용 된 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> 생성자입니다. 사용 하는 방법도 보여 줍니다 합니다 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> 생성자 (지정 `true` 에 대 한 `isThreadSafe`) 및 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> 생성자 (지정 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> 에 대 한 `mode`). 다른 생성자를 전환 하는 생성자는 주석으로 처리 변경 하기만 됩니다.  
>   
>  예외를 보여 주는 예제에 대 한 참조는 같은 생성자를 사용 하 여 캐싱용는 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> 생성자입니다.  
  
 이 예제에서는 여러 스레드 중 하나를 사용하여 지연 초기화될 `LargeObject` 클래스를 정의합니다. 코드의 네 가지 주요 섹션 이니셜라이저, 팩터리 메서드, 실제 초기화 및 생성자의 생성을 보여 줍니다는 `LargeObject` 클래스 개체를 만들 때 메시지를 표시 합니다. 예제에서는 `Main` 메서드의 시작 부분에서 `LargeObject`에 대해 스레드로부터 안전한 지연 이니셜라이저를 만듭니다.  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 팩터리 메서드 추가로 초기화에 대 한 자리 표시자를 사용 하 여 개체의 생성을 보여 줍니다.  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 처음 두 코드 섹션에서는 다음과 같이 람다 함수를 사용 하 여 결합할 수 없습니다 note:  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 이 예제에서는 초기화 지연이 발생 하기 전에 정해 지지 않은 기간 경과 될 수 있습니다를 나타내기 위해 일시 중지 합니다. 누를 때 합니다 **Enter** 키, 예제를 만들고 세 개의 스레드를 시작 합니다. 합니다 `ThreadProc` 모든 세 개의 스레드 호출에 의해 사용 되는 메서드는 <xref:System.Lazy%601.Value%2A> 속성입니다. 이 경우 처음으로 `LargeObject` 인스턴스가 만들어집니다.  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 생성자는 `LargeObject` 클래스 코드의 마지막 키 섹션을 포함 하는 메시지를 표시 하 고 초기화 하는 동안 스레드 id를 기록 합니다. 프로그램의 출력은 전체 코드 목록 끝에 나타납니다.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  편의상 이 예제에서는 <xref:System.Lazy%601>의 전역 인스턴스를 사용하며, 모든 메서드는 `static`(Visual Basic의 경우 `Shared`)입니다. 이는 초기화 지연의 사용에 필요한 요구 사항은 아닙니다.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>기본적으로의 모든 public 및 protected 멤버는 <see cref="T:System.Lazy`1" /> 클래스는 스레드로부터 안전 하 고 여러 스레드에서 동시에 사용할 수 있습니다. 필요에 따라 및 형식의 생성자에 매개 변수를 사용 하 여 인스턴스당 이러한 스레드로부터의 안전성 보장을 제거할 수 있습니다.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">초기화 지연</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Lazy`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Lazy`1" /> 클래스의 새 인스턴스를 초기화합니다. 초기화 지연이 발생하는 경우 대상 형식의 기본 생성자가 사용됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용 하 여 만든 인스턴스는 여러 스레드에서 동시에 사용할 수 있습니다.  
  
 스레드 보안 모드를 <xref:System.Lazy%601> 이 생성자를 사용 하 여 초기화 되는 인스턴스는 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>합니다. 스레드 안전 모드는 여러 스레드가 초기화 하려고 시도할 때 동작을 설명 합니다 <xref:System.Lazy%601> 인스턴스.  
  
 <xref:System.Lazy%601> 이 생성자를 사용 하 여 만든 인스턴스 예외를 캐시 하지 않습니다. 자세한 내용은 <xref:System.Lazy%601> 클래스 또는 <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 열거형을 참조하십시오.  
  
   
  
## Examples  
 다음 예제에서는이 생성자를 사용 하는 방법을 보여 줍니다. 사용도 보여 줍니다 합니다 <xref:System.Lazy%601.%23ctor%28System.Boolean%29> 생성자 (지정 `true` 에 대 한 `isThreadSafe`) 및 <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> 생성자 (지정 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> 에 대 한 `mode`). 다른 생성자를 전환 하는 생성자는 주석으로 처리 변경 하기만 됩니다.  
  
 이 예제에서는 여러 스레드 중 하나를 사용하여 지연 초기화될 `LargeObject` 클래스를 정의합니다. 이 예제의 코드의 두 가지 핵심 줄은 이니셜라이저 및 실제 초기화를 생성 합니다. 예제에서는 `Main` 메서드의 시작 부분에서 `LargeObject`에 대해 스레드로부터 안전한 지연 이니셜라이저를 만듭니다.  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 예제를 만들고 세 개의 스레드를 차단 하는 시작을 <xref:System.Threading.ManualResetEvent> 개체 예제는 한 번에 스레드를 해제할 수 있도록 합니다. `ThreadProc` 모든 세 개의 스레드 호출에 의해 사용 되는 메서드를 <xref:System.Lazy%601.Value%2A> 가져올 속성을 `LargeObject` 인스턴스:  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 합니다 <xref:System.Lazy%601> 클래스 잠금, 스레드를 하나만 만들 수 있도록 제공 된 `LargeObject` 인스턴스. 이 예제에서는 모든 다른 스레드가 동일한 인스턴스를 가져옵니다 하 하는 방법을 보여 줍니다.  
  
> [!NOTE]
>  편의상 이 예제에서는 <xref:System.Lazy%601>의 전역 인스턴스를 사용하며, 모든 메서드는 `static`(Visual Basic의 경우 `Shared`)입니다. 이는 초기화 지연의 사용에 필요한 요구 사항은 아닙니다.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">초기화 지연</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; isThreadSafe" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe">이 인스턴스를 여러 스레드에서 동시에 사용할 수 있으면 <see langword="true" />이고, 이 인스턴스를 한 번에 한 스레드에서만 사용할 수 있으면 <see langword="false" />입니다.</param>
        <summary><see cref="T:System.Lazy`1" /> 클래스의 새 인스턴스를 초기화합니다. 초기화 지연이 발생하는 경우 대상 형식의 기본 생성자 및 지정된 초기화 모드가 사용됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드 보안 모드를 <xref:System.Lazy%601> 이 생성자를 사용 하 여 초기화 되는 인스턴스는 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> 경우 `isThreadSafe` 는 `true`고, 그렇지 않으면 모드는 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. 스레드 안전 모드는 여러 스레드가 초기화 하려고 시도할 때 동작을 설명 합니다 <xref:System.Lazy%601> 인스턴스. 지정 하는 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> 모드를 사용 합니다 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> 또는 <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> 생성자.  
  
 <xref:System.Lazy%601> 이 생성자를 사용 하 여 만든 인스턴스 예외를 캐시 하지 않습니다. 자세한 내용은 <xref:System.Lazy%601> 클래스 또는 <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 열거형을 참조하십시오.  
  
   
  
## Examples  
 다음 예제에서는 스레드 지연 초기화 된 개체에 대 한 모든 액세스 동일한 스레드에서 발생 하는 시나리오에 대 한 안전 하지 않은 지연 이니셜라이저를 만들려면이 생성자를 사용 하는 방법을 보여 줍니다. 사용 하는 방법도 보여 줍니다 합니다 <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> 생성자 (지정 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> 에 대 한 `mode`합니다. 다른 생성자를 전환 하려면 바꾸면 생성자 주석으로 처리 됩니다.  
  
> [!NOTE]
>  다중 스레드 시나리오에서이 생성자를 사용 하는 방법을 보여 주는 코드에 대 한 (지정 `true` 에 대 한 `isThreadSafe`)에 대 한 예제를 참조 하세요.를 <xref:System.Lazy%601.%23ctor> 생성자입니다.  
  
 이 예제에서는 정의 `LargeObject` 지연 초기화 될 클래스입니다. 에 `Main` 메서드는이 예제에서는 생성을 <xref:System.Lazy%601> 인스턴스 및 일시 중지 합니다. 누를 때를 **Enter** 키, 예제에 액세스를 <xref:System.Lazy%601.Value%2A> 의 속성을 <xref:System.Lazy%601> 초기화가 발생 시키는 인스턴스. 생성자는 `LargeObject` 콘솔 메시지를 표시 하는 클래스입니다.  
  
> [!NOTE]
>  편의상 이 예제에서는 <xref:System.Lazy%601>의 전역 인스턴스를 사용하며, 모든 메서드는 `static`(Visual Basic의 경우 `Shared`)입니다. 이는 초기화 지연의 사용에 필요한 요구 사항은 아닙니다.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">초기화 지연</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; valueFactory" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="valueFactory">필요할 때 지연된 초기화 값을 생성하기 위해 호출된 대리자입니다.</param>
        <summary><see cref="T:System.Lazy`1" /> 클래스의 새 인스턴스를 초기화합니다. 초기화 지연이 발생하는 경우 지정된 초기화 함수가 사용됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용 하 여 만든 인스턴스는 여러 스레드에서 동시에 사용할 수 있습니다.  
  
 스레드 보안 모드를 <xref:System.Lazy%601> 이 생성자를 사용 하 여 초기화 되는 인스턴스는 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>합니다. 스레드 안전 모드는 여러 스레드가 초기화 하려고 시도할 때 동작을 설명 합니다 <xref:System.Lazy%601> 인스턴스.  
  
 throw 된 예외 `valueFactory` 캐시 됩니다. 자세한 내용은 <xref:System.Lazy%601> 클래스 또는 <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 열거형을 참조하십시오.  
  
   
  
## Examples  
 다음 예제에서는 예외 캐싱을 사용 하 여 지연 초기화를 제공 하려면이 생성자를 사용 하는 방법을 보여 줍니다. 사용 하는 방법도 보여 줍니다 합니다 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> 생성자 (지정 `true` 에 대 한 `isThreadSafe`) 및 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> 생성자 (지정 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> 에 대 한 `mode`). 다른 생성자를 전환 하는 생성자는 주석으로 처리 변경 하기만 됩니다.  
  
 이 예제에서는 여러 스레드 중 하나를 사용하여 지연 초기화될 `LargeObject` 클래스를 정의합니다. 코드의 세 가지 주요 섹션의 생성자, 실제 초기화 및 이니셜라이저 만들기를 보여 줍니다.는 `LargeObject` 클래스 예외 캐싱을 하는 방법을 보여 줍니다. 예제에서는 `Main` 메서드의 시작 부분에서 `LargeObject`에 대해 스레드로부터 안전한 지연 이니셜라이저를 만듭니다.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 이 예제에서는 만들고 세 개의 스레드를 시작 합니다. `ThreadProc` 모든 세 개의 스레드 호출에 의해 사용 되는 메서드를 <xref:System.Lazy%601.Value%2A> 가져올 속성을 `LargeObject` 인스턴스:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 생성자에는 `LargeObject` 클래스 코드의 세 번째 키 섹션을 처음으로 예외를 throw를 `LargeObject` 인스턴스가 만들어지지만 그 되려면 인스턴스를 만들 수 있습니다:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 예제를 실행할 때의 인스턴스를 만들려고 시도 하는 첫 번째 스레드가 `LargeObject` 실패 및 예외 포착 됩니다. 다음 스레드는 인스턴스를 만들려면 예상할 수 있지만 <xref:System.Lazy%601> 개체에서 예외를 캐시 합니다. 이 때문에 세 개의 스레드 예외를 throw 합니다.  
  
> [!NOTE]
>  편의상 이 예제에서는 <xref:System.Lazy%601>의 전역 인스턴스를 사용하며, 모든 메서드는 `static`(Visual Basic의 경우 `Shared`)입니다. 이는 초기화 지연의 사용에 필요한 요구 사항은 아닙니다.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" />가 <see langword="null" />인 경우</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">초기화 지연</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; mode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="mode">스레드 보안 모드를 지정하는 열거형 값 중 하나입니다.</param>
        <summary><paramref name="T" />의 기본 생성자 및 지정된 스레드 보안 모드를 사용하는 <see cref="T:System.Lazy`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드 보안 모드를 <xref:System.Lazy%601> 인스턴스가 여러 스레드 초기화 하려고 시도할 때 동작을 설명 합니다는 <xref:System.Lazy%601> 인스턴스.  
  
 <xref:System.Lazy%601> 이 생성자를 사용 하 여 만든 인스턴스 예외를 캐시 하지 않습니다. 자세한 내용은 <xref:System.Lazy%601> 클래스 또는 <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 열거형을 참조하십시오.  
  
   
  
## Examples  
 다음 예제에서는 여러 스레드 경합 지연 개체를 만들 수 있도록 하는 지연 이니셜라이저를 만들려면이 생성자를 사용 하는 방법을 보여 줍니다. 인스턴스를 만드는 여러 스레드가 성공 하더라도 모든 스레드는 먼저 생성 된 인스턴스를 사용 합니다.  
  
> [!NOTE]
>  단일 스레드 시나리오에서이 생성자를 사용 하는 방법을 보여 주는 예 (지정 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> 에 대 한 `mode`), 참조는 <xref:System.Lazy%601.%23ctor%28System.Boolean%29> 생성자입니다. 다중 스레드 시나리오에서 경합 하는 대신 잠금을 제공 하려면이 생성자를 사용 하는 방법에 설명 하는 예제 (지정 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> 에 대 한 `mode`), 참조는 <xref:System.Lazy%601.%23ctor> 생성자입니다.  
  
 이 예제에서는 정의 `LargeObject` 몇 개의 스레드 중 하나에서 지연 초기화 될 클래스입니다. 코드의 세 가지 주요 섹션에 설명 이니셜라이저, 실제 초기화 및 생성자의 만들기와의 종료자는 `LargeObject` 클래스입니다. 맨 앞에 `Main` 메서드를 만듭니다 합니다 <xref:System.Lazy%601> 의 초기화 지연을 수행 하는 개체는 `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 예제를 만들고 세 개의 스레드를 차단 하는 시작을 <xref:System.Threading.ManualResetEvent> 개체 예제는 한 번에 스레드를 해제할 수 있도록 합니다. 에 `ThreadProc` 모든 세 개의 스레드를 호출 하 여 사용 되는 메서드를 <xref:System.Lazy%601.Value%2A> 속성을 만듭니다는 `LargeObject` 인스턴스:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 때문에 대 한 생성자는 <xref:System.Lazy%601> 지정 된 인스턴스 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, 세 개의 스레드를 만들 수 `LargeObject` 인스턴스. 이 예제에서는 생성자와의 종료자에서 콘솔 메시지를 표시 하 여이 보여 줍니다는 `LargeObject` 클래스:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 그러나는 <xref:System.Lazy%601> 개체 인스턴스를 하나만 모든 스레드를 사용해 확인 합니다. 예제의 출력이 동일한 인스턴스 및도 보여 줍니다 가비지 컬렉션에서 다른 두 인스턴스를 회수할 수 있습니다 세 개의 스레드를 사용 하는 보여 줍니다.  
  
> [!NOTE]
>  편의상 이 예제에서는 <xref:System.Lazy%601>의 전역 인스턴스를 사용하며, 모든 메서드는 `static`(Visual Basic의 경우 `Shared`)입니다. 이는 초기화 지연의 사용에 필요한 요구 사항은 아닙니다.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />에 잘못된 값이 포함된 경우</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">초기화 지연</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : 'T -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">사용될 미리 초기화된 값입니다.</param>
        <summary>미리 초기화된 지정 값을 사용하는 <see cref="T:System.Lazy`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
이 생성자를 사용 하 여 만든 인스턴스는 동시에 여러 스레드에서 사용할 수 있습니다.
]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, isThreadSafe)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="valueFactory">필요할 때 지연된 초기화 값을 생성하기 위해 호출된 대리자입니다.</param>
        <param name="isThreadSafe">이 인스턴스를 여러 스레드에서 동시에 사용할 수 있으면 <see langword="true" />이고, 이 인스턴스를 한 번에 한 스레드에서만 사용할 수 있으면 <see langword="false" />입니다.</param>
        <summary><see cref="T:System.Lazy`1" /> 클래스의 새 인스턴스를 초기화합니다. 초기화 지연이 발생하는 경우 지정된 초기화 함수 및 초기화 모드가 사용됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드 보안 모드를 <xref:System.Lazy%601> 이 생성자를 사용 하 여 초기화 되는 인스턴스는 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> 경우 `isThreadSafe` 는 `true`고, 그렇지 않으면 모드는 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. 스레드 안전 모드는 여러 스레드가 초기화 하려고 시도할 때 동작을 설명 합니다 <xref:System.Lazy%601> 인스턴스.  
  
 지정 하는 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> 모드를 사용 합니다 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> 또는 <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> 생성자.  
  
 throw 된 예외 `valueFactory` 캐시 됩니다. 자세한 내용은 <xref:System.Lazy%601> 클래스 또는 <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 열거형을 참조하십시오.  
  
   
  
## Examples  
 다음 예제에서는 캐싱, 단일 스레드 시나리오에서 예외를 사용 하 여 지연 초기화를 제공 하려면이 생성자를 사용 하는 방법을 보여 줍니다. 사용 하는 방법도 보여 줍니다 합니다 <xref:System.Lazy%601.%23ctor%2A> 생성자 (지정 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> 에 대 한 `mode`). 해당 생성자를 전환 하려면 바꾸면 생성자 주석으로 처리 됩니다.  
  
> [!NOTE]
>  다중 스레드 시나리오에서이 생성자를 사용 하는 방법을 보여 주는 코드에 대 한 (지정 `true` 에 대 한 `isThreadSafe`)에 대 한 예제를 참조 하세요.를 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> 생성자입니다.  
  
 이 예제에서는 여러 스레드 중 하나를 사용하여 지연 초기화될 `LargeObject` 클래스를 정의합니다. 코드의 세 가지 주요 섹션의 생성자, 실제 초기화 및 이니셜라이저 만들기를 보여 줍니다.는 `LargeObject` 클래스 예외 캐싱을 하는 방법을 보여 줍니다. 예제에서는 `Main` 메서드의 시작 부분에서 `LargeObject`에 대해 스레드로부터 안전한 지연 이니셜라이저를 만듭니다.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 생성자 호출에는 `isThreadSafe` 매개 변수가 `false`이므로 <xref:System.Lazy%601> 은 스레드로부터 안전 합니다. 이 예제에서는 호출 하는 스레드로부터 안전 하지 않으므로 <xref:System.Lazy%601.Value%2A> 세 번 동일한 스레드에서 속성:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 생성자에는 `LargeObject` 클래스 코드의 세 번째 키 섹션을 처음으로 예외를 throw를 `LargeObject` 인스턴스가 만들어지지만 그 되려면 인스턴스를 만들 수 있습니다:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 예제를 실행할 때의 인스턴스를 만드는 첫 번째 시도 `LargeObject` 실패 및 예외 포착 됩니다. 예상한 다음 시도 성공 하지만 <xref:System.Lazy%601> 개체에서 예외를 캐시 합니다. 이 인해 모든 세 번의 시도가 예외를 throw 합니다.  
  
> [!NOTE]
>  편의상 이 예제에서는 <xref:System.Lazy%601>의 전역 인스턴스를 사용하며, 모든 메서드는 `static`(Visual Basic의 경우 `Shared`)입니다. 이는 초기화 지연의 사용에 필요한 요구 사항은 아닙니다.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" />가 <see langword="null" />인 경우</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">초기화 지연</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="valueFactory">필요할 때 지연된 초기화 값을 생성하기 위해 호출된 대리자입니다.</param>
        <param name="mode">스레드 보안 모드를 지정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 초기화 함수 및 스레드 보안 모드를 사용하는 <see cref="T:System.Lazy`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드 보안 모드를 <xref:System.Lazy%601> 인스턴스가 여러 스레드 초기화 하려고 시도할 때 동작을 설명 합니다는 <xref:System.Lazy%601> 인스턴스.  
  
 throw 된 예외 `valueFactory` 캐시 된 경우가 아니면 `mode` 는 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>합니다. 자세한 내용은 <xref:System.Lazy%601> 클래스 또는 <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> 열거형을 참조하십시오.  
  
   
  
## Examples  
 다음 예제에서는 여러 스레드 경합 지연 개체를 만들 수 있도록 하는 지연 이니셜라이저를 만들려면이 생성자를 사용 하는 방법을 보여 줍니다. 인스턴스를 만드는 여러 스레드가 성공 하더라도 모든 스레드는 먼저 생성 된 인스턴스를 사용 합니다. 또한 예제에 지정 하는 경우 예외가 캐시 되지 않습니다는 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>지연 생성된 된 형식에 기본 생성자가 초기화를 대신 함수에서 수행 하는 경우에 합니다.  
  
> [!NOTE]
>  단일 스레드 시나리오에서이 생성자를 사용 하는 방법을 보여 주는 예 (지정 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> 에 대 한 `mode`), 참조는 <xref:System.Lazy%601.%23ctor%28System.Boolean%29> 생성자입니다. 다중 스레드 시나리오에서 경합 하는 대신 잠금을 제공 하려면이 생성자를 사용 하는 방법에 설명 하는 예제 (지정 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> 에 대 한 `mode`), 참조는 <xref:System.Lazy%601.%23ctor> 생성자입니다.  
  
 이 예제에서는 정의 `LargeObject` 몇 개의 스레드 중 하나에서 지연 초기화 될 클래스입니다. 코드의 네 가지 주요 섹션에 설명의 이니셜라이저, 실제 초기화, 초기화 함수를 생성자 만들기와의 종료자는 `LargeObject` 클래스입니다. 맨 앞에 `Main` 메서드를 만듭니다 합니다 <xref:System.Lazy%601> 의 초기화 지연을 수행 하는 개체는 `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 지연 이니셜라이저는 초기화를 수행 하는 함수를 사용 합니다. 이 경우 함수는에 대 한 기본 생성자가 없는 있기 때문에 필요 합니다 `LargeObject` 클래스입니다.  
  
 예제를 만들고 세 개의 스레드를 차단 하는 시작을 <xref:System.Threading.ManualResetEvent> 개체 예제는 한 번에 스레드를 해제할 수 있도록 합니다. 에 `ThreadProc` 모든 세 개의 스레드를 호출 하 여 사용 되는 메서드를 <xref:System.Lazy%601.Value%2A> 속성을 만듭니다는 `LargeObject` 인스턴스:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 코드의 세 번째 키 섹션을 만들려면 지연 초기화 함수 호출을 `LargeObject` 인스턴스. 함수 라고 하는 첫 번째 예외 시간을 throw 됩니다.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 모든 다른 <xref:System.Threading.LazyThreadSafetyMode> 설정, 초기화 함수에서 처리 되지 않은 예외가 캐시 됩니다. 그러나 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> 예외 캐싱을 표시 하지 않습니다. 예제의 출력 개체를 초기화 하면 이후 시도 성공 하는 방법을 보여 줍니다.  
  
> [!NOTE]
>  예외 메시지는 일반적으로 메시지를 나타내는 다른 스레드가 개체를 초기화 했습니다. 한 후 표시 됩니다. Throw 하 고 예외를 catch 하 여 도입 된 지연 때문입니다.  
  
 때문에 대 한 생성자는 <xref:System.Lazy%601> 지정 된 인스턴스 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, 세 개의 스레드를 만들 수 `LargeObject` 인스턴스. 이 예제에서는 생성자와의 종료자에서 콘솔 메시지를 표시 하 여이 보여 줍니다는 `LargeObject` 클래스:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 <xref:System.Lazy%601> 개체 인스턴스를 하나만 (초기화 함수가 예외를 throw 하는 위치는 스레드)를 제외한 모든 스레드를 사용해 확인 합니다. 출력의 예제에서이 보여 줍니다.  
  
> [!NOTE]
>  편의상 이 예제에서는 <xref:System.Lazy%601>의 전역 인스턴스를 사용하며, 모든 메서드는 `static`(Visual Basic의 경우 `Shared`)입니다. 이는 초기화 지연의 사용에 필요한 요구 사항은 아닙니다.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />에 잘못된 값이 포함된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" />가 <see langword="null" />인 경우</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">초기화 지연</related>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueCreated : bool" Usage="System.Lazy&lt;'T&gt;.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>값이 이 <see cref="T:System.Lazy`1" /> 인스턴스에 대해 만들어졌는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>값이 <see cref="T:System.Lazy`1" /> 인스턴스에 대해 만들어졌으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 초기화 지연에 대해 발생 하는 경우는 <xref:System.Lazy%601> 인스턴스에 발생할 생성 되는 값 또는 예외가 throw 됩니다. 예외가 throw 된, 후속 동작의 경우는 <xref:System.Lazy%601> 인스턴스 인지에 따라 다릅니다 예외 캐싱을 적용 합니다. 경우는 <xref:System.Lazy%601> 초기화 함수를 지정 하지 않는 생성자를 사용 하 여 인스턴스를 만든 후 예외 캐싱을 적용 되지 않습니다. 초기화 이후 시도 <xref:System.Lazy%601> 성공할 수 및 성공적으로 초기화 된 후 합니다 <xref:System.Lazy%601.IsValueCreated%2A> 속성에서 반환 `true`. 경우는 <xref:System.Lazy%601> 인스턴스를 초기화 함수를 사용 하 여 만든 (지정 된를 `valueFactory` 의 매개 변수는 <xref:System.Lazy%601> 생성자), 다음 스레드 보안 모드를 통해 제어 됩니다 예외 캐싱을 합니다.  
  
-   모드가 <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> 또는 <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, 두 번째 가능성이 초기화할 수 없습니다는 <xref:System.Lazy%601> 인스턴스. 해당 예외가 캐시 되 고의 후속 액세스에서 다시 throw 예외가 발생 하 고 초기화 함수에서 처리 되지 않을 경우는 <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> 속성입니다. 예외가 throw 되 면, 이러한 경우이 값이 만들어지지 <xref:System.Lazy%601.IsValueCreated%2A> 반환 `false`합니다.  
  
-   모드가 <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>를 성공적으로 초기화 함수 (또는 기본 생성자)를 실행 하는 첫 번째 스레드가 대 한 값을 만듭니다.는 <xref:System.Lazy%601> 인스턴스. 한 스레드에서 예외를 throw 하는 초기화 함수를 다른 스레드에서 계속 시도할 수 초기화는 <xref:System.Lazy%601> 인스턴스. 값을 만들 때까지 합니다 <xref:System.Lazy%601.IsValueCreated%2A> 속성이 반환 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">초기화 지연</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="lazy.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 <see cref="P:System.Lazy`1.Value" /> 속성에 대한 문자열 표현을 만들고 반환합니다.</summary>
        <returns>값이 생성된 경우(즉, <see cref="P:System.Lazy`1.IsValueCreated" /> 속성에서 <see langword="true" />를 반환한 경우) 이 인스턴스의 <see cref="P:System.Lazy`1.Value" /> 속성에서 <see cref="M:System.Object.ToString" /> 메서드를 호출한 결과입니다. 그러지 않으면 값이 생성되지 않았음을 나타내는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하면 초기화가 되지 않습니다.  
  
 <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> 속성 일 수 있습니다 `null` 되었으면 팩터리 메서드는 초기화 지연 후에 대해 지정 된를 `valueFactory` 의 매개 변수를 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, 또는 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> 생성자가 반환 `null`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><see cref="P:System.Lazy`1.Value" /> 속성은 <see langword="null" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'T" Usage="System.Lazy&lt;'T&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Lazy`1" /> 인스턴스의 지연된 초기화 값을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Lazy`1" /> 인스턴스의 지연된 초기화 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType> 속성은 `false`에 액세스 합니다 <xref:System.Lazy%601.Value%2A> 속성 초기화를 강제 합니다.  
  
 나열 되는 예외 외에도 합니다 <xref:System.Lazy%601.Value%2A> 속성에 전달 된 팩터리 메서드에 의해 throw 되는 처리 되지 않은 예외를 throw 할 수 있습니다 합니다 `valueFactory` 의 매개 변수를 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, 또는 <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> 생성자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><see cref="T:System.Lazy`1" /> 인스턴스는 초기화가 지연되는 형식의 기본 생성자를 사용하도록 초기화되며 생성자에 액세스할 수 있는 권한은 없습니다.</exception>
        <exception cref="T:System.MissingMemberException"><see cref="T:System.Lazy`1" /> 인스턴스는 초기화가 지연되는 형식의 기본 생성자를 사용하도록 초기화되며 그 형식에는 매개 변수가 없는 public 생성자가 없습니다.</exception>
        <exception cref="T:System.InvalidOperationException">초기화 함수가 이 인스턴스에서 <see cref="P:System.Lazy`1.Value" />에 액세스하려고 합니다.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">초기화 지연</related>
      </Docs>
    </Member>
  </Members>
</Type>