<Type Name="MulticastDelegate" FullName="System.MulticastDelegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9973e07fbce6416998f6f3811b5f3a7a6c44a503" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52593067" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MulticastDelegate : Delegate" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit MulticastDelegate extends System.Delegate" />
  <TypeSignature Language="DocId" Value="T:System.MulticastDelegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MulticastDelegate&#xA;Inherits Delegate" />
  <TypeSignature Language="C++ CLI" Value="public ref class MulticastDelegate abstract : Delegate" />
  <TypeSignature Language="F#" Value="type MulticastDelegate = class&#xA;    inherit Delegate" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="faefe-101">멀티캐스트 대리자 즉, 해당 호출 목록에 둘 이상의 요소를 가질 수 있는 대리자를 나타냅니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="faefe-101">Represents a multicast delegate; that is, a delegate that can have more than one element in its invocation list.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="faefe-102"><xref:System.MulticastDelegate> 특수 클래스가입니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-102"><xref:System.MulticastDelegate> is a special class.</span></span> <span data-ttu-id="faefe-103">컴파일러 및 도구는이 클래스에서 파생할 수 있지만 명시적으로에서 파생 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-103">Compilers and other tools can derive from this class, but you cannot derive from it explicitly.</span></span> <span data-ttu-id="faefe-104">마찬가지 여 <xref:System.Delegate> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-104">The same is true of the <xref:System.Delegate> class.</span></span>  
  
 <span data-ttu-id="faefe-105">상속 형식 위임 하는 방법 외에도 <xref:System.MulticastDelegate>, 두 개의 특수 메서드를 제공 하는 공용 언어 런타임: `BeginInvoke` 및 `EndInvoke`합니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-105">In addition to the methods that delegate types inherit from <xref:System.MulticastDelegate>, the common language runtime provides two special methods: `BeginInvoke` and `EndInvoke`.</span></span> <span data-ttu-id="faefe-106">이러한 방법에 대 한 자세한 내용은 참조 하세요. [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-106">For more information about these methods, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
 <span data-ttu-id="faefe-107"><xref:System.MulticastDelegate> 대리자 호출 목록에 이라는 하나 이상의 요소로 구성 된 연결 된 목록이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-107">A <xref:System.MulticastDelegate> has a linked list of delegates, called an invocation list, consisting of one or more elements.</span></span> <span data-ttu-id="faefe-108">멀티 캐스트 대리자를 호출 하면 대리자 호출 목록에 나타나는 순서로 동기적으로 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-108">When a multicast delegate is invoked, the delegates in the invocation list are called synchronously in the order in which they appear.</span></span> <span data-ttu-id="faefe-109">목록의 실행 하는 동안 오류가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-109">If an error occurs during execution of the list then an exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="faefe-110">다음 예제에서는 클래스를 정의 `StringContainer`, 문자열의 컬렉션을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-110">The following example defines a class, `StringContainer`, which includes a collection of strings.</span></span> <span data-ttu-id="faefe-111">해당 멤버 중 하나인 합니다 `CheckAndDisplayDelegate` 에 저장 된 문자열을 표시 하는 데 사용 되는 대리자를 `StringContainer` 특정 조건을 충족 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-111">One of its members is the `CheckAndDisplayDelegate` delegate, which is used to display strings stored in a `StringContainer` object that satisfy particular criteria.</span></span> <span data-ttu-id="faefe-112">대리자는 단일 문자열을 매개 변수로 받아서 반환 `void` (또는 Visual basic에서는 것을 `Sub` 프로시저).</span><span class="sxs-lookup"><span data-stu-id="faefe-112">The delegate takes a single string as a parameter and returns `void` (or, in Visual Basic, it's a `Sub` procedure).</span></span> <span data-ttu-id="faefe-113">또한 메서드를 `DisplayAllQualified`, 단일 매개 변수가 있는 `CheckAndDisplayDelegate` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-113">It also includes a method, `DisplayAllQualified`, that has a single parameter, a `CheckAndDisplayDelegate` delegate.</span></span> <span data-ttu-id="faefe-114">이 메서드를 호출할 수 있으며 대리자를 포함 하는 방법에 따라 필터링 되는 문자열 집합을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-114">This allows the method to be called and to display a set of strings that are filtered based on the methods that the delegate contains.</span></span>  
  
 <span data-ttu-id="faefe-115">이 예제에서는 유틸리티 클래스를 정의 `StringExtensions`, 두 개의 메서드가 있는:</span><span class="sxs-lookup"><span data-stu-id="faefe-115">The example also defines a utility class, `StringExtensions`, that has two methods:</span></span>  
  
-   <span data-ttu-id="faefe-116">`ConStart`에 자음을 시작 하는 문자열을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-116">`ConStart`, which displays strings that begin with a consonant.</span></span>  
  
-   <span data-ttu-id="faefe-117">`VowelStart`에 모음을 시작 하는 문자열을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-117">`VowelStart`, which displays strings that begin with a vowel.</span></span>  
  
 <span data-ttu-id="faefe-118">두 방법 모두는 단일 문자열 매개 변수를 포함 하 고 반환 `void`합니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-118">Note that both methods include a single string parameter and return `void`.</span></span> <span data-ttu-id="faefe-119">즉, 두 메서드 모두 할당할 수는 `CheckAndDisplayDelegate` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-119">In other words, both methods can be assigned to the  `CheckAndDisplayDelegate` delegate.</span></span>  
  
 <span data-ttu-id="faefe-120">`Test.Main` 메서드는 응용 프로그램 진입점입니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-120">The `Test.Main` method is the application entry point.</span></span> <span data-ttu-id="faefe-121">인스턴스화할를 `StringContainer` 개체를 문자열을 사용 하 여 채웁니다 만들고 두 개의 `CheckAndDisplayDelegate` 대리자 `conStart` 및 `vowelStart`, 단일 메서드를 호출 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-121">It instantiates a `StringContainer` object, populates it with strings, and creates two `CheckAndDisplayDelegate` delegates, `conStart` and `vowelStart`, that invoke a single method.</span></span> <span data-ttu-id="faefe-122">그런 다음 호출 하는 <xref:System.Delegate.Combine%2A?displayProperty=nameWithType> 메서드를를 `multipleDelegates` 처음에 포함 된 대리자를 `ConStart` 및 `VowelStart` 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-122">It then calls the <xref:System.Delegate.Combine%2A?displayProperty=nameWithType> method to create the `multipleDelegates` delegate, which initially contains the `ConStart` and  `VowelStart` delegates.</span></span> <span data-ttu-id="faefe-123">경우는 `multipleDelegates` 대리자 호출 되 면 원래 순서 대로 컬렉션에서 모든 문자열을 표시 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-123">Note that when the `multipleDelegates` delegate is invoked, it displays all the strings in the collection in their original order.</span></span> <span data-ttu-id="faefe-124">각 문자는 각 대리자에 개별적으로 전달 되며 각 문자에는 두 명의 대리자 중 하나에 필터링 기준을 충족 하는 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-124">This is because each letter is passed separately to each delegate, and each letter meets the filtering criteria of only one of the two delegates.</span></span> <span data-ttu-id="faefe-125">마지막으로 호출한 후 <xref:System.Delegate.Remove%2A?displayProperty=nameWithType> 및 <xref:System.Delegate.Combine%2A?displayProperty=nameWithType>, `multipleDelegates` 에 두 개의 `conStart` 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-125">Finally, after calls to <xref:System.Delegate.Remove%2A?displayProperty=nameWithType> and <xref:System.Delegate.Combine%2A?displayProperty=nameWithType>, `multipleDelegates` contains two `conStart` delegates.</span></span> <span data-ttu-id="faefe-126">가 호출 될 때, 각 문자열은 `StringContainer` 개체가 두 번 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-126">When it is invoked, each string in the `StringContainer` object is displayed twice.</span></span>  
  
 [!code-cpp[Multicast Delegate Introduction#1](~/samples/snippets/cpp/VS_Snippets_CLR/Multicast Delegate Introduction/CPP/delegatestring.cpp#1)]
 [!code-csharp[Multicast Delegate Introduction#1](~/samples/snippets/csharp/VS_Snippets_CLR/Multicast Delegate Introduction/CS/delegatestring.cs#1)]
 [!code-vb[Multicast Delegate Introduction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Multicast Delegate Introduction/VB/delegatestring.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="faefe-127">
            <see cref="T:System.MulticastDelegate" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-127">Initializes a new instance of the <see cref="T:System.MulticastDelegate" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MulticastDelegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MulticastDelegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new MulticastDelegate : obj * string -&gt; MulticastDelegate" Usage="new System.MulticastDelegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="faefe-128">
            <paramref name="method" />가 정의된 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-128">The object on which <paramref name="method" /> is defined.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="faefe-129">대리자가 만들어진 메서드의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-129">The name of the method for which a delegate is created.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="faefe-130">
            <see cref="T:System.MulticastDelegate" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-130">Initializes a new instance of the <see cref="T:System.MulticastDelegate" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="faefe-131">이 생성자는 응용 프로그램 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-131">This constructor cannot be used in application code.</span></span> <span data-ttu-id="faefe-132">인스턴스 메서드의 이름을 지정 하 여 대리자를 만들려는 오버 로드를 사용 합니다 <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> 메서드 이름 및 대상 개체를 지정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-132">To create a delegate by specifying the name of an instance method, use an overload of the <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> method that specifies a method name and a target object.</span></span> <span data-ttu-id="faefe-133">예를 들어를 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29?displayProperty=nameWithType> 메서드 오버 로드는 지정 된 이름의 인스턴스 메서드의 대리자를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-133">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29?displayProperty=nameWithType> method overload creates a delegate for an instance method with a specified name.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="faefe-134">추상 클래스의 인스턴스를 만들 수 없거나 이 멤버가 런타임에 바인딩 메커니즘을 사용하여 호출되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-134">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="faefe-135">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-135">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="faefe-136">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-136">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MulticastDelegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MulticastDelegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new MulticastDelegate : Type * string -&gt; MulticastDelegate" Usage="new System.MulticastDelegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="faefe-137">
            <paramref name="method" />가 정의된 개체의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-137">The type of object on which <paramref name="method" /> is defined.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="faefe-138">대리자가 만들어진 정적 메서드의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-138">The name of the static method for which a delegate is created.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="faefe-139">
            <see cref="T:System.MulticastDelegate" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-139">Initializes a new instance of the <see cref="T:System.MulticastDelegate" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="faefe-140">이 생성자는 응용 프로그램 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-140">This constructor cannot be used in application code.</span></span> <span data-ttu-id="faefe-141">정적 메서드 이름을 지정 하 여 대리자를 만들려는 오버 로드를 사용 합니다 <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> 메서드 메서드 이름을 지정 하지만 대상 개체를 지정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-141">To create a delegate by specifying the name of a static method, use an overload of the <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> method that specifies a method name but does not specify a target object.</span></span> <span data-ttu-id="faefe-142">예를 들어를 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29?displayProperty=nameWithType> 메서드 오버 로드는 지정 된 이름의 메서드에 대 한 정적 대리자를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-142">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29?displayProperty=nameWithType> method overload creates a static delegate for a method with a specified name.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="faefe-143">추상 클래스의 인스턴스를 만들 수 없거나 이 멤버가 런타임에 바인딩 메커니즘을 사용하여 호출되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-143">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="faefe-144">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-144">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="faefe-145">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-145">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected override sealed Delegate CombineImpl (Delegate follow);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Delegate CombineImpl(class System.Delegate follow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CombineImpl (follow As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Delegate ^ CombineImpl(Delegate ^ follow);" />
      <MemberSignature Language="F#" Value="override this.CombineImpl : Delegate -&gt; Delegate" Usage="multicastDelegate.CombineImpl follow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="follow" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="follow">
          <span data-ttu-id="faefe-146">이 대리자와 결합시킬 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-146">The delegate to combine with this delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="faefe-147">이 <see cref="T:System.Delegate" />를 지정된 <see cref="T:System.Delegate" />와 결합하여 새 대리자를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-147">Combines this <see cref="T:System.Delegate" /> with the specified <see cref="T:System.Delegate" /> to form a new delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="faefe-148">
            <see cref="T:System.MulticastDelegate" /> 호출 목록의 새 루트인 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-148">A delegate that is the new root of the <see cref="T:System.MulticastDelegate" /> invocation list.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="faefe-149">
            <paramref name="follow" />에는 이 인스턴스와 같은 형식이 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-149">
              <paramref name="follow" /> does not have the same type as this instance.</span>
          </span>
        </exception>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="faefe-150">추상 클래스의 인스턴스를 만들 수 없거나 이 멤버가 런타임에 바인딩 메커니즘을 사용하여 호출되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-150">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="faefe-151">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-151">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="faefe-152">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-152">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected override sealed object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="multicastDelegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">
          <span data-ttu-id="faefe-153">캡슐화된 메서드에 전달할 인수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-153">The arguments to pass to the encapsulated method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="faefe-154">전체 호출 목록을 처리합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-154">Processes the full invocation list.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="faefe-155">캡슐화된 메서드의 반환 값을 포함하는 <see cref="T:System.Object" /> 유형의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-155">An array of type <see cref="T:System.Object" /> that contains the return value of the encapsulated method.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="faefe-156">추상 클래스의 인스턴스를 만들 수 없거나 이 멤버가 런타임에 바인딩 메커니즘을 사용하여 호출되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-156">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
          <span data-ttu-id="faefe-157">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-157">-or-</span>
          </span>
          <span data-ttu-id="faefe-158">호출자에게 액세스 권한이 없는 메서드 즉, 전용 메서드를 호출하려고 시도하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-158">There is an attempt to invoke a method to which the caller does not have access (that is, a private method).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="faefe-159">매개 변수의 개수, 순서 또는 형식이 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-159">The number, order, or type of parameters is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="faefe-160">캡슐화된 메서드가 정적 메서드가 아니며 대상 개체가 null인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-160">An encapsulated method is not static, and the target object is null.</span>
          </span>
          <span data-ttu-id="faefe-161">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-161">-or-</span>
          </span>
          <span data-ttu-id="faefe-162">메서드를 지원하지 않는 개체 또는 클래스에서 메서드를 호출하려고 시도하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-162">There is an attempt to invoke a method on an object or class that does not support the method.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="faefe-163">캡슐화된 메서드 중 하나에서 예외를 throw하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-163">One of the encapsulated methods throws an exception.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="multicastDelegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="faefe-164">이 인스턴스와 비교할 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-164">The object to compare with this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="faefe-165">이 멀티캐스트 대리자와 지정된 개체가 같은지를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-165">Determines whether this multicast delegate and the specified object are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="faefe-166">
            <paramref name="obj" /> 및 이 인스턴스가 같은 호출 목록을 가지면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-166">
              <see langword="true" /> if <paramref name="obj" /> and this instance have the same invocation lists; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="faefe-167">두 명의 대리자가 없는 경우 같은 `null` 되며 정확히 같은 형식으로의 호출 목록이 포함 요소 수가 첫 번째 대리자의 호출 목록의 모든 요소가 동일 하 고 해당 요소 호출 두 번째 대리자의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-167">Two delegates are equal if they are not `null` and are of exactly the same type, their invocation lists contain the same number of elements, and every element in the invocation list of the first delegate is equal to the corresponding element in the invocation list of the second delegate.</span></span>  
  
 <span data-ttu-id="faefe-168">동일한 대상 인스턴스에서 동일한 인스턴스 메서드 호출 또는 같은 정적 메서드를 호출 하는 경우 두 호출 목록 요소 같습니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-168">Two invocation list elements are equal if they invoke the same instance method on the same target instance, or they invoke the same static method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="faefe-169">추상 클래스의 인스턴스를 만들 수 없거나 이 멤버가 런타임에 바인딩 메커니즘을 사용하여 호출되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-169">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="faefe-170">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-170">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="faefe-171">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-171">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="multicastDelegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="faefe-172">이 인스턴스의 해시 코드를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-172">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="faefe-173">부호 있는 32비트 정수 해시 코드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-173">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="faefe-174">추상 클래스의 인스턴스를 만들 수 없거나 이 멤버가 런타임에 바인딩 메커니즘을 사용하여 호출되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-174">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="faefe-175">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-175">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="faefe-176">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-176">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public override sealed Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="override this.GetInvocationList : unit -&gt; Delegate[]" Usage="multicastDelegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="faefe-177">호출 순서대로 이 멀티캐스트 대리자의 호출 목록을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-177">Returns the invocation list of this multicast delegate, in invocation order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="faefe-178">호출 목록 전체가 이 인스턴스의 호출 목록과 일치하는 대리자의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-178">An array of delegates whose invocation lists collectively match the invocation list of this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="faefe-179">배열의 한 항목의 호출 목록을 가진 각 대리자 집합을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-179">The array contains a set of delegates, each with an invocation list of one entry.</span></span> <span data-ttu-id="faefe-180">현재 인스턴스를 호출 하는 것 같은 결과 생성 배열의 순서 대로 순차적으로 이러한 대리자를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-180">Invoking these delegates sequentially, in the order they appear in the array, produces the same results as invoking the current instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="faefe-181">추상 클래스의 인스턴스를 만들 수 없거나 이 멤버가 런타임에 바인딩 메커니즘을 사용하여 호출되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-181">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="faefe-182">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-182">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="faefe-183">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-183">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="multicastDelegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="faefe-184">현재 <see cref="T:System.MulticastDelegate" />에서 나타내는 정적 메서드를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-184">Returns a static method represented by the current <see cref="T:System.MulticastDelegate" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="faefe-185">현재 <see cref="T:System.MulticastDelegate" />에서 나타내는 정적 메서드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-185">A static method represented by the current <see cref="T:System.MulticastDelegate" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="faefe-186">경우는 <xref:System.MulticastDelegate> 여러 메서드를 나타내는 하나의 메서드만 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-186">If the <xref:System.MulticastDelegate> represents multiple methods, only one method is returned.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public override void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="multicastDelegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="faefe-187">이 인스턴스를 serialize 또는 deserialize하는 데 필요한 모든 데이터를 보유한 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-187">An object that holds all the data needed to serialize or deserialize this instance.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="faefe-188">(예약됨) Serialize된 데이터가 저장 및 검색되는 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-188">(Reserved) The location where serialized data is stored and retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="faefe-189">이 인스턴스를 serialize하는 데 필요한 모든 데이터로 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체를 채웁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-189">Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with all the data needed to serialize this instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="faefe-190">이 메서드는 모든 정보를 저장 `info` 이 인스턴스를 serialize 하는 데 필요한 합니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-190">This method stores all the information in `info` necessary to serialize this instance.</span></span>  
  
 <span data-ttu-id="faefe-191">`context` 매개 변수는 예약 되어 이며이 메서드의 실행에 현재 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-191">The `context` parameter is reserved and is not currently used in the execution of this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="faefe-192">
            <paramref name="info" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-192">
              <paramref name="info" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="faefe-193">추상 클래스의 인스턴스를 만들 수 없거나 이 멤버가 런타임에 바인딩 메커니즘을 사용하여 호출되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-193">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <span data-ttu-id="faefe-194">serialization 오류가 발생한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-194">A serialization error occurred.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="faefe-195">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-195">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="faefe-196">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-196">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (MulticastDelegate d1, MulticastDelegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.MulticastDelegate d1, class System.MulticastDelegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.op_Equality(System.MulticastDelegate,System.MulticastDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As MulticastDelegate, d2 As MulticastDelegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(MulticastDelegate ^ d1, MulticastDelegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : MulticastDelegate * MulticastDelegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.MulticastDelegate" />
        <Parameter Name="d2" Type="System.MulticastDelegate" />
      </Parameters>
      <Docs>
        <param name="d1">
          <span data-ttu-id="faefe-197">왼쪽 피연산자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-197">The left operand.</span>
          </span>
        </param>
        <param name="d2">
          <span data-ttu-id="faefe-198">오른쪽 피연산자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-198">The right operand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="faefe-199">두 <see cref="T:System.MulticastDelegate" /> 개체가 서로 같은지 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-199">Determines whether two <see cref="T:System.MulticastDelegate" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="faefe-200">
            <paramref name="d1" /> 및 <paramref name="d2" />가 같은 호출 목록을 가지면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-200">
              <see langword="true" /> if <paramref name="d1" /> and <paramref name="d2" /> have the same invocation lists; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="faefe-201">두 명의 대리자가 없는 경우 같은 `null` 되며 정확히 같은 형식으로의 호출 목록이 포함 요소 수가 첫 번째 대리자의 호출 목록의 모든 요소가 동일 하 고 해당 요소 호출 두 번째 대리자의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-201">Two delegates are equal if they are not `null` and are of exactly the same type, their invocation lists contain the same number of elements, and every element in the invocation list of the first delegate is equal to the corresponding element in the invocation list of the second delegate.</span></span>  
  
 <span data-ttu-id="faefe-202">동일한 대상 인스턴스에서 동일한 인스턴스 메서드 호출 또는 같은 정적 메서드를 호출 하는 경우 두 호출 목록 요소 같습니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-202">Two invocation list elements are equal if they invoke the same instance method on the same target instance, or they invoke the same static method.</span></span>  
  
 <span data-ttu-id="faefe-203">이 연산자에 대 한 해당 메서드는 <xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="faefe-203">The equivalent method for this operator is <xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="faefe-204">추상 클래스의 인스턴스를 만들 수 없거나 이 멤버가 런타임에 바인딩 메커니즘을 사용하여 호출되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-204">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="faefe-205">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-205">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="faefe-206">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-206">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (MulticastDelegate d1, MulticastDelegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.MulticastDelegate d1, class System.MulticastDelegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.op_Inequality(System.MulticastDelegate,System.MulticastDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As MulticastDelegate, d2 As MulticastDelegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(MulticastDelegate ^ d1, MulticastDelegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : MulticastDelegate * MulticastDelegate -&gt; bool" Usage="System.MulticastDelegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.MulticastDelegate" />
        <Parameter Name="d2" Type="System.MulticastDelegate" />
      </Parameters>
      <Docs>
        <param name="d1">
          <span data-ttu-id="faefe-207">왼쪽 피연산자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-207">The left operand.</span>
          </span>
        </param>
        <param name="d2">
          <span data-ttu-id="faefe-208">오른쪽 피연산자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-208">The right operand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="faefe-209">두 개의 <see cref="T:System.MulticastDelegate" /> 개체가 같은지 여부를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-209">Determines whether two <see cref="T:System.MulticastDelegate" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="faefe-210">
            <paramref name="d1" /> 및 <paramref name="d2" />가 같은 호출 목록을 가지지 않으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-210">
              <see langword="true" /> if <paramref name="d1" /> and <paramref name="d2" /> do not have the same invocation lists; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="faefe-211">두 명의 대리자가 없는 경우 같은 `null` 되며 정확히 같은 형식으로의 호출 목록이 포함 요소 수가 첫 번째 대리자의 호출 목록의 모든 요소가 동일 하 고 해당 요소 호출 두 번째 대리자의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-211">Two delegates are equal if they are not `null` and are of exactly the same type, their invocation lists contain the same number of elements, and every element in the invocation list of the first delegate is equal to the corresponding element in the invocation list of the second delegate.</span></span>  
  
 <span data-ttu-id="faefe-212">동일한 대상 인스턴스에서 동일한 인스턴스 메서드 호출 또는 같은 정적 메서드를 호출 하는 경우 두 호출 목록 요소 같습니다.</span><span class="sxs-lookup"><span data-stu-id="faefe-212">Two invocation list elements are equal if they invoke the same instance method on the same target instance, or they invoke the same static method.</span></span>  
  
 <span data-ttu-id="faefe-213">이 연산자에 대 한 해당 메서드는 <xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="faefe-213">The equivalent method for this operator is <xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="faefe-214">추상 클래스의 인스턴스를 만들 수 없거나 이 멤버가 런타임에 바인딩 메커니즘을 사용하여 호출되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-214">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="faefe-215">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-215">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="faefe-216">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-216">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected override sealed Delegate RemoveImpl (Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Delegate RemoveImpl(class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function RemoveImpl (value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Delegate ^ RemoveImpl(Delegate ^ value);" />
      <MemberSignature Language="F#" Value="override this.RemoveImpl : Delegate -&gt; Delegate" Usage="multicastDelegate.RemoveImpl value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="faefe-217">호출 목록에서 검색할 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-217">The delegate to search for in the invocation list.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="faefe-218">이 <see cref="T:System.MulticastDelegate" />의 호출 목록에서 지정된 대리자와 같은 요소를 제거합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-218">Removes an element from the invocation list of this <see cref="T:System.MulticastDelegate" /> that is equal to the specified delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="faefe-219">이 인스턴스의 호출 목록에 <paramref name="value" />가 있으면 호출 목록에 <paramref name="value" />가 없는 새 <see cref="T:System.Delegate" />이고, 그렇지 않으면 원본 호출 목록이 있는 이 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-219">If <paramref name="value" /> is found in the invocation list for this instance, then a new <see cref="T:System.Delegate" /> without <paramref name="value" /> in its invocation list; otherwise, this instance with its original invocation list.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="faefe-220">추상 클래스의 인스턴스를 만들 수 없거나 이 멤버가 런타임에 바인딩 메커니즘을 사용하여 호출되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-220">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="faefe-221">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-221">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="faefe-222">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="faefe-222">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>