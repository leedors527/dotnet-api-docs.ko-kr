<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bfae8b3cf5ca6697f5210623349d31d86271db33" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37480726" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>.Net Framework 클래스 계층 구조의 모든 클래스를 지원하며 파생 클래스에 하위 수준 서비스를 제공합니다. 또한 .NET Framework의 모든 클래스 중에서 기본 클래스이며 형식 계층 구조의 루트입니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 언어에서 상속을 선언 하는 클래스를 일반적으로 필요 하지 않습니다 <xref:System.Object> 상속은 암시적 때문입니다.  
  
 .NET Framework의 모든 클래스에서 파생 되므로 <xref:System.Object>에 정의 된 모든 메서드는 <xref:System.Object> 클래스는 시스템의 모든 개체에서 사용할 수 있습니다. 파생 클래스 수 및 포함 하 여 이러한 메서드의 일부를 재정의 하는:  
  
-   <xref:System.Object.Equals%2A> -개체 간의 비교를 지원합니다.  
  
-   <xref:System.Object.Finalize%2A> -개체를 자동으로 회수 하기 전에 정리 작업을 수행 합니다.  
  
-   <xref:System.Object.GetHashCode%2A> -해시 테이블의 사용을 지원 하려면 개체의 값에 해당 하는 숫자를 생성 합니다.  
  
-   <xref:System.Object.ToString%2A> -클래스의 인스턴스를 설명 하는 사람이 읽을 수 있는 텍스트 문자열을 만듭니다.  
  
## <a name="performance-considerations"></a>성능 고려 사항  
 인스턴스를 허용 하는 클래스 멤버를 만들 수 같은 모든 형식의 개체를 처리 해야 하는 컬렉션 클래스를 디자인 하는 경우는 <xref:System.Object> 클래스입니다. 그러나 프로세스를 boxing 및 unboxing 형식 성능 비용을 전달 합니다. 새 클래스를 특정 값 형식을 처리할 자주 알고 있는 경우 boxing 비용을 최소화 하려면 두 가지 방법 중 하나를 사용할 수 있습니다.  
  
-   허용 하는 일반 메서드는 <xref:System.Object> 형식 및 각 값 형식에서 자주 처리 클래스를 허용 하는 형식별 메서드 오버 로드 집합. 호출 매개 변수 형식을 허용 하는 형식별 메서드 있으면 boxing 되지 않습니다 발생 하 고 형식별 메서드를 호출 합니다. 호출 매개 변수 형식과 일치 하는 메서드 인수가 있으면 매개 변수는 boxed 및 일반 메서드가 호출 됩니다.  
  
-   제네릭을 사용 하 여 형식 및 해당 멤버를 디자인 합니다. 공용 언어 런타임 클래스의 인스턴스를 만들고 제네릭 형식 인수를 지정할 때 닫힌된 제네릭 형식을 만듭니다. 제네릭 메서드의 형식 특정 이며 호출 매개 변수를 boxing 하지 않고 호출할 수 있습니다.  
  
 받아들이거나 반환 하는 범용 클래스를 개발 해야 하는 경우도 있지만 <xref:System.Object> 형식에도 자주 사용 되는 형식을 처리 하는 type 별 클래스를 제공 하 여 성능을 개선할 수 있습니다. 예를 들어, 설정 및 부울 값을 가져오고이에 관련 된 클래스를 제공 비용 boxing 및 unboxing 부울 값을 제거 합니다.  
  
   
  
## Examples  
 다음 예제에서 파생 되는 지점 형식 정의 <xref:System.Object> 클래스 및 대부분의 가상 메서드를 재정의 합니다 <xref:System.Object> 클래스입니다. 또한 예제에서는를 호출 하는 다양 한 정적 메서드와 인스턴스는 <xref:System.Object> 클래스.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>공용 정적 (<see langword="Shared" /> Visual Basic의)이 형식의 멤버는 스레드로부터 안전 합니다. 인스턴스 멤버는 스레드로부터 안전 하 보장 되지 않습니다.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Object" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 파생된 클래스의 생성자가 호출 되지만의 인스턴스를 직접 만들려면 사용할 수도 있습니다는 <xref:System.Object> 클래스입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>두 개체 인스턴스가 같은지를 확인합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">현재 개체와 비교할 개체입니다.</param>
        <summary>지정한 개체와 현재 개체가 같은지 여부를 확인합니다.</summary>
        <returns>지정한 개체가 현재 개체와 같으면 <see langword="true" />이고, 다르면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 인스턴스 간 비교의 형식 및 `obj` 매개 변수는 현재 인스턴스 참조 형식 또는 값 형식 인지에 따라 다릅니다.  
  
-   현재 인스턴스 참조 형식인 경우는 <xref:System.Object.Equals%28System.Object%29> 참조 같음에 대 한 테스트 메서드를 호출 하는 <xref:System.Object.Equals%28System.Object%29> 를 호출 하는 것과 같습니다는 <xref:System.Object.ReferenceEquals%2A> 메서드. 참조 같음 비교 하는 개체 변수를 같은 개체 참조는 것을 의미 합니다. 다음 예제에서는 이러한 비교의 결과를 보여 줍니다. 정의 `Person` 참조 형식인 클래스를 호출 합니다 `Person` 두 개의 새 인스턴스화할 클래스 생성자 `Person` 개체 `person1a` 및 `person2`, 동일한 값을 포함 하는. 또한 할당 `person1a` 다른 개체 변수에 `person1b`합니다. 예제에서 출력으로 `person1a` 고 `person1b` 동일한 개체를 참조 하기 때문에 있습니다. 그러나 `person1a` 고 `person2` 동일한 값을 갖고 있지만, 두 개체가 다릅니다.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   현재 인스턴스 값 형식인 경우는 <xref:System.Object.Equals%28System.Object%29> 메서드는 값이 같은지를 테스트 합니다. 값 같음은 다음을 의미 합니다.  
  
    -   두 개체는 같은 형식입니다. 다음 예제와 같이 <xref:System.Byte> 12의 값이 있는 개체와 같지 않습니다는 <xref:System.Int32> 두 개체가 서로 다른 런타임 형식을 있으므로 12의 값이 있는 개체입니다.  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   두 개체의 public 및 private 필드의 값이 같습니다. 다음 예제에서는 값이 같은지 테스트합니다. 정의 `Person` 구조, 즉 값 형식 및 호출 합니다 `Person` 두 개의 새 인스턴스화할 클래스 생성자 `Person` 개체 `person1` 및 `person2`, 동일한 값을 포함 하는 합니다. 두 개체 변수를 다양 한 개체 참조 하지만 예제의 출력을 볼 수 있듯이 `person1` 하 고 `person2` 개인에 대 한 동일한 값이 없으므로 같은지 `personName` 필드입니다.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 때문에 합니다 <xref:System.Object> 클래스는.NET Framework의 모든 형식에 대 한 기본 클래스를 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 메서드는 다른 모든 형식에 대 한 기본 같음 비교를 제공 합니다. 그러나 형식은 종종를 재정의 합니다 <xref:System.Object.Equals%2A> 값 같음을 구현 하는 방법입니다. 자세한 정보를 상속자 섹션에 대 한 호출자 및 정보에 대 한 참조.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>에 대 한 정보는 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 호출 하는 경우는 <xref:System.Object.Equals%28System.Object%29> 클래스의 메서드 오버 로드는 [!INCLUDE[wrt](~/includes/wrt-md.md)]를 재정의 하지 않는 하는 클래스에 대 한 기본 동작을 쉽게 <xref:System.Object.Equals%28System.Object%29>합니다. 이.NET Framework에 대 한 제공 하는 지원의 일부를 [!INCLUDE[wrt](~/includes/wrt-md.md)] (참조 [.NET Framework 지원에 대 한 Windows 스토어 앱 및 Windows 런타임](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). 클래스는 [!INCLUDE[wrt](~/includes/wrt-md.md)] 상속 안 함 <xref:System.Object>, 및 현재 구현 하지는 <xref:System.Object.Equals%28System.Object%29> 메서드. 그러나 가진 것으로 나타납니다 <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, 및 <xref:System.Object.GetHashCode%2A> 메서드 C# 또는 Visual Basic 코드에서 사용 하 고.NET Framework는 이러한 메서드의 기본 동작을 제공 하는 경우.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] C# 또는 Visual Basic에서 작성 된 클래스에서 재정의할 수는 <xref:System.Object.Equals%28System.Object%29> 메서드 오버 로드 합니다.  
  
## <a name="notes-for-callers"></a>호출자에 대 한 정보  
 파생된 클래스를 자주 재정의 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 값 같음을 구현 하는 방법입니다. 또한 형식에 추가 강력한 형식의 오버 로드를 자주 제공 합니다 `Equals` 메서드를 구현 하 여 일반적으로 <xref:System.IEquatable%601> 인터페이스입니다. 호출 하는 경우는 `Equals` 같은지 테스트 하는 방법 현재 인스턴스가 재정의 하는지 여부를 알아야 할 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 이해 하는 방법에 대 한 특정 호출 및는 `Equals` 메서드는 해결 합니다. 이 고, 그렇지을 수행할 수도 있습니다는 테스트에 의도 한 것과 다른 같은지 및 메서드는 예기치 않은 값을 반환할 수 있습니다.  
  
 다음 예제에서 이에 대해 설명합니다. 세 개의 인스턴스화할 <xref:System.Text.StringBuilder> 동일한 문자열을 사용 하 여 개체를 다음에 4 개의 호출 `Equals` 메서드. 첫 번째 메서드 호출 반환 `true`, 고 나머지 세 반환 `false`합니다.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 강력한 형식의 첫 번째 경우 <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> 값이 같은지를 테스트 하는 메서드 오버 로드가 호출 됩니다. 두 문자열을 할당 하기 때문에 <xref:System.Text.StringBuilder> 메서드는 반환 개체가 같은지를 `true`입니다. 그러나 <xref:System.Text.StringBuilder> 재정의 하지 않는 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>합니다. 이 인해 때 합니다 <xref:System.Text.StringBuilder> 개체가로 캐스팅는 <xref:System.Object>때를 <xref:System.Text.StringBuilder> 인스턴스가 형식의 변수에 할당 됩니다 <xref:System.Object>, 및 시기를 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> 두 메서드에 전달 됩니다 <xref:System.Text.StringBuilder> 기본개체<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>메서드가 호출 됩니다. 때문에 <xref:System.Text.StringBuilder> 참조 형식이 면 두 전달 같습니다 <xref:System.Text.StringBuilder> 개체는 <xref:System.Object.ReferenceEquals%2A> 메서드. 하지만 세 가지 모두 <xref:System.Text.StringBuilder> 동일한 문자열을 포함 하는 개체, 세 개의 고유한 개체를 참조 합니다. 따라서 이러한 세 개의 메서드 호출 반환 `false`합니다.  
  
 현재 개체 참조 같음에 대 한 다른 개체를 호출 하 여 비교할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A> 메서드. Visual basic에서 사용할 수도 있습니다는 `is` 키워드 (예를 들어 `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>상속자에 대 한 정보  
 해당 형식에서 정의 된 기능을 상속 고유한 형식을 정의 하는 경우는 `Equals` 메서드의 기본 형식입니다. 다음 표에서 기본 구현의 `Equals` 메서드 형식에서.NET Framework의 주요 범주에 대 한 합니다.  
  
|형식 범주|로 정의 된 같음|설명|  
|-------------------|-------------------------|--------------|  
|직접 파생 된 클래스 <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|참조 같음; 호출할 때와 동일한 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>입니다.|  
|구조체|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|값이 같은지 확인 합니다. 직접 바이트 단위로 비교 또는 리플렉션을 사용 하 여 필드 별로 비교 합니다.|  
|열거형|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|값은 동일한 열거형 및 기본값이 있어야 합니다.|  
|대리자|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|대리자와 동일한 호출 목록 가지 유형이 있어야 합니다.|  
|인터페이스|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|참조 같음입니다.|  
  
 값 형식에 대 한 항상 재정의 해야 <xref:System.Object.Equals%2A>이므로 리플렉션을 사용 하는 같음에 대 한 테스트의 성능이 저하 됩니다. 기본 구현을 재정의할 수도 있습니다 <xref:System.Object.Equals%2A> 참조 형식의 참조 일치 하는 대신 값이 같은지 테스트 하 고 값 같음의 정확한 의미를 정의 합니다. 이러한 구현이 <xref:System.Object.Equals%2A> 반환 `true` 두 개체가 있으면 같은 값을 동일한 인스턴스에 없는 경우에 합니다. 형식의 구현 자가 결정 요인을 개체의 값 이지만 일반적으로 일부 또는 모든 데이터 개체의 인스턴스 변수에 저장 합니다. 예를 들어, 값을 <xref:System.String> 문자열의 문자를 기준으로 하는 개체를 <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> 메서드 재정의 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 반환 하는 방법 `true` 인스턴스가 동일한 순서로 동일한 문자를 포함 하는 두 개의 문자열에 대 한 합니다.  
  
 다음 예제에서는 재정의 하는 방법의 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 값이 같은지를 테스트 하는 방법입니다. 재정의 된 <xref:System.Object.Equals%2A> 에 대 한 메서드는 `Person` 클래스입니다. 하는 경우 `Person` 같음의 기본 클래스 구현을 수락 두 `Person` 개체는 단일 개체를 참조 하는 경우에 같은 것입니다. 그러나이 예제의 경우 두 `Person` 개체는 동일한 값을 가질 경우 동일 합니다 `Person.Id` 속성입니다.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 재정의 하는 것 외에도 <xref:System.Object.Equals%2A>를 구현할 수 있습니다는 <xref:System.IEquatable%601> 인터페이스를 강력한 형식의 같음 테스트를 제공 합니다.  
  
 다음 문은 모든 구현에 대해 true 여야 합니다는 <xref:System.Object.Equals%28System.Object%29> 메서드. 목록에서 `x`, `y`, 및 `z` 되지 않는 개체 참조를 나타내는 **null**합니다.  
  
-   `x.Equals(x)` 반환 `true`, 부동 소수점 형식은 포함 하는 경우는 제외 합니다. ISO/IEC/IEEE 60559:2011, Information technology-마이크로프로세서 시스템-부동 소수점 산술을 참조 하세요.  
  
-   `x.Equals(y)` 와 동일한 값을 반환 `y.Equals(x)`합니다.  
  
-   `x.Equals(y)` 반환 `true` 둘 다 `x` 하 고 `y` 는 `NaN`합니다.  
  
-   경우 `(x.Equals(y) && y.Equals(z))` 반환 `true`, 한 다음 `x.Equals(z)` 반환 `true`합니다.  
  
-   에 대 한 연속 호출 `x.Equals(y)` 에서 참조 하는 개체와 동일한 값을 반환 `x` 및 `y` 수정 되지 않습니다.  
  
-   `x.Equals(null)`가 `false`를 반환하는 경우  
  
 구현의 <xref:System.Object.Equals%2A> 예외를 throw 하면 안 항상 값을 반환 해야 합니다. 예를 들어 경우 `obj` 됩니다 `null`, <xref:System.Object.Equals%2A> 메서드는 반환 해야 `false` throw 하는 대신는 <xref:System.ArgumentNullException>합니다.  
  
 재정의 하는 경우 이러한 지침 <xref:System.Object.Equals%28System.Object%29>:  
  
-   구현 하는 형식을 <xref:System.IComparable> 재정의 해야 <xref:System.Object.Equals%28System.Object%29>합니다.  
  
-   재정의 하는 형식 <xref:System.Object.Equals%28System.Object%29> 재정의 해야 <xref:System.Object.GetHashCode%2A>고, 그렇지 않으면 해시 테이블 올바르게 작동 하지 않을 수 있습니다.  
  
-   구현 하는 것이 좋습니다는 <xref:System.IEquatable%601> 강력 하 게 지원 하기 위해 인터페이스 형식의 같은지 여부를 테스트 합니다. 프로그램 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> 구현에서 일관 된 결과 반환 해야 <xref:System.Object.Equals%2A>합니다.  
  
-   프로그래밍 언어가 연산자 오버 로드를 지 원하는 지정된 된 형식에 같음 연산자를 오버 로드를 재정의 해야 하는 경우는 <xref:System.Object.Equals%28System.Object%29> 같음 연산자와 동일한 결과 반환 하는 방법입니다. 이렇게 하면 사용 하는 클래스 라이브러리 코드가 <xref:System.Object.Equals%2A> (같은 <xref:System.Collections.ArrayList> 고 <xref:System.Collections.Hashtable>) 응용 프로그램 코드에서 같음 연산자를 사용 하는 방법은 일치 하는 방식으로 동작 합니다.  
  
### <a name="guidelines-for-reference-types"></a>참조 형식에 대 한 지침  
 다음 지침에 재정의 적용 <xref:System.Object.Equals%28System.Object%29> 참조 형식에 대 한 합니다.  
  
-   재정의 하는 것이 좋습니다. <xref:System.Object.Equals%2A> 형식의 의미 체계 일부 값을 나타내는 경우.  
  
-   재정의 한 경우에 대부분의 참조 형식은 같음 연산자를 재정의 하지 해야 합니다 <xref:System.Object.Equals%2A>합니다. 그러나 복잡 한 숫자 형식과 같은 값 의미 체계에 참조 형식을 구현 하는 경우 같음 연산자를 재정의 해야 합니다.  
  
-   재정의 하지 않아야 함 <xref:System.Object.Equals%2A> 변경 가능한 참조 형식입니다. 재정의 되기 때문에 이것이 <xref:System.Object.Equals%2A> 도 재정의 하는 필요는 <xref:System.Object.GetHashCode%2A> 메서드를 이전 섹션에 설명 된 대로 합니다. 이 해시 테이블에서 손실 될 개체를 일으킬 수 있는 해당 수명 동안 변경할 수 있는 참조 형식 인스턴스의 해시 코드를 변경할 수 있다는 것을 의미 합니다.  
  
### <a name="guidelines-for-value-types"></a>값 형식에 대 한 지침  
 재정의에 다음 지침이 적용 <xref:System.Object.Equals%28System.Object%29> 값 형식을 사용 합니다.  
  
-   하나 이상의 필드를 포함 하는 값 형식을 정의 하는 경우 해당 값은 참조 형식, 재정의 해야 <xref:System.Object.Equals%28System.Object%29>합니다. <xref:System.Object.Equals%28System.Object%29> 가 제공한 구현을 <xref:System.ValueType> 형식이 값에 대 한 바이트 단위로 비교 필드는 모든 값 형식 이지만 리플렉션을 사용 하 여 해당 필드는 참조 형식을 포함 하는 값 형식의 필드에서 비교를 수행 합니다.  
  
-   재정의 하는 경우 <xref:System.Object.Equals%2A> 개발 언어가 연산자 오버 로드를 지 원하는, 같음 연산자를 오버 로드 해야 합니다.  
  
-   구현 해야 합니다 <xref:System.IEquatable%601> 인터페이스입니다. 강력한 형식의 호출 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> boxing을 방지 하는 메서드는 `obj` 인수입니다.  
  
   
  
## Examples  
 다음 예제와 `Point` 재정의 하는 클래스를 <xref:System.Object.Equals%2A> 값이 같은지를 제공 하는 방법 및 `Point3D` 클래스에서 파생 된 `Point`합니다. 때문에 `Point` 재정의 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 의 값이 같은지를 테스트 하는 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 메서드가 호출 되지 않습니다. 그러나 `Point3D.Equals` 호출 `Point.Equals` 있으므로 `Point` 구현 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 값이 같은지를 제공 하는 방식입니다.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 `Point.Equals` 메서드 했는지를 확인 합니다 `obj` 인수가 아닙니다 **null** 이 개체와 동일한 형식의 인스턴스를 참조 하 고 있습니다. 메서드가 반환 하는 경우 검사에 실패할 `false`합니다.  
  
 합니다 `Point.Equals` 메서드 호출을 <xref:System.Object.GetType%2A> 두 개체의 런타임 형식이 동일한 지 확인 하는 방법입니다. 메서드는 폼의 확인을 사용 하는 경우 `obj is Point` C# 또는 `TryCast(obj, Point)` Visual basic의 경우 반환 합니다 `true` 의 경우 여기서 `obj` 파생된 클래스의 인스턴스인 `Point`경우에 `obj` 및 현재 인스턴스는 동일한 런타임 형식이 아닙니다. 것을 확인 했으면는 개체를 모두 같은 형식의 메서드 캐스팅 `obj` 형식으로 `Point` 두 개체의 인스턴스 필드 비교의 결과 반환 합니다.  
  
 `Point3D.Equals`에서 상속 된 `Point.Equals` 메서드를 재정의 하는 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, 인스턴스인지 전에 호출 됩니다. 때문에 `Point3D` 클래스는 봉인된 클래스 (`NotInheritable` Visual basic에서), 형식에서 검사를 `obj is Point` C# 또는 `TryCast(obj, Point)` Visual Basic의 적합 하도록 `obj` 는 `Point3D` 개체. 경우는 `Point3D` 개체를 캐스팅 되는 `Point` 개체 및의 기본 클래스 구현에 전달 <xref:System.Object.Equals%2A>. 경우에만 상속 된 `Point.Equals` 메서드가 반환 `true` 메서드 비교에는 `z` 인스턴스 파생된 클래스에서 도입 된 필드입니다.  
  
 다음 예제에서는 정의 `Rectangle` 내부적으로 두 개의 사각형을 구현 하는 클래스 `Point` 개체입니다. 합니다 `Rectangle` 클래스에 재정의 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 값 같음에 대 한 제공 합니다.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 C# 및 Visual Basic과 같은 일부 언어 연산자 오버 로드를 지원 합니다. 형식이 같음 연산자를 오버 로드를 때 재정의 해야 합니다 <xref:System.Object.Equals%28System.Object%29> 동일한 기능을 제공 하는 방법입니다. 작성 하 여 일반적으로 이렇게는 <xref:System.Object.Equals%28System.Object%29> 메서드는 다음 예제와 같이 오버 로드 된 같음 연산자를 기준으로 합니다.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 때문에 `Complex` 값 형식에서 파생 될 수 없습니다.  재정의 하므로 <xref:System.Object.Equals%28System.Object%29> 메서드를 호출 하지 않아도 <xref:System.Object.GetType%2A> 결정할 정확한 런타임 유형의 없지만 각 개체를 대신 사용 합니다 `is` C# 연산자 또는 `TypeOf` 합니다 의유형을확인하려면VisualBasic의연산자`obj` 매개 변수입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">비교할 첫 번째 개체입니다.</param>
        <param name="objB">비교할 두 번째 개체입니다.</param>
        <summary>지정한 개체 인스턴스가 동일한지를 확인합니다.</summary>
        <returns>개체가 동일한 것으로 간주되면 <see langword="true" />이고, 간주되지 않으면 <see langword="false" />입니다. <paramref name="objA" /> 및 <paramref name="objB" />가 **null**인 경우 메서드는 <see langword="true" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정적 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> 여부를 두 개체, 메서드를 나타냅니다 `objA` 고 `objB`, 같은지 합니다. 이 값인 개체를 테스트할 수도 있습니다 **null** 같음에 대 한 합니다. 비교 `objA` 고 `objB` 같이 같음에 대 한 합니다.  
  
-   두 개체가 같은 개체 참조를 나타내는지 여부를 결정 합니다. 메서드가 반환 하는 경우 그럴 `true`합니다. 이 테스트는 호출에 해당 합니다 <xref:System.Object.ReferenceEquals%2A> 메서드. 또한 모두 `objA` 및 `objB` 됩니다 **null**, 메서드가 반환 `true`합니다.  
  
-   결정 하는지 여부를 중 하나 `objA` 또는 `objB` 됩니다 **null**합니다. 따라서 반환 하는 경우 `false`합니다.  
  
-   두 개체가 같은 개체 참조를 나타내지 않으면 고 둘 다 **null**을 호출한 `objA`.`Equals` (`objB`) 결과 반환 합니다. 즉 `objA` 재정의 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 메서드를이 재정의 라고 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> 메서드 및 비교 하는 <xref:System.Object.ReferenceEquals%2A> 메서드.  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>가비지 컬렉션이 회수하기 전에 개체가 리소스를 해제하고 다른 정리 작업을 수행할 수 있게 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A> 메서드 개체를 제거 하기 전에 현재 개체를 소유 하는 관리 되지 않는 리소스 정리 작업을 수행할를 사용 합니다. 메서드는 보호 되 고 이므로이 클래스 또는 파생된 클래스를 통해 액세스할 수 있습니다.  
  
 섹션 내용  
  
-   [종료의 작동 원리](#How)  
  
-   [구현자 참고 사항](#Notes)  
  
-   [SafeHandle 대안](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>종료의 작동 원리  
 합니다 <xref:System.Object> 클래스에 대 한 구현을 제공 합니다 <xref:System.Object.Finalize%2A> 메서드를 가비지 수집기에서 파생 된 형식으로 표시 되지 않습니다 <xref:System.Object> 종료에 대 한 재정의 하지 않는 한를 <xref:System.Object.Finalize%2A> 메서드.  
  
 형식에서 재정의 하는 경우는 <xref:System.Object.Finalize%2A> 메서드를 가비지 수집기는 종료 큐 라는 내부 구조에는 형식의 각 인스턴스에 대 한 항목을 추가 합니다. 가비지 수집기가 메모리를 회수할 수 전에 종료 코드를 실행 해야 관리 되는 힙에 있는 모든 개체에 대 한 항목을 포함 하는 종료 큐에 추가 합니다. 그런 다음 가비지 수집기를 호출 합니다 <xref:System.Object.Finalize%2A> 메서드는 다음 조건을 자동으로:  
  
-   가비지 수집기는 개체에 액세스할 수 없는 개체를 호출 하 여 종료에서 제외 된가 하지 않으면 검색에 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 메서드.  
  
-   응용 프로그램 도메인을 종료 하는 동안 없으면 개체를 종료 한 예외로 지정 합니다. 종료 하는 동안에 개체 계속 액세스할 수 있는 종료 됩니다.  
  
 <xref:System.Object.Finalize%2A> 자동으로 한 번만 호출 인스턴스에, 개체는 같은 메커니즘을 사용 하 여 다시 등록 하지 않는 한 <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> 하며 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 메서드가 이후에 호출 되지 않습니다.  
  
 <xref:System.Object.Finalize%2A> 작업은 다음과 같은 제한 사항이 있습니다.  
  
-   정확한 시간 종료 자가 실행 되는 경우 정의 되지 않습니다. 클래스의 인스턴스는 구현에 대 한 리소스의 명확한 해제를 확인 하는 `Close` 메서드 제공 또는 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 구현 합니다.  
  
-   다른 하나의 개체가 참조 하는 경우에 특정 순서에 관계 없이 실행 하는 두 개체의 종료자 보장 되지 않습니다. 즉, 둘 다 종료자 개체 A가 개체 B에 대 한 참조를 개체 B 수 이미 종료 되었을 개체의 종료자를 시작할 때입니다.  
  
-   종료 자가 실행 되는 스레드가 지정 되지 않습니다.  
  
 <xref:System.Object.Finalize%2A> 메서드 완료 될 때까지 실행 되지 않거나 다음 예외적인 상황에서 전혀 실행 되지 않을 수 있습니다.  
  
-   다른 종료자를 무기한으로 차단 하는 경우 (잠금이 되지를 고 수 등을 가져오려고 시도 무한 루프로 이동). 런타임에서 종료자 실행이 완료 하려고 하기 때문에 다른 종료자 수 호출할 수 없습니다 경우 종료자 블록 무기한.  
  
-   경우 런타임에서 정리할 기회를 제공 하지 않고 프로세스가 종료 됩니다. 이 경우 종료 프로세스의 첫 번째 알림 런타임의 DLL_PROCESS_DETACH 알림을 경우합니다  
  
 런타임에서 종료 가능한 개체 수가 계속 감소 하는 동안에 개체를 종료 하는 동안 종료를 계속 합니다.  
  
 하는 경우 <xref:System.Object.Finalize%2A> 또는 재정의 <xref:System.Object.Finalize%2A> 예외를 throw 하 고 런타임이 기본 정책을 재정의 하는 응용 프로그램에서 호스트 되지 않는, 프로세스 및 없는 활성 런타임이 종료 `try` / `finally` 블록 또는 종료자 실행 됩니다. 이 동작은 종료자 없거나 사용 가능한 리소스를 삭제 하는 경우 프로세스의 무결성을 보장 합니다.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Finalize 메서드 재정의 
 재정의 해야 <xref:System.Object.Finalize%2A> 파일 핸들이 나 사용 하는 관리 되는 개체가 가비지 수집 중에 삭제 됩니다 때 해제 되어야 하는 데이터베이스 연결 등의 관리 되지 않는 리소스를 사용 하는 클래스에 대 한 합니다. 구현 하지 않아야는 <xref:System.Object.Finalize%2A> 메서드를 가비지 수집기는 관리 되는 리소스를 자동으로 해제 하기 때문에 개체를 관리 합니다.  
  
> [!IMPORTANT]
>  경우는 <xref:System.Runtime.InteropServices.SafeHandle> 개체는 사용할 수 있는 관리 되지 않는 리소스를 래핑하는 권장 되는 대신 safehandle 사용 하 여 dispose 패턴을 구현 하 여 재정의 하지 <xref:System.Object.Finalize%2A>합니다. 자세한 내용은 [The SafeHandle 대안](#SafeHandle) 섹션입니다.  
  
 합니다 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 메서드가 기본적으로 아무 작업도 수행 하지 않지만 재정의 해야 <xref:System.Object.Finalize%2A> 필요 하 고 관리 되지 않는 리소스를 해제 하려는 경우에 합니다. 메모리를 회수 길어질 종료 작업을 실행 하는 경우 두 개 이상의 가비지 컬렉션을 필요로 하는 경향이 있습니다. 또한를 재정의 해야 하는 <xref:System.Object.Finalize%2A> 메서드 참조용 형식 에서만. 공용 언어 런타임에서 참조 형식만 종료합니다. 값 형식에 종료자는 무시합니다.  

범위는 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 메서드는 `protected`합니다. 클래스에서 메서드를 재정의 하는 경우에이 제한 된 범위를 유지 관리 해야 합니다. 유지 하 여는 <xref:System.Object.Finalize%2A> 개체의 호출에서 응용 프로그램의 사용자를 방지 보호 되는 메서드, <xref:System.Object.Finalize%2A> 메서드를 직접.
  
 모든 구현의 <xref:System.Object.Finalize%2A> 파생된 형식에서의 해당 기본 형식 구현을 호출 해야 <xref:System.Object.Finalize%2A>합니다. 이 응용 프로그램에서 코드를 호출할 수는 유일한 경우는 <xref:System.Object.Finalize%2A>합니다. 개체의 <xref:System.Object.Finalize%2A> 메서드 이외의 해당 기본 클래스의 모든 개체에서 메서드를 호출 해서는 안 됩니다. 호출 되는 다른 개체 수집할 수 있는 동시 호출 하는 개체와 같은 공용 언어 런타임 종료의 경우 때문입니다. 
  
> [!NOTE]
>  C# 컴파일러에서는 재정의할 수 없습니다는 <xref:System.Object.Finalize%2A> 메서드. 구현 하 여 종료자를 제공 하는 대신 한 [소멸자](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) 클래스에 대 한 합니다. C# 소멸자는 자동으로 기본 클래스의 소멸자를 호출합니다.  
>   
>  Visual c + + 구현에 대 한 자체 구문을 제공 합니다 <xref:System.Object.Finalize%2A> 메서드. 자세한 내용은 "소멸자 및 종료자" 섹션을 참조 하세요 [방법: 정의 사용할 클래스 및 구조체 (C + + CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)합니다.  
  
 가비지 컬렉션에서는 비결 이기 때문에 모르는 가비지 수집기가 종료를 수행 하는 경우에 정확 하 게 합니다. 리소스를 해제 하려면 즉시 수도 있습니다를 구현 하는 [삭제 패턴](~/docs/standard/design-guidelines/dispose-pattern.md) 고 <xref:System.IDisposable> 인터페이스입니다. <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 구현 클래스 소비자가 관리 되지 않는 리소스를 해제 하 여 호출할 수 있고 사용할 수는 <xref:System.Object.Finalize%2A> 관리 되지 않는 리소스를 해제 하는 방법에는 <xref:System.IDisposable.Dispose%2A> 메서드가 호출 되지 않습니다.  
  
 <xref:System.Object.Finalize%2A> 가비지 수집 동안 정리 되지 않은 후 개체 (즉, 내게 필요한 옵션이 개체 다시) 부활 하기를 포함 하 여 거의 모든 작업을 걸릴 수 있습니다. 그러나 개체 수만 복원할 되지 않습니다. <xref:System.Object.Finalize%2A> 가비지 수집 중 부활 개체에서 호출할 수 없습니다. 하나의 액션이 구현의 <xref:System.Object.Finalize%2A> 해서는 안 됩니다: 예외를 throw 하지 해야 합니다. 메서드에서 throw 된 예외에서 호출 된 경우는 <xref:System.Object.Finalize%2A> 메서드는 처리 되지를 <xref:System.Object.Finalize%2A> 메서드를 런타임에 가정를 <xref:System.Object.Finalize%2A> 메서드는 반환 하 고 계속 호출 하는 <xref:System.Object.Finalize%2A> 다른 개체의 메서드. 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>SafeHandle 대안  
 신뢰할 수 있는 종료자를 만들기 어렵습니다, 이므로 같은 시스템 예외를 처리 되지 않은 응용 프로그램의 상태에 대 한 가정을 변경할 수 없으므로 <xref:System.OutOfMemoryException> 고 <xref:System.StackOverflowException> 종료자를 종료 합니다. 관리 되지 않는 리소스를 해제 하려면 클래스에 대 한 종료자를 구현 하는 대신에서 파생 된 개체를 사용할 수 있습니다는 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 관리 되지 않는 리소스를 래핑할 클래스 및 종료 자가 없는 dispose 패턴을 구현 합니다. .NET Framework의 클래스를 제공 합니다 <xref:Microsoft.Win32?displayProperty=nameWithType> 에서 파생 되는 네임 스페이스 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 파일 핸들의 래퍼 클래스가입니다.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> 메모리 매핑된 파일 핸들에 대 한 래퍼 클래스가입니다.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> 관리 되지 않는 메모리 블록에 대 한 포인터에 대 한 래퍼 클래스가입니다.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>를 <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, 및 <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> 암호화 핸들에 대 한 래퍼 클래스입니다.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> 파이프 핸들에 대 한 래퍼 클래스가입니다.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 레지스트리 키에 대 한 핸들에 대 한 래퍼 클래스가입니다.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 대기 핸들의 래퍼 클래스가입니다.  
  
 다음 예제에서는 합니다 [삭제 패턴](~/docs/standard/design-guidelines/dispose-pattern.md) 재정의 하는 대신 safehandle을 사용 하 여는 <xref:System.Object.Finalize%2A> 메서드. 정의 `FileAssociation` 특정 파일 확장명을 사용 하 여 파일을 처리 하는 응용 프로그램에 대 한 레지스트리 정보를 래핑하는 클래스입니다. 로 반환 하는 두 레지스트리 핸들 `out` Windows에서 매개 변수 [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) 함수 호출에 전달 되는 <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 생성자입니다. 종류의 protected `Dispose` 메서드를 호출 합니다 `SafeRegistryHandle.Dispose` 이러한 두 핸들을 해제 하는 방법.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 다음 예제에서는 확인 합니다 <xref:System.Object.Finalize%2A> 메서드는 재정의 하는 개체가 <xref:System.Object.Finalize%2A> 소멸 됩니다. 응용 프로그램을 프로덕션에서의 <xref:System.Object.Finalize%2A> 개체에서 보유 하는 관리 되지 않는 리소스를 해제 메서드를 재정의 해야 합니다. C# 예제에서는 재정의 하는 대신 소멸자는 참고를 <xref:System.Object.Finalize%2A> 메서드.  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 재정의 하는 추가 예제는 <xref:System.Object.Finalize%2A> 메서드를 참조 합니다 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>기본 해시 함수로 작동합니다.</summary>
        <returns>현재 개체의 해시 코드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 해시 코드를 삽입 하 고 같은 해시를 기반으로 컬렉션의 개체를 식별 하는 데 사용 되는 숫자 값을 <xref:System.Collections.Generic.Dictionary%602> 클래스를 <xref:System.Collections.Hashtable> 클래스나 형식에서 파생 된는 <xref:System.Collections.DictionaryBase> 클래스. <xref:System.Object.GetHashCode%2A> 메서드 개체 같음의 빠른 검사 해야 하는 알고리즘에 대 한이 해시 코드를 제공 합니다.  
  
> [!NOTE]
>  해시 테이블의 해시 코드 사용 하는 방법에 대 한 내용은 및 일부 추가 해시 코드 알고리즘에 대 한 참조를 [해시 함수](https://en.wikipedia.org/wiki/Hash_function) Wikipedia의 항목입니다.  
  
 두 개체는 동일한 반환는 같은 해시 코드입니다. 그러나는 성립 되지: 다른 (같지 않음) 개체는 동일한 해시 코드를 포함할 수 있으므로 같은 해시 코드를 개체 같음 나타내지 않습니다. 또한.NET Framework의 기본 구현을 보장 하지 않습니다는 <xref:System.Object.GetHashCode%2A> 메서드와이 메서드가 반환 다 32 비트 및 64 비트 플랫폼 등의 플랫폼 및.NET Framework 버전 간의 값입니다. 이러한 이유로, 사용 하지 마십시오이 메서드의 기본 구현은 고유한 개체 식별자로 해시를 위해. 두 결과에서이 수행합니다.  
  
-   같은 해시 코드 개체 같음 의미는 가정 하지 않아야 합니다.  
  
-   되지 유지 하거나 응용 프로그램 도메인, 프로세스 및 플랫폼에서 동일한 개체 해시 수 때문에 생성 된 응용 프로그램 도메인 외부 해시 코드를 사용 해야 합니다.  
  
> [!WARNING]
>  해시 코드를 효율적인 삽입 및 해시 테이블을 기반으로 하는 컬렉션에서 조회를 위한 것입니다. 해시 코드를 영구적으로 값이 아닙니다. 이러한 이유로:  
>   
> -   해시 코드 값을 serialize 하거나 데이터베이스에 저장 하지 마십시오.  
> -   키 컬렉션에서 개체를 검색할 키로 해시 코드를 사용 하지 마십시오.  
> -   응용 프로그램 도메인 또는 프로세스에서 해시 코드를 보내지 않습니다. 경우에 따라 해시 코드는 프로세스별 또는 응용 프로그램 도메인 별로 계산 될 수 있습니다.  
> -   암호화 된 강력한 해시 해야 하는 경우 암호화 해시 함수에서 반환 된 값 대신 해시 코드를 사용 하지 마세요. 암호화 해시, 파생 클래스를 사용 합니다 <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> 또는 <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> 클래스입니다.  
> -   두 개체가 같은지 여부를 확인 하려면 해시 코드의 같은지 테스트 하지 마십시오. (같지 않은 개체에 동일한 해시 코드를 가질 수 있습니다.) 같은지를 테스트 하려면 다음을 호출 합니다 <xref:System.Object.ReferenceEquals%2A> 또는 <xref:System.Object.Equals%2A> 메서드.  
  
 <xref:System.Object.GetHashCode%2A> 파생된 된 형식에서 메서드를 재정의할 수 있습니다. 하는 경우 <xref:System.Object.GetHashCode%2A> 은 재정의 되지 않으면 해시 코드를 호출 하 여 계산 됩니다 참조 형식에 대 한 합니다 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 메서드의 해시 코드를 계산 하는 기본 클래스를을 기준으로 개체의 참조에 대 한 자세한 내용은 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>합니다. 즉, 두 개체의 합니다 <xref:System.Object.ReferenceEquals%2A> 메서드가 반환 되는 `true` 동일한 해시 코드입니다. 값 형식을 재정의 하지 않습니다 <xref:System.Object.GetHashCode%2A>, <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> 메서드는 기본 클래스의 리플렉션을 사용 하 여 해당 형식의 필드의 값을 기반으로 해시 코드를 계산 합니다. 즉, 해당 필드에 값이 같으면 값 형식에는 같은 해시 코드가 있습니다. 재정의 하는 방법에 대 한 자세한 내용은 <xref:System.Object.GetHashCode%2A>, "상속자 참고 사항" 섹션을 참조 하세요.  
  
> [!WARNING]
>  재정의 하는 경우는 <xref:System.Object.GetHashCode%2A> 메서드를 재정의 해야 하는 또한 <xref:System.Object.Equals%2A>, 그 반대로 가능 합니다. 경우 재정의 된 <xref:System.Object.Equals%2A> 메서드가 반환 `true` 재정의 된 같음에 대 한 두 개체는 테스트 하는 경우 <xref:System.Object.GetHashCode%2A> 메서드는 두 개체에 대해 동일한 값을 반환 해야 합니다.  
  
 경우 해시 테이블의 키로 사용 되는 개체에서는 구현 하는 유용한 <xref:System.Object.GetHashCode%2A>를 제공 하 여 해시 코드 공급자를 지정할 수 있습니다는 <xref:System.Collections.IEqualityComparer> 오버 로드 중 하나를 구현 합니다 <xref:System.Collections.Hashtable> 클래스 생성자.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>에 대 한 정보는 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 호출 하는 경우는 <xref:System.Object.GetHashCode%2A> 클래스의 메서드를 [!INCLUDE[wrt](~/includes/wrt-md.md)]를 재정의 하지 않는 하는 클래스에 대 한 기본 동작을 제공 <xref:System.Object.GetHashCode%2A>합니다. 이.NET Framework에 대 한 제공 하는 지원의 일부를 [!INCLUDE[wrt](~/includes/wrt-md.md)] (참조 [.NET Framework 지원에 대 한 Windows 스토어 앱 및 Windows 런타임](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). 클래스는 [!INCLUDE[wrt](~/includes/wrt-md.md)] 상속 안 함 <xref:System.Object>, 및 현재 구현 하지 않습니다는 <xref:System.Object.GetHashCode%2A>합니다. 그러나 가진 것으로 나타납니다 <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, 및 <xref:System.Object.GetHashCode%2A> 메서드 C# 또는 Visual Basic 코드에서 사용 하 고.NET Framework는 이러한 메서드의 기본 동작을 제공 하는 경우.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] C# 또는 Visual Basic에서 작성 된 클래스에서 재정의할 수는 <xref:System.Object.GetHashCode%2A> 메서드.  
  
   
  
## Examples  
 동일 하거나 보다 작은 범위에는 숫자 값에 대 한 해시 코드를 계산 하는 가장 간단한 방법 중 하나는 <xref:System.Int32> 형식은 단순히 해당 값을 반환 합니다. 다음 예제에서는 이러한 구현에 대 한는 `Number` 구조입니다.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 대부분의 경우 형식에 해시 코드를 생성에 참여할 수 있는 여러 데이터 필드입니다. 해시 코드를 생성 하는 한 가지 방법은 사용 하 여 이러한 필드를 결합 하는 것을 `XOR (eXclusive OR)` 다음 예제에서와 같이 작업 합니다.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 이전 예제에서는 동일한 해시 코드를 반환 합니다 (n1, n2) 및 (n2, n1), 이므로 적합 한 보다 자세한 충돌을 생성할 수 있습니다. 이러한 경우 해시 코드가 동일 하지 않은 되도록 여러 솔루션을 사용할 수 있습니다. 해시 코드를 반환 하는 경우 하나는 `Tuple` 각 필드의 순서를 반영 하는 개체입니다. 다음 예제에서는 사용 하는 가능한 구현 된 <xref:System.Tuple%602> 클래스입니다. 단는 인스턴스화하는 성능 오버 헤드를 `Tuple` 개체 해시 테이블에 많은 수의 개체를 저장 하는 응용 프로그램의 전반적인 성능에 큰 영향 수 있습니다.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 두 번째 대체 솔루션으로 비트를 두 개 이상의 연속 된 필드의 해시 코드를 왼쪽-이동 하 여 개별 해시 코드를 가중치 포함 됩니다. 최적으로 삭제 되는 대신 31 비트를 벗어나 이동 비트 기준으로 줄 바꿈되는 대신 삭제. 비트는 C# 및 Visual Basic 왼쪽 시프트 연산자가 무시 되는 있으므로이 다음과 같이 왼쪽된 시프트 및 줄 바꿈 메서드 만들기 필요 합니다.  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 다음 예제에서는이 shift 및 줄 바꿈의 해시 코드를 계산 하는 `Point` 이전 예제에서 사용 되는 구조입니다.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>해시 함수 개체의 값에 해당 하는 숫자 (해시 코드)를 신속 하 게 생성 됩니다. 해시 함수는 각 형식에 일반적으로 특정 하 고 고유성을 위해 사용 해야 하나 이상의 인스턴스 필드를 입력으로 합니다. 정적 필드의 값을 사용 하 여 해시 코드를 계산할 수 해야 합니다.  파생 된 클래스 <see cref="T:System.Object" />는 <see langword="GetHashCode" /> 메서드는 기본 클래스를 위임할 수 <see cref="M:System.Object.GetHashCode" /> 파생된 클래스 참조 일치에 일치 여부를 정의 하는 경우에 구현 합니다. 기본 구현의 <see cref="M:System.Object.GetHashCode" /> 참조 형식을 반환한 것에 해당 하는 해시 코드를 반환 하는 <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> 메서드. 재정의할 수 있습니다 <see cref="M:System.Object.GetHashCode" /> 변경할 수 없는 참조 형식에 대 한 합니다. 일반적으로 변경할 수 있는 참조 형식에 대해 재정의 해야 <see cref="M:System.Object.GetHashCode" /> 경우에만:-; 변경할 수 없는 필드에서 해시 코드를 계산할 수 있습니다 또는 collecti에 개체가 포함 되는 동안 변경할 수 있는 개체의 해시 코드를 변경 하지 않도록 확인할 수 있습니다 에 해당 해시 코드를 사용합니다.  그렇지 않으면 변경할 수 있는 개체 해시 테이블에서 손실 되는 생각할 수 있습니다. 재정의 하려는 경우 <see cref="M:System.Object.GetHashCode" /> 변경 가능한 참조 형식에 대 한 설명서는 명확 하 게 사용자 형식의 개체는 해시 테이블에 저장 하는 동안 개체 값을 수정 하지 않아야 합니다.  값 형식에 대 한 <see cref="M:System.ValueType.GetHashCode" /> 리플렉션을 사용 하는 기본 해시 코드 구현을 제공 합니다. 성능 향상을 위해 재정의 하는 것이 좋습니다.  <block subset="none" type="note"><para> 자세한 내용과 다양 한 방법에에서 대 한 해시 코드를 계산 하는 예제는 예제 섹션을 참조 하세요.  </para></block>  해시 함수는 다음과 같은 속성이 있어야 합니다.:-두 개체 같음으로 비교 하는 경우는 <see cref="M:System.Object.GetHashCode" /> 각 개체에 대 한 메서드는 동일한 값을 반환 해야 합니다. 그러나 두 개체를 동일한 것으로 비교 하지 않습니다 하는 경우는 <see cref="M:System.Object.GetHashCode" /> 두 개체의 메서드를 다른 값을 반환할 필요가 없습니다.  - <see cref="M:System.Object.GetHashCode" /> 메서드는 개체에 대 한 개체의 [System.Object.Equals](xref:System.Object.Equals*) 메서드입니다 반환 값을 결정 하는 개체 상태를 수정 하지 않으면으로 동일한 해시 코드를 일관 되 게 반환 해야 합니다. 이 응용 프로그램의 현재 실행에 대해서만 true 및 응용 프로그램을 다시 실행 되 면 다른 해시 코드를 반환할 수는 note 합니다.  -해시 함수는 최상의 성능을 위해 클러스터 많이 않은 입력을 포함 하 여 모든 입력에 대해 균등을 생성 해야 합니다. 의미는 개체 상태를 약간 수정할 개가 수신 되어야 대규모 수정을 최상의 성능을 얻으려면 해시 테이블 결과 해시 코드입니다.  해시 함수를 계산 하는 데 비용이 많이 드는 취소 해야 합니다.  - <see cref="M:System.Object.GetHashCode" /> 메서드는 예외를 throw 하지 않아야 합니다.  구현의 예를 들어, 합니다 <see cref="M:System.String.GetHashCode" /> 에서 제공 하는 메서드를 <see cref="T:System.String" /> 클래스 동일한 문자열 값에 대해 동일한 해시 코드를 반환 합니다. 따라서 두 <see cref="T:System.String" /> 동일한 문자열 값을 나타내는 경우 개체는 같은 해시 코드를 반환 합니다. 또한 메서드를 사용 하 여 모든 문자 문자열에 입력 특정 범위에 클러스터 된 경우에 무작위 분포 된 출력을 생성 (예를 들어 많은 사용자가 있을 수 있습니다도 낮은 128 ASCII 문자만 포함 하는 문자열을 문자열이 포함할 수 있습니다 65,535 유니코드 문자).  클래스에 적절 한 해시 함수를 제공 하는 해시 테이블에 해당 개체를 추가 하는 성능 크게 달라질 수 있습니다. 해시 함수를 구현 하는 키를 사용 하 여 해시 테이블의 요소를 검색 시간이 상수 (예: O(1) 작업). 잘 구현 되지 않은 해시 함수를 사용 하 여 해시 테이블의 검색 성능에 따라 달라 집니다 해시 테이블의 항목 수가 (O('n') 작업 예를 들어, 여기서 ' n '은 해시 테이블에는 항목의 수). 악의적인 사용자는 다음 조건에서 해시 테이블에 종속 된 응용 프로그램의 성능을 상당히 저하 될 수 있는 충돌 수가 증가 하는 데이터를 입력할 수:-자주 충돌을 생성 하는 해시 함수입니다.  -경우 해시 테이블에서 개체의 상당한 부분 같은지 또는 약 서로 같은지 여부를 지정 하는 해시 코드를 생성 합니다.  -사용자의 해시 코드 계산 되는 데이터를 입력 합니다.  재정의 하는 클래스를 파생 <see cref="M:System.Object.GetHashCode" /> 재정의 해야 합니다 <see cref="M:System.Object.Equals(System.Object)" /> 같은 것으로 간주 하는 두 개체가 동일한 해시 코드를 있는지을 보장 하기 위해이 고, 그렇지는 <see cref="T:System.Collections.Hashtable" /> 형식을 제대로 작동 하지 않을 수 있습니다.</para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 인스턴스의 <see cref="T:System.Type" />을 가져옵니다.</summary>
        <returns>현재 인스턴스의 정확한 런타임 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때문에 <xref:System.Object?displayProperty=nameWithType> .NET Framework 형식 시스템의 모든 형식에 대 한 기본 클래스인 합니다 <xref:System.Object.GetType%2A> 메서드를 사용 하 여 반환할 수 있습니다 <xref:System.Type> 모든.NET Framework 형식을 나타내는 개체입니다. .NET Framework에는 다음 다섯 가지 범주의 형식 인식합니다.  
  
-   클래스에서 파생 되는 <xref:System.Object?displayProperty=nameWithType>,  
  
-   값 형식에서 파생 되는 <xref:System.ValueType?displayProperty=nameWithType>합니다.  
  
-   인터페이스에서 파생 되는 <xref:System.Object?displayProperty=nameWithType> .NET Framework 2.0을 사용 하 여 시작 합니다.  
  
-   열거형에서 파생 되는 <xref:System.Enum?displayProperty=nameWithType>합니다.  
  
-   파생 되는 대리자 <xref:System.MulticastDelegate?displayProperty=nameWithType>합니다.  
  
 두 개체에 대 한 `x` 하 고 `y` 동일한 런타임 유형의 `Object.ReferenceEquals(x.GetType(),y.GetType())` 반환 `true`합니다. 다음 예제에서는 합니다 <xref:System.Object.GetType%2A> 메서드는 <xref:System.Object.ReferenceEquals%2A> 하나의 숫자 값에 동일한 두 개의 다른 숫자 값 형식 인지 여부를 확인 하는 방법입니다.  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  개체는 특정 형식 인지를 확인 하려면 비교 키워드를 입력 하는 언어의를 사용할 수도 있고 생성 키를 누릅니다. 예를 들어 사용할 수 있습니다 합니다 `TypeOf…Is` Visual Basic의 생성 또는 `is` C#의 키워드입니다.  
  
 합니다 <xref:System.Object.GetType%2A> 메서드는에서 파생 되는 모든 형식에서 상속 되며, <xref:System.Object>합니다. 이 사용자 고유의 언어의 비교 키워드를 사용 하는 것 외에도 사용할 수 있는 것을 의미 합니다 <xref:System.Object.GetType%2A> 다음 예와 같이 특정 개체의 형식을 결정 하는 방법입니다.  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 합니다 <xref:System.Type> 개체는 현재 클래스와 연결 된 메타 데이터를 노출 <xref:System.Object>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Object.GetType%2A> 현재 인스턴스의 런타임 형식을 반환 합니다.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Object" />의 단순 복사본을 만듭니다.</summary>
        <returns>현재 <see cref="T:System.Object" />의 단순 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.MemberwiseClone%2A> 메서드는 새 개체를 만들고 다음 새 개체를 현재 개체의 비정적 필드를 복사 하 여 단순 복사본을 만듭니다. 필드 값 형식이 면 필드를 비트 단위로 복사가 수행 됩니다. 필드 참조 형식이 면 참조가 복사 되 고 이지만 참조 된 개체는 없습니다. 따라서 원래 개체 및 해당 복제본 같은 개체를 참조 하세요.  
  
 예를 들어 참조 개체 C는 개체 및 개체 B를 참조 하는 X 라는 개체 X의 단순 복사본을 만들고 개체 A 및 B를 참조 하는 새 개체 X2 반면, X의 전체 복사본을 A2 및 B2, A의 복사본 인 새 개체를 참조 하는 새 개체 X2 만들고 B. B2 C의 복사본 인 새 개체 C2, 참조 예제는 단순 하 고 전체 복사 작업의 차이점을 보여 줍니다.  
  
 단순 복사 작업을 수행한 경우 전체 복사 작업을 구현 하는 방법은 여러 가지가 <xref:System.Object.MemberwiseClone%2A> 메서드 요구를 충족 하지 않습니다. 이러한 요구 사항은 다음과 같습니다.  
  
-   첫 번째 개체에서 가져온 속성 값을 사용 하 여 두 번째 개체를 만들려는 복사 대상 개체의 클래스 생성자를 호출 합니다. 이 개체의 값을 클래스 생성자에 의해 완전히 정의 되어 있는지 가정 합니다.  
  
-   호출 된 <xref:System.Object.MemberwiseClone%2A> 메서드를 개체의 단순 복사본을 만들고 해당 값은 속성 또는 필드 값은 참조 형식에 원래 개체와 동일한 새 개체를 할당 합니다. `DeepCopy` 메서드 예제에서에서는이 방법을 보여 줍니다.  
  
-   복사 심층 되도록 개체를 serialize 하 고 다양 한 개체 변수를 serialize 된 데이터를 복원 합니다.  
  
-   리플렉션을 사용 하 여 재귀를 사용 하 여 심층 복사 작업을 수행 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Object.MemberwiseClone%2A> 메서드. 정의 `ShallowCopy` 메서드를 호출 하는 <xref:System.Object.MemberwiseClone%2A> 단순 복사 작업을 수행 하는 방법을 `Person` 개체입니다. 또한 정의 `DeepCopy` 에서 전체 복사 작업을 수행 하는 메서드를 `Person` 개체입니다.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 이 예제에서는 합니다 `Person.IdInfo` 속성이 반환을 `IdInfo` 개체입니다. 예제에서 출력으로 경우는 `Person` 개체를 호출 하 여 복제를 <xref:System.Object.MemberwiseClone%2A> 메서드를 선택 하 여 복제 된 `Person` 개체가 원래 개체의 독립적인 복사본을 동일한 공유 한다는 점을 제외 하면 `Person.IdInfo` 개체 참조입니다. 결과적으로 복제본의 수정 `Person.IdInfo` 속성에는 원래 개체의 변경 `Person.IdInfo` 속성입니다. 반면에 전체 복사 작업을 수행 될 때 복제 된 `Person` 개체를 포함 하 여 해당 `Person.IdInfo` 원래 개체에 영향을 주지 않고 속성을 수정할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">비교할 첫 번째 개체입니다.</param>
        <param name="objB">비교할 두 번째 개체입니다.</param>
        <summary>지정한 <see cref="T:System.Object" /> 인스턴스가 동일한지 여부를 확인합니다.</summary>
        <returns>
          <paramref name="objA" />와 <paramref name="objB" />의 인스턴스가 같거나 둘 다 **null**인 경우 <see langword="true" />이고 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 달리 합니다 <xref:System.Object.Equals%2A> 메서드와 같음 연산자는 <xref:System.Object.ReferenceEquals%2A> 메서드를 재정의할 수 없습니다. 이 인해 테스트 하려는 경우 두 개체 같음에 대 한 참조 및 구현에 대 한 확실 하지 않은 합니다 `Equals` 메서드를 호출할 수 있습니다는 <xref:System.Object.ReferenceEquals%2A> 메서드.  
  
 그러나의 반환 값은 <xref:System.Object.ReferenceEquals%2A> 메서드는 이러한 두 가지 시나리오에서 비정상으로 표시 될 수 있습니다.  
  
-   값 형식 비교 합니다. 경우 `objA` 하 고 `objB` 는 값 형식에 전달 되기 전에 boxed 됩니다는 <xref:System.Object.ReferenceEquals%2A> 메서드. 즉, 둘 다 `objA` 및 `objB` 값 형식의 같은 인스턴스를 <xref:System.Object.ReferenceEquals%2A> 그럼에도 불구 하 고 반환 `false`다음 예제와 같이 합니다.  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Boxing 값 형식에 대 한 자세한 내용은 [Boxing 및 Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)합니다.  
  
-   문자열 비교 합니다. 하는 경우 `objA` 및 `objB` 는 문자열을 <xref:System.Object.ReferenceEquals%2A> 메서드가 반환 되는 `true` 문자열 내부 풀에 추가 하는 경우. 값이 같은지를 테스트를 수행 하지 않습니다.  다음 예에서 `s1` 고 `s2` 이므로 단일 인턴 지정된 문자열의 두 인스턴스가 같은지 합니다. 그러나 `s3` 고 `s4` 문자열이 인턴 지정 되지 동일한 문자열 값을 같지만 때문에, 두 개체가 다릅니다.  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     문자열 인터닝에 대 한 자세한 내용은 참조 하세요. <xref:System.String.IsInterned%2A?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Object.ReferenceEquals%2A> 두 개체가 같은 인스턴스 되는지 확인할 수 있습니다.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 개체를 나타내는 문자열을 반환합니다.</summary>
        <returns>현재 개체를 나타내는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 주요는.NET Framework의 메서드 서식이 지정 되어 있습니다. 표시에 적합 한 되도록 개체를 문자열 표현으로 변환 합니다. (.NET framework에서 지원 형식에 대 한 내용은 [형식](~/docs/standard/base-types/formatting-types.md).) 기본 구현은 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드 개체 형식의 정규화 된 이름을 반환 합니다.  
  
> [!IMPORTANT]
>  수에 도달 했습니다.이 페이지에서 다른 형식의 멤버 목록에 링크를 따라 해당 형식을 재정의 하지 않는 때문 <xref:System.Object.ToString%2A?displayProperty=nameWithType>합니다. 대신,의 기능을 상속 되는 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드.  
  
 형식은 자주 재정의 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 특정 형식의 더 적합 한 문자열 표현을 제공 하는 방법입니다. 형식에서 자주도 오버 로드는 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 형식 문자열 또는 문화권 구분 서식 지정에 대 한 지원을 제공 하는 방법입니다.  
  
 섹션 내용  
  
 [기본 object.tostring () 메서드](#Default)   
 [Object.tostring () 메서드를 재정의합니다.](#Overriding)   
 [ToString 메서드를 오버 로드](#Overloading)   
 [Object.ToString 메서드를 확장합니다.](#Extending)   
 [Windows 런타임에 대 한 정보](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>기본 object.tostring () 메서드  
 기본 구현을 <xref:System.Object.ToString%2A> 메서드 형식의 정규화 된 이름을 반환 합니다 <xref:System.Object>다음 예제와 같이 합니다.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 때문에 <xref:System.Object> 모든 참조 형식의 기본 클래스인.NET framework에서이 동작 재정의 하지 않는 참조 형식에서 상속 되는 <xref:System.Object.ToString%2A> 메서드. 다음은 이에 대한 예입니다. 이라는 클래스를 정의 `Object1` 기본 구현의 모든을 허용 하는 <xref:System.Object> 멤버입니다. 해당 <xref:System.Object.ToString%2A> 메서드는 개체의 정규화 된 형식 이름을 반환 합니다.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Object.tostring () 메서드를 재정의합니다.  
 형식은 일반적으로 재정의 된 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 개체 인스턴스를 나타내는 문자열을 반환 하는 방법입니다. 예를 들어,와 같은 기본 형식 <xref:System.Char>, <xref:System.Int32>, 및 <xref:System.String> 제공 <xref:System.Object.ToString%2A> 문자열 형식의 개체를 나타내는 값을 반환 하는 구현 합니다. 다음 예제에서는 클래스를 정의 `Object2`를 재정의 하는 <xref:System.Object.ToString%2A> 해당 값과 함께 형식 이름을 반환 하는 방법입니다.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 다음 표에서.NET Framework의 형식 범주를 나열 하 고 재정의 되었는지 아닌지를 나타냅니다는 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드.  
  
|형식 범주|Object.tostring ()를 재정의합니다.|동작|  
|-------------------|-----------------------------------|--------------|  
|클래스|N/A|N/A|  
|구조체|예 (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Object.tostring ()와 동일|  
|열거형|예 (<xref:System.Enum.ToString?displayProperty=nameWithType>)|멤버 이름|  
|인터페이스|아니요|N/A|  
|대리자|아니요|N/A|  
  
 재정의에 상속자 섹션 추가 정보에 대 한 정보를 참조 하세요. <xref:System.Object.ToString%2A>합니다.  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>ToString 메서드를 오버 로드  
 매개 변수가 없는 재정의 하는 것 외에도 <xref:System.Object.ToString?displayProperty=nameWithType> 메서드를 다양 한 형식을 오버 로드는 `ToString` 매개 변수를 받아들이는 메서드의 버전을 제공 하는 방법입니다. 가장 일반적으로 이렇게 하면 변수 서식을 지정 하 고 문화권 구분 서식 지정 지원을 제공 합니다.  
  
 다음 예제에서는 오버 로드는 `ToString` 의 다양 한 필드의 값을 포함 하는 결과 문자열을 반환 하는 메서드는 `Automobile` 클래스입니다. 4 개의 형식 문자열을 정의 합니다: 모델 이름 및 연간;를 반환 하는 G 모델 이름, 연도 및; 문의 개수를 반환 하는 D 모델 이름, 연도 및; 실린더 수를 반환 하는 C 및는 모든 4 개의 필드 값을 사용 하 여 문자열을 반환 합니다.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 다음 예제에서는 오버 로드 된 <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 통화 값의 문화권 구분 서식 지정을 표시 하는 방법입니다.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 형식 문자열 및 문화권 구분 서식 지정에 대 한 자세한 내용은 참조 하세요. [형식](~/docs/standard/base-types/formatting-types.md)합니다. 숫자 값에서 지원 되는 형식 문자열을 참조 하세요 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 날짜 및 시간 값에서 지원 되는 형식 문자열을 참조 하세요 [표준 날짜 및 시간 서식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 하 고 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다.  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Object.ToString 메서드를 확장합니다.  
 기본값을 상속 하는 형식은 있으므로 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드 있습니다 동작 바람직하지 않은 찾아서 변경 하려면. 배열 및 컬렉션 클래스의 경우 특히 그렇습니다. 수 있지만 `ToString` 메서드는 배열 또는 컬렉션 클래스의 해당 멤버의 값을 표시 하려면 대신 표시 형식 정규화 된 형식 이름, 다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 원하는 결과 문자열을 생성 하는 몇 가지 옵션이 있습니다.  
  
-   형식 배열, 컬렉션 개체 또는 개체를 구현 하는 경우는 <xref:System.Collections.IEnumerable> 또는 <xref:System.Collections.Generic.IEnumerable%601> 인터페이스를 사용 하 여 해당 요소를 열거할 수 있습니다는 `foreach` C#의 문은 또는 `For Each...Next` Visual Basic에서 생성 합니다.  
  
-   클래스가 아닌 경우 `sealed` (C#에서) 또는 `NotInheritable` (Visual Basic의 경우)의 해당 기본 클래스에서 상속 하는 래퍼 클래스를 개발할 수 있습니다 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드를 사용자 지정 하려면. 최소한 다음을 수행 하는이 필요 합니다.  
  
    1.  필요한 생성자를 구현 합니다. 파생된 클래스는 기본 클래스 생성자를 상속 하지 않습니다.  
  
    2.  재정의 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 싶은 결과 문자열을 반환 하는 방법입니다.  
  
     다음 예제에 대 한 래퍼 클래스를 정의 합니다 <xref:System.Collections.Generic.List%601> 클래스입니다. 재정의 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 정규화 된 형식 이름 대신 컬렉션의 각 메서드에 값을 표시 하는 방법입니다.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   개발을 [확장 메서드](~/docs/standard/design-guidelines/extension-methods.md) 는 원하는 결과 문자열을 반환 합니다. 기본값을 재정의할 수 없습니다는 참고 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 이런에서 메서드 (프로그램 확장 클래스 (C#) 또는 모듈 (Visual Basic)에서는 라는 매개 변수가 없는 메서드를 사용할 수 없습니다, 즉 `ToString` 원래 형식 대신 호출 되는 `ToString` 메서드 . 에 매개 변수가 없는의 다른 이름을 제공 해야 `ToString` 대체 합니다.  
  
     확장 하는 두 메서드를 정의 하는 다음 예제에서는 합니다 <xref:System.Collections.Generic.List%601> 클래스: 매개 변수가 없는 `ToString2` 메서드를 및 `ToString` 메서드를 <xref:System.String> 서식 문자열을 나타내는 매개 변수입니다.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>에 대 한 정보는 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 호출 하는 경우는 <xref:System.Object.ToString%2A> 클래스의 메서드를 [!INCLUDE[wrt](~/includes/wrt-md.md)]를 재정의 하지 않는 하는 클래스에 대 한 기본 동작을 제공 <xref:System.Object.ToString%2A>합니다. 이.NET Framework에 대 한 제공 하는 지원의 일부를 [!INCLUDE[wrt](~/includes/wrt-md.md)] (참조 [.NET Framework 지원에 대 한 Windows 스토어 앱 및 Windows 런타임](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). 클래스는 [!INCLUDE[wrt](~/includes/wrt-md.md)] 상속 안 함 <xref:System.Object>, 항상 구현 하지는 <xref:System.Object.ToString%2A>합니다. 그러나 항상 가진 것으로 나타납니다 <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, 및 <xref:System.Object.GetHashCode%2A> 메서드 C# 또는 Visual Basic 코드에서 사용 하 고.NET Framework는 이러한 메서드에 대 한 기본 동작을 제공 하는 경우.  
  
 부터 합니다 [!INCLUDE[net_v451](~/includes/net-v451-md.md)], 공용 언어 런타임을 사용 합니다 [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) 에 [!INCLUDE[wrt](~/includes/wrt-md.md)] 대체의 기본 구현 하기 전에 개체 <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] C# 또는 Visual Basic에서 작성 된 클래스에서 재정의할 수는 <xref:System.Object.ToString%2A> 메서드.  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)] 및 IStringable 인터페이스  
 부터 [!INCLUDE[win81](~/includes/win81-md.md)]의 [!INCLUDE[wrt](~/includes/wrt-md.md)] 포함을 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 인터페이스 인 단일 메서드 [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), 기본 서식 지정 지원을 제공 합니다 제공한 <xref:System.Object.ToString%2A?displayProperty=nameWithType>합니다. 모호성을 방지 하려면 구현 하지 않아야 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 에서 관리 되는 형식입니다.  
  
 JavaScript 또는 C +와 같은 언어로 작성 된 코드 또는 네이티브 코드에서 관리 되는 개체 호출 될 때 + 구현에 게 표시 되는, CX [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)합니다. 공용 언어 런타임 호출에서 자동으로 라우팅하므로 [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) 하 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 이벤트 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 관리 개체에서 구현 되지 않습니다.  
  
> [!WARNING]
>  공용 언어 런타임에서 자동 구현 하기 때문에 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 관리 되는 형식에서 모든 [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] 앱 것이 좋습니다는 제공 하지 않으면 사용자 고유의 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 구현 합니다. 구현 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 를 호출할 때 의도 하지 않은 동작이 발생할 `ToString` 에서 [!INCLUDE[wrt](~/includes/wrt-md.md)], C + + /CX 또는 JavaScript입니다.  
  
 구현 하려는 경우 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 에서 내보낸 관리 공용 형식에는 [!INCLUDE[wrt](~/includes/wrt-md.md)] 구성 요소는 다음 제한이 적용 됩니다.  
  
-   정의할 수 있습니다 합니다 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 와 같은 "클래스 구현" 관계 에서만에서 인터페이스  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     C#  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     Visual Basic  
  
-   구현할 수 없습니다 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 인터페이스에서 합니다.  
  
-   형식 매개 변수를 선언할 수 없습니다 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)합니다.  
  
-   [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 반환 형식의 메서드, 속성 또는 필드 일 수 없습니다.  
  
-   숨길 수 없습니다 하 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 다음과 같은 메서드 정의 사용 하 여 기본 클래스에서 구현 합니다.  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     대신 합니다 [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) 구현은 언제나 기본 클래스 구현을 재지정 해야 합니다. 강력한 형식의 클래스 인스턴스에서 호출해야만 `ToString` 구현을 숨길 수 있습니다.  
  
 다양 한 조건에서 구현 하는 관리 되는 형식에 네이티브 코드에서 호출 하는 참고 [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 표시 하거나 숨깁니다 해당 [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) 구현에 예기치 않은 동작이 발생할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>사용자 고유의 형식을 구현할 때 재정의 해야 합니다 <see cref="M:System.Object.ToString" /> 해당 형식에 대 한 의미 있는 값을 반환 하는 방법입니다. 보다 자세한 제어를 필요로 하는 클래스를 파생 <see cref="M:System.Object.ToString" /> 제공 구현할 수는 <see cref="T:System.IFormattable" /> 인터페이스입니다. 해당 <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> 메서드를 사용 하면 서식을 제어 하는 서식 문자열을 정의 하 고 사용 하는 <see cref="T:System.IFormatProvider" /> culture 별 서식 지정에 도움이 되는 개체입니다.  재정의 <see cref="M:System.Object.ToString" /> 메서드 이러한 지침을 따라야 합니다.-친숙 하 고 사용자가 읽을 수는 반환 된 문자열 이어야 합니다.  -반환 된 문자열 개체 인스턴스의 값을 고유 하 게 식별 해야 합니다.  -반환 된 문자열 디버거에 의해 표시 하기에 적합 되도록 가능한 한 짧은 것 이어야 합니다.  - <see cref="M:System.Object.ToString" /> 재정의 반환 되어서는 안 <see cref="F:System.String.Empty" /> 또는 null 문자열입니다.  - <see cref="M:System.Object.ToString" /> 재정의 예외를 throw 하지 않아야 합니다.  -인스턴스의 문자열 표현을 문화권을 구분 하거나 여러 가지 방법으로 서식을 지정할 수 있습니다, 경우 구현 된 <see cref="T:System.IFormattable" /> 인터페이스입니다.  -반환된 된 문자열에 중요 한 정보를 포함 하는 경우 먼저 적절 한 권한을 요청 해야 합니다. 요청이 성공 하면 중요 한 정보를 반환할 수 있습니다. 그렇지 않으면 중요 한 정보를 제외 하는 문자열을 반환 합니다.  - <see cref="M:System.Object.ToString" /> 재정의 디버깅 문제가 발생 하지 않도록 하려면 식별할 수 있는 파생 작업이 있어야 합니다. 예를 들어,에 대 한 호출을 <see cref="M:System.Object.ToString" /> 메서드는 인스턴스 필드의 값을 변경 하지 않습니다.  -형식을 구문 분석 메서드를 구현 하는 경우 (또는 <see langword="Parse" /> 또는 <see langword="TryParse" /> 메서드, 생성자 또는 문자열에서 형식의 인스턴스를 인스턴스화하는 일부 다른 정적 메서드)를 반환 하는 문자열 확인 해야 합니다 <see cref="M:System.Object.ToString" /> 메서드 일 수 있습니다 개체 인스턴스로 변환 합니다.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>