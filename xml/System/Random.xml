<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="db0be843724a3e5db9bde798d384dd7ecf5a6c0f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36429196" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>의사(pseudo) 난수 생성기를 나타냅니다. 이 장치는 무작위성에 대한 통계적인 특정 요구 사항과 일치하는 숫자 시퀀스를 생성합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 의사 난수는 같은 확률으로 한정 된 숫자 집합에서 선택 됩니다. 수학적 알고리즘을 선택한 후 사용 되었지만 실무 충분히 임의로 선택 된 숫자가 완전히 임의 않습니다. 현재 구현에서 <xref:System.Random> 클래스가 Donald E. 크누스의 빼기 난수 생성기 알고리즘의 수정된 된 버전을 기반 합니다. 자세한 내용은 4. 5.를 참조 하십시오. 크누스 합니다. *컴퓨터 볼륨 2를 프로그래밍 아트: Seminumerical 알고리즘*합니다. Addison-wesley, 읽기, MA 세 번째 버전에서는 1997 합니다.  
  
 사용 하 여 임의의 암호를 만들기에 적합 한 암호화 보안 난수 번호를 생성 하는 <xref:System.Security.Cryptography.RNGCryptoServiceProvider> 나 클래스에서 클래스를 파생 <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>합니다.  
  
 항목 내용:  
  
 [난수 생성기를 인스턴스화](#Instantiate)   
 [여러 인스턴스 방지](#Multiple)   
 [System.Random 클래스 및 스레드 안전성](#ThreadSafety)   
 [다양 한 유형의 난수를 생성합니다.](#Functionality)   
 [사용자 고유의 알고리즘으로 대체](#Overriding)   
 [사용 하는 방법에 대 한 System.Random 중...](#Operations)   
 [동일한 임의 값의 시퀀스를 검색 합니다.](#Same)  
 [난수 값의 고유한 시퀀스를 검색 합니다.](#Unique)  
 [지정된 된 범위에 있는 정수를 검색 합니다.](#Range)  
 [지정된 된 수의 자릿수를 가진 정수를 검색 합니다.](#Digits)  
 [지정된 된 범위에서 부동 소수점 값을 검색](#Floats)  
 [임의의 Boolean 값을 생성 합니다.](#Boolean)  
 [임의의 64 비트 정수를 생성 합니다.](#Long)  
 [지정된 된 범위에 바이트를 검색 합니다.](#Bytes)  
 [배열 또는 컬렉션에서 요소를 무작위로 검색](#Array)  
 [배열 또는 컬렉션에서 고유 요소를 검색 합니다.](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>난수 생성기를 인스턴스화  
 에 시드 값 (의 의사 (pseudo) 난수 생성 알고리즘에 대 한 시작 값)를 제공 하 여 난수 생성기를 인스턴스화하는 <xref:System.Random.%23ctor%2A> 클래스 생성자입니다.  명시적 또는 암시적으로 시드 값을 제공할 수 있습니다.  
  
-   <xref:System.Random.%23ctor%28System.Int32%29> 생성자를 제공 하는 명시적 시드 값을 사용 합니다.  
  
-   <xref:System.Random.%23ctor> 생성자에서 시스템 클록을 사용 하 여 시드 값을 제공 합니다. 이것이 난수 생성기를 인스턴스화하는 가장 일반적인 방법입니다.  
  
 동일한 초기값 별개의 사용 되는 경우 <xref:System.Random> 개체를 같은 일련의 임의 숫자를 생성 합니다. 이 재생 데이터 임의 숫자에서 파생 되는 게임에 대 한 또는 임의의 값을 처리 하는 테스트 도구 모음을 만드는 데 유용할 수 있습니다. 하지만, <xref:System.Random> 다른 버전의.NET Framework에서 실행 중인 프로세스의 개체 값이 동일한 시드 인스턴스화되는 경우에 다른 일련의 임의 숫자를 반환할 수 있습니다.  
  
 임의의 숫자의 서로 다른 시퀀스를 생성 하려면 가능 시드 값은 시간 종속적 함으로써 다른 일련의 각 새 인스턴스를 생성 <xref:System.Random>합니다. 매개 변수가 있는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자 가져올 수 있습니다는 <xref:System.Int32> 값 수에 따라 틱의 현재 시간에서 반면 매개 변수가 없는 <xref:System.Random.%23ctor> 생성자 시스템 시계를 사용 하 여 시드 값을 생성 합니다. 그러나 클록 확인에는 한계가 때문에 사용 하 여 매개 변수가 없는 생성자를 만들려면 다른 <xref:System.Random> 개체 짧은 간격에 동일한 시퀀스 난수를 생성 하는 난수 생성기를 만듭니다. 다음 예제에서는 두 <xref:System.Random> 짧은 간격에 시작 된 개체가 생성 한 동일한 일련의 임의 숫자입니다. 대부분의 Windows 시스템에서 <xref:System.Random> 서로 15 밀리초 내에 만들어진 개체는 같은 시드 값을 갖고 있습니다.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 이 문제를 방지 하려면 단일 만들 <xref:System.Random> 여러 개체 대신 개체입니다.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>여러 인스턴스 방지  
 두 개의 난수 생성기를 빨리 연속 또는 루프에서 초기화를 두 개의 난수 생성기의 난수 동일한 시퀀스를 생성할 수 있는 만듭니다. 대부분의 경우에서이 개발자의 의도 아니며 인스턴스화 및 초기화는 난수 생성기에 상대적으로 비용이 많이 드는 프로세스 이므로 성능 문제가 발생할 수 있습니다.  
  
 성능 향상을 위해와 모두 동일한 숫자 시퀀스를 생성 하는 별도 임의의 수 생성기 실수로 않도록 하기 위해, 하나를 만드는 것이 좋습니다 <xref:System.Random> 만드는 대신 시간에 따라 많은 난수를 생성 하는 개체 새 <xref:System.Random> 하나 난수를 생성 하는 개체입니다.  
  
 그러나는 <xref:System.Random> 클래스에는 스레드로부터 안전 하 게 보호 되지 않습니다. 호출 하는 경우 <xref:System.Random> 여러 스레드에서 메서드는 다음 섹션에서 설명한 지침을 따릅니다.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>System.Random 클래스 및 스레드 안전성  
 인스턴스화하는 동안 개별 대신 <xref:System.Random> 개체는 단일을 만들어야 하는 것이 좋습니다 <xref:System.Random> 인스턴스를 응용 프로그램에 필요한 모든 임의 숫자를 생성 합니다. 그러나 <xref:System.Random> 개체는 스레드로부터 안전 하지 않습니다. 응용 프로그램을 호출 하는 경우 <xref:System.Random> 여러 스레드에서 메서드를 한 번에 한 스레드만 난수 생성기를 액세스할 수 있도록 하는 동기화 개체를 사용 해야 합니다. 있는지를 확인 하지 않는 경우는 <xref:System.Random> 개체는 스레드로부터 안전한 방식으로 액세스, 0을 반환 하는 난수를 반환 하는 메서드를 호출 합니다.  
  
 다음 예제에서는 C# [lock 문](~/docs/csharp/language-reference/keywords/lock-statement.md) 및 Visual Basic [SyncLock 문](~/docs/visual-basic/language-reference/statements/synclock-statement.md) 스레드로부터 안전한 방식으로 단일 난수 생성기 11 스레드에서 액세스할 있도록 합니다. 각 스레드 2 백만 난수를 생성, 난수 생성의 수를 계산 하 고 해당 합계를 계산 및 실행 완료 될 때 모든 스레드에 대 한 합계를 업데이트 합니다.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 이 예제에서는 다음과 같은 방법으로 스레드 보안을 확인합니다.  
  
-   <xref:System.ThreadStaticAttribute> 특성 난수를 생성 하 고 각 스레드에 대 한 합계의 총 수를 추적 하는 스레드 로컬 변수를 정의 하는 데 사용 됩니다.  
  
-   잠금을 (의 `lock` C# 문 및 `SyncLock` Visual Basic의 문)는 총 수 및 모든 스레드에서 생성 된 모든 임의 수의 합계에 대 한 변수에 대 한 액세스를 보호 합니다.  
  
-   세마포 (의 <xref:System.Threading.CountdownEvent> 개체)는 모든 다른 스레드가 될 때까지 주 스레드 차단 실행을 완료 하는 데 사용 됩니다.  
  
-   이 예제에서는 난수 생성기 난수 생성 메서드를 두 번 연속 호출 0을 반환 하는지 여부를 확인 하 여 손상 되었습니다 있는지 여부를 확인 합니다. 이 예에서는 사용 손상이 감지 되 면는 <xref:System.Threading.CancellationTokenSource> 모든 스레드를 취소 해야 한다는 신호를 보내 개체입니다.  
  
-   각 난수를 생성 하기 전에 각 스레드는의 상태를 확인는 <xref:System.Threading.CancellationToken> 개체입니다. 이 예에서는 호출 취소를 요청한 경우는 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 스레드를 취소할 메서드.  
  
 다음 예제는 사용 하 여 첫 번째는 <xref:System.Threading.Tasks.Task> 대신 람다 식과 개체 <xref:System.Threading.Thread> 개체입니다.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 다음과 같은 방법으로의 첫 번째 예제에서 마다 다릅니다.  
  
-   난수 생성의 수 및 각 작업의 합계를 추적 하는 변수는 작업에 로컬 이므로 사용할 필요가 없습니다는 <xref:System.ThreadStaticAttribute> 특성입니다.  
  
-   정적 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 주 스레드에서 모든 작업 완료 전에 작업이 완료 되지 되도록 메서드를 사용 합니다. 에 대 한 필요가 없습니다는 <xref:System.Threading.CountdownEvent> 개체입니다.  
  
-   작업 취소의 결과로 생성 되는 예외에 표시 되는 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 메서드. 이전 예제에서 각 스레드에 의해 처리 됩니다.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>다양 한 유형의 난수를 생성합니다.  
 난수 생성기에는 다음과 같은 유형의 난수를 생성할 수 있는 방법을 제공 합니다.  
  
-   일련의 <xref:System.Byte> 값입니다. 요소를 반환 하려면 메서드를 원하는 수로 초기화 하는 배열을 전달 하 여 바이트 값의 수를 결정은 <xref:System.Random.NextBytes%2A> 메서드. 다음 예제에서는 20 바이트를 생성합니다.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   단일 정수입니다. 0에서 최대값 사이의 정수 사용할지를 선택할 수 있습니다 (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1)를 호출 하 여는 <xref:System.Random.Next> 메서드를 호출 하 여 특정 값과 0 사이의 정수는 <xref:System.Random.Next%28System.Int32%29> 메서드나는 를호출하여값의범위내의정수<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>메서드. 매개 변수가 있는 오버 로드에서는 지정 된 최대 값은 없습니다. 생성 된 실제 최대 하나는 즉, 지정된 된 값 보다 작아야 합니다.  
  
     다음 예제에서는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드를 10으로-10에서 10 사이의 난수를 생성 합니다. 메서드에 대 한 두 번째 인수 메서드에서 반환 된 난수 값의 범위 단독 상한을 지정 했는지 확인 합니다. 즉, 하나는 메서드가 반환할 수 있는 가장 큰 정수 보다 작은 값입니다.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   부동 소수점에서 단일 값을 0.0 호출 하 여 1.0 보다 작은 <xref:System.Random.NextDouble%2A> 메서드. 메서드에 의해 반환 되는 임의의 수의 단독 상한을 1 이므로 실제 상한 0.99999999999999978 됩니다. 다음 예제에서는 10 개의 부동 소수점 난수를 생성합니다.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드는 반환 된 난수의 범위를 지정할 수 있습니다. 그러나는 `maxValue` 상위 범위가 반환 숫자를 지정 하는 매개 변수는 배타적, 하지는 까지의 값입니다. 즉, 메서드 호출 `Next(0, 100)` 0과 99 사이의 및 not between 0과 100 값을 반환 합니다.  
  
 사용할 수도 있습니다는 <xref:System.Random> 생성 등의 작업에 대 한 클래스 [임의의 T:System.Boolean 값](#Boolean)생성, [임의의 부동 소수점 값 0 ~ 1 아닌 다른 범위와](#Floats), 생성[임의 64 비트 정수](#Long), 및 [임의로 배열 또는 컬렉션에서 고유 요소를 검색](#UniqueArray)합니다. 이러한 및 다른 일반적인 작업에 대 한 참조는 [사용 하는 방법에 대 한 System.Random...](#Operations) 단원을 참조 하십시오입니다.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>사용자 고유의 알고리즘으로 대체  
 상속 하 여 사용자 고유의 난수 생성기를 구현할 수는 <xref:System.Random> 클래스와 프로그램 난수 생성 알고리즘을 제공 합니다. 사용자 고유의 알고리즘을 제공 하려면 재정의 해야 합니다는 <xref:System.Random.Sample%2A> 메서드는 난수 생성 알고리즘을 구현 합니다. 재정의 해야는 <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, 및 <xref:System.Random.NextBytes%2A> 메서드 재정의 된 호출할 있도록 <xref:System.Random.Sample%2A> 메서드. 재정의할 필요가 없습니다는 <xref:System.Random.Next%28System.Int32%29> 및 <xref:System.Random.NextDouble%2A> 메서드.  
  
 파생 하는 예제는 <xref:System.Random> 클래스 및 해당 기본 의사 (pseudo) 난수 생성기를 수정 참조는 <xref:System.Random.Sample%2A> 참조 페이지입니다.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>사용 하는 방법에 대 한 System.Random 중...  
 다음 섹션에 설명 하 고 일부의 응용 프로그램에서 임의의 숫자를 사용 하려는 방법에 대 한 예제 코드를 제공 합니다.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>동일한 임의 값의 시퀀스를 검색 합니다.  
 소프트웨어 테스트 시나리오 및 게임과 난수 동일한 시퀀스를 생성 하려는 경우가 있습니다. 난수 동일한 시퀀스를 사용 하 여 테스트를 재발을 감지 하 여 버그 수정 확인 있습니다. 임의의 숫자의 순서를 사용 하 여 게임에서 이전 게임을 재생할 수 있습니다.  
  
 동일한 초기값을 제공 하 여 난수 동일한 시퀀스를 생성할 수 있습니다는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자입니다. 시드 값은 의사 (pseudo) 난수 생성 알고리즘에 대 한 시작 값을 제공합니다. 다음 예에서는를 사용 하 여 100100 임의 시드 값으로 인스턴스화하는 <xref:System.Random> 개체를 20 임의의 부동 소수점 값을 표시 하 고 시드 값을 유지 합니다. 시드 값을 복원, 새 난수 생성기를 인스턴스화하고 하 고 동일한 20 임의의 부동 소수점 값이 표시 됩니다.  Note 서로 다른 버전의.NET Framework에서 실행 되는 경우이 예제에서는 난수 시퀀스를 생성 될 수 있습니다.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>고유한 난수 시퀀스를 검색 합니다.  
 인스턴스를 다른 시드 값을 제공 하는 <xref:System.Random> 클래스 값의 다른 시퀀스를 생성 하기 위해 각 난수 생성기를 발생 합니다. 명시적으로 호출 하 여 시드 값을 제공할 수 있습니다는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자를 호출 하 여 암시적으로 <xref:System.Random.%23ctor> 생성자입니다. 대부분의 개발자는 시스템 클록을 사용 하 여 매개 변수가 없는 생성자를 호출 합니다. 다음 예제에서는이 방법을 사용 하 여 두 개의 인스턴스화할 <xref:System.Random> 인스턴스. 각 인스턴스는 일련의 10 임의의 정수를 표시합니다.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 그러나는 유한 해상도 인해 시스템 클록 약 15 밀리초 미만 시간 차이 검색 되지 않을 때 따라서 코드를 호출 하는 경우는 <xref:System.Random.%23ctor> 인스턴스화할 두 오버 로드 <xref:System.Random> 개체를 연속 해 서에서 동일한 시드 값을 가진 개체를 제공 실수로 수 있습니다. 이 위 예제의 확인 하려면 주석으로 처리는 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 메서드 호출 및 컴파일 및 다시 실행 예입니다.  
  
 이 방지 하기 상황이 발생 하지는 단일을 인스턴스화하고 권장 <xref:System.Random> 여러 세션 대신 개체입니다. 그러나 이후 <xref:System.Random> 스레드로부터 안전 액세스 하는 경우에 몇 가지 동기화 장치를 사용 해야 되지 않습니다는 <xref:System.Random> 참조 하십시오; 자세한 내용은 여러 스레드에서 인스턴스 [The 임의 클래스와 스레드 안전](#ThreadSafety) 이 이전 항목입니다. 와 같은 지연 메커니즘을 사용할 수는 또는 <xref:System.Threading.Thread.Sleep%2A> 되는 인스턴스에 더 많이 떨어져 있는 15 밀리초 수행 되는지 확인 하기 이전 예제에서 사용 하는 방법입니다.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>지정된 된 범위에 있는 정수를 검색 합니다.  
 호출 하 여 지정된 된 범위에 있는 정수를 검색할 수 있습니다는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드를 더 작은 값 및 반환 하는 난수 생성기 원하는 숫자의 상한을 둘 다 지정할 수 있습니다. 상한값은 배타적, 하지는 까지의 값입니다. 즉, 메서드에 의해 반환 되는 값 범위 포함 되어 있지 않습니다. 다음 예제에서는이 방법을 사용 하 여-10에서 10 사이의 난수를 생성 합니다. 11을 지정 하기 값과 원하는 값 보다 큰 1의 `maxValue` 메서드 호출의 인수입니다.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>지정된 된 수의 자릿수를 가진 정수를 검색 합니다.  
 호출할 수 있습니다는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 지정된 된 수의 자릿수를 가진 숫자를 검색 하는 메서드입니다. 예를 들어 네 자리 숫자 (즉,: 1000에서 9999 까지의 숫자)를 가진 숫자를 검색 하려면 호출는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드는 `minValue` 1000의 값 및 `maxValue` 다음 예제와 같이 10000의 값입니다.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>지정된 된 범위에서 부동 소수점 값을 검색  
 <xref:System.Random.NextDouble%2A> 메서드 반환 임의의 부동 소수점 값 범위에 0에서 1 보다 작게 합니다. 그러나 다른 범위에서 임의 값을 생성 해야 경우가 많습니다.  
  
 최소 및 최대 원하는 값 간의 간격을 반환 하는 숫자에 원하는 시작 간격에서 0 사이의 차이 추가할 수 있습니다는 <xref:System.Random.NextDouble%2A> 메서드. 다음 예제에서는 10으로 0에서 1 사이의 난수를 생성 합니다.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 부동 소수점 난수를 생성 된 하 한은 0 하지만 상한 값이 1 보다 큰 (또는 음수 값의 경우 하한값 인-1 보다 작은 되며 상한 값은 0), 0이 아닌 바인딩 임의 숫자를 곱합니다. 다음 예제에서는 20 백만 부동 소수점 난수를 생성 하려면이 범위에 0 ~ <xref:System.Int64.MaxValue?displayProperty=nameWithType>합니다. 에서는 또한 메서드에 의해 생성 된 난수 값의 분포를 표시 합니다.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 와 같은 임의의 두 값 사이의 부동 소수점 난수를 생성 하려면는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 정수에 대 한 메서드는, 다음 수식을 사용 합니다.  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 다음 예제에서는 11.0을를 10.0에서 1 백만 임의의 숫자 범위를 생성 하 고 해당 분포를 표시 합니다.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>임의의 Boolean 값을 생성 합니다.  
 <xref:System.Random> 클래스 생성 하는 메서드를 제공 하지 않습니다 <xref:System.Boolean> 값입니다. 그러나 사용자 고유의 클래스 또는 작업을 수행 하는 메서드를 정의할 수 있습니다. 다음 예제에서는 클래스를 정의 `BooleanGenerator`, 단일 메서드 `NextBoolean`합니다. `BooleanGenerator` 저장소 클래스는 <xref:System.Random> 개인 변수는 개체입니다. `NextBoolean` 메서드 호출의 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 메서드 결과를 전달 하 고는 <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> 메서드. 참고 임의 숫자의 상한을 지정 하는 인수 2를 사용 합니다. 제외 값 이므로, 메서드 호출 0 또는 1을 반환 합니다.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 난수를 생성 하는 별도 클래스를 만드는 대신 <xref:System.Boolean> 값이 예제에서는 단일 메서드 정의 단순히 수 없습니다. 그러나 경우에는 <xref:System.Random> 개체는 새 인스턴스화를 방지 하기 위해 클래스 수준 변수를 클래스로 정의 해야 <xref:System.Random> 각 메서드 호출에서 인스턴스. Visual Basic의 임의 인스턴스도 정의할 수 있습니다는 [정적](~/docs/visual-basic/language-reference/modifiers/static.md) 변수에 `NextBoolean` 메서드.  다음 예제에서는 구현을 제공 합니다.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>임의의 64 비트 정수를 생성 합니다.  
 오버 로드는 <xref:System.Random.Next%2A> 메서드 32 비트 정수를 반환 합니다. 하지만, 경우에 따라 64 비트 정수를 작성 하려면 필요할 수 있습니다. 이 작업은 다음과 같이 수행할 수 있습니다.  
  
1.  호출 된 <xref:System.Random.NextDouble%2A> 메서드를 검색 배정밀도 부동 소수점 값입니다.  
  
2.  해당 값에 곱할 <xref:System.Int64.MaxValue?displayProperty=nameWithType>합니다.  
  
 다음 예제에서는이 방법을 사용 하 여 20 백만 임의 정수 (long)를 생성 하 고 같은 10 개의 그룹에서 분류 하 합니다. 그런 다음 0에서 각 그룹의 수를 계산 하 여 난수 분포를 계산 <xref:System.Int64.MaxValue?displayProperty=nameWithType>합니다. 예제의 출력에서 볼 수 있듯이 숫자 정수 (long) 범위를 통해 보다 균등 하 게 분산 됩니다.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 다른 방법 사용 하 여 비트 조작을 진정으로 난수를 생성 하지 않습니다. 이 기술은 호출 <xref:System.Random.Next> 두 정수, 왼쪽 이동 1에서 32 비트 및 Or를 생성 하려면 함께 합니다. 이 기술은 두 개의 제한이 있습니다.  
  
1.  31 비트의 부호 비트 이기 때문에 결과 정수 (long)의 31 비트의 값은 항상 0입니다.  31 비트인 및 ORing 임의의 0 또는 1, 왼쪽-변화 하는 것을 생성 하 여 해결할 수 있습니다는 원래 임의의 정수 (long)로 합니다.  
  
2.  더 심각 하 게 되므로 확률 반환한 값을 <xref:System.Random.Next> 0이 됩니다, 0x0 0x00000000FFFFFFFF 범위에 있는 경우에 몇 개의 난수가 포함 됩니다.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>지정된 된 범위에 바이트를 검색 합니다.  
 오버 로드는 <xref:System.Random.Next%2A> 메서드를 사용 하면 임의의 번호의 범위를 지정할 수는 있지만 <xref:System.Random.NextBytes%2A> 메서드가 없습니다. 다음 예제에서는 구현 하는 `NextBytes` 메서드는 반환 된 바이트 범위를 지정할 수 있습니다. 정의 `Random2` 에서 파생 된 클래스 <xref:System.Random> 오버 로드 하 고 해당 `NextBytes` 메서드.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 `NextBytes(Byte[], Byte, Byte)` 메서드 호출을 래핑하는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드 최소값 및 최 댓 값 보다 큰 하나를 지정 하 고 (이 경우 0과 101) 바이트 배열에 반환 된 한다고 합니다. 정수 값으로 반환 되도록 해야 하기 때문에 <xref:System.Random.Next%2A> 의 범위 내에 있는 메서드는 <xref:System.Byte> 데이터 형식으로 안전 하 게 (C#의)으로 캐스팅 하거나 수 (Visual Basic)에서는 정수에서 바이트로 변환 합니다.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>배열 또는 컬렉션에서 요소를 무작위로 검색  
 임의의 숫자는 종종 배열 또는 컬렉션에서 값을 검색 인덱스로 사용 합니다. 임의의 인덱스 값을 검색 하려면 호출할 수 있습니다는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드를 사용 하 여 배열의 값으로 하한값 해당 `minValue` 인수 및 배열 값의 상한 보다 1 큽니다 해당 `maxValue` 인수입니다. 0부터 시작 하 여 배열에 대 한이 해당 하는 <xref:System.Array.Length%2A> 속성 또는에서 반환 된 값 보다 1 큽니다는 <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> 메서드. 다음 예에서는 도시 배열을에서 미국에는 도시 이름을 무작위로 검색합니다.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>배열 또는 컬렉션에서 고유 요소를 검색 합니다.  
 난수 생성기 중복 값을 항상 반환 수 있습니다. 에 숫자의 범위가 작은 하거나 생성 하는 값의 개수 값이 클수록 중복 값의 확률이 증가 합니다. 임의의 값은 고유 해야 합니다, 더 많은 성능이 저하 점점 더 보정 하기 위해 중복을 생성 됩니다.  
  
 이 시나리오를 처리 하는 방법의 여러 가지가 있습니다. 일반적인 솔루션 배열 또는 컬렉션을 검색할 수 값을 포함 하 고 임의의 부동 소수점 숫자를 포함 하는 병렬 배열 만드는 것입니다. 두 번째 배열 채워집니다 난수 첫 번째 배열 만들어질 때와 <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> 배열을 정렬 하 여 첫 번째 병렬 배열 값을 사용 하 여 메서드를 사용 합니다.  
  
 예를 들어 카드놀이 게임을 개발 하는 하려는 경우 카드 당 한 번만 사용 되 고 있는지 확인 합니다. 카드와 해당 카드 이미 처리 여부를 추적을 검색 하는 난수를 생성 하는 대신 난수의 묶음을 정렬 하려면 사용할 수 있는 병렬 배열을 만들 수 있습니다. 묶음이 정렬 되 면 응용 프로그램에 대 한 포인터를 묶음에 다음 카드의 인덱스를 나타내는 유지할 수 있습니다.  
  
 다음 예제에서 이 방법을 보여 줍니다. 정의 `Card` 클래스 플레잉 카드와 해당는 `Dealer` 섞으 려 카드에서 설명 하는 클래스입니다. `Dealer` 클래스 생성자에는 두 배열을 채웁니다:는 `deck` 클래스 범위 있고 묶음; 및 로컬 모든 카드를 나타내는 배열 `order` 에 동일한 수의 요소를 배열에서 `deck` 배열 하 고 채워진 임의로 생성 된 <xref:System.Double> 값입니다.  <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> 정렬 메서드가 호출 됩니다는 `deck` 배열에 있는 값에 따라는 `order` 배열입니다.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 다음 예제에서는 단일 난수 생성기 및 호출 해당 <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, 및 <xref:System.Random.NextDouble%2A> 메서드 내 서로 다른 범위에서 난수 시퀀스를 생성 합니다.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 다음 예제에서는 생성 한 인덱스로 사용 하는 임의의 정수를 배열에서 문자열 값을 검색 합니다.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>.NET Framework 1.0 및 1.1에서 파생 된 클래스의 최소 구현을 <see cref="T:System.Random" /> 재정의 하는 데 필요한는 <see cref="M:System.Random.Sample" /> 난수를 생성 하는 것에 대 한 새 또는 수정 된 알고리즘을 정의 하는 메서드. 파생된 클래스의 기본 클래스 구현을 의존 다음 수는 <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, 및 <see cref="M:System.Random.NextDouble" /> 의 파생된 클래스 구현을 호출 하는 메서드는 <see cref="M:System.Random.Sample" /> 메서드.  .NET Framework 2.0 이상의 동작에에서는 <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, 및 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 메서드 변경 되어 이러한 메서드는 파생된 클래스 구현을 호출 하지 않을 <see cref="M:System.Random.Sample" /> 메서드. 클래스에서 파생 되는 결과적으로, <see cref="T:System.Random" /> .NET Framework 2.0 대상으로 하 고 나중에 이러한 세 가지 방법을 재정의 해야 합니다.</para>
    </block>
    <block subset="none" type="usage">
      <para>에 난수 생성기의 구현에서 <see cref="T:System.Random" /> 클래스는.NET Framework의 주 버전 간에 동일 하 게 보장 되지 않습니다. 결과적으로, 동일한 초기값 서로 다른 버전의.NET Framework 동일한 의사 난수 시퀀스에서 발생 합니다 가정 하지 않아야 합니다.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Random" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>시간에 따라 달라지는 시드 값을 사용하여 <see cref="T:System.Random" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 시드 값은 시스템 클록에서 파생 되며 확인에는 한계가 있습니다. 결과적으로 다른 <xref:System.Random> 짧은 간격에 기본 생성자를 호출 하 여 만든 개체는 동일한 기본 시드 값을 한 따라서 임의의 숫자의 동일한 집합을 생성 합니다. 단일을 사용 하 여이 문제를 방지할 수 <xref:System.Random> 모든 난수를 생성 하는 개체입니다. 시스템 클록에서 반환 된 시드 값을 수정 하 고 다음이 새 초기값을 명시적으로 제공 하 여 주변 사용할 수도 있습니다는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자입니다. 자세한 내용은 참조는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자입니다.  
  
 숫자의 임의 시퀀스를 생성 하 여 난수 생성기를 원하는 경우이 생성자를 호출 합니다. 서로 다른 난수 생성기에 대해 동일 하 게 될 난수 고정된 시퀀스를 생성 하려면 호출의 <xref:System.Random.%23ctor%28System.Int32%29> 고정된 초기값이 있는 생성자입니다. 이 <xref:System.Random> 생성자 오버 로드는 임의의 숫자를 사용 하는 앱을 테스트할 때 자주 사용 됩니다.  
  
 개별을 호출 하는 난수 생성기의 인스턴스화된 한 후 <xref:System.Random> 메서드 같은 <xref:System.Random.Next> 또는 <xref:System.Random.NextDouble>, 난수를 생성 합니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 생성자를 사용 하 여 세 개의 인스턴스화할 <xref:System.Random> 개체 하 고 각각에 대해 5 개의 임의 정수 시퀀스를 표시 합니다. 때문에 처음 두 <xref:System.Random> 개체에 연속적으로, 시스템 클록에 따라 동일한 시드 값을 사용 하 여 인스턴스화되는 만들어지며, 따라서 임의의 숫자의 순서는 동일 하며를 생성 합니다. 반면, 세 번째 작업의 기본 생성자 <xref:System.Random> 호출 하 여 2 초 지연 후 호출 되는 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 메서드. 이 세 번째 작업에 대 한 다른 초기값을 생성 하므로 <xref:System.Random> 개체는 다른 일련의 난수를 생성 합니다.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">의사(pseudo) 난수 시퀀스의 시작 값을 계산하는 데 사용되는 숫자입니다. 음수를 지정하면 이 숫자의 절대 값이 사용됩니다.</param>
        <summary>지정된 시드 값을 사용하여 <see cref="T:System.Random" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다른 동일한 시드 값 <xref:System.Random> 개체 하면 각 인스턴스가 동일한 시퀀스 난수를 생성 하 게 합니다. 이 경우 난수 생성기를 사용 하는 응용 프로그램을 테스트할 때 자주 수행 됩니다.  
  
 응용 프로그램에 필요한 다른 난수 시퀀스를 반복 해 서 다른 시드 값을 갖는이 생성자를 호출 합니다. 고유한 시드 값을 생성 하는 한 가지 방법은 시간에 따라 달라 지도록 하려면 됩니다. 예를 들어 시드 값으로 시스템 클록에서 파생 되는 <xref:System.Random.%23ctor> 오버 로드가 없습니다. 그러나, 시스템 클록이이 생성자의 서로 다른 호출 다른 시드 값을 제공할 수 있는 충분 한 해상도 없을 수 있습니다. 처음 두 표시 된 것 처럼이 인해 의사 (pseudo) 난수 동일한 시퀀스를 생성 하는 난수 생성기에서 <xref:System.Random> 다음 예제에서는 개체입니다. 이 방지 하려면 각 호출 또는 호출에서 시드 값을 식별 하는 알고리즘을 적용 된 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 메서드를 다른 초기값이 있는 각 생성자를 제공 해야 합니다.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 또 다른 옵션은 단일 인스턴스화할 <xref:System.Random> 응용 프로그램에 모든 난수 생성에 사용 하는 개체입니다. 이 난수 생성기를 인스턴스화 비용과 이므로 성능이 약간 향상을 생성 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Random> 초기값 매개 변수를 사용 하 고 임의의 정수 및 double 값의 시퀀스를 생성 하는 클래스 생성자를 사용 하 여 개체입니다. 같은 열이 생성은 예제 때는 <xref:System.Random> 개체 생성자 및 초기값 매개 변수와 함께 다시 생성 됩니다.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>임의의 정수를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>음수가 아닌 임의의 정수를 반환합니다.</summary>
        <returns>0보다 크거나 같고 <see cref="F:System.Int32.MaxValue" />보다 작은 부호 있는 32비트 정수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> 0에서 그 값의 범위가 난수를 생성 미만 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다. 사용 하 여 그 값의 범위가 난수를 0에서 다른 양수 값을 생성 하려면는 <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> 메서드 오버 로드 합니다. 다른 범위 내에서 난수를 생성 하려면 사용 된 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 호출을 반복된 하는 다음 예제는 <xref:System.Random.Next%2A> 특정 수의 사용자가 요청 하는 난수를 생성 하는 메서드. <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> 메서드는 사용자 입력을 가져오는 데 사용 됩니다.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 다음 예제에서 클래스를 파생 <xref:System.Random> 는 균일 분포에 의해 생성 된 난수 분포의 다른 시퀀스를 생성 하는 <xref:System.Random.Sample%2A> 기본 클래스의 메서드. 재정의 <xref:System.Random.Sample%2A> 난수가 포함 및 재정의의 분포를 제공 하는 메서드는 <xref:System.Random.Next%2A?displayProperty=nameWithType> 난수 수를 사용 하는 메서드.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>클래스를 파생 하는 경우.NET Framework 버전 2.0 부터는 <see cref="T:System.Random" /> 재정의 <see cref="M:System.Random.Sample" /> 메서드, 파생된 클래스 구현에 의해 제공 된 배포는 <see cref="M:System.Random.Sample" /> 메서드가 기본 클래스에 대 한 호출에서 사용 되지 않습니다 구현에서 <see cref="M:System.Random.Next" /> 메서드. 균일 한 분포는 기본에서 반환 하는 대신, <see cref="T:System.Random" /> 클래스가 사용 됩니다. 이 동작의 전반적인 성능이 향상 된 <see cref="T:System.Random" /> 클래스입니다. 이 동작을 수정 하는 <see cref="M:System.Random.Sample" /> 파생된 클래스에서 메서드를 재정의 해야는 <see cref="M:System.Random.Next" /> 메서드.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">생성될 난수의 상한(제외)입니다. <c>maxValue</c>는 0보다 크거나 같아야 합니다.</param>
        <summary>지정된 최대값보다 작은 음수가 아닌 임의의 정수를 반환합니다.</summary>
        <returns>0보다 크거나 같고 <paramref name="maxValue" />보다 작은 부호 있는 32비트 정수이므로 반환 값의 범위에는 대개 0이 포함되지만 <paramref name="maxValue" />는 포함되지 않습니다. 하지만 <paramref name="maxValue" />가 0과 같으면 <paramref name="maxValue" />가 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%29> 오버 로드를 반환 임의의 정수 범위에 0 ~ `maxValue` – 1입니다. 그러나 경우 `maxValue` 가 0 이면 메서드가 0을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 오버 로드를 통해 임의의 정수는 <xref:System.Random.Next%2A> 메서드.  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 다음 예제에서는 생성 한 인덱스로 사용 하는 임의의 정수를 배열에서 문자열 값을 검색 합니다. 배열의 가장 높은 인덱스는 1 보다 작은 길이, 값 이므로 <xref:System.Array.Length%2A?displayProperty=nameWithType> 속성으로 제공 되는 `maxValue` 매개 변수입니다.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxValue" />가 0보다 작습니다.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">반환되는 난수의 하한(포함)입니다.</param>
        <param name="maxValue">반환되는 난수의 상한(제외)입니다. <c>maxValue</c>는 <c>minValue</c>보다 크거나 같아야 합니다.</param>
        <summary>지정된 범위 내의 임의의 정수를 반환합니다.</summary>
        <returns>
          <paramref name="minValue" />보다 크거나 같고 <paramref name="maxValue" />보다 작은 부호 있는 32비트 정수이므로 반환 값의 범위에는 <paramref name="minValue" />가 포함되지만 <paramref name="maxValue" />는 포함되지 않습니다. <paramref name="minValue" />가 <paramref name="maxValue" />와 같은 경우에는 <paramref name="minValue" />가 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 오버 로드에서 사이의 임의의 정수를 반환 `minValue` 를 `maxValue` – 1입니다. 그러나 경우 `maxValue` equals `minValue`, 메서드가 반환 `minValue`합니다.  
  
 다른 오버 로드와는 달리는 <xref:System.Random.Next%2A> 메서드만 음수가 아닌 값을 반환 하는이 메서드는 음수 임의의 정수를 반환할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 메서드를 임의 정수 세 개의 서로 다른 범위를 생성 합니다. 이 예제에서는 정확한 출력에 전달 된 시스템 제공 시드 값에 따라 달라 집니다는 <xref:System.Random> 클래스 생성자입니다.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 다음 예제에서는 생성 한 인덱스로 사용 하는 임의의 정수를 배열에서 문자열 값을 검색 합니다. 배열의 가장 높은 인덱스는 1 보다 작은 길이, 값 이므로 <xref:System.Array.Length%2A?displayProperty=nameWithType> 속성으로 제공 되는 `maxValue` 매개 변수입니다.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="minValue" />가 <paramref name="maxValue" />보다 큰 경우</exception>
        <block subset="none" type="overrides">
          <para>클래스를 파생 하는 경우.NET Framework 버전 2.0 부터는 <see cref="T:System.Random" /> 재정의 <see cref="M:System.Random.Sample" /> 메서드, 파생된 클래스 구현에 의해 제공 된 배포는 <see cref="M:System.Random.Sample" /> 메서드가 기본 클래스에 대 한 호출에서 사용 되지 않습니다 구현은 <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 메서드 오버 로드 간의 차이 <paramref name="minValue" /> 및 <paramref name="maxValue" /> 매개 변수 보다 크면 <see cref="F:System.Int32.MaxValue" />합니다. 균일 한 분포는 기본에서 반환 하는 대신, <see cref="T:System.Random" /> 클래스가 사용 됩니다. 이 동작의 전반적인 성능이 향상 된 <see cref="T:System.Random" /> 클래스입니다. 이 동작을 수정 하는 <see cref="M:System.Random.Sample" /> 파생된 클래스에서 메서드를 재정의 해야는 <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 메서드 오버 로드 합니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">난수를 포함하는 바이트 배열입니다.</param>
        <summary>지정된 바이트 배열의 요소를 난수로 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 보다 크거나 0 바이트 배열의 각 요소는 임의의 수로 설정 되 고 보다 작거나 <xref:System.Byte.MaxValue>합니다.  
  
 예를 들어 임의의 암호를 만드는 데 적합 한 암호화 보안된 난수를 생성 하려면 메서드를와 같은 사용 <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 <xref:System.Random.NextBytes%2A> 메서드를 임의 바이트 값으로 바이트 배열을 채웁니다.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="overrides">
          <para>클래스를 파생 하는 경우.NET Framework 버전 2.0 부터는 <see cref="T:System.Random" /> 재정의 <see cref="M:System.Random.Sample" /> 메서드, 파생된 클래스 구현에 의해 제공 된 배포는 <see cref="M:System.Random.Sample" /> 메서드가 기본 클래스에 대 한 호출에서 사용 되지 않습니다 구현에서 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 메서드. 균일 한 분포는 기본에서 반환 하는 대신, <see cref="T:System.Random" /> 클래스가 사용 됩니다. 이 동작의 전반적인 성능이 향상 된 <see cref="T:System.Random" /> 클래스입니다. 이 동작을 수정 하는 <see cref="M:System.Random.Sample" /> 파생된 클래스에서 메서드를 재정의 해야는 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 메서드.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0.0보다 크거나 같고 1.0보다 작은 부동 소수점 난수입니다.</summary>
        <returns>0.0보다 크거나 같고 1.0보다 작은 배정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에서 반환 되는 임의의 수의 실제 상한값은 0.99999999999999978 합니다.  
  
 0.0에서 1.0 이외의 범위 내에서 임의의 부동 소수점 값을 검색 하려면의 "지정된 된 범위에서 부동 소수점 값을 검색" 섹션을 참조는 <xref:System.Random> 클래스 항목입니다.  
  
 이 메서드는 보호 된 메서드의 공개 버전 <xref:System.Random.Sample%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Random.NextDouble%2A> 메서드 doubles 임의 시퀀스를 생성 합니다.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 다음 예제에서는 <xref:System.Random.NextDouble%2A> 100 개의 난수를 생성 하는 메서드 번호 및 해당 주파수 분포를 표시 합니다.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0.0과 1.0 사이의 임의의 부동 소수점 숫자를 반환합니다.</summary>
        <returns>0.0보다 크거나 같고 1.0보다 작은 배정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서로 다른 난수 분포 또는 서로 다른 난수 생성기 원칙을 생성 하려면에서 클래스를 파생는 <xref:System.Random> 클래스 및 재정의 <xref:System.Random.Sample%2A> 메서드.  
  
> [!IMPORTANT]
>  <xref:System.Random.Sample%2A> 방법은 `protected`, 내 에서만 액세스할 수는 <xref:System.Random> 클래스와 해당 파생된 클래스입니다. 0과 1 사이의 난수를 생성 하는 <xref:System.Random> 인스턴스를 호출 하 여 <xref:System.Random.NextDouble%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서 클래스를 파생 <xref:System.Random> 재정의 <xref:System.Random.Sample%2A> 메서드 난수 분포를 생성 합니다. 이 분포는 균일 분포에 의해 생성 된 다른는 <xref:System.Random.Sample%2A> 기본 클래스의 메서드.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>클래스를 파생 하는 경우.NET Framework 버전 2.0 부터는 <see cref="T:System.Random" /> 재정의 <see cref="M:System.Random.Sample" /> 메서드, 파생된 클래스 구현에 의해 제공 된 배포는 <see cref="M:System.Random.Sample" /> 메서드가 기본 클래스에 대 한 호출에서 사용 되지 않습니다 다음과 같은 메서드의 구현:- <see cref="M:System.Random.NextBytes(System.Byte[])" /> 메서드.  - <see cref="M:System.Random.Next" /> 메서드.  - <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 메서드를 하는 경우 (<paramref name="maxValue" /> - <paramref name="minValue" />) 보다 크면 <see cref="F:System.Int32.MaxValue" />합니다.  균일 한 분포는 기본 제공 하는 대신, <see cref="T:System.Random" /> 클래스가 사용 됩니다. 이 동작의 전반적인 성능이 향상 된 <see cref="T:System.Random" /> 클래스입니다. 이 동작의 구현을 호출을 수정 하는 <see cref="M:System.Random.Sample" /> 메서드는 파생된 클래스에서 재정의 해야 이러한 세 멤버의 동작입니다. 이 예제에 대해 설명을 합니다.</para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>