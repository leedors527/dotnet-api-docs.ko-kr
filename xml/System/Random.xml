<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="adf29f522d3625dba7e4bd956743ac3e35b25683" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58716524" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>의사(pseudo) 난수 생성기를 나타냅니다. 이 디바이스는 무작위성에 대한 통계적인 특정 요구 사항과 일치하는 숫자 시퀀스를 생성합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 의사 (pseudo) 난수 숫자 유한 집합에서 동일한 가능성을 가진 선택 됩니다. 선택한 숫자 수학적 알고리즘을 선택한 후에 되지만 충분히 임의의 실무 때문에 완전 한 임의 않습니다. 현재 구현은 <xref:System.Random> 클래스 Donald E. 크누스 무언가 감 난수 생성기 알고리즘의 수정된 된 버전에 기반 합니다. 자세한 내용은 4. 5.를 참조 하세요. 크누스 합니다. *The Art of 컴퓨터 프로그래밍에 볼륨 2: Seminumerical 알고리즘*합니다. 4.0"(addison-Wesley, 읽기, MA, 세 번째 버전, 1997입니다.  
  
 암호화 보안 난수를 임의의 암호를 만들기 위한 적합 한 것과 같은 생성 하려면 사용 합니다 <xref:System.Security.Cryptography.RNGCryptoServiceProvider> 클래스 또는 클래스를 파생 <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>합니다.  
  
 항목 내용  
  
 [난수 생성기의 인스턴스화](#Instantiate)   
 [여러 인스턴스화를 방지합니다.](#Multiple)   
 [System.Random 클래스와 스레드 안전성](#ThreadSafety)   
 [다양 한 유형의 난수를 생성합니다.](#Functionality)   
 [사용자 고유의 알고리즘을 대체](#Overriding)   
 [System.Random를 어떻게 사용 하는 중...](#Operations)   
 [난수 값의 순서를 검색 합니다.](#Same)  
 [난수 값의 고유한 시퀀스를 검색 합니다.](#Unique)  
 [지정된 된 범위에 있는 정수를 검색 합니다.](#Range)  
 [지정 된 자릿수를 사용 하 여 정수를 검색 합니다.](#Digits)  
 [지정된 된 범위에서 부동 소수점 값을 검색](#Floats)  
 [임의의 부울 값을 생성](#Boolean)  
 [임의의 64 비트 정수를 생성 합니다.](#Long)  
 [지정 된 범위의 바이트를 검색 합니다.](#Bytes)  
 [배열 또는 컬렉션에서 요소를 무작위로 검색](#Array)  
 [배열 또는 컬렉션에서 고유 요소를 검색 합니다.](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>난수 생성기의 인스턴스화  
 에 시드 값 (의 의사 (pseudo) 난수 생성 알고리즘에 대 한 시작 값)를 제공 하 여 난수 생성기를 인스턴스화하는 <xref:System.Random.%23ctor%2A> 클래스 생성자입니다.  명시적 또는 암시적으로 시드 값을 제공할 수 있습니다.  
  
-   <xref:System.Random.%23ctor%28System.Int32%29> 생성자를 제공 하는 명시적 시드 값을 사용 합니다.  
  
-   <xref:System.Random.%23ctor> 생성자 시스템 클록을 사용 하 여 시드 값을 제공 합니다. 이것이 난수 생성기를 인스턴스화하는 가장 일반적인 방법입니다.  
  
 별개의 동일한 초기값을 사용 하는 경우 <xref:System.Random> 개체를 동일한 일련의 난수 생성 됩니다. 이 임의 값을 처리 하는 테스트 도구 모음을 만들기 위한 하거나 임의의 숫자에서 해당 데이터를 파생 되는 게임을 재생 하는 데 유용할 수 있습니다. 그러나 <xref:System.Random> 개체가 다른 버전의.NET Framework에서 실행 중인 프로세스에서 동일한 초기값을 사용 하 여 인스턴스화되는 경우에 다른 일련의 임의 숫자를 반환할 수 있습니다.  
  
 여러 가지 임의의 숫자 시퀀스를 생성 하려면 할 수 있습니다 초기값 시간 종속적의 각 새 인스턴스를 사용 하 여 다른 시리즈를 생성 하므로 <xref:System.Random>합니다. 매개 변수가 있는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자 가져올 수 있습니다는 <xref:System.Int32> 값 틱 수에에서 따른 현재 반면 매개 변수가 없는 <xref:System.Random.%23ctor> 생성자 시스템 시계를 사용 하 여 시드 값을 생성 합니다. 그러나 시계 확인에는 한계가 있으므로 사용 하 여 매개 변수가 없는 생성자를 만들 다른 <xref:System.Random> 개체 닫기 연속 해 서에서 동일한 시퀀스로 난수를 생성 하는 난수 생성기를 만듭니다. 다음 예제에서는 두 <xref:System.Random> 연속적으로 인스턴스화된 개체는 동일한 일련의 임의 숫자를 생성 합니다. 대부분의 Windows 시스템에서 <xref:System.Random> 서로 15 시간 (밀리초) 내에서 만든 개체는 동일한 초기값을 갖고 있습니다.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 이 문제를 방지 하려면 만드는 단일 <xref:System.Random> 여러 개체 대신 개체입니다.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>여러 인스턴스화를 방지합니다.  
 두 개의 난수 생성기 빽빽한 루프에서 또는 빠르게 연속적으로 초기화 난수 동일한 시퀀스를 생성할 수 있는 두 임의의 수 생성기를 만듭니다. 대부분의 경우에서이 개발자의 의도 아니며 인스턴스화하고 난수 생성기를 초기화 하는 비교적 비용이 많이 드는 프로세스 이므로 성능 문제가 발생할 수 있습니다.  
  
 성능 향상을 위해을 모두 동일한 숫자 시퀀스를 생성 하는 별도 임의의 수 생성기를 실수로 만들지를 하나 만든 것이 좋습니다 <xref:System.Random> 개체를 만드는 대신 시간이 지남에 따라 여러 난수를 생성 합니다. 새 <xref:System.Random> 하나 난수를 생성 하는 개체입니다.  
  
 그러나는 <xref:System.Random> 클래스에는 스레드로부터 안전 하지 않습니다. 호출 하는 경우 <xref:System.Random> 여러 스레드에서 메서드는 다음 섹션에서 설명한 지침을 따릅니다.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>System.Random 클래스와 스레드 안전성  
 개별 인스턴스화하는 대신 <xref:System.Random> 개체를 단일 만들어야 하는 것이 좋습니다 <xref:System.Random> 인스턴스를 응용 프로그램에 필요한 모든 임의의 숫자를 생성 합니다. 그러나 <xref:System.Random> 개체는 스레드로부터 안전 하지 않습니다. 앱을 호출 하는 경우 <xref:System.Random> 여러 스레드에서 메서드를 한 번에 하나의 스레드만 난수 생성기를 액세스할 수 있는지 확인 하려면 동기화 개체를 사용 해야 합니다. 되도록 없는 경우는 <xref:System.Random> 스레드로부터 안전한 방식으로 액세스 합니다, 난수를 반환 하는 메서드를 호출 하는 0을 반환 합니다.  
  
 다음 예제에서는 C# [lock 문](~/docs/csharp/language-reference/keywords/lock-statement.md) 및 Visual Basic [SyncLock 문](~/docs/visual-basic/language-reference/statements/synclock-statement.md) 스레드로부터 안전한 방식으로 단일 난수 생성기 11 스레드에서 액세스할 수 있는지 확인 합니다. 각 스레드 2 백만 난수 생성, 난수 생성의 수를 계산 하 고 해당 합계를 계산 및 실행 완료 되 면 모든 스레드에 대 한 합계를 업데이트 한 다음  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 이 예제에서는 다음과 같은 방법으로 스레드로부터의 안전성을 보장합니다.  
  
-   <xref:System.ThreadStaticAttribute> 특성 총 난수를 생성 하 고 각 스레드에 대 한 합계를 추적 하는 스레드 지역 변수를 정의 하는 데 사용 됩니다.  
  
-   잠금 (합니다 `lock` C#의 문은 및 `SyncLock` Visual Basic의 문) 모든 스레드에서 생성 된 모든 임의 숫자의 합을 총 변수에 대 한 액세스를 보호 합니다.  
  
-   세마포 (합니다 <xref:System.Threading.CountdownEvent> 개체)를 사용 하는 다른 모든 스레드가 될 때까지 주 스레드 차단 실행이 완료를 확인 합니다.  
  
-   이 예제에서는 난수 생성기 난수 생성 메서드를 두 번 연속 호출 0을 반환 하는지 여부를 확인 하 여 손상 되었습니다 여부를 확인 합니다. 예제에서는 손상이 발견 되는 경우는 <xref:System.Threading.CancellationTokenSource> 모든 스레드를 취소 해야 한다는 신호를 보낼 개체입니다.  
  
-   각 난수를 생성 하기 전에 각 스레드는 상태를 확인 합니다 <xref:System.Threading.CancellationToken> 개체입니다. 이 예제에서는 호출에 취소가 요청 된 경우는 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 스레드를 취소 하는 방법입니다.  
  
 다음 예에서는 동일 하면 첫 번째 사용 한다는 점을 제외 하 고는 <xref:System.Threading.Tasks.Task> 개체 및 대신 람다 식을 <xref:System.Threading.Thread> 개체입니다.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 다음과 같은 방법으로 첫 번째 예제에서 다릅니다.  
  
-   난수 생성의 수 및 각 작업의 합계를 추적 하는 변수에 로컬인 작업을 사용 하지 않아도 되므로 <xref:System.ThreadStaticAttribute> 특성입니다.  
  
-   정적 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 메서드를 사용 하는 주 스레드에서 모든 작업을 완료 되기 전에 완료 되지 않도록 합니다. 에 대 한 필요가 없습니다를 <xref:System.Threading.CountdownEvent> 개체입니다.  
  
-   작업 취소를 결과로 생성 되는 예외에 표시 되는 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 메서드. 이전 예제에서는 각 스레드에 의해 처리 됩니다.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>다양 한 유형의 난수를 생성합니다.  
 난수 생성기의 다음과 같은 유형의 난수를 생성할 수 있도록 하는 메서드를 제공 합니다.  
  
-   일련의 <xref:System.Byte> 값입니다. 요소를 반환 하려면 메서드를 원하는 수로 초기화 하는 배열을 전달 하 여 바이트 값의 수를 결정 합니다 <xref:System.Random.NextBytes%2A> 메서드. 다음 예제에서는 20 바이트를 생성합니다.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   단일 정수입니다. 0에서 최대값 사이의 정수 것인지를 선택할 수 있습니다 (<xref:System.Int32.MaxValue?displayProperty=nameWithType> -1)를 호출 하 여 합니다 <xref:System.Random.Next> 메서드를 호출 하 여 특정 값을 0 사이의 정수를 <xref:System.Random.Next%28System.Int32%29> 메서드나 를호출하여값의범위내정수<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>메서드. 매개 변수가 있는 오버 로드를 지정 된 최대 값은 없습니다. 즉, 생성 된 실제 최대 개수는 하나에 지정 된 값 미만입니다.  
  
     다음 예제에서는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드를 10으로-10에서 10 사이의 난수를 생성 합니다. 메서드에 두 번째 인수는 난수의 상한 메서드에서 반환 된 난수 값의 범위 지정 하는지 참고 합니다. 즉, 하나는 메서드를 반환할 수 있는 가장 큰 정수 보다 작은 값입니다.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   단일 부동 소수점 값 0.0에서으로 호출 하 여 1.0 보다 작은 <xref:System.Random.NextDouble%2A> 메서드. 난수 메서드에서 반환 되는 난수의 상한 1 이므로 실제 상한 0.99999999999999978 됩니다. 다음 예제에서는 10 개의 부동 소수점 난수를 생성합니다.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드를 사용 하면 반환 되는 난수의 범위를 지정할 수 있습니다. 그러나는 `maxValue` 상위 범위 반환 번호를 지정 하는 매개 변수는 배타적을 포함 하지 않습니다는, 값입니다. 즉, 메서드 호출 `Next(0, 100)` 0에서 99 사이의 및 not between 0과 100 값을 반환 합니다.  
  
 사용할 수도 있습니다는 <xref:System.Random> 생성 등의 작업에 대 한 클래스 [임의 T:System.Boolean 값](#Boolean)생성, [0 ~ 1 이외의 범위를 사용 하 여 임의의 부동 소수점 값](#Floats), 생성 [임의 64 비트 정수의](#Long), 및 [배열 또는 컬렉션에서 고유 요소를 무작위로 검색](#UniqueArray)합니다. 이러한 및 다른 일반적인 작업에 대 한 참조를 [를 System.Random 사용 방법...](#Operations) 섹션입니다.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>사용자 고유의 알고리즘을 대체  
 상속 하 여 고유한 난수 생성기를 구현할 수 있습니다는 <xref:System.Random> 클래스 및 사용자 난수 생성 알고리즘을 제공 합니다. 사용자 고유의 알고리즘을 제공 하려면 재정의 해야 합니다 <xref:System.Random.Sample%2A> 는 난수 생성 알고리즘을 구현 하는 메서드. 또한 재정의 해야 합니다 <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, 및 <xref:System.Random.NextBytes%2A> 재정의 된 호출을 확인 하는 방법 <xref:System.Random.Sample%2A> 메서드. 재정의할 필요가 합니다 <xref:System.Random.Next%28System.Int32%29> 고 <xref:System.Random.NextDouble%2A> 메서드.  
  
 파생 되는 예는 <xref:System.Random> 클래스 및 해당 기본 의사 (pseudo) 난수 생성기를 수정 합니다. 참조는 <xref:System.Random.Sample%2A> 참조 페이지입니다.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>System.Random를 어떻게 사용 하는 중...  
 다음 섹션에 설명 하 고 일부의 응용 프로그램에서 난수를 사용 하려는 방법에 대 한 샘플 코드를 제공 합니다.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>난수 값의 순서를 검색 합니다.  
 소프트웨어 테스트 시나리오에서 게임 플레이 동일한 시퀀스의 임의 숫자를 생성 하려는 경우가 있습니다. 임의의 숫자의 순서를 사용 하 여 테스트를 재발을 감지 하 여 버그 수정 확인 있습니다. 임의의 수의 동일한 시퀀스가 게임에서 사용 하 여 이전 게임을 재생할 수 있습니다.  
  
 동일한 초기값을 제공 하 여 동일한 난수 시퀀스를 생성할 수 있습니다는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자입니다. 초기값을 의사 (pseudo) 난수 생성 알고리즘에 대 한 시작 값을 제공합니다. 다음 예제를 사용 하 여 100100 임의 시드 값으로 인스턴스화하는 <xref:System.Random> 개체 20 개의 임의 부동 소수점 값을 표시 하 고 시드 값을 유지 합니다. 이 다음 시드 값을 복원, 새 난수 생성기를 인스턴스화하고 20 같은 임의의 부동 소수점 값을 표시 합니다.  Note는 다른 버전의.NET Framework에서 실행 하는 경우 예제에서는 여러 가지 임의의 숫자 시퀀스를 생성할 수 있습니다.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>고유한 난수 시퀀스를 검색 합니다.  
 인스턴스의 다른 시드 값을 제공 하는 <xref:System.Random> 클래스 값의 서로 다른 시퀀스를 생성 하기 위해 각 난수 생성기를 발생 합니다. 초기값을 호출 하 여 명시적으로 제공할 수 있습니다는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자를 암시적으로 호출 하 여를 <xref:System.Random.%23ctor> 생성자입니다. 대부분의 개발자는 시스템 클록을 사용 하는 매개 변수가 없는 생성자를 호출 합니다. 다음 예제에서는이 방법을 사용 하 여 두 인스턴스화할 <xref:System.Random> 인스턴스. 각 인스턴스는 일련의 10 임의의 정수를 표시합니다.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 그러나 해당 유한 확인으로 인해 시스템 클록은 약 15 밀리초 미만 시간 차이 검색 하지 않습니다. 따라서 코드를 호출 하는 경우는 <xref:System.Random.%23ctor> 오버 로드 두 인스턴스화를 <xref:System.Random> 개체를 연속으로 동일한 초기값을 사용 하 여 개체를 제공 의도치 않게 될 수 있습니다. 이 이전 예제에서 확인 하려면 주석으로 처리 된 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 메서드 호출에서 컴파일 및 다시 실행 예제입니다.  
  
 이를 방지 하려면 단일 인스턴스화하고 권장 <xref:System.Random> 여러 세션 대신 개체입니다. 그러나 <xref:System.Random> 스레드로부터 안전 하 게 액세스 하는 경우에 몇 가지 동기화 장치를 사용 해야 합니다는 <xref:System.Random> 인스턴스 여러 스레드에서; 자세한 내용은 [은 임의 클래스와 스레드 안전성](#ThreadSafety) 이 이전 항목입니다. 와 같은 지연 메커니즘을 사용할 수는 또는 <xref:System.Threading.Thread.Sleep%2A> 인스턴스화를 15 개 이상의 밀리초 간격 발생 하는 이전 예에서 사용 된 방법입니다.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>지정된 된 범위에 있는 정수를 검색 합니다.  
 호출 하 여 지정된 된 범위에 있는 정수를 검색할 수 있습니다는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드를 아래와 난수 생성기를 반환 하 고 싶은 숫자의 상한을 지정할 수 있습니다. 상한값은 배타적을 포함 하지 않습니다는, 값입니다. 즉,이 메서드에 의해 반환 되는 값의 범위에 포함 되지 않습니다. 다음 예제에서는이 메서드를 사용 하 여-10에서 10 사이의 임의의 정수를 생성 합니다. 참고 11을 지정 하는지, 값으로 원하는 값 보다 1의 `maxValue` 메서드 호출의 인수입니다.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>지정 된 자릿수를 사용 하 여 정수를 검색 합니다.  
 호출할 수 있습니다는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드는 지정 된 자릿수를 사용 하 여 번호를 검색할 수 있습니다. 예를 들어, 4 자리 (즉, 1000에서 9999 범위의 숫자)를 사용 하 여 숫자를 검색 하려면 호출을 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드를 `minValue` 값 1000 및 `maxValue` 값이 다음 예제와 같이 10000입니다.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>지정된 된 범위에서 부동 소수점 값을 검색  
 <xref:System.Random.NextDouble%2A> 메서드 돌아갑니다 임의의 부동 소수점 값 범위 0에서 1 보다 작습니다. 그러나에서는 몇 가지 다른 범위에서 임의의 값을 생성 하려는 경우가 많습니다.  
  
 최소 및 최대 원하는 값 간의 간격을 1 인 경우에서 반환 된 숫자에 원하는 시작 간격에서 0 사이의 차이 추가할 수 있습니다는 <xref:System.Random.NextDouble%2A> 메서드. 다음 예제에서는 10으로 0에서 1 사이의 난수를 생성 하려면이 작업을 수행 합니다.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 부동 소수점 난수를 생성 된 하 한은 0 하지만 상한 값이 1 보다 큰 (또는 음수의 경우 해당 하한값은-1 보다 작은 상한 값은 0), 0이 아닌 바인딩으로 임의 숫자를 곱합니다. 다음 예제와 20 백만 부동 소수점 난수를 생성 하려면 해당 범위에는 0에서 <xref:System.Int64.MaxValue?displayProperty=nameWithType>합니다. 에 메서드에 의해 생성 된 난수 값의 분포를 표시 합니다.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 같은 임의의 두 값 사이의 부동 소수점 난수를 생성 하려면는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 정수에 대 한 메서드는, 다음 수식을 사용 합니다.  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 다음 예제에서는 11.0으로 범위를 보이는 난수 1 백만 10.0에서 생성 하 고 해당 배포를 표시 합니다.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>임의의 부울 값을 생성  
 합니다 <xref:System.Random> 클래스를 생성 하는 메서드를 제공 하지 않습니다 <xref:System.Boolean> 값입니다. 그러나 사용자 고유의 클래스 또는 작업을 수행 하는 메서드를 정의할 수 있습니다. 다음 예제에서는 클래스를 정의 `BooleanGenerator`, 단일 메서드를 사용 하 여 `NextBoolean`입니다. 합니다 `BooleanGenerator` 저장소 클래스는 <xref:System.Random> 개인 변수는 개체입니다. 합니다 `NextBoolean` 메서드 호출을 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 메서드 결과를 전달 하 고는 <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> 메서드. 참고는 난수의 상한 값을 지정 하려면 2를 인수로 사용 합니다. 전용 값을 이므로 메서드 호출 0 또는 1을 반환 합니다.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 난수를 생성 하는 별도 클래스를 만드는 대신 <xref:System.Boolean> 값을이 예제에서는 단일 메서드 정의 하기만 하면 수 없습니다. 그러나 경우에는 <xref:System.Random> 개체는 새 인스턴스화를 방지 하려면 클래스 수준의 변수로 정의 해야 <xref:System.Random> 각 메서드 호출의 인스턴스. Visual Basic에서는 Random 인스턴스에서으로 정의할 수 있습니다는 [정적](~/docs/visual-basic/language-reference/modifiers/static.md) 변수에 `NextBoolean` 메서드.  다음 예제에서는 구현을 제공 합니다.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>임의의 64 비트 정수를 생성 합니다.  
 오버 로드는 <xref:System.Random.Next%2A> 메서드 32 비트 정수를 반환 합니다. 그러나 경우에 따라 64 비트 정수를 사용 수 있습니다. 이 작업은 다음과 같이 수행할 수 있습니다.  
  
1.  호출 된 <xref:System.Random.NextDouble%2A> 메서드를 배정밀도 부동 소수점 값입니다.  
  
2.  해당 값에 곱할 <xref:System.Int64.MaxValue?displayProperty=nameWithType>합니다.  
  
 다음 예제에서는이 방법을 사용 하 여 20 백만 임의 정수 (long)를 생성 및 10 동일한 그룹에이 분류 합니다. 그런 다음 0에서 각 그룹의 수를 계산 하 여 난수 분포를 계산 <xref:System.Int64.MaxValue?displayProperty=nameWithType>합니다. 예제의 출력에서 볼 수 있듯이 숫자의 정수 (long) 범위를 통해 더 많거나 적은 동일 하 게 분산 됩니다.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 사용 하 여 비트 조작 하는 다른 기술에서 진정한 난수를 생성 하지 않습니다. 이 기술은 호출 <xref:System.Random.Next> 정수 두 개를 왼쪽으로 이동 1에서 32 비트 및 ORs 생성 해야 합니다. 이 기술에는 두 가지 제한이 있습니다.  
  
1.  31 비트의 부호 비트 이기 때문에 결과 정수 (long)의 31 비트의 값은 항상 0입니다.  31 비트 or 연산 하 고 임의 0 또는 1에 왼쪽 시프트 것을 생성 하 여이 문제를 해결할 수 있습니다 원래 임의 정수 (long)를 사용 하 여 합니다.  
  
2.  더 심각 하 게 되므로 확률 값을 반환한 <xref:System.Random.Next> 값은 0, 0x0 0x00000000FFFFFFFF 범위에 있는 경우에 몇 가지 임의의 숫자 됩니다.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>지정 된 범위의 바이트를 검색 합니다.  
 오버 로드 된 <xref:System.Random.Next%2A> 메서드를 사용 하면 임의의 숫자의 범위를 지정 하지만 <xref:System.Random.NextBytes%2A> 메서드가 없습니다. 다음 예제에서는 구현 하는 `NextBytes` 메서드는 반환 된 바이트 범위를 지정할 수 있습니다. 정의 된 `Random2` 에서 파생 된 클래스 <xref:System.Random> 오버 로드 하 고 해당 `NextBytes` 메서드.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 합니다 `NextBytes(Byte[], Byte, Byte)` 메서드 호출을 래핑한는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드 최 솟 값 및 최 댓 값 보다 큰 하나 지정 (이 경우 0과 101) 바이트 배열에서 반환 한다고 합니다. 정수 값으로 반환 되도록 해야 하기 때문에 합니다 <xref:System.Random.Next%2A> 메서드 범위 내에 <xref:System.Byte> 데이터 형식에서는 수 안전 하 게 캐스팅 하 (C#) 또는 변환 (Visual Basic)에서는 정수에서 바이트입니다.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>배열 또는 컬렉션에서 요소를 무작위로 검색  
 임의의 숫자 배열 또는 컬렉션에서 값을 검색할 인덱스와 많이 사용 합니다. 임의 인덱스 값을 검색 하려면 호출할 수 있습니다 합니다 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드를 사용 하 여 배열의 값으로 하한값 해당 `minValue` 인수와 값으로 배열 상한 보다 크지 하나 해당 `maxValue` 인수입니다. 0부터 시작 하 여 배열에 대 한이 설정은 해당 <xref:System.Array.Length%2A> 속성 또는 반환 값 보다 큰 하나는 <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> 메서드. 다음 예제에서는 임의로 도시 배열을에서 미국의 도시 이름을 검색합니다.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>배열 또는 컬렉션에서 고유 요소를 검색 합니다.  
 난수 생성기를 중복 값을 반환할 항상 있습니다. 숫자의 범위가 더 작은 또는 생성 된 값 수가 더 커지면으로 중복 가능성이 증가 합니다. 임의 값은 고유 해야 합니다, 더 많은 성능이 더욱 저하 중복에 대 한 보정을 위해 생성 됩니다.  
  
 이 시나리오를 처리 하는 방법의 여러 가지가 있습니다. 일반적인 솔루션 배열 또는 값을 검색할 수 있는 컬렉션 및 부동 소수점 난수를 포함 하는 병렬 배열 만드는 것입니다. 첫 번째 배열 만들어진 시점에 임의의 숫자를 사용 하 여 두 번째 배열이 채워진 및 <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> 메서드를 사용 하는 병렬 배열에서 값을 사용 하 여 첫 번째 배열을 정렬 합니다.  
  
 예를 들어 카드놀이 게임을 개발 하는 경우 각 카드 한 번만 사용 되는지 확인 하려는 합니다. 카드를 해당 카드를 이미 처리 여부를 추적 하 고 검색할 난수를 생성 하는 대신 데크를 정렬 하는 난수의 병렬 배열을 만들 수 있습니다. 데크는 정렬 된 후 앱 다음 카드 데크에 인덱스를 나타냅니다에 대 한 포인터를 유지할 수 있습니다.  
  
 다음 예제에서 이 방법을 보여 줍니다. 정의 된 `Card` 플레잉 카드 및 나타내는 클래스 `Dealer` 섞으 카드 데크를 처리 하는 클래스입니다. `Dealer` 클래스 생성자에는 두 개의 배열을 채웁니다:를 `deck` 클래스 범위에 있는 모든 카드 데크; 및 로컬을 나타내는 배열 `order` 만큼의 요소가 있는 배열은 `deck` 배열 및 채워집니다 임의로 생성 <xref:System.Double> 값입니다.  <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> 메서드를 호출 정렬 하는 `deck` 의 값을 기반으로 하는 배열은 `order` 배열.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 다음 예제에서는 단일 난수 생성기를 만들고 호출 해당 <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, 및 <xref:System.Random.NextDouble%2A> 서로 다른 범위 내의 난수 시퀀스를 생성 하는 방법입니다.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 다음 예제에서는 생성 한 인덱스로 사용 되는 임의의 정수를 배열에서 문자열 값을 검색 하려면.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>.NET Framework 1.0 및 1.1에서 파생 된 클래스의 최소 구현을 <see cref="T:System.Random" /> 재정의 하는 데 필요한는 <see cref="M:System.Random.Sample" /> 난수를 생성 하는 것에 대 한 새롭거나 수정 된 알고리즘을 정의 하는 방법입니다. 파생된 클래스의 기본 클래스 구현을 사용 합니다는 <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, 및 <see cref="M:System.Random.NextDouble" /> 파생된 클래스 구현을 호출 하는 방법의 <see cref="M:System.Random.Sample" /> 메서드.  
  
.NET Framework 2.0 이상에서는의 동작에에서는 <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, 및 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 메서드는 이러한 메서드는 파생된 클래스 구현을 호출 하지 않을 수 있도록 변경한는 <see cref="M:System.Random.Sample" /> 메서드. 클래스에서 파생 되는 결과적으로, <see cref="T:System.Random" /> .NET Framework 2.0을 대상으로 하 고 나중에 이러한 세 가지 방법을 재정의 해야 합니다.</para></block>
    <block subset="none" type="usage"><para>난수 생성기 구현의 <see cref="T:System.Random" /> 클래스는.NET Framework의 주 버전 간에 동일 하 게 보장 되지 않습니다. 결과적으로, 동일한 초기값을 다른 버전의.NET Framework에서 동일한 의사 (pseudo) 난수 시퀀스 하면는 가정 하지 않아야 합니다.</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Random" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>시간에 따라 달라지는 시드 값을 사용하여 <see cref="T:System.Random" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 시드 값은 시스템 클록에서 파생 되며 확인에는 한계가 있습니다. 결과적으로 다른 <xref:System.Random> 기본 생성자를 호출 하 여 연속적으로에서 만든 개체에는 동일한 기본 시드 값 있고, 따라서 난수의 동일한 집합을 생성 됩니다. 단일을 사용 하 여이 문제를 방지할 수 있습니다 <xref:System.Random> 모든 난수를 생성 하는 개체입니다. 시스템 클록에서 반환 된 시드 값을 수정 하 고 다음이 새 초기값을 명시적으로 제공 하 여 묶어 사용할 수도 있습니다는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자입니다. 자세한 내용은 참조는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자입니다.  
  
 숫자의 임의 시퀀스를 생성 하 여 난수 생성기를 하려는 경우이 생성자를 호출 합니다. 고정된 될 다른 난수 생성기에 대해 동일한 난수 시퀀스를 생성 하려면 호출을 <xref:System.Random.%23ctor%28System.Int32%29> 고정된 초기값을 사용 하 여 생성자입니다. 이 <xref:System.Random> 생성자 오버 로드는 임의의 숫자를 사용 하는 앱을 테스트 하는 경우에 자주 사용 됩니다.  
  
 난수 생성기를 인스턴스화한 후 호출 개별 <xref:System.Random> 메서드를 같은 <xref:System.Random.Next> 또는 <xref:System.Random.NextDouble>, 난수를 생성 합니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 생성자를 사용 하 여 3 개를 인스턴스화하기 위해 <xref:System.Random> 개체 및 각각에 대 한 5 개의 임의 정수 시퀀스를 표시 합니다. 때문에 처음 두 <xref:System.Random> 개체 닫기 연속 해 서에서, 시스템 클록에 따라 동일한 시드 값을 사용 하 여 인스턴스화되는 만들어지고, 따라서 난수 동일한 시퀀스를 생성 합니다. 반면, 세 번째의 기본 생성자 <xref:System.Random> 개체를 호출 하 여 일으킬 2 초 지연 후 호출 된 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 메서드. 이 세 번째 다른 초기값을 생성 하므로 <xref:System.Random> 개체를 임의 숫자의 서로 다른 시퀀스를 생성 합니다.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">의사(pseudo) 난수 시퀀스의 시작 값을 계산하는 데 사용되는 숫자입니다. 음수를 지정하면 이 숫자의 절대 값이 사용됩니다.</param>
        <summary>지정된 시드 값을 사용하여 <see cref="T:System.Random" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다른 동일한 시드 값을 제공 <xref:System.Random> 개체 하면 각 인스턴스가 동일한 시퀀스 난수를 생성 하 게 합니다. 난수 생성기를 사용 하는 앱을 테스트 하는 경우에 자주 수행 됩니다.  
  
 응용 프로그램에서 다른 난수 시퀀스에 필요한 경우 다른 초기값을 사용 하 여 반복적으로이 생성자를 호출 합니다. 고유한 시드 값을 생성 하는 한 가지 방법은 해당 시간에 따라 달라 지도록 방법은입니다. 예를 들어 초기값으로 시스템 클록에서 파생 되는 <xref:System.Random.%23ctor> 오버 로드 않습니다. 그러나 시스템 클록의 다른 초기값을 사용 하 여이 생성자의 여러 호출을 제공 하기에 충분 한 해상도 없을 수도 있습니다. 처음 두에 나온 것 처럼이 인해 동일한 시퀀스의 의사 (pseudo) 난수를 생성 하는 난수 생성기의 <xref:System.Random> 다음 예제에서는 개체입니다. 이 방지 하려면 각 호출 또는 호출에서 시드 값을 식별 하는 알고리즘을 적용 합니다 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 메서드를 제공 하는 각 생성자는 다른 시드 값을 확인 합니다.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 또 다른 옵션은 단일 인스턴스화할 <xref:System.Random> 응용 프로그램에서 모든 난수를 생성 하는 데 사용할 수 있는 개체입니다. 이 상당히 듭니다 난수 생성기를 인스턴스화 하므로 성능이 약간 향상을 생성 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Random> 초기값 매개 변수를 사용 하 고 임의 정수 및 double 값의 시퀀스를 생성 하는 클래스 생성자를 사용 하 여 개체입니다. 예제 순서가 생성 되는 때를 <xref:System.Random> 개체 생성자 및 초기값 매개 변수를 사용 하 여 다시 생성 됩니다.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>임의의 정수를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>음수가 아닌 임의의 정수를 반환합니다.</summary>
        <returns>0보다 크거나 같고 <see cref="F:System.Int32.MaxValue" />보다 작은 부호 있는 32비트 정수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> 0에서 그 값의 범위가 난수를 생성 보다 작은 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다. 난수 값 범위를 0에서 다른 양수 값을 생성 하려면 사용 된 <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> 메서드 오버 로드 합니다. 다른 범위 내의 난수를 생성 하려면 사용 된 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 다음 예에서는 호출을 반복된 합니다 <xref:System.Random.Next%2A> 특정 개수의 사용자가 요청한 난수를 생성 하는 방법입니다. <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> 메서드는 고객 입력을 가져오는 데 사용 됩니다.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 다음 예제에서 클래스를 파생 <xref:System.Random> 에서 생성 하는 균일 분포에서 해당 배포와 다른 난수 시퀀스를 생성 하는 <xref:System.Random.Sample%2A> 기본 클래스의 메서드. 재정의 <xref:System.Random.Sample%2A> 임의의 숫자와 재정의의 분포를 제공 하는 메서드는 <xref:System.Random.Next%2A?displayProperty=nameWithType> 일련의 임의 숫자를 사용 하는 방법입니다.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>클래스를 파생 하는 경우.NET Framework 버전 2.0부터 <see cref="T:System.Random" /> 시키고 합니다 <see cref="M:System.Random.Sample" /> 메서드를 파생된 클래스 구현에 의해 제공 된 분산이 <see cref="M:System.Random.Sample" /> 메서드가 기본 클래스에 대 한 호출에서 사용 되지 않습니다 구현 된 <see cref="M:System.Random.Next" /> 메서드. 균일 분포 기본 반환 하는 대신 <see cref="T:System.Random" /> 클래스가 사용 됩니다. 이 동작의 전반적인 성능이 개선 된 <see cref="T:System.Random" /> 클래스입니다. 이 동작을 수정 하는 <see cref="M:System.Random.Sample" /> 파생된 클래스에서 메서드를 재정의 해야 합니다 <see cref="M:System.Random.Next" /> 메서드.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">생성될 난수의 상한(제외)입니다. <paramref name="maxValue" />는 0보다 크거나 같아야 합니다.</param>
        <summary>지정된 최댓값보다 작은 음수가 아닌 임의의 정수를 반환합니다.</summary>
        <returns>0보다 크거나 같고 <paramref name="maxValue" />보다 작은 부호 있는 32비트 정수이므로 반환 값의 범위에는 대개 0이 포함되지만 <paramref name="maxValue" />는 포함되지 않습니다. 하지만 <paramref name="maxValue" />가 0과 같으면 <paramref name="maxValue" />가 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Random.Next%28System.Int32%29> 오버 로드는 반환 난수의 범위 0 ~ `maxValue` -1입니다. 그러나 경우 `maxValue` 가 0 이면 메서드에서 0을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 오버 로드를 사용 하 여 난수를 생성 합니다 <xref:System.Random.Next%2A> 메서드.  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 다음 예제에서는 생성 한 인덱스로 사용 되는 임의의 정수를 배열에서 문자열 값을 검색 하려면. 배열의 가장 높은 인덱스 하나 보다 작은 길이, 값 이므로 <xref:System.Array.Length%2A?displayProperty=nameWithType> 속성으로 제공 되는 `maxValue` 매개 변수입니다.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue" />가 0보다 작은 경우</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">반환되는 난수의 하한(포함)입니다.</param>
        <param name="maxValue">반환되는 난수의 상한(제외)입니다. <paramref name="maxValue" />는 <paramref name="minValue" />보다 크거나 같아야 합니다.</param>
        <summary>지정된 범위 내의 임의의 정수를 반환합니다.</summary>
        <returns><paramref name="minValue" />보다 크거나 같고 <paramref name="maxValue" />보다 작은 부호 있는 32비트 정수이므로 반환 값의 범위에는 <paramref name="minValue" />가 포함되지만 <paramref name="maxValue" />는 포함되지 않습니다. <paramref name="minValue" />가 <paramref name="maxValue" />와 같은 경우에는 <paramref name="minValue" />가 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 오버 로드는 해당 범위에서 임의의 정수 반환 `minValue` 에 `maxValue` -1입니다. 그러나 경우 `maxValue` equals `minValue`, 메서드가 반환 `minValue`합니다.  
  
 다른 오버 로드와 달리는 <xref:System.Random.Next%2A> 만 음수가 아닌 값을 반환 하는 메서드를이 메서드는 음수 임의의 정수를 반환할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 세 개의 서로 다른 범위를 사용 하 여 난수를 생성 하는 방법입니다. 정확한 출력의 예제에서 전달 되는 시스템 제공 시드 값에 따라 달라 집니다는 <xref:System.Random> 클래스 생성자입니다.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 다음 예제에서는 생성 한 인덱스로 사용 되는 임의의 정수를 배열에서 문자열 값을 검색 하려면. 배열의 가장 높은 인덱스 하나 보다 작은 길이, 값 이므로 <xref:System.Array.Length%2A?displayProperty=nameWithType> 속성으로 제공 되는 `maxValue` 매개 변수입니다.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minValue" />가 <paramref name="maxValue" />보다 큰 경우</exception>
        <block subset="none" type="overrides"><para>클래스를 파생 하는 경우.NET Framework 버전 2.0부터 <see cref="T:System.Random" /> 시키고 합니다 <see cref="M:System.Random.Sample" /> 메서드를 파생된 클래스 구현에 의해 제공 된 분산이 <see cref="M:System.Random.Sample" /> 메서드가 기본 클래스에 대 한 호출에서 사용 되지 않습니다 구현의 합니다 <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 경우 메서드 오버 로드 간의 차이 <paramref name="minValue" /> 및 <paramref name="maxValue" /> 매개 변수 보다 크거나 <see cref="F:System.Int32.MaxValue" />합니다. 균일 분포 기본 반환 하는 대신 <see cref="T:System.Random" /> 클래스가 사용 됩니다. 이 동작의 전반적인 성능이 개선 된 <see cref="T:System.Random" /> 클래스입니다. 이 동작을 수정 하는 <see cref="M:System.Random.Sample" /> 파생된 클래스에서 메서드를 재정의 해야 합니다 <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 메서드 오버 로드 합니다.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">난수를 포함하는 바이트 배열입니다.</param>
        <summary>지정된 바이트 배열의 요소를 난수로 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 0 보다 크거나 바이트 배열의 각 요소는 임의의 수로 설정 되어 보다 작거나 같음 <xref:System.Byte.MaxValue>합니다.  
  
 예를 들어, 임의의 암호를 만드는 데 적합 한 암호화 보안된 난수를 생성 하려면 메서드를 같은 사용 <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Random.NextBytes%2A> 메서드를 임의 바이트 값으로 바이트 배열을 채웁니다.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <block subset="none" type="overrides"><para>클래스를 파생 하는 경우.NET Framework 버전 2.0부터 <see cref="T:System.Random" /> 시키고 합니다 <see cref="M:System.Random.Sample" /> 메서드를 파생된 클래스 구현에 의해 제공 된 분산이 <see cref="M:System.Random.Sample" /> 메서드가 기본 클래스에 대 한 호출에서 사용 되지 않습니다 구현 된 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 메서드. 균일 분포 기본 반환 하는 대신 <see cref="T:System.Random" /> 클래스가 사용 됩니다. 이 동작의 전반적인 성능이 개선 된 <see cref="T:System.Random" /> 클래스입니다. 이 동작을 수정 하는 <see cref="M:System.Random.Sample" /> 파생된 클래스에서 메서드를 재정의 해야 합니다 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 메서드.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0.0보다 크거나 같고 1.0보다 작은 부동 소수점 난수입니다.</summary>
        <returns>0.0보다 크거나 같고 1.0보다 작은 배정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에서 반환 된 임의 수의 실제 상한을 0.99999999999999978 됩니다.  
  
 0.0과 1.0 이외의 범위 내에서 임의의 부동 소수점 값을 검색할의 "지정된 된 범위에서 부동 소수점 값을 검색" 섹션을 참조 합니다 <xref:System.Random> 클래스 항목입니다.  
  
 이 메서드는 공용 버전의 보호 된 메서드, <xref:System.Random.Sample%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Random.NextDouble%2A> 임의 double 값의 시퀀스를 생성 하는 방법입니다.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 다음 예제에서는 <xref:System.Random.NextDouble%2A> 100 개의 난수를 생성 하는 메서드 번호 및 해당 빈도 분포를 표시 합니다.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>0.0과 1.0 사이의 임의의 부동 소수점 숫자를 반환합니다.</summary>
        <returns>0.0보다 크거나 같고 1.0보다 작은 배정밀도 부동 소수점 숫자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서로 다른 무작위 분포 또는 다른 임의의 수 생성기 원칙을 생성 하려면에서 클래스를 파생 합니다 <xref:System.Random> 클래스를 재정의 합니다 <xref:System.Random.Sample%2A> 메서드.  
  
> [!IMPORTANT]
>  합니다 <xref:System.Random.Sample%2A> 메서드는 `protected`, 즉, 내 에서만 액세스할 수 있는지를 <xref:System.Random> 클래스와 파생된 클래스입니다. 0에서 1 사이의 난수를 생성 하는 <xref:System.Random> 인스턴스를 호출 합니다 <xref:System.Random.NextDouble%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서 클래스를 파생 <xref:System.Random> 재정의 <xref:System.Random.Sample%2A> 난수 분포를 생성 하는 방법입니다. 이 분포는 균일 분포에서 생성 된 다른는 <xref:System.Random.Sample%2A> 메서드의 기본 클래스입니다.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>클래스를 파생 하는 경우.NET Framework 버전 2.0부터 <see cref="T:System.Random" /> 시키고 합니다 <see cref="M:System.Random.Sample" /> 메서드를 파생된 클래스 구현에 의해 제공 된 분산이 <see cref="M:System.Random.Sample" /> 메서드가 기본 클래스에 대 한 호출에서 사용 되지 않습니다 다음 메서드를 구현 합니다. 
-   <see cref="M:System.Random.NextBytes(System.Byte[])" /> 메서드  
  
-   <see cref="M:System.Random.Next" /> 메서드  
  
- <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 메서드인 경우 (<paramref name="maxValue" /> - <paramref name="minValue" />) 보다 크면 <see cref="F:System.Int32.MaxValue" />합니다.  
  
균일 분포는 기본 제공 하는 대신 <see cref="T:System.Random" /> 클래스가 사용 됩니다. 이 동작의 전반적인 성능이 개선 된 <see cref="T:System.Random" /> 클래스입니다. 구현을 호출 하도록이 동작을 수정 하는 <see cref="M:System.Random.Sample" /> 메서드는 파생된 클래스에서 재정의 해야 이러한 세 가지 멤버의 동작입니다. 예제에서는 그림을 제공합니다.</para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>