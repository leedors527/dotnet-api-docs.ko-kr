<Type Name="Span&lt;T&gt;" FullName="System.Span&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c61e6b59e39fd9f77ea203c0bdabd7429fb24683" /><Meta Name="ms.sourcegitcommit" Value="635a1dbdc9cbcf7f7c258ac9ffa0314ed734da90" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="04/10/2019" /><Meta Name="ms.locfileid" Value="59472185" /></Metadata><TypeSignature Language="C#" Value="public struct Span&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Span`1&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Span`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Span(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public value class Span" />
  <TypeSignature Language="F#" Value="type Span&lt;'T&gt; = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">항목의 형식은 <see cref="System.Span`1" />합니다.</typeparam>
    <summary>인접한 임의의 메모리 영역에 대해 형식 및 메모리 안전 표현을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

`Span<T>` [ref 구조체](~/docs/csharp/language-reference/keywords/ref.md#ref-struct-types) 스택에 아닌 관리 되는 힙에 할당 되는 합니다. Ref 구조체 형식을 제한 하는 수준을 올릴 수 없습니다를 넣을 수 없습니다, 형식의 변수에 할당할 수 없는 관리 되는 힙에 하도록 많은 <xref:System.Object>, `dynamic` 임의의 인터페이스 형식에서 필드 일 수 없습니다 또는 참조 형식 있으며에서 사용할 수 없습니다 `await` 고 `yield` 경계입니다. 또한 두 개의 메서드를 호출 <xref:System.Span%601.Equals(System.Object)> 하 고 <xref:System.Span%601.GetHashCode%2A>을 throw를 <xref:System.NotSupportedException>입니다. 

> [!IMPORTANT]
> 스택 전용 형식 이므로 `Span<T>` 힙에 버퍼에 대 한 참조를 저장 해야 하는 많은 시나리오에 적합 하지 않습니다. 이것이 asynchrous 메서드 호출을 수행 하는 루틴의 예를 들어 true입니다. 이러한 시나리오에 대 한 무료 따르면 <xref:System.Memory%601?displayProperty=nameWithType> 고 <xref:System.ReadOnlyMemory%601?displayProperty=nameWithType> 형식입니다.

변경할 수 없는 또는 읽기 전용으로 구조를 나타내는 범위를 사용 하 여 <xref:System.ReadOnlySpan%601?displayProperty=nameWithType>입니다.

## <a name="spant-and-memory"></a>범위\<T > 및 메모리

`Span<T>` 연속 임의의 메모리 영역을 나타냅니다. `Span<T>` 인스턴스는 배열의 요소나 배열의 일부를 포함 하는 데 자주 사용 됩니다. 그러나 배열 달리를 `Span<T>` 인스턴스는 기본 메모리 관리 되는 메모리를 가리킬 수 또는 메모리에서 관리 되는 스택. 다음 예제에서는 한 `Span<Byte>` 배열에서:

[!code-csharp[Creating a Span\<Byte> from an array](~/samples/snippets/csharp/api/system/span/program.cs#1)]
     
다음 예제에서는 `Span<Byte>` 100 바이트의 네이티브 메모리에서:

[!code-csharp[Creating a Span\<Byte> from native memory](~/samples/snippets/csharp/api/system/span/program.cs#2)]

다음 예제는 C# [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) 100 바이트의 스택 메모리를 할당 하는 키워드:

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#3)]

때문에 `Span<T>` 메모리의 메서드는 임의의 블록과 추상화 합니다 `Span<T>` 클래스 및 메서드를 `Span<T>` 매개 변수에서 작동 `Span<T>` 캡슐화 하는 메모리의 종류에 관계 없이 개체입니다. 예를 들어, 각 범위를 초기화 하 고 다음 예제와 같이 단일 초기화 및 계산 방법으로 해당 요소의 합계를 변경할 수 있습니다를 계산 하는 코드의 개별 구역이 보여 줍니다.

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#4)]

## <a name="spant-and-arrays"></a>범위\<T > 및 배열

배열을 래핑하는 경우 `Span<T>` 의 예제에서와 마찬가지로 배열 전체를 래핑할 수 합니다 [범위\<T > 및 메모리](#spant-and-memory) 섹션입니다. 조각화 지원 하므로 `Span<T>` 배열 내의 모든 연속 범위를 가리킬 수도 있습니다.  

다음 예제에서는 10 요소 정수 배열의 중간 다섯 개 요소의 조각을 만듭니다. 코드 조각에서 각 정수 값을 두 배로 증가 하는 참고 합니다. 출력에서 볼 수 있듯이 배열의 값 범위에서 변경한 내용이 반영 됩니다.

[!code-csharp[Creating a slice from a portion of a span](~/samples/snippets/csharp/api/system/span/slice/program.cs)]

## <a name="spant-and-slices"></a>범위\<T > 및 조각

`Span<T>` 두 오버 로드를 포함 합니다 <xref:System.Span%601.Slice%2A> 조각이 지정된 된 인덱스에서 시작 하는 현재 범위에서 구성 하는 메서드. 따라서에서 해당 데이터를 처리 하는 `Span<T>` 최소 성능에 영향을 데이터 처리 파이프라인의 부분에서 필요에 따라 처리할 수 있는 논리 영역 집합으로 합니다. 예를 들어 최신 서버 프로토콜은 종종 텍스트를 기반으로 하므로 문자열에서 부분 문자열을 조작이 특히 중요 합니다. 에 <xref:System.String> 클래스의 주요 메서드 부분 문자열을 추출 하는 것에 대 한 <xref:System.String.Substring%2A>합니다. 광범위 한 문자열 조작에 의존 하는 데이터 파이프라인에 대 한 용도 이후 몇 가지 성능 저하를 제공 합니다.

1. 부분 문자열을 저장할 새 문자열을 만듭니다.

2. 원래 문자열에서 문자의 하위 집합을 새 문자열을 복사합니다.

이 할당 및 복사 작업 중 하나를 사용 하 여 제거할 수 있습니다 `Span<T>` 또는 <xref:System.ReadOnlySpan%601>다음 예제와 같이:

[!code-csharp[Creating a slice from a substring](~/samples/snippets/csharp/api/system/span/slice2/program.cs)]


      ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; array" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Span`1" /> 개체를 만들 배열입니다.</param>
        <summary>지정된 배열 전체에 새로운 <see cref="T:System.Span`1" /> 개체를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

경우 `array` 됩니다 `null`,이 생성자를 반환을 `null` `Span<T>`합니다.

      ]]></format>
        </remarks>
        <exception cref="T:System.TypeMismatchException"><paramref name="T" /> 참조 형식이며, <paramref name="array" />는 <paramref name="T" /> 형식의 배열이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (void* pointer, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* pointer, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(System.Void*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(void* pointer, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : nativeptr&lt;unit&gt; * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (pointer, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Void*" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer">메모리에서 지정된 <typeparamref name="T" /> 요소 수의 시작 주소에 대한 포인터입니다.</param>
        <param name="length"><see cref="T:System.Span`1" />에 포함될 <typeparamref name="T" /> 요소의 수입니다.</param>
        <summary>지정된 메모리 주소에서 시작하는 지정된 <typeparamref name="T" /> 수로부터 새로운 <see cref="T:System.Span`1" /> 개체를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

        This constructor should be used with care, since it creates arbitrarily typed `T`s from a `void*`-typed block of memory, and `length` is not checked. However, if the constructor succeeds in creating a new <xref:System.Span%601> object, all subsequent uses are correct.        

      ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="T" /> 참조 형식이거나 포인터를 포함하므로 관리되지 않는 메모리에 저장할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> 음수입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] * int * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (array, start, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">소스 배열입니다.</param>
        <param name="start">새 <see cref="T:System.Span`1" />에 포함할 첫 번째 요소의 인덱스입니다.</param>
        <param name="length">새 <see cref="T:System.Span`1" />에 포함할 요소 수입니다.</param>
        <summary>지정된 인덱스에서 시작하는 배열의 지정된 요소 수를 포함하는 새 <see cref="T:System.Span`1" /> 개체를 만듭니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="array" /> <see langword="null" />이지만, <paramref name="start" /> 또는 <paramref name="length" />는 0이 아닙니다.

또는

<paramref name="start" /> 배열의 범위 밖에 있습니다.

또는

<paramref name="start" /> 및 <paramref name="length" />가 배열의 요소 수를 초과합니다.</exception>
        <exception cref="T:System.TypeMismatchException"><paramref name="T" /> 참조 형식이며, <paramref name="array" />는 <paramref name="T" /> 형식의 배열이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="span.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Span`1" /> 개체의 콘텐츠를 지웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

합니다 `Clear` 항목을 설정 하는 메서드는 <xref:System.Span%601> 기본값으로 개체입니다. 항목을 제거 하지 않습니다는 <xref:System.Span%601>합니다.  

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.CopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Span&lt;'T&gt; -&gt; unit" Usage="span.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">대상 <see cref="System.Span`1" /> 개체입니다.</param>
        <summary>이 <see cref="System.Span`1" />의 콘텐츠를 대상 <see cref="System.Span`1" />로 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

이 메서드는 모두 복사 `source` 에 `destination` 경우에 `source` 및 `destination` 겹칩니다.

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destination" /> 원본 <see cref="System.Span`1" />보다 짧습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Span`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Span&lt;T&gt; Empty { Span&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Empty : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Empty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>빈 <see cref="T:System.Span`1" /> 개체를 반환합니다.</summary>
        <value>빈 <see cref="T:System.Span`1" /> 개체입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="span.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Equals() on Span will always throw an exception. Use == instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">지원되지 않습니다.</param>
        <summary>이 메서드의 호출은 지원되지 않습니다.</summary>
        <returns>이 메서드의 호출은 지원되지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
에 대 한 호출을 <xref:System.Span%601.Equals%2A> 메서드가 지원 되지 않습니다. 에 대 한 호출을 <xref:System.Span%601.Equals%2A> 생성 되는 두 개의 결과 중 하나:

- 경우 `obj` 되는 <xref:System.Span%601>, 컴파일러 오류 CS1503를 생성 하는 메서드 호출: "변환할 수 없습니다 'System.Span'에서 'object'." 때문에 이것이 <xref:System.Span%601> 되는 [ref 구조체](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) 넣을 수 없습니다 하 고로 변환할 수 없습니다는 <xref:System.Object>합니다.

- 경우 유형의 `obj` 아닙니다를 <xref:System.Span%601>, 메서드 호출에서 throw를 <xref:System.NotSupportedException>입니다. 

비교할 두 개의 <xref:System.Span%601> 개체가 같은지를 사용 하 여는 <xref:System.Span%601.op_Equality%2A> 비교 연산자입니다.

        ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드의 호출은 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public void Fill (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Fill(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Fill(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Fill (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Fill(T value);" />
      <MemberSignature Language="F#" Value="member this.Fill : 'T -&gt; unit" Usage="span.Fill value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">범위의 각 요소에 할당할 값입니다.</param>
        <summary>지정된 값으로 이 범위의 요소를 채웁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Span(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; Span&lt;'T&gt;.Enumerator" Usage="span.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Span`1" />에 대한 열거자를 반환합니다.</summary>
        <returns>이 범위에 대한 열거자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
호출 하는 대신 합니다 <xref:System.Span%601.GetEnumerator%2A> 메서드를 직접 사용할 수는 C# `foreach` 문 및 Visual Basic `For Each`... `Next` 구문을 사용 열거 하는 <xref:System.Span%601>합니다.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="span.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetHashCode() on Span will always throw an exception.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.NotSupportedException" />를 throw합니다.</summary>
        <returns>이 메서드를 호출하면 <see cref="T:System.NotSupportedException" />이 항상 throw됩니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">이 메서드의 호출은 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public T GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T % GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; " Usage="span.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T@</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>인덱스 0에서 <see cref="T:System.Span`1" />의 마지막 요소에 대한 참조를 반환합니다.</summary>
        <returns>인덱스 0에서 <see cref="T:System.Span`1" /> 요소에 대한 참조이거나 <see cref="M:System.Span`1.IsEmpty" />가 <see langword="true" />인 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

합니다 `GetPinnableReference` 메서드가 반환 되는 [ref 구조체](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type)합니다. 고정할 수는 <xref:System.Span%601> 메모리에 있습니다. 사용을 지원 해야는 <xref:System.Span%601> 내에서 [고정](~/docs/csharp/language-reference/keywords/fixed-statement.md) 문입니다.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Span&lt;'T&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Span`1" />가 비어 있는지 여부를 나타내는 값을 반환합니다.</summary>
        <value><see langword="true" /> 현재 범위가 비어 있는 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[Index index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(valuetype System.Index)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Index) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[Index] { T % get(Index index); };" />
      <MemberSignature Language="F#" Value="member this.Item(Index) : " Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[int] { T % get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : " Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">요소의 0부터 시작하는 인덱스입니다.</param>
        <summary>지정된 인덱스(0부터 시작)에서 요소를 가져옵니다.</summary>
        <value>지정한 인덱스의 요소입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> 0보다 작거나 <see cref="P:System.Span`1.Length" />보다 크거나 같은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; this[Range range] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Span`1&lt;!T&gt; Item(valuetype System.Range)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Range)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(range As Range) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Span&lt;T&gt; default[Range] { Span&lt;T&gt; get(Range range); };" />
      <MemberSignature Language="F#" Value="member this.Item(Range) : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Span&lt;'T&gt;.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 범위의 길이를 설정합니다.</summary>
        <value>현재 범위의 길이입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 범위입니다.</param>
        <param name="right">비교할 두 번째 범위입니다.</param>
        <summary>두 <see cref="T:System.Span`1" /> 개체가 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" /> 두 <see cref="T:System.Span`1" /> 개체가 같고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

두 개의 <xref:System.Span%601> 동일한 길이 및 해당 요소의 경우 개체가 같은지 `left` 및 `right` 동일한 메모리를 가리킵니다. 같음 테스트를 수행 하는 참고 *되지* 내용이 같은지 여부를 확인 하려고 합니다.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; arraySegment) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (arraySegment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; segment) cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.ArraySegment{`0})~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (segment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member op_Implicit : ArraySegment&lt;'T&gt; -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="segment"><see cref="T:System.Span`1" />로 변환될 배열 세그먼트입니다.</param>
        <summary><see cref="T:System.ArraySegment`1" />을 <see cref="T:System.Span`1" />로 변환하는 암시적 변환을 정의합니다.</summary>
        <returns>배열 세그먼트에 해당하는 범위입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;T&gt; (Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;!T&gt; op_Implicit(valuetype System.Span`1&lt;!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.Span{`0})~System.ReadOnlySpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (span As Span(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;T&gt;(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : Span&lt;'T&gt; -&gt; ReadOnlySpan&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="span"><see cref="T:System.ReadOnlySpan`1" />으로 변환할 개체입니다.</param>
        <summary><see cref="T:System.Span`1" />을 <see cref="T:System.ReadOnlySpan`1" />로 변환하는 암시적 변환을 정의합니다.</summary>
        <returns>현재 인스턴스에 해당하는 읽기 전용 범위입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(`0[])~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : 'T[] -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Span`1" />로 변환할 배열입니다.</param>
        <summary>배열을 <see cref="T:System.Span`1" />로 변환하는 암시적 변환을 정의합니다.</summary>
        <returns><paramref name="array" />에 해당하는 범위입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="System.Span&lt;'T&gt;.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 범위입니다.</param>
        <param name="right">비교할 두 번째 범위입니다.</param>
        <summary>두 <see cref="T:System.Span`1" /> 개체가 같지 않은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" /> 두 <see cref="T:System.Span`1" /> 개체가 같지 않고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

두 개의 <xref:System.Span%601> 개체가 같은지 없거나 길이가 다른 경우의 해당 요소 `left` 고 `right` 동일한 메모리를 가리키지 않습니다. 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (startIndex As Index) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(Index startIndex);" />
      <MemberSignature Language="F#" Value="member this.Slice : Index -&gt; Span&lt;'T&gt;" Usage="span.Slice startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start);" />
      <MemberSignature Language="F#" Value="member this.Slice : int -&gt; Span&lt;'T&gt;" Usage="span.Slice start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">조각을 시작할 인덱스입니다.</param>
        <summary>지정된 인덱스로 시작되는 현재 범위에서 하나의 조각을 형성합니다.</summary>
        <returns><paramref name="index" />에서 스팬의 끝까지 현재 범위의 모든 요소로 구성된 범위입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 0보다 작거나 <see cref="T:System.Span`1.Length" />보다 크거나 같은 경우.</exception>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(Range range);" />
      <MemberSignature Language="F#" Value="member this.Slice : Range -&gt; Span&lt;'T&gt;" Usage="span.Slice range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start, int length);" />
      <MemberSignature Language="F#" Value="member this.Slice : int * int -&gt; Span&lt;'T&gt;" Usage="span.Slice (start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">이 조각을 시작할 인덱스입니다.</param>
        <param name="length">조각에 대한 원하는 길이입니다.</param>
        <summary>지정된 길이 대해 지정된 인덱스에서 시작하는 현재 범위에서 벗어난 조각을 형성합니다.</summary>
        <returns><paramref name="index" />에서 시작하는 현재 범위로부터 <paramref name="length" /> 요소를 구성하는 범위입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" /> 또는 <paramref name="start" /> + <paramref name="index" />가 0보다 작거나 <see cref="T:System.Span`1.Length" />보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="span.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 범위의 콘텐츠를 새 배열로 복사합니다.</summary>
        <returns>현재 범위에서 데이터를 포함하는 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

이 메서드는 힙 할당을 수행 하 고 따라서 가능한 경우 피해 야 합니다. 이 Api는 지원 되는 경우 작업이 필요한 경우도 해당 <xref:System.Span%601> 개체를 사용할 수 없는 있지만 api는 배열을 사용 합니다.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="span.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Span`1" /> 개체의 문자열 표현을 반환합니다.</summary>
        <returns>이 <see cref="T:System.Span`1" /> 개체의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
에 대 한를 `Span<Char>`, `ToString` 메서드가 반환 되는 <xref:System.String> 가리키는 문자가 포함 된를 <xref:System.Span%601>. 를 반환 합니다는 <xref:System.String> 형식 및 요소 수의 이름으로는 <xref:System.Span%601> 포함 되어 있습니다.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.TryCopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.TryCopyTo : Span&lt;'T&gt; -&gt; bool" Usage="span.TryCopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">복사 작업의 대상입니다.</param>
        <summary>현재 <see cref="T:System.Span`1" />을 대상 <see cref="T:System.Span`1" />에 복사하려고 시도하고 복사 작업의 성공 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" /> 복사 작업이 성공적으로 수행되는 경우이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

이 메서드는 모두 복사 `source` 에 `destination` 경우에 `source` 및 `destination` 겹칩니다.

하는 경우 `destination` 원본 보다 짧은 <xref:System.Span%601>,이 메서드는 반환 `false`에 데이터가 기록 됩니다 `destination`합니다.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>