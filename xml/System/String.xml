<Type Name="String" FullName="System.String">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4d25436086f9e3033aa184eea75f303fbc6d4a03" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52608901" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>텍스트를 UTF-16 코드 단위의 시퀀스로 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 문자열은 텍스트를 나타내는 데 사용 되는 문자의 순차적인 컬렉션입니다. A <xref:System.String> 개체의 순차 컬렉션이 <xref:System.Char?displayProperty=nameWithType> 있으며 문자열을 나타내는 개체를 개체 <xref:System.Char?displayProperty=nameWithType> utf-16 코드 단위에 해당 하는 개체입니다. 값을 <xref:System.String> 개체의 순차 컬렉션의 콘텐츠가 <xref:System.Char?displayProperty=nameWithType> 개체 및 값은 변경할 수 없습니다 (즉,이 읽기 전용). 문자열의 불변성에 대 한 자세한 내용은 참조는 [불변성 및 StringBuilder 클래스](#Immutability) 이 항목의 뒷부분에 나오는 섹션입니다. 최대 크기는 <xref:System.String> 메모리에서 개체는 약 1 십억 자 2GB입니다.  
  
 섹션 내용  
  
 [문자열 개체 인스턴스화](#Instantiation)   
 [개체 및 유니코드 문자를 문자](#Characters)   
 [문자열과 유니코드 표준](#Unicode)   
 [문자열 및 포함 된 null 문자](#EmbeddedNulls)   
 [문자열 및 인덱스](#Indexes)   
 [Null 문자열 및 빈 문자열](#Nulls)   
 [불변성 및 StringBuilder 클래스](#Immutability)   
 [문화권 구분 작업 및 서 수](#CultureSensitive)   
 [정규화](#Normalization)   
 [범주별 문자열 작업](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>문자열 개체 인스턴스화  
 인스턴스화할 수 있습니다는 <xref:System.String> 다음과 같은 방법으로 개체:  
  
-   문자열 리터럴을 할당 하 여를 <xref:System.String> 변수입니다. 이 방법은 문자열을 만들기 위해 가장 일반적으로 사용 합니다. 다음 예제에서는 할당을 사용 하 여 여러 문자열을 만들 수 있습니다. 때문에 C#에서 유의 백슬래시 (\\)는 이스케이프 문자, 문자열에서 리터럴 백슬래시를 이스케이프 해야 합니다 또는 전체 문자열 이어야 합니다 @-quoted합니다.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   호출 하 여를 <xref:System.String> 클래스 생성자입니다. 다음 예제에서는 몇 가지 클래스 생성자를 호출 하 여 문자열을 인스턴스화합니다. 문자 배열 또는 매개 변수 사용 되는 부호 있는 바이트 배열에 대 한 포인터를 포함 하는 생성자 중 일부를 note 합니다. Visual Basic에서 이러한 생성자에 대 한 호출을 지원 하지 않습니다. 에 대 한 자세한 내용은 <xref:System.String> 생성자를 참조 합니다 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   문자열 연결 연산자를 사용 하 여 (+, C# 및 & 또는 + Visual Basic의) 단일 문자열로 조합 중에서 만들려는 <xref:System.String> 인스턴스 및 문자열 리터럴. 다음 예제에서는 문자열 연결 연산자를 사용을 하는 방법을 보여 줍니다.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   속성을 검색 하거나 메서드를 호출 하 여 문자열을 반환 하는 합니다. 메서드를 사용 하는 다음 예제는 <xref:System.String> 클래스를 더 큰 문자열에서 부분 문자열을 추출 합니다.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   값 또는 개체를 문자열 표현으로 변환 하는 형식 지정 메서드를 호출 합니다. 다음 예제에서는 합니다 [복합 서식 지정](~/docs/standard/base-types/composite-formatting.md) 문자열로 두 개체의 문자열 표현을 포함 하는 기능입니다.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>개체 및 유니코드 문자를 문자  
 문자열의 각 문자는 유니코드 코드 포인트 또는 유니코드 문자의 서 수 (숫자) 값을 유니코드 스칼라 값으로 정의 됩니다. Utf-16 인코딩을 사용 하 여 각 코드 포인트를 인코딩하고 인코딩을의 각 요소 숫자 값은 표현 된 <xref:System.Char> 개체입니다.  
  
> [!NOTE]
>  때문에 <xref:System.String> utf-16 코드 단위 순차 컬렉션의 인스턴스 구성, 만들 수 있기를 <xref:System.String> 개체는 올바른된 유니코드 문자열입니다. 예를 들어, 해당 상위 서로게이트 없이 하위 서로게이트 된 문자열을 만들 수입니다. 하지만 인코딩 및 디코딩에서 개체의 메서드와 같은 일부 메서드는 <xref:System.Text> 네임 스페이스 문자열이 제대로 구성 되어 있는지 확인 하는 검사를 수행 될 수 있습니다 <xref:System.String> 문자열은 올바른 형식의 클래스 멤버 보장할 수 없습니다.  
  
 단일 <xref:System.Char> 개체에는 일반적으로 단일 나타냅니다 코드 포인트의 숫자 값, 즉는 <xref:System.Char> 코드 포인트와 같습니다. 예를 들어, 코드 포인트를 "문자에 대 한 a"가 단어로 합니다. 그러나 코드 포인트를 인코딩된 요소가 둘 이상 필요할 수도 있습니다 (둘 이상의 <xref:System.Char> 개체). 유니코드 표준은 여러 문자에 해당 하는 두 가지 유형의 정의 <xref:System.Char> 개체: 제자, 및에서 유니코드 보조 평면 문자에 해당 하는 유니코드 보충 코드 포인트입니다.  
  
-   기본 문자 뒤에 하나 이상의 조합 문자는 문자 소 표시 됩니다. 문자 ä는 표현 예를 들어 <xref:System.Char> 단어로 뒤에 해당 코드 포인트 개체 <xref:System.Char> 해당 코드 포인트 + 0308 개체입니다. 이 문자는 단일 정의할 수도 있습니다 <xref:System.Char> 00 e U + 4 인 코드 포인트를 가진 개체입니다. 다음 예제와 같이 일반 서 수 비교 하지 않습니다 하지만 이러한 두 표현은 같음, 같음에 대 한 문화권 구분 비교를 나타냅니다. 그러나 두 문자열 정규화 되는 경우 서 수 비교를 나타내기도 같은지 합니다. (문자열 정규화에 대 한 자세한 내용은 참조는 [정규화](#Normalization) 섹션입니다.)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   보조 코드 포인트 (서로게이트 쌍)가 나타내는 유니코드를 <xref:System.Char> 뒤에 상위 서로게이트 코드 포인트가 개체는 <xref:System.Char> 하위 서로게이트 코드 포인트가 개체입니다. U+d800부터 U + dbff 사이의 높은 서로게이트가 범위의 코드 단위입니다. 이 U+dc00부터 U + dfff 낮은 서로게이트가 범위의 코드 단위입니다. 서로게이트 쌍에 16 유니코드 보조 평면 문자를 나타내기 위해 사용 됩니다. 다음 예제에서는 서로게이트 문자를 만들어 전달 된 <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> 이 서로게이트 쌍인지 여부를 결정 하는 방법입니다.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>문자열과 유니코드 표준  
 문자열의 문자는 해당 하는 u t F-16으로 인코딩된 코드 단위를 나타내는 <xref:System.Char> 값입니다.  
  
 문자열의 각 문자에 하 여.NET에서 표현 되는 연결 된 유니코드 문자 범주는 <xref:System.Globalization.UnicodeCategory> 열거형입니다. 호출 하 여 문자 또는 서로게이트 쌍의 범주를 확인할 수 있습니다는 <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> 메서드.  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 또한.NET 문자열 비교를 지원 하 고 유니코드 표준에 따라 정렬 합니다. 통해.NET Framework의 버전에서을 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)],.NET Framework에 문자열 데이터의 자체 테이블 유지 관리 합니다. 부터.NET Framework의 버전도 마찬가지 여 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] Windows 7을 실행 합니다. 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] Window 8 및 이후 버전의 Windows 운영 체제를 실행, 런타임 대리자 문자열 비교 및 정렬 작업의 운영 체제입니다. .NET Core에서 문자열 비교 및 정렬 정보가 제공한 [유니코드에 대 한 구성 요소 International](http://site.icu-project.org/) 라이브러리입니다. 다음 표에서.NET 버전 및 문자 비교 및 정렬 기반으로 하는 유니코드 표준의 버전을 나열 합니다.  
  
|.NET 버전|유니코드 표준 버전|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[유니코드 표준, 버전 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[유니코드 표준, 버전 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[유니코드 표준, 버전 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[유니코드 표준, 버전 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] Windows 7 이상|[유니코드 표준, 버전 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] 나중에 Windows 8 및 이후 Windows 운영 체제|[유니코드 표준, 버전 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET Core(모든 버전)|기본 운영 체제에서 지원 되는 유니코드 표준의 버전에 따라 달라 집니다.|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>문자열 및 포함 된 null 문자  
 .NET에서는 <xref:System.String> 개체 계산에 포함 된 문자열의 길이 포함 된 null 문자를 포함할 수 있습니다. 그러나 C 및 c + +와 같은 일부 언어에서 null 문자를 끝을 나타내는 문자열입니다. 문자열의 일부로 간주 되지 않습니다 하 고 문자열의 길이의 일부로 계산 되지 않습니다. 즉, 문자열에 대 한 C 및 c + + 프로그래머 또는 C 또는 c + +로 작성 된 라이브러리 적합할 수 있는 다음과 같은 일반적인 가정을 유효 하지 않음을 반드시 적용할 때 <xref:System.String> 개체:  
  
-   값을 반환 합니다 `strlen` 또는 `wcslen` 함수를 반드시 같지 않습니다 <xref:System.String.Length%2A?displayProperty=nameWithType>합니다.  
  
-   만든 문자열을 `strcpy_s` 또는 `wcscpy_s` 함수에서 생성 된 문자열을 반드시 동일 하지 않습니다는 <xref:System.String.Copy%2A?displayProperty=nameWithType> 메서드.  
  
 인스턴스화하는 네이티브 C 및 c + + 코드를 확인 해야 <xref:System.String> 개체 및 전달 되는 코드 <xref:System.String> 플랫폼을 통해 개체 호출, 포함 된 null 문자는 문자열의 끝을 표시는 가정 하지 마십시오.  
  
 또한 문자열에 포함 된 null 문자 및 문자열 정렬 (또는 비교) 하는 경우 문자열을 검색할 때 다르게 처리 됩니다. Null 문자는 두 문자열을 고정 문화권을 사용한 비교를 포함 하 여 문화권 구분 비교를 수행 하는 경우 무시 됩니다. 서 수 비교를 서 수 또는 대/소문자에 대해서만 간주 됩니다. 반면에 포함 된 null 문자를 항상 고려와 같은 메서드를 사용 하 여 문자열을 검색 하는 경우 <xref:System.String.Contains%2A>하십시오 <xref:System.String.StartsWith%2A>, 및 <xref:System.String.IndexOf%2A>합니다.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>문자열 및 인덱스  
 인덱스의 위치를는 <xref:System.Char> (유니코드 문자가 아님)에서 개체를 <xref:System.String>입니다. 인덱스는 인덱스 위치 0에 해당 하는 문자열의 첫 번째 위치에서 시작 하는 음수가 아닌 숫자 0부터 시작 합니다. 검색 방법의 수와 같은 <xref:System.String.IndexOf%2A> 및 <xref:System.String.LastIndexOf%2A>, 문자의 인덱스를 반환 하거나 문자열 인스턴스에서 문자열입니다.  
  
 합니다 <xref:System.String.Chars%2A> 속성에 액세스할 수 있게 개별 <xref:System.Char> 문자열의 인덱스 위치에 의해 개체입니다. 때문에 합니다 <xref:System.String.Chars%2A> 속성이 (Visual Basic)의 기본 속성 또는 인덱서 (C#), 개별에 액세스할 수 있습니다 <xref:System.Char> 다음과 같은 코드를 사용 하 여 문자열에서 개체입니다. 이 코드에서는 공백이 나 문장 부호 문자 문자열이 단어의 개수를 결정 하는 문자열에서 찾습니다.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 때문에 <xref:System.String> 구현 클래스를 <xref:System.Collections.IEnumerable> 인터페이스를 반복할 수 있습니다도 <xref:System.Char> 를 사용 하 여 문자열에서 개체를 `foreach` 다음 예제와 같이 구문.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 연속 되는 인덱스 값 서로 다를 수 연속 유니코드 문자를 유니코드 문자 수 인코딩된 개 이상의 있으므로 <xref:System.Char> 개체입니다. 특히, 문자열에 기본 문자 뒤에 하나 이상의 조합 문자 또는 서로게이트 쌍에 의해 형성 된 텍스트 단위의 여러 문자를 포함할 수 있습니다. 대신 유니코드 문자로 작업 해야 <xref:System.Char> 개체를 사용 합니다 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 및 <xref:System.Globalization.TextElementEnumerator> 클래스입니다. 다음 예제에서는 작동 하는 코드 간의 차이점을 보여 줍니다. <xref:System.Char> 개체 및 유니코드 문자를 사용 하 여 작동 하는 코드입니다. 문자 또는 문장의 각 단어의 텍스트 요소 수를 비교합니다. 문자열 기본 문자와 조합 문자 뒤에 두 개의 시퀀스를 포함 합니다.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 이 예제를 사용 하 여 텍스트 요소를 사용 하 여 작동 합니다 <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> 메서드 및 <xref:System.Globalization.TextElementEnumerator> 문자열의 모든 텍스트 요소를 열거 하는 클래스입니다. 호출 하 여 각 텍스트 요소의 시작 하는 인덱스를 포함 하는 배열을 검색할 수도 있습니다는 <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> 메서드.  
  
 개별이 아닌 텍스트의 단위를 사용 하는 방법에 대 한 자세한 내용은 <xref:System.Char> 값, 참조는 <xref:System.Globalization.StringInfo> 클래스입니다.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Null 문자열 및 빈 문자열  
 선언 되었지만 값 할당 되지 않았습니다 하는 문자열은 `null`합니다. 문자열에서 메서드를 호출 하는 동안 throw 된 <xref:System.NullReferenceException>합니다. Null 문자열을 문자열 값이 빈 문자열인 경우와 다릅니다. "" 또는 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 일부 경우에는 예외를 throw 메서드 호출에서 인수로 null 문자열 또는 빈 문자열을 전달 합니다. 예를 들어, null 문자열을 전달 합니다 <xref:System.Int32.Parse%2A?displayProperty=nameWithType> 메서드가 throw를 <xref:System.ArgumentNullException>, throw 빈 문자열을 전달 하는 <xref:System.FormatException>합니다. 다른 경우에는 null 문자열 또는 빈 문자열 메서드 인수 수 있습니다. 예를 들어, 제공 하는 경우는 <xref:System.IFormattable> 일반 ("G") 서식 지정자를 사용 하 여 null 문자열 및 빈 문자열을 모두 같게 하려는 클래스의 구현입니다.  
  
 합니다 <xref:System.String> 문자열 인지 여부를 테스트할 수 있도록 하는 다음 두 가지 편의 메서드를 포함 하는 클래스 `null` 또는 빈:  
  
-   <xref:System.String.IsNullOrEmpty%2A>를 문자열 중 하나 인지를 나타내는 `null` 와 같은지를 <xref:System.String.Empty?displayProperty=nameWithType>입니다. 이 메서드는 다음과 같은 코드를 사용할 필요를 제거 합니다.  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>를 문자열 인지 여부를 나타내는 `null`, 같음 <xref:System.String.Empty?displayProperty=nameWithType>, 모두 공백 문자로 구성 되어 또는 합니다. 이 메서드는 다음과 같은 코드를 사용할 필요를 제거 합니다.  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 다음 예제에서는 합니다 <xref:System.String.IsNullOrEmpty%2A> 의 메서드를 <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> 사용자 지정 구현의 `Temperature` 클래스입니다. 메서드는 "G", "C", "F" 및 "K" 형식 문자열을 지원합니다. 형식 문자열이 비어 또는 형식 문자열 값인 경우 `null` 전달 되는 메서드를 "G" 형식 문자열에 해당 값을 변경 합니다.  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>불변성 및 StringBuilder 클래스  
 <xref:System.String> 개체를 변경할 수 없는 호출 (읽기 전용)를 만든 후 값을 수정할 수 없습니다. 수정 하는 메서드를 <xref:System.String> 개체는 실제로 새 반환 <xref:System.String> 수정을 포함 하는 개체입니다.  
  
 문자열을 변경할 수 없기 때문에 추가 또는 단일 문자열에는 성능이 크게 저하 정확한 수를 표시 하는 삭제를 수행 하는 문자열 조작 루틴 반복 합니다. 예를 들어, 다음 코드는 1000 ~ 0x052F 0x0001 범위의 문자를 사용 하 여 문자열을 만들려면 난수 생성기를 사용 합니다. 문자열 연결 이라는 기존 문자열에 새 문자를 추가 하는 데 코드 보이지만 `str`를 실제로 만드는 새 <xref:System.String> 각 연결 작업에 대 한 개체입니다.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 사용할 수는 <xref:System.Text.StringBuilder> 대신 클래스는 <xref:System.String> 문자열의 값에 대 한 여러 변경 하는 작업에 대 한 클래스입니다. 인스턴스와 달리 합니다 <xref:System.String> 클래스 <xref:System.Text.StringBuilder> 개체는 변경할 수, 연결, 추가 또는 문자열에서 부분 문자열을 삭제 작업을 단일 문자열에 대해 수행 됩니다. 값을 수정 했으면 하는 경우는 <xref:System.Text.StringBuilder> 개체를 호출할 수 있습니다 해당 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 를 문자열로 변환 하는 방법입니다. 다음 예제에서는 대체 합니다 <xref:System.String> 0x052F 0x0001로 범위에서 임의의 문자 1000을 연결 하려면 이전 예제에서 사용을 <xref:System.Text.StringBuilder> 개체입니다.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>문화권 구분 작업 및 서 수  
 멤버는 <xref:System.String> 서 수 또는 문화권 (언어) 작업을 수행 하는 클래스를 <xref:System.String> 개체입니다. 각각의 숫자 값에는 서 수이 연산은 <xref:System.Char> 개체입니다. 값에 문화권 구분 작업을 수행 합니다 <xref:System.String> 개체 및는 문화권별 대/소문자 구분, 정렬, 형식 및 계정에 규칙을 구문 분석 합니다. 문화권 구분 작업을 명시적으로 선언 된 문화권 이나 암시적 현재 문화권의 컨텍스트에서 실행합니다. 동일한 문자열에 수행 하는 경우 두 종류의 작업에서 매우 다른 결과 생성할 수 있습니다.  
  
.NET 고정 문화권을 사용 하 여 문화권을 구분 하지 않는 언어적 문자열 작업도 지원 (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), 영어 영역의 독립의 culture 설정을 기준으로 하는 느슨하게 합니다. 달리 <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> 설정, 고정 문화권의 설정 시스템에.net 버전 간에 시스템에서 단일 컴퓨터에서 일관성을 유지 하도록 보장 합니다. 고정 문화권은 대기 모든 문화권에서 문자열 비교의 안정성을 보장 하는 블랙 박스 형태의 표시 및 순서 지정 수 있습니다.  
  
> [!IMPORTANT]
>  응용 프로그램 파일 이름과 같은 기호 식별자에 대 한 보안 결정을 내리는 또는 명명 된 파이프 하는 경우, XML 파일에 텍스트 기반 데이터와 같은 지속형된 데이터에 대 한 작업 대신 문화권 구분 비교는 서 수 비교를 사용 해야 합니다. 서 수 비교를 문자를 비교의 이진 값에 따라서만 달라 집니다 하지만 문화권 구분 비교를 문화권에 따라 다른 결과 실제로 생성 수 때문입니다.  
  
> [!IMPORTANT]
>  형식의 매개 변수가 있는 오버 로드를 포함 하는 문자열 작업을 수행 하는 대부분의 메서드가 <xref:System.StringComparison>, 메서드는 서 수 또는 문화권 구분 작업을 수행 하는지 여부를 지정할 수 있습니다. 일반적으로 지우기 호출 메서드의 의도 확인 합니다.이 오버 로드를 호출 해야 합니다. 모범 사례 및 문자열의 서 수 및 문화권 구분 작업을 사용 하기 위한 지침을 참조 하세요 [를 사용 하 여 문자열에 대 한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)합니다.  
  
 에 대 한 작업 [대/소문자 구분](#casing)를 [구문 분석 및 서식 지정](#parsing)를 [비교 및 정렬](#comparison), 및 [같은지 테스트](#equality) 수 두 서 수 또는 문화권을 구분 합니다. 다음 섹션에서는 각 범주의 작업을 설명합니다.  
  
> [!TIP]
>  지우기 호출 메서드의 의도 메서드 오버 로드를 호출 해야 합니다. 호출 하는 대신에 예를 들어, 합니다 <xref:System.String.Compare%28System.String%2CSystem.String%29> 현재 문화권의 규칙을 사용 하 여 두 문자열의 문화권 구분 비교를 수행 하는 방법 호출 해야 합니다 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 값을 사용 하 여 메서드 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> 에 대 한는 `comparisonType` 인수입니다. 자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.  

Windows 운영 체제에 대한 정렬 및 비교 작업에 사용되는 문자 가중치에 대한 정보를 포함하는 텍스트 파일의 집합, [가중치 테이블 정렬](https://www.microsoft.com/en-us/download/details.aspx?id=10921) 및 Linux 및 macOS의 정렬 가중치 테이블 [기본 유니코드 데이터 정렬 요소 테이블](https://www.unicode.org/Public/UCA/latest/allkeys.txt)을 다운로드할 수 있습니다.

<a name="casing"></a>   
### <a name="casing"></a>대/소문자 구분  
 대/소문자 규칙 확인 된 유니코드 문자의 대/소문자를 변경 하는 방법 예를 들어 대문자 소문자입니다. 종종 작업을 대/소문자 구분 문자열 비교 전에 수행 됩니다. 예를 들어, 다른 대문자 문자열을 사용 하 여 비교할 수 있도록 하는 문자열을 대문자로 변환 될 수 있습니다. 호출 하 여 소문자로 문자열의 문자를 변환할 수 있습니다는 <xref:System.String.ToLower%2A> 나 <xref:System.String.ToLowerInvariant%2A> 메서드를 호출 하 여 대문자로으로 변환할 수는 <xref:System.String.ToUpper%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드. 또한 사용할 수 있습니다는 <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> 문자열 첫 글자를 대문자로 변환 하는 방법입니다.  
  
 대/소문자 구분 작업은 현재 문화권, 지정된 된 문화권 이나 고정 문화권의 규칙에 기반 할 수 있습니다. 대/소문자 매핑 사용 하는 문화권에 따라 달라질 수 있으므로 대/소문자 구분 작업의 결과 문화권에 따라 달라질 수 있습니다. 실제 대/소문자 차이 세 가지 종류입니다.  
  
-   LATIN CAPITAL LETTER I의 대/소문자 매핑에의 차이점 (U + 0049), 라틴 문자 작은 문자 I (라는)를 LATIN CAPITAL LETTER I (U + 0130), 위에서 점 및 라틴 작은 문자 점 없는 I를 사용 하 여 (U + 0131). TR-TR (터키어 (터키)) 및 Latn-AZ-AZ (아제르바이잔, 라틴 문자) 문화권 및 tr, az, az Latn 중립 문화권에 해당 하는 라틴어 대문자 I의 소문자 라틴어 작은 문자 점 없는 I, 이며 라틴어 작은 문자 I의 대문자에 해당 라틴어 대문자 I 점 위를 사용 하 여 합니다. 다른 모든 문화권에서 라틴 문자 작은 문자 I 및 LATIN CAPITAL LETTER 필자는 대 / 소문자 해당 하는 고정 문화권을 포함 합니다.  
  
     다음 예제에서는 어떻게 설계 하는 문자열 비교를 파일 시스템 액세스를 방지 하기 위해는 대/소문자 문화권 구분 비교를 사용 하는 경우 실패할 수 있습니다. (고정 문화권의 대/소문자 규칙을 사용 합니다.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   대/소문자 매핑 고정 문화권 및 다른 모든 문화권 간의 차이점입니다. 이러한 경우 고정 문화권의 대/소문자 규칙을 사용 하 여 문자를 대문자 또는 소문자를 변경 하려면 같은 문자를 반환 합니다. 다른 모든 문화권에 다른 문자를 반환합니다. 일부 영향을 받는 문자는 다음 표에 나열 됩니다.  
  
    |문자|로 변경 하는 경우|반환 값|  
    |---------------|-------------------|-------------|  
    |미크론 기호 (U + 00B5)|대문자|그리스어 대문자 MU (U +-39 C)|  
    |라틴어 대문자 I 점이 (U + 0130) 위에|소문자|작은 라틴 문자 I (라는)|  
    |라틴어 소문자 점 없는 I (U + 0131)|대문자|라틴어 대문자 I (U + 0049)|  
    |영문 소문자 긴 S (U + 017F)|대문자|라틴어 대문자 S (U + 0053)|  
    |파이프 기호 있는 작은 문자 Z로 영문 대문자 D (U + 01C 5)|소문자|파이프 기호 있는 DZ 영문 소문자 (U + 01C 6)|  
    |그리스어 YPOGEGRAMMENI 결합 (U + 0345)|대문자|그리스어 대문자 IOTA (U + 0399)|  
  
-   ASCII 문자 범위에서 두 문자의 소문자가 혼합 쌍의 대/소문자 매핑 차이입니다. 대부분의 문화권에서 두 문자의 소문자가 혼합 쌍은 해당 두 문자의 대문자 또는 소문자 쌍과 같습니다. 이 아니므로 다음 문화에 다음 두 문자 쌍에 대 한 true 각각의 경우에서에 digraph 비교 됩니다.  
  
    -   "lJ" 및 "nJ" HR-HR (크로아티아어 (크로아티아)) 문화권에 있습니다.  
  
    -   "cH" sk-SK (슬로바키아어 (슬로바키아)) 문화권에 CS-CZ (체코어 (체코 공화국)).  
  
    -   "aA" DA-DK (덴마크어 (덴마크)) 문화권에서.  
  
    -   "cS", "dZ", "dZS", "nY", "sZ", "tY" 및 "zS" HU-HU (헝가리어 (헝가리)) 문화권에서  
  
    -   "cH" 및 "lL" es-es_tradnl (스페인어 (스페인, 전통 정렬)) 문화권에서.  
  
    -   "cH", "gI", "kH", "nG" "nH", "pH", "qU',"tH"및"tR"vi-VN (베트남어 (베트남)) 문화권에서.  
  
     그러나 이러한 쌍 고정된 문자열 또는 식별자에서 일반적으로 없기 때문에 이러한 쌍의 문화권 구분 비교를 만드는 문제의 상황이 발생 하는 데 평소 아닙니다.  
  
 다음 예제에서는 대/소문자 규칙의 문화권 문자열을 대문자로 변환 하는 경우 간의 차이점 중 일부를 보여 줍니다.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>구문 분석 및 서식 지정  
 서식 지정 및 구문 분석은 역 작업입니다. 서식 설정 규칙 구문 분석 규칙에는 날짜 및 시간과 같은 값으로 문자열 표현을 변환 하는 방법을 결정 하는 반면 같은 날짜 및 시간 또는 숫자 값을 문자열 표현으로 변환 하는 방법을 결정 합니다. 서식 지정 및 구문 분석 규칙에는 문화권 규칙에 따라 다릅니다. 다음 예에서는 culture 별 날짜 문자열을 해석할 때 발생할 수 있는 모호성을 보여 줍니다. 날짜 문자열을 생성 하는 데 사용 된 문화권의 규칙을 알고 있으면 없이 불가능 2011 년 03 월 01, 2011 년 3 월 1/및 2011/01/03 2011 년 1 월 3 일 또는 2011 년 3 월 1 표현 하는지 여부를 알아야 합니다.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 마찬가지로, 다음 예제와 같이 단일 문자열을 구문 분석 작업에서 규칙이 포함 되는 문화권에 따라 서로 다른 날짜를 생성할 수 있습니다.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>문자열 비교 및 정렬  
 문자열 정렬 및 비교에 대 한 규칙에는 문화권 달라 집니다. 예를 들어, 정렬 순서 음성 또는 문자의 시각적 표현을 기반 수 있습니다. 동아시아 언어에서는 표의 문자의 부수와 획에 따라 문자가 정렬됩니다. 언어와 문화권이 알파벳에 사용하는 순서에 따라 정렬 순서가 달라지기도 합니다. 예를 들어 덴마크어 알파벳의 "Æ" 문자는 "Z" 다음에 옵니다. 또한 대/소문자 구분 또는 대/소문자를 비교 될 수 있습니다 및 일부 경우에서 대/소문자 규칙에 따라서도 문화권입니다. 반면에 서 수 비교를 비교 하 고 문자열을 정렬 하는 경우 문자열에서 개별 문자의 유니코드 코드 포인트를 사용 합니다.  
  
 정렬 규칙을 서로 비교 하는 알파벳이 유니코드 문자 순서와 두 문자열을 결정 합니다. 예를 들어 합니다 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> 기반으로 하는 두 문자열을 비교 하는 메서드는 <xref:System.StringComparison> 매개 변수입니다. 매개 변수 값이 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, 메서드 매개 변수 값이 현재 문화권의 규칙을 사용 하는 언어 비교를 수행 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, 메서드는 서 수 비교를 수행 합니다. 따라서 다음 예와 같이, 현재 문화권이 미국 영어, 첫 번째 호출은 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> 메서드 (문화권 구분 비교 사용) "A", "a" 작음 되었지만 두 번째 호출 (서 수 비교 사용) 같은 방법으로 간주 "a" "A" 보다 큰 합니다.  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET에서는 단어, 문자열 및 서 수 정렬 규칙을 지원합니다.  
  
-   단어 정렬 특정 영숫자가 아닌 유니코드 문자에 특별 한 가중치가 할당 해야 할 수 있는 문자열의 문화권 구분 비교를 수행 합니다. 예를 들어, 하이픈 (-)는 매우 작은 가중치가 할당 "coop" 및 "co-op" 정렬된 된 목록에 나란히 표시 되도록 있을 수 있습니다. 목록은 <xref:System.String> 단어 정렬 규칙을 사용 하 여 두 문자열을 비교 하는 메서드를 참조 합니다 [범주별 문자열 작업](#ByCategory) 섹션입니다.  
  
-   또한 문자열 정렬 문화권 구분 비교를 수행합니다. 이 특수 한 사례가 없습니다, 모든 영숫자 유니코드 문자를 앞으로 모든 영숫자가 아닌 기호가 있다는 점을 제외 하면에 단어 정렬 비슷합니다. 문자열 정렬 규칙을 사용 하 여 호출 하 여 두 문자열을 비교할 수는 <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> 메서드 오버 로드의 경우는 `options` 의 값이 제공 되는 매개 변수가 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>합니다. 이.NET 문자열 정렬 규칙을 사용 하 여 두 문자열을 비교를 제공 하는 유일한 방법은 note 합니다.  
  
-   각각의 숫자 값을 기반으로 하는 문자열을 비교 하는 서 수 정렬 <xref:System.Char> 문자열에는 개체입니다. 서 수 비교는 대 / 소문자 버전의 문자는 점이 다른 코드 때문에 자동으로 대/소문자 구분입니다. 그러나 대/소문자는 중요 하지 않습니다, 경우에 대/소문자를 구분 하지 않는 서 수 비교를 지정할 수 있습니다. 문자열을 고정 문화권을 사용 하 고 다음 결과에 서 수 비교를 수행 하 여 대문자로 변환 하는 것과 같습니다. 목록은 <xref:System.String> 서 수 정렬 규칙을 사용 하 여 두 문자열을 비교 하는 메서드를 참조 합니다 [범주별 문자열 작업](#ByCategory) 섹션입니다.  
  
 문화권 구분 비교는 명시적 또는 암시적으로 사용 하는 모든 비교는 <xref:System.Globalization.CultureInfo> 에 지정 된 고정 문화권을 포함 하 여 개체를 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 속성. 암시적 문화권은 현재 문화권으로 지정 되는 <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> 고 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 속성입니다. 영문자의 정렬 순서에서 상당한 변화는 (는 문자, 합니다 <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> 속성이 반환 `true`) 문화권에 걸쳐 합니다. 제공 하 여 특정 문화권의 규칙을 사용 하는 문화권 구분 비교를 지정할 수 있습니다는 <xref:System.Globalization.CultureInfo> 와 같은 개체는 문자열 비교 메서드를 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>입니다. 제공 하 여 현재 문화권의 규칙을 사용 하는 문화권 구분 비교를 지정할 수 있습니다 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, 또는의 모든 멤버는 <xref:System.Globalization.CompareOptions> 이외의 열거형 <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> 또는 <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 를 적절 한 오버 로드는 <xref:System.String.Compare%2A> 메서드. 문화권 구분 비교는 서 수 비교 하는 반면 정렬에 대 한 일반적으로 적합 합니다. 서 수 비교는 두 문자열이 같은지 여부를 결정 하는 데 일반적으로 적절 한 (즉, id 확인에 대 한) 문화권 구분 비교는 없습니다.  
  
 다음 예제에서는 문화권 구분 및 서 수 비교 간의 차이점을 보여 줍니다. 이 예제에서는 세 문자열, "Apple", "æ b l e" 및 "AEble", 서 수 비교 및 DA-DK 및 EN-US 문화권의 규칙을 사용 하 여 평가 (시 기본 문화권은 각각는 <xref:System.String.Compare%2A> 메서드는). 덴마크어 "→" 문자는 개별 문자를 처리 하 고 문자에서 "Z" 뒤에 정렬 하기 때문에 문자열 "æ b l e"는 "Apple" 보다 큽니다. 그러나 "æ b l e" 간주 되지 않습니다 "AEble" 같음 "æ b l e"를 "AEble" 보다 큰 이기도 하므로. EN-US 문화권 "→" 문자를 포함 하지 않습니다 하지만 동일한 "AE" 이유 "æ b l e"는 "Apple" 보다 작지만 "AEble" 같은 설명 하는 것으로 처리 합니다. 서 수 비교는 반면에 "Apple" "AEble" 보다 큰 값으로 "æ b l e" 및 "æ b l e" 보다 작아야를 고려 합니다.  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 적절 한 정렬 또는 문자열 비교 방법을 선택 하려면 다음 일반 지침을 사용 합니다.  
  
-   문자열을 정렬할 수를 지정 하지 않고 사용자의 문화권을 기반으로 하려는 경우 현재 문화권의 규칙을 기반으로 주문할 해야 있습니다. 사용자의 문화권 변경 되 면 정렬 된 문자열의 순서도 그에 따라 변경 됩니다. 예를 들어 동의어 사전 응용 프로그램을 사용자의 문화권을 기준으로 단어를 항상 정렬 해야 합니다.  
  
-   문자열을 정렬할 수를 지정 하지 않고 특정 문화권의 규칙에 따라 하려는 경우 제공에 따라 정렬 해야 하는 <xref:System.Globalization.CultureInfo> 비교 메서드에 해당 문화권을 나타내는 개체입니다. 예를 들어, 학생에 게 특정 언어를 설명 하도록 응용 프로그램에서 원하는 문자열을 정렬할 익히면 해당 하는 문화권 중 하나로의 규칙에 따라 합니다.  
  
-   문화권에 걸쳐 그대로 문자열의 순서를 하려는 경우에 고정 문화권의 규칙을 기준으로 정렬 하거나 서 수 비교를 사용 해야 합니다. 예를 들어, 파일, 프로세스, 뮤텍스 이름을 구성 하는 서 수 정렬 사용 또는 명명 된 파이프 합니다.  
  
-   보안 의사 결정 (예: 사용자가 유효한 지 여부)를 포함 하는 비교를 항상 수행 해야 같음에 대 한 서 수는 테스트의 오버 로드를 호출 하 여는 <xref:System.String.Equals%2A> 메서드.  
  
> [!NOTE]
>  문화권 구분 정렬 및 문자열 비교에 사용 되는 규칙을 대/소문자 버전의.NET에 따라 달라 집니다. 이상 버전에서 실행 되 고.NET Framework 4.5는 [!INCLUDE[win8](~/includes/win8-md.md)] 유니코드 6.0 표준을 따르는 운영 체제, 정렬, 대/소문자 구분, 정규화 및 유니코드 문자 정보입니다. 다른 Windows 운영 체제에서 표준 유니코드 5.0에 맞습니다. .NET Core에서 기본 운영 체제에서 지원 되는 유니코드 표준의 버전에 따라 다릅니다. 
  
 Word, 문자열 및 서 수 정렬 규칙에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 항목입니다. 각 규칙을 사용 하는 경우에 추가 권장 사항을 참조 하세요 [를 사용 하 여 문자열에 대 한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)합니다.  
  
 일반적으로 호출 하지 않으면 문자열 비교와 같은 메서드와 <xref:System.String.Compare%2A> 문자열의 정렬 순서를 결정 하려면 직접. 와 같은 메서드를 정렬 하 여 비교 메서드는 호출 하는 대신 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 또는 <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>합니다. 다음 예제에서는 명시적으로 문자열 비교 메서드를 호출 하지 않고 네 가지 정렬 작업 (현재 문화권, 고정 문화권을 사용 하 여 단어 정렬, 서 수 정렬 및 고정 문화권을 사용 하 여 문자열 정렬을 사용 하 여 단어 정렬) 수행 사용할 비교 형식을 지정지 않습니다 하지만. 각 유형의 정렬 배열에서 문자열의 고유한 순서를 생성 하는 참고 합니다.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  내부적으로.NET 정렬 키를 사용 하 여 문화권 구분 문자열 비교를 지원 합니다. 문자열의 각 문자에는 사전순, 대/소문자 및 분음 부호를 포함하여 여러 범주의 정렬 가중치가 적용됩니다. 정렬 키를 나타내는 <xref:System.Globalization.SortKey> 클래스, 특정 문자열에 대 한 이러한 가중치의 리포지토리를 제공 합니다. 앱을 많은 수의 검색 또는 정렬 문자열의 동일한 집합에 대 한 작업을 수행 하는 경우 생성 하 고 사용 되는 모든 문자열에 대 한 정렬 키를 저장 하 여 성능을 개선할 수 있습니다. 정렬 또는 비교 작업이 필요한 경우에 문자열 대신 정렬 키를 사용 합니다. 자세한 내용은 <xref:System.Globalization.SortKey> 클래스를 참조하세요.  
  
 문자열 비교 규칙을 지정 하지 않으면, 메서드 같은 정렬 <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> 문자열에서 문화권 구분 및 대/소문자 구분 정렬을 수행 합니다. 다음 예제에서는 배열에서 정렬 된 문자열의 순서에 미치는 현재 문화권을 변경 하는 방법을 보여 줍니다. 세 문자열의 배열을 만듭니다. 우선 `System.Threading.Thread.CurrentThread.CurrentCulture` 속성을 "en-US"로 설정하고 <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> 메서드를 호출합니다. 결과 정렬 순서는 정렬 규칙 영어 (미국) 문화권을 기반으로 합니다. 다음으로 예제에서는 `System.Threading.Thread.CurrentThread.CurrentCulture` 속성을 da-DK로 설정하고 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 메서드를 다시 호출합니다. 덴마크어(덴마크)의 정렬 규칙을 사용하는 경우 결과 정렬 순서가 en-US 결과와 어떻게 다른지 확인해 봅니다.  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  기본 문자열 비교의 목적이 호출 해야 해당 값이 같은지 여부를 결정 하는 경우는 <xref:System.String.Equals%2A?displayProperty=nameWithType> 메서드. 일반적으로 사용 해야 <xref:System.String.Equals%2A> 는 서 수 비교를 수행 합니다. <xref:System.String.Compare%2A?displayProperty=nameWithType> 메서드가 기본적으로 문자열을 정렬 하기에 적합 합니다.  
  
 와 같은 문자열 검색 메서드를 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 고 <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, 또한 문화권 구분 또는 서 수 문자열 비교를 수행할 수 있습니다. 다음 예제에서는 서 수 및 문화권 구분 비교를 사용 하 여 차이 보여 줍니다.는 <xref:System.String.IndexOf%2A> 메서드. 현재 문화권의 영어 (미국) 문화권 구분 검색을 부분 문자열 "oe" 합자 "œ"와 일치 하도록 고려 합니다. 검색에서 동등 하 게 사용자 지정 하이픈을 처리 하는 하이픈이 (U + 00AD)는 너비가 0 인 문자 이므로 <xref:System.String.Empty> 문자열의 시작 부분에서 일치 하는 항목을 찾습니다. 서 수 검색, 다른 한편으로 찾지 일치 하는 두 경우 모두.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>문자열 검색  
 와 같은 문자열 검색 메서드를 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 및 <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, 또한 문화권별으로 수행할 수 있습니다 또는 지정된 된 문자열의 서 수 문자열 비교 문자나 부분 문자열을 여부를 확인 하려면가 있습니다.  
  
 에 검색 메서드는 <xref:System.String> 와 같은 개별 문자를 검색 하는 클래스를 <xref:System.String.IndexOf%2A> 메서드 또는 문자 집합 중 하나 같은 <xref:System.String.IndexOfAny%2A> 메서드를 모든 서 수 검색을 수행 합니다. 호출 된 문자에 대 한 문화권 구분 검색을 수행 해야 합니다는 <xref:System.Globalization.CompareInfo> 메서드와 같은 <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> 또는 <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>합니다. 참고 서 수 및 문화권 구분 비교를 사용 하 여 문자에 대 한 검색 결과 매우 달라질 수 있습니다. 예를 들어 합자 "→"와 같은 미리 구성 된 유니코드 문자에 대 한 검색 (U + 00 C 6) 수 찾습니다 모든 "AE"와 같은 올바른 순서로 구성 요소 (U + 041U + 0045) 문화권에 따라 합니다. 다음 예제에서는 차이점을 보여 줍니다.는 <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> 고 <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> 개별 문자를 검색할 때 메서드. 합자 "→" (U + 00E6)가 문자열에 "항공" EN-US 문화권의 규칙을 사용 하는 경우 있지만 DA-DK 문화권의 규칙을 사용 하 여 때가 아니라 또는 서 수 비교를 수행 하는 경우.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 다른 한편 <xref:System.String> 검색할 문자가 아니라 문자열 검색 옵션 형식의 매개 변수를 통해 명시적으로 지정 되지 않은 경우 문화권 구분 검색을 수행 하는 메서드를 클래스 <xref:System.StringComparison>합니다. 한 가지 예외는 <xref:System.String.Contains%2A>, 서 수 검색을 수행 합니다.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>같음에 대 한 테스트  
 사용 된 <xref:System.String.Compare%2A?displayProperty=nameWithType> 정렬 순서에서 두 문자열의 관계를 결정 하는 방법입니다. 일반적으로 문화권 구분 작업입니다. 반면, 호출 된 <xref:System.String.Equals%2A?displayProperty=nameWithType> 같은지 테스트 하는 방법입니다. 같음 테스트는 일반적으로 파일 시스템 경로 올바른 사용자 이름, 암호 등의 몇 가지 알려진된 문자열을 사용 하 여 사용자 입력을 비교 하기 때문에 일반적으로 서 수에 연산입니다.  
  
> [!WARNING]
>  호출 하 여 같은지 테스트 하는 것이 불가능 합니다 <xref:System.String.Compare%2A?displayProperty=nameWithType> 메서드와 반환 값이 0 인지 여부를 결정 합니다. 그러나이 방법은 권장 되지 않습니다. 두 문자열이 같은지를 확인 하려면 호출 해야 오버 로드 중 하나는 <xref:System.String.Equals%2A?displayProperty=nameWithType> 메서드. 기본 오버 로드를 호출 되는 인스턴스 <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> 메서드 또는 정적 <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드를 두 방법 모두 포함 되므로 <xref:System.StringComparison?displayProperty=nameWithType> 비교의 형식을 명시적으로 지정 하는 매개 변수입니다.  
  
 다음 예제에서는 같음 경우 하나를 대신 사용 해야 하는 서 수에 대 한 문화권 구분 비교를 수행 하는 위험을 보여 줍니다. 이 경우 코드의 의도 "FILE://" 문자열을 사용 하 여 URL 부분에 대 한 대/소문자 구분 비교를 수행 하 여 "FILE://" 또는 "file://"로 시작 하는 Url에서 파일 시스템 액세스를 금지 하는 것입니다. 그러나 터키어 (터키) 문화권 "file://"로 시작 하는 URL에서 사용 하 여 문화권 구분 비교를 수행 하는 경우 같음 비교가 실패할 Turkish 대문자 소문자 "i"은 "i" 대신 "I" 합니다. 결과적으로, 파일 시스템 액세스 실수로 허용 됩니다. 반면에 서 수 비교를 수행 하는 경우 같음 비교가 성공 하 고 파일 시스템 액세스가 거부 됩니다.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>표준화  
 일부 유니코드 문자에 여러 표현이 있습니다. 예를 들어, 다음 코드 지점 중 하나는 문자 "ắ"을 나타낼 수 있습니다.  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 단일 문자에 대 한 여러 표현을 검색, 정렬, 일치 및 기타 작업이 복잡해 집니다.  
  
 유니코드 표준 라는 해당 하는 이진 표현에 대 한 유니코드 문자에 대 한 이진 표현을 반환 하는 정규화 프로세스를 정의 합니다. 정규화에는 다양 한 규칙을 따르는 정규화 형식 이라는 다양 한 알고리즘을 사용 합니다. .NET에는 유니코드 정규화 형식 C, D, KC 및 KD 지원합니다. 문자열 같은 정규화로 표준화 되었으므로, 경우 서 수 비교를 사용 하 여 비교할 수 있습니다.  
  
 서 수 비교는 해당 유니코드 스칼라 값에 대 한 이진 비교 <xref:System.Char> 각 문자열에서 개체입니다. <xref:System.String> 클래스는 다양 한 다음을 비롯 한 서 수 비교를 수행할 수 있는 메서드를 포함 합니다.  
  
-   오버 로드는 <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, 및 <xref:System.String.LastIndexOf%2A> 포함 하는 메서드를 <xref:System.StringComparison> 매개 변수입니다. 값을 제공 하는 경우 메서드는 서 수 비교를 수행 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 또는 <xref:System.StringComparison.OrdinalIgnoreCase> 이 매개 변수에 대 한 합니다.  
  
-   오버 로드는 <xref:System.String.CompareOrdinal%2A> 메서드.  
  
-   기본적으로 같은 서 수 비교를 사용 하는 방법 <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, 및 <xref:System.String.Split%2A>합니다.  
  
-   검색 하는 메서드를 <xref:System.Char> 값 또는 요소에 대 한는 <xref:System.Char> 문자열 인스턴스의 배열입니다. 이러한 메서드를 포함 <xref:System.String.IndexOf%28System.Char%29> 고 <xref:System.String.Split%28System.Char%5B%5D%29>입니다.  
  
 호출 하 여 정규화 형식 C 문자열이 정규화 되는지 여부를 확인할 수 있습니다 합니다 <xref:System.String.IsNormalized?displayProperty=nameWithType> 하거나 메서드를 호출할 수는 <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> 문자열에 지정 된 정규화 형식인 정규화 되는지 여부를 결정 하는 방법입니다. 호출할 수도 있습니다는 <xref:System.String.Normalize?displayProperty=nameWithType> 정규화 형식 C에 문자열을 변환 하는 메서드를 호출할 수는 <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> 지정한 정규화 형식을 문자열로 변환 하는 방법입니다. 정규화 및 문자열 비교에 대 한 단계별 정보를 참조 하세요. 합니다 <xref:System.String.Normalize> 고 <xref:System.String.Normalize%28System.Text.NormalizationForm%29> 메서드.  
  
 다음의 간단한 예제에서는 문자열 정규화를 보여 줍니다. 세 개의 다른 문자열의 세 가지 방법으로 "ố" 문자를 정의 하 고 같음에 대 한 서 수 비교를 사용 하 여 각 문자열에서 다른 두 문자열이 다른 것을 결정 합니다. 그런 다음 지원 되는 정규화 폼, 각 문자열을 변환 하 고 다시 지정 된 정규화 형식인 각 문자열의 서 수 비교를 수행 합니다. 각각의 경우에서 같음에 대 한 두 번째 테스트에서는 문자열이 같은지를 보여 줍니다.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 정규화 및 정규화 형식에 대 한 자세한 내용은 참조 하세요. <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, 뿐만 [Unicode Standard Annex #15: Unicode Normalization Forms](https://unicode.org/reports/tr15/) 하며 [정규화 FAQ](https://www.unicode.org/faq/normalization.html) 에 unicode.org 웹 사이트입니다.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>범주별 문자열 작업  
 합니다 <xref:System.String> 클래스는 같음, 문자 또는 형식을 지정 하는 문자열을 복사 하는 값을 문자열을 결합 하는 문자열에서 부분 문자열을 추출 하는 문자열을 수정 하는 문자열의 부분 문자열 찾기에 대 한 문자열을 테스트 하는 문자열 비교에 대 한 멤버를 제공 하 고 문자열을 정규화 합니다.  
  
### <a name="comparing-strings"></a>문자열 비교  
 다음을 사용 하 여 정렬 순서에서 상대 위치를 결정 하는 문자열을 비교할 수 있습니다 <xref:System.String> 메서드:  
  
-   <xref:System.String.Compare%2A> 정렬 순서에서 두 번째 문자열을 하나의 문자열로의 관계를 나타내는 정수를 반환 합니다.  
  
-   <xref:System.String.CompareOrdinal%2A> 두 번째 문자열의 코드 포인트 비교를 기반으로 하는 문자열 하나의 관계를 나타내는 정수를 반환 합니다.  
  
-   <xref:System.String.CompareTo%2A> 정렬 순서에서 두 번째 문자열에는 현재 문자열 인스턴스가의 관계를 나타내는 정수를 반환 합니다. <xref:System.String.CompareTo%28System.String%29> 메서드를 제공 합니다 <xref:System.IComparable> 및 <xref:System.IComparable%601> 에 대 한 구현을 <xref:System.String> 클래스입니다.  
  
### <a name="testing-strings-for-equality"></a>문자열이 같은지를 테스트합니다.  
 호출 하 여 <xref:System.String.Equals%2A> 두 문자열이 같은지 여부를 확인 하는 방법입니다. 인스턴스 <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> 및 정적 <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> 오버 로드를 통해 문화권 구분 또는 서 수 비교 인지 및 대/소문자가 고려 되거나 무시 하는지 여부를 지정 합니다. 같음에 대 한 대부분의 테스트는 서 수 및 시스템 리소스 (예: 파일 시스템 개체)에 대 한 액세스를 결정 하는 같음 비교 항상 서 수 여야 합니다.  
  
### <a name="finding-characters-in-a-string"></a>문자열의 문자를 찾기  
 <xref:System.String> 클래스는 두 가지 검색 메서드를 포함 합니다.  
  
-   반환 하는 메서드를 <xref:System.Boolean> 문자열 인스턴스에서 특정 하위 문자열이 있는지 여부를 나타내는 값입니다. 여기에 포함 된 <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, 및 <xref:System.String.StartsWith%2A> 메서드.  
  
-   문자열 인스턴스의 하위 문자열의 시작 위치를 나타내는 메서드. 여기에 <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, 및 <xref:System.String.LastIndexOfAny%2A> 메서드.  
  
> [!WARNING]
>  특정 부분 문자열 보다는 특정 패턴에 대 한 문자열을 검색 하려는 경우 정규식을 사용 해야 합니다. 자세한 내용은 [.NET 정규식](~/docs/standard/base-types/regular-expressions.md)합니다.  
  
### <a name="modifying-a-string"></a>문자열을 수정합니다.  
 <xref:System.String> 클래스는 문자열의 값을 수정 하는 다음 메서드를 포함 합니다.  
  
-   <xref:System.String.Insert%2A> 현재 문자열 삽입 <xref:System.String> 인스턴스.  
  
-   <xref:System.String.PadLeft%2A> 문자열의 시작 부분에는 지정 된 문자 하나 이상의 항목을 삽입합니다.  
  
-   <xref:System.String.PadRight%2A> 문자열의 끝에 지정 된 문자의 하나 이상의 항목을 삽입합니다.  
  
-   <xref:System.String.Remove%2A> 부분 문자열을 현재에서 삭제 <xref:System.String> 인스턴스.  
  
-   <xref:System.String.Replace%2A> 현재에서 다른 부분 문자열을 사용 하 여 부분 문자열을 대체 <xref:System.String> 인스턴스.  
  
-   <xref:System.String.ToLower%2A> 및 <xref:System.String.ToLowerInvariant%2A> 문자열의 모든 문자를 소문자로 변환 합니다.  
  
-   <xref:System.String.ToUpper%2A> 및 <xref:System.String.ToUpperInvariant%2A> 문자열의 모든 문자를 대문자로 변환 합니다.  
  
-   <xref:System.String.Trim%2A> 문자열의 시작과 끝에서 모든 문자를 제거합니다.  
  
-   <xref:System.String.TrimEnd%2A> 문자열의 끝에서 모든 문자를 제거합니다.  
  
-   <xref:System.String.TrimStart%2A> 문자열의 시작 부분에서 모든 문자를 제거합니다.  
  
> [!IMPORTANT]
>  모든 문자열 수정 메서드 반환 새 <xref:System.String> 개체입니다. 현재 인스턴스의 값을 수정 하지 마세요.  
  
### <a name="extracting-substrings-from-a-string"></a>문자열에서 부분 문자열을 추출합니다.  
 <xref:System.String.Split%2A?displayProperty=nameWithType> 메서드는 여러 문자열으로 단일 문자열을 구분 합니다. 메서드의 오버 로드를 사용 하면 메서드를 추출 하는 부분 문자열의 최대 수를 확인 하려면 및 빈 문자열 (발생 하는 구분 기호 옆에 있는 경우) 반환 된 문자열 중 포함 되는지 여부를 확인 하려면 여러 개의 구분 기호를 지정할 수 있습니다.  
  
### <a name="combining-strings"></a>결합 문자열  
 다음 <xref:System.String> 문자열 연결에 대 한 메서드를 사용할 수 있습니다.  
  
-   <xref:System.String.Concat%2A> 하나 이상의 부분 문자열을 단일 문자열로 결합합니다.  
  
-   <xref:System.String.Join%2A> 단일 요소에 하나 이상의 부분 문자열을 연결 하 고 각 부분 문자열 사이의 구분 기호를 추가 합니다.  
  
### <a name="formatting-values"></a>값의 서식 지정  
 <xref:System.String.Format%2A?displayProperty=nameWithType> 메서드 복합 서식 지정 기능을 사용 하 여 문자열에서 하나 이상의 자리 표시자 일부 개체 또는 값의 문자열 표현으로 바꿉니다. <xref:System.String.Format%2A> 메서드는 종종 다음을 수행 하는 데 사용 됩니다.  
  
-   문자열에서 숫자 값의 문자열 표현을 포함 합니다.  
  
-   문자열에서 날짜 및 시간 값의 문자열 표현을 포함 합니다.  
  
-   문자열에서 열거형 값의 문자열 표현을 포함 합니다.  
  
-   지 원하는 일부 개체의 문자열 표현을 포함 하는 <xref:System.IFormattable> 문자열에 대 한 인터페이스입니다.  
  
-   오른쪽 맞춤 또는 더 큰 문자열 내에서 필드의 부분 문자열을 왼쪽에 맞춥니다.  
  
 작업 및 예 형식에 대 한 자세한 내용은 참조는 <xref:System.String.Format%2A> 요약 오버 로드 합니다.  
  
### <a name="copying-a-string"></a>문자열 복사  
 다음을 호출할 수 있습니다 <xref:System.String> 문자열의 복사본을 확인 하는 방법.  
  
-   <xref:System.String.Clone%2A> 기존에 대 한 참조를 반환 합니다. <xref:System.String> 개체입니다.  
  
-   <xref:System.String.Copy%2A> 기존 문자열의 복사본을 만듭니다.  
  
-   <xref:System.String.CopyTo%2A> 문자 배열에 있는 문자열 부분을 복사합니다.  
  
### <a name="normalizing-a-string"></a>문자열 정규화  
 유니코드, 단일 문자 코드 포인트를 여러 개 있을 수 있습니다. 정규화 같은 이진 표현으로 이러한 동등한 문자로 변환합니다. 합니다 <xref:System.String.Normalize%2A?displayProperty=nameWithType> 정규화를 수행 하는 메서드 및 <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> 메서드 문자열이 정규화 되는지 여부를 결정 합니다.  
  
 자세한 내용 및 예제에 대 한 참조를 [정규화](#Normalization) 이 항목의 앞부분에 나오는 섹션입니다.  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/en-us/download/details.aspx?id=10921">정렬 가중치 테이블에 대 한 Windows 운영 체제</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">Linux 및 macOS 용 기본 유니코드 데이터 정렬 Elemeent 테이블</related>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">.NET Framework에서 문자열 사용에 대한 유용한 정보</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 섹션 내용  
  
 [오버 로드 된 생성자 구문](#Syntax)   
 [매개 변수](#Params)   
 [예외](#Exceptions)   
 [메서드 호출 합니까?](#Tasks)   
 [문자열 만들기](#Creating_Strings)   
 [반복적인 문자열 처리](#Repetitive)   
 인스턴스화하 문자열의 예:   
 [문자열 할당을 사용 하 여](#Ctor1_Example)  
 [문자 배열을 사용 하 여](#Ctor2_Example)  
 [문자 배열의 일부를 사용 하 고 단일 문자를 반복 합니다.](#Ctor3_Example)  
 [문자 배열에 대 한 포인터를 사용 하 여](#Ctor4_Example)  
 [에 대 한 포인터 및 배열 범위를 사용 하 여](#Ctor5_Example)  
 [부호 있는 바이트 배열에 대 한 포인터를 사용 하 여](#Ctor6_Example)  
[버전 정보](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>오버 로드 된 생성자 구문  
 문자열 생성자 두 가지 범주로 나뉩니다: 포인터 매개 변수 없이 포인터 매개 변수를 사용 합니다. 포인터를 사용 하는 생성자는 CLS 규격이 아닙니다. 또한 Visual Basic 포인터 사용을 지원 하지 않습니다 하 고 C# 코드를 사용 하 여 포인터 안전 하지 않은 컨텍스트에서 실행 해야 합니다. 자세한 내용은 [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md)를 참조하세요.  
  
 오버 로드를 선택 하면 추가 지침을 참조 하세요. [메서드 호출 합니까?](#Tasks)  
  
 `String(Char[] value)`  
 유니코드 문자의 배열에 의해 표시 되는 값의 새 인스턴스를 초기화 합니다. 유니코드 문자를 복사 하는이 생성자 ([예제](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 길이 및 해당 배열 내의 시작 문자 위치를 유니코드 문자 배열에서 나타내는 값으로 새 인스턴스를 초기화 ([예제](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 지정 된 유니코드 문자로 표시 된 값으로 새 인스턴스를 초기화 합니다. 지정된 된 횟수 만큼 반복 ([예제](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(CLS 규격이 아닙니다.)**  Null 문자로 종료 되는 유니코드 문자의 배열에 대 한 포인터가 나타내는 값으로 새 인스턴스를 초기화 (u+0000 또는 '\0'). ([예제](#Ctor4_Example)).  
  
 권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(CLS 규격이 아닙니다.)**  유니코드 문자, 길이 및 해당 배열 내의 시작 문자 위치를 배열에 대 한 포인터가 가리키는 값으로 새 인스턴스를 초기화 합니다. 유니코드 문자를 복사 하는 생성자 `value` 인덱스부터 `startIndex` 인덱스에서 끝나는 `startIndex`  +  `length` – 1 ([예제](#Ctor5_Example)).  
  
 권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.  
  
 `String(SByte* value)`  
 **(CLS 규격이 아닙니다.)**  8 비트 부호 있는 정수 배열에 대 한 포인터가 나타내는 값으로 새 인스턴스를 초기화 합니다. 배열 현재 시스템 코드 페이지를 사용 하 여 인코딩된 문자열을 나타내는 것으로 간주 됩니다 (즉, 지정한 인코딩을 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). 문자를 처리 하는 생성자 `value` null 문자 (0x00)에 도달할 때까지 포인터에 의해 지정 된 위치에서 시작 ([예제](#Ctor6_Example)).  
  
 권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(CLS 규격이 아닙니다.)**  길이 및 해당 배열 내의 시작 위치, 8 비트 부호 있는 정수 배열에 대 한 포인터가 나타내는 값으로 새 인스턴스를 초기화 합니다.  배열 현재 시스템 코드 페이지를 사용 하 여 인코딩된 문자열을 나타내는 것으로 간주 됩니다 (즉, 지정한 인코딩을 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). 시작 하는 값에서 문자를 처리 하는 생성자 `startIndex` 에서 끝나는 `startIndex`  +  `length` – 1 ([예제](#Ctor6_Example)).  
  
 권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(CLS 규격이 아닙니다.)**  길이 해당 배열 내의 시작 위치를 8 비트 부호 있는 정수 배열에 대 한 포인터가 나타내는 값으로 새 인스턴스를 초기화 및 <xref:System.Text.Encoding> 개체입니다.  
  
 권한: <xref:System.Security.SecurityCriticalAttribute>, 직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.  
  
<a name="Params"></a>   
## <a name="parameters"></a>매개 변수  
 사용 하는 매개 변수의 전체 목록은 다음과 같습니다 <xref:System.String> 포인터 매개 변수를 포함 하지 않는 생성자입니다. 각 오버 로드에서 사용 하는 매개 변수를 위의 구문은 오버 로드를 참조 하세요.  
  
|매개 변수|형식|설명|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|유니코드 문자 배열입니다.|  
|`c`|<xref:System.Char>|유니코드 문자입니다.|  
|`startIndex`|<xref:System.Int32>|시작 위치 `value` 새 문자열의 첫 번째 문자입니다.<br /><br /> 기본값: 0|  
|`length`|<xref:System.Int32>|문자 수가 `value` 새 문자열에 포함 합니다.<br /><br /> 기본값: <xref:System.Array.Length%2A?displayProperty=nameWithType> |  
|`count`|<xref:System.Int32>|횟수 문자 `c` 새 문자열에서 반복 됩니다. 하는 경우 `count` 가 0 이면 새 개체의 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.|  
  
 사용 하는 매개 변수의 전체 목록은 다음과 같습니다 <xref:System.String> 포인터 매개 변수를 포함 하는 생성자입니다. 각 오버 로드에서 사용 하는 매개 변수를 위의 구문은 오버 로드를 참조 하세요.  
  
|매개 변수|형식|설명|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> 또는<br /><br /> <xref:System.SByte>\*|유니코드 문자를 null로 끝나는 배열 또는 8 비트 부호 있는 정수 배열에 대 한 포인터입니다. 하는 경우 `value` 됩니다 `null` 이거나 빈 배열이 면 새 문자열의 값이 <xref:System.String.Empty?displayProperty=nameWithType>합니다.|  
|`startIndex`|<xref:System.Int32>|새 문자열에서 첫 번째 문자를 정의 하는 배열 요소의 인덱스입니다.<br /><br /> 기본값: 0|  
|`length`|<xref:System.Int32>|새 문자열을 만드는 데 사용 되는 배열 요소의 수입니다. 길이가 0 인 경우 생성자 값인 문자열을 만듭니다. <xref:System.String.Empty?displayProperty=nameWithType>합니다.<br /><br /> 기본값: <xref:System.Array.Length%2A?displayProperty=nameWithType> |  
|`enc`|<xref:System.Text.Encoding>|지정 하는 개체를 어떻게 `value` 배열 인코딩됩니다.<br /><br /> 기본값: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, 또는 시스템의 현재 ANSI 코드 페이지|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>예외  
 포인터 매개 변수를 포함 하지 않는 생성자에서 throw 된 예외 목록은 다음과 같습니다.  
  
|예외|조건|throw|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value`가 `null`인 경우|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`를`length`, 또는 `count` 가 0 보다 작습니다.<br /><br /> 또는<br /><br /> `startIndex`와 `length`의 합계가 `value`의 요소 수보다 큽니다.<br /><br /> 또는<br /><br /> `count`가 0보다 작은 경우|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 포인터 매개 변수를 포함 하는 생성자에서 throw 된 예외 목록은 다음과 같습니다.  
  
|예외|조건|throw|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` 잘못 된 유니코드 문자가 포함 된 배열을 지정 합니다.<br /><br /> 또는<br /><br /> `value` 또는 `value`  +  `startIndex` 있는 64k 보다 작은 주소를 지정 합니다.<br /><br /> 또는<br /><br /> 새 <xref:System.String> 에서 인스턴스를 초기화 하지 못했습니다 합니다 `value` 때문에 바이트 배열 `value` 기본 코드 페이지 인코딩을 사용 하지 않습니다.|포인터를 사용 하 여 모든 생성자입니다.|  
|<xref:System.ArgumentNullException>|`value`가 null인 경우|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|현재 프로세스에 주소가 지정된 모든 문자에 대한 읽기 액세스 권한이 있는 것은 아닙니다.<br /><br /> 또는<br /><br /> `startIndex` 또는 `length`가 0보다 작거나 `value` + `startIndex`로 인해 포인터 오버플로가 발생하거나, 현재 프로세스에서 주소가 지정된 모든 문자에 대한 읽기 액세스 권한을 갖지는 않습니다.<br /><br /> 또는<br /><br /> 새 문자열의 길이가 너무 커서 할당할 수 있습니다.|포인터를 사용 하 여 모든 생성자입니다.|  
|<xref:System.AccessViolationException>|`value`또는 `value`  +  `startIndex`  +  `length` – 1, 잘못 된 주소를 지정 합니다.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>메서드 호출 합니까?  
  
|대상|호출 또는 사용|  
|--------|-----------------|  
|문자열을 만듭니다.|기존 문자열 또는 문자열 리터럴을 할당 ([예제](#Ctor1_Example))|  
|전체 문자 배열에서 문자열을 만듭니다.|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([예제](#Ctor2_Example))|  
|일부 문자 배열에서 문자열을 만듭니다.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([예제](#Ctor3_Example))|  
|같은 문자를 여러 번 반복 하는 문자열을 만듭니다.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([예제](#Ctor3_Example))|  
|유니코드 또는 와이드 문자 배열에 대 한 포인터에서 문자열을 만듭니다.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|해당 포인터를 사용 하 여 부분으로 된 유니코드 또는 와이드 문자 배열에서 문자열을 만듭니다.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|C + +에서 문자열을 만들려면 `char` 배열입니다.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> 또는<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|ASCII 문자에서 문자열을 만듭니다.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>문자열 만들기  
 가장 일반적으로 사용 되는 기법에 문자열을 프로그래밍 방식으로 만드는 단순한 할당을에 설명 된 대로 [이 예제에서는](#Ctor1_Example)합니다. <xref:System.String> 클래스에 네 가지 유형의 다음 값 중에서 문자열을 만들 수 있도록 하는 생성자 오버 로드도 포함 되어 있습니다.  
  
-   문자 배열 (u t F-16으로 인코딩된 문자 배열)입니다. 새로 만들 수 있습니다 <xref:System.String> 개체에서 배열 전체 또는 그 일부에 있는 문자입니다. <xref:System.String.%23ctor%28System.Char%5B%5D%29> 생성자 새 문자열을 배열에 있는 모든 문자를 복사 합니다. <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 인덱스에서 문자를 복사 하는 생성자 `startIndex` 인덱스로 `startIndex`  +  `length` – 새 문자열을 1입니다. 하는 경우 `length` 가 0 인 새 문자열의 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
     코드 반복적으로 동일한 값이 있는 문자열을 인스턴스화하는 경우 문자열을 작성 하는 대체 방법을 사용 하 여 응용 프로그램 성능을 개선할 수 있습니다. 자세한 내용은 [반복적인 문자열 처리](#Repetitive)합니다.  
  
-   단일에서 문자를 한 번 이상를 사용 하 여 중복 된 0은 <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> 생성자입니다. 하는 경우 `count` 가 0 인 새 문자열의 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
-   null로 끝나는 문자 배열에 대 한 포인터를 사용 합니다 <xref:System.String.%23ctor%28System.Char%2A%29> 또는 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 생성자입니다. 전체 배열 또는 지정된 된 범위 수 데 사용할 문자열을 초기화 합니다. 생성자는 지정된 된 포인터가 더하기 또는 지정된 된 포인터에서 시작 하는 유니코드 문자의 시퀀스를 복사 `startIndex` 또는 배열의 끝까지 계속 `length` 문자입니다. 하는 경우 `value` 가 null 포인터 또는 `length` 가 0 이면 생성자 값인 문자열을 만듭니다 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 배열의 끝에 복사 작업이 진행 하 고 null로 끝나는 배열 하지 않는 경우 생성자 동작은 시스템에 따라 다릅니다. 이러한 조건이 액세스 위반이 발생할 수 있습니다.  
  
     배열에 포함 된 null 문자가 포함 된 경우 (u+0000 또는 '\0') 및 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 오버 로드 호출 되 면 포함 된 문자열 인스턴스 `length` 문자를 포함 하 여 null을 포함 합니다. 다음 예제에서는 두 개의 null 문자를 포함 하는 요소가 10 개인 배열에 대 한 포인터에 전달 될 때 일어나는 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 메서드. 주소는 배열의 시작 부분 문자열에 추가할 배열의 모든 요소 이기 때문에 생성자 내장된 된 null이 두 가지를 포함 하는 10 개의 문자를 사용 하 여 문자열을 인스턴스화합니다. 반면, 동일한 배열을 전달 하는 경우는 <xref:System.String.%23ctor%28System.Char%2A%29> 생성자의 결과 첫 번째 null 문자를 포함 하지 않는 4 자의 문자열입니다.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     배열의는 유니코드 문자를 포함 해야 합니다. 문자 배열 되도록 즉 c + +에서 관리 되는 것으로 정의 하거나 <xref:System.Char>형식 또는 관리 되지 않는`wchar_t`형식입니다.  
  
     경우는 <xref:System.String.%23ctor%28System.Char%2A%29> 오버 로드 호출 되 고 때 배열의 null로 종료 하지 않은 경우는 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 오버 로드가 호출 됩니다 및 `startIndex`  +  `length`외부 메모리를 할당 된 문자 시퀀스에 대 한 범위를 포함 하는-1 생성자의 동작은 시스템에 종속 된 및 액세스 위반이 발생할 수 있습니다. 또한 Intel Itanium 프로세서에 호출을 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 생성자가 throw 될 수 있습니다는 <xref:System.DataMisalignedException> 예외입니다. 이 경우 호출 된 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 대신 합니다.  
  
-   부호 있는 바이트 배열에 대 한 포인터입니다. 전체 배열 또는 지정된 된 범위 수 데 사용할 문자열을 초기화 합니다. 인코딩 기본 코드 페이지를 사용 하 여 바이트 시퀀스를 해석할 수 있습니다 또는 생성자 호출에서 인코딩을 지정할 수 있습니다. 생성자를 null로 종료 되지 않는 전체 배열에서 문자열을 인스턴스화하려고 시도 아니면에서 배열의 범위 `value`  +  `startIndex` 하려면 `value`  +  `startIndex`  +  `length` 배열에 대해 할당 된 메모리 외부-1은,이 생성자의 동작은 시스템에 종속 된 및 액세스 위반이 발생할 수 있습니다.  
  
     부호 있는 바이트 배열을 매개 변수로 포함 하는 세 가지 생성자는 주로 c + +를 변환할 설계 `char` 이 예와 같이 문자열로 배열:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     값이 0 인 모든 null 문자 ('\0') 또는 바이트 배열에 있는 경우와 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> 오버 로드 호출 되 면 포함 된 문자열 인스턴스 `length` 문자를 포함 하 여 null을 포함 합니다. 다음 예제에서는 두 개의 null 문자를 포함 하는 요소가 10 개인 배열에 대 한 포인터에 전달 될 때 일어나는 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> 메서드. 주소는 배열의 시작 부분 문자열에 추가할 배열의 모든 요소 이기 때문에 생성자 내장된 된 null이 두 가지를 포함 하는 10 개의 문자를 사용 하 여 문자열을 인스턴스화합니다. 반면, 동일한 배열을 전달 하는 경우는 <xref:System.String.%23ctor%28System.SByte%2A%29> 생성자의 결과 첫 번째 null 문자를 포함 하지 않는 4 자의 문자열입니다.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     때문에 합니다 <xref:System.String.%23ctor%28System.SByte%2A%29> 하 고 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> 생성자 해석 `value` 기본 ANSI 코드 페이지를 사용 하 여 동일한 바이트 배열 사용 하는 이러한 생성자를 호출 합니다. 만들 수 있습니다 다른 시스템에서 다른 값이 있는 문자열입니다.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>반복적인 문자열 처리  
 구문 분석 하거나 자주 스트림의 텍스트를 디코딩하는 앱을 사용 합니다 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 생성자 또는 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 문자의 시퀀스를 문자열로 변환 하는 방법입니다. 반복적으로 만들고 하나의 문자열을 다시 사용 하는 대신 동일한 값을 사용 하 여 새 문자열 만들기 메모리가 낭비 되 고 있습니다. 동일한 문자열 값을 반복적으로 호출 하 여 만들 수 있는 경우는 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 생성자에서 알 수 없는 경우에 이동 수 있는 이러한 동일한 문자열 값을 조회 테이블을 대신 사용할 수 있습니다.  
  
 예를 들어 읽고 XML 태그 및 특성을 포함 하는 파일에서 문자 스트림 구문 분석 합니다. 스트림을 구문 분석 하는 경우 특정 토큰 (즉, 기호화 된 의미가 있는 문자 시퀀스) 반복적으로 발생 합니다. "0", "1", "true" 및 "false" 문자열에 해당 하는 토큰은 XML 스트림에서 자주 발생할 수 있습니다.  
  
 각 토큰으로 새 문자열로 변환 하는 대신 만들 수 있습니다는 <xref:System.Xml.NameTable?displayProperty=nameWithType> 일반적으로 발생 하는 문자열을 저장 하는 개체입니다. <xref:System.Xml.NameTable> 개체 임시 메모리를 할당 하지 않고 저장 된 문자열을 검색 하므로 성능이 향상 됩니다. 사용 하 여 토큰을 발생 하는 경우는 <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 테이블에서 토큰을 검색 하는 방법입니다. 토큰이 있으면 메서드는 해당 문자열을 반환 합니다. 토큰 존재 하지 않는 경우 사용 하 여를 <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 메서드 테이블을 사용 하 여 토큰을 삽입 하는 데 해당 문자열을 가져옵니다.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>문자열 할당을 사용 하는 예 1:  
 다음 예제에서는 문자열 리터럴을 할당 하 여 새 문자열을 만듭니다. 두 번째 문자열에 첫 번째 문자열의 값을 할당 하 여 만듭니다. 이 두 가지 가장 일반적인 새 <xref:System.String> 개체입니다.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>예제 2: 문자 배열 사용  
 다음 예제에서는 새 <xref:System.String> 문자 배열에서 개체입니다.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>예제 3: 문자 배열의 일부를 사용 하 고 단일 문자를 반복 합니다.  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.String> 개체를 만들기 위한 방법과 문자 배열에 부분에서 <xref:System.String> 단일 문자를 여러 번 포함 하는 개체입니다.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>예제 4: 문자 배열에 대 한 포인터를 사용 하 여  
 다음 예제에서는 새 <xref:System.String> 문자의 배열에 대 한 포인터에서 개체입니다. C# 예제를 사용 하 여 컴파일해야 합니다 `/unsafe` 컴파일러 스위치입니다.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>예제 5: 포인터 및 배열 범위에서 문자열로 인스턴스화  
 다음 예제에서는 마침표 또는 느낌표를 문자 배열의 요소를 검사합니다. 을 찾으면 문장 부호 기호가 앞에 있는 배열의 문자에서 문자열을 인스턴스화합니다. 그렇지 않은 경우 문자열 배열의 전체 내용으로 인스턴스화합니다. C# 예제를 사용 하 여 컴파일해야 합니다 `/unsafe` 컴파일러 스위치입니다.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>예제 6: 부호 있는 바이트 배열에 대 한 포인터에서 문자열을 인스턴스화  
 다음 예제에서는 어떻게의 인스턴스를 만들 수 있습니다 합니다 <xref:System.String> 클래스는 <xref:System.String.%23ctor%28System.SByte%2A%29> 생성자입니다.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>버전 정보  
 .NET Framework  
 모든 오버 로드에 지원 됩니다: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 모든 오버 로드에 지원 됩니다: 4, 3.5 SP1  
  
 이식 가능한 클래스 라이브러리  
 없이 모든 오버 로드는 <xref:System.SByte> `*` 매개 변수는 지원  
  
 Windows 스토어 앱용 .NET  
 없이 모든 오버 로드는 <xref:System.SByte> `*` 매개 변수에서 지원 됩니다: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">null로 끝나는 유니코드 문자 배열에 대한 포인터입니다.</param>
        <summary>유니코드 문자 배열에 대한 지정된 포인터가 가리키는 값으로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 및 기타에 대 한 포괄적인 사용 정보와 예제 `String` 생성자 오버 로드를 참조 합니다 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">현재 프로세스에 주소가 지정된 모든 문자에 대한 읽기 액세스 권한이 있는 것은 아닙니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />는 잘못된 유니코드 문자가 포함된 배열을 지정하거나 <paramref name="value" />가 64000보다 작은 주소를 지정합니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">유니코드 문자 배열입니다.</param>
        <summary>유니코드 문자 배열에서 나타내는 값으로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 및 기타에 대 한 포괄적인 사용 정보와 예제 `String` 생성자 오버 로드를 참조 합니다 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">null로 끝나는 8비트 부호 있는 정수 배열에 대한 포인터입니다. 정수는 현재 시스템 코드 페이지 인코딩(즉, <see cref="P:System.Text.Encoding.Default" />로 지정된 인코딩)을 사용하여 해석됩니다.</param>
        <summary>8비트 부호 있는 정수 배열에 대한 포인터가 나타내는 값으로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 및 기타에 대 한 포괄적인 사용 정보와 예제 `String` 생성자 오버 로드를 참조 합니다 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />가 ANSI로 인코딩되었다고 가정하고 <see cref="T:System.String" />의 새 인스턴스를 <paramref name="value" />를 사용하여 초기화할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" />의 null 종결 문자로 결정되는 초기화할 새 문자열의 길이가 너무 커서 할당할 수 없습니다.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />가 잘못된 주소를 지정합니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">유니코드 문자입니다.</param>
        <param name="count">
          <paramref name="c" />가 발생하는 횟수입니다.</param>
        <summary>지정한 횟수만큼 반복되는 지정된 유니코드 문자가 나타내는 값으로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 및 기타에 대 한 포괄적인 사용 정보와 예제 `String` 생성자 오버 로드를 참조 합니다 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />가 0보다 작은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">유니코드 문자 배열에 대한 포인터입니다.</param>
        <param name="startIndex">
          <paramref name="value" /> 내의 시작 위치입니다.</param>
        <param name="length">
          <paramref name="value" /> 내에서 사용할 문자의 수입니다.</param>
        <summary>유니코드 문자 배열에 대한 지정된 포인터가 나타내는 값, 해당 배열 내의 시작 문자 위치 및 길이로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 및 기타에 대 한 포괄적인 사용 정보와 예제 `String` 생성자 오버 로드를 참조 합니다 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작거나 <paramref name="value" /> + <paramref name="startIndex" />로 인해 포인터 오버플로가 발생하거나, 현재 프로세스에서 주소가 지정된 모든 문자에 대한 읽기 액세스 권한을 갖지는 않습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />는 잘못된 유니코드 문자가 포함된 배열을 지정하거나 <paramref name="value" /> + <paramref name="startIndex" />가 64000보다 작은 주소를 지정합니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">유니코드 문자 배열입니다.</param>
        <param name="startIndex">
          <paramref name="value" /> 내의 시작 위치입니다.</param>
        <param name="length">
          <paramref name="value" /> 내에서 사용할 문자의 수입니다.</param>
        <summary>유니코드 문자 배열에서 나타내는 값, 해당 배열 내의 시작 문자 위치 및 길이로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 및 기타에 대 한 포괄적인 사용 정보와 예제 `String` 생성자 오버 로드를 참조 합니다 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.  
  
또는 
<paramref name="startIndex" />와 <paramref name="length" />의 합계가 <paramref name="value" />의 요소 수보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">8비트 부호 있는 정수에 대한 포인터입니다. 정수는 현재 시스템 코드 페이지 인코딩(즉, <see cref="P:System.Text.Encoding.Default" />로 지정된 인코딩)을 사용하여 해석됩니다.</param>
        <param name="startIndex">
          <paramref name="value" /> 내의 시작 위치입니다.</param>
        <param name="length">
          <paramref name="value" /> 내에서 사용할 문자의 수입니다.</param>
        <summary>8비트 부호 있는 정수 배열에 대한 지정된 포인터가 나타내는 값, 해당 배열 내의 시작 위치 및 길이로 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 및 기타에 대 한 포괄적인 사용 정보와 예제 `String` 생성자 오버 로드를 참조 합니다 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.  
  
또는 
<paramref name="value" /> + <paramref name="startIndex" />로 지정된 주소가 현재 플랫폼에 비해 너무 큽니다. 즉, 주소 계산이 오버플로됩니다.  
  
또는 
초기화할 새 문자열의 길이가 너무 커서 할당할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> + <paramref name="startIndex" />로 지정된 주소가 64K 미만입니다.  
  
또는 
<paramref name="value" />가 ANSI로 인코딩되었다고 가정하고 <see cref="T:System.String" />의 새 인스턴스를 <paramref name="value" />를 사용하여 초기화할 수 없습니다.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> 및 <paramref name="length" />가 전체적으로 잘못된 주소를 지정합니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">8비트 부호 있는 정수에 대한 포인터입니다.</param>
        <param name="startIndex">
          <paramref name="value" /> 내의 시작 위치입니다.</param>
        <param name="length">
          <paramref name="value" /> 내에서 사용할 문자의 수입니다.</param>
        <param name="enc">
          <paramref name="value" />에서 참조하는 배열이 인코딩되는 방법을 지정하는 개체입니다. <paramref name="enc" />가 <see langword="null" />이면 ANSI 인코딩으로 간주됩니다.</param>
        <summary>8비트 부호 있는 정수 배열에 대한 지정된 포인터가 나타내는 값, 해당 배열 내의 시작 문자 위치, 길이 및 <see cref="T:System.String" /> 개체로 <see cref="T:System.Text.Encoding" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 및 기타에 대 한 포괄적인 사용 정보와 예제 `String` 생성자 오버 로드를 참조 합니다 <xref:System.String.%23ctor%2A> 생성자 요약 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.  
  
또는 
<paramref name="value" /> + <paramref name="startIndex" />로 지정된 주소가 현재 플랫폼에 비해 너무 큽니다. 즉, 주소 계산이 오버플로됩니다.  
  
또는 
초기화할 새 문자열의 길이가 너무 커서 할당할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> + <paramref name="startIndex" />로 지정된 주소가 64K 미만입니다.  
  
또는 
<paramref name="value" />가 <paramref name="enc" />로 지정된 대로 인코딩되었다고 가정하고 <see cref="T:System.String" />의 새 인스턴스를 <paramref name="value" />를 사용하여 초기화할 수 없습니다.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> 및 <paramref name="length" />가 전체적으로 잘못된 주소를 지정합니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">현재 문자열의 위치입니다.</param>
        <summary>현재 <see cref="T:System.Char" /> 개체에서 지정된 문자 위치에 있는 <see cref="T:System.String" /> 개체를 가져옵니다.</summary>
        <value>
          <paramref name="index" /> 위치에 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` 매개 변수는 0부터 시작 합니다.  
  
 이 속성을 반환 합니다 <xref:System.Char> 로 지정 된 위치에 있는 개체는 `index` 매개 변수입니다. 그러나 둘 이상의 유니코드 문자를 표현 될 수 있습니다 <xref:System.Char>합니다. 사용 된 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 유니코드를 사용 하는 클래스는 문자 대신 <xref:System.Char> 개체입니다. 자세한 내용은 "개체 및 유니코드 문자 문자" 섹션을 참조 하세요.를 <xref:System.String> 클래스 개요입니다.  
  
 C#에서 <xref:System.String.Chars%2A> 속성 인덱서입니다. Visual Basic에서는의 기본 속성을 <xref:System.String> 클래스입니다. 각 <xref:System.Char> 다음과 같은 코드를 사용 하 여 문자열에서 개체를 액세스할 수 있습니다.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 다음 예제에서는 문자열의 유효성을 검사 하는 루틴에이 인덱서를 사용할 수는 방법을 보여 줍니다.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" />가 이 개체의 길이보다 크거나 같거나 0보다 작습니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.String" />의 이 인스턴스에 대한 참조를 반환합니다.</summary>
        <returns>이 <see cref="T:System.String" />의 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 값이이 인스턴스;의 독립 복사본 아닙니다. 동일한 데이터의 다른 뷰입니다. 사용 된 <xref:System.String.Copy%2A> 또는 <xref:System.String.CopyTo%2A> 메서드를 별도 <xref:System.String> 이 인스턴스와 같은 값을 가진 개체입니다.  
  
 때문에 <xref:System.String.Clone%2A> 메서드를 직접 호출할 필요가 거의 메서드는 단순히 기존 문자열 인스턴스를 반환 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 두 <see cref="T:System.String" /> 개체를 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Compare%2A> 메서드의 모든 오버로드는 두 비교 대상 간의 어휘 관계를 나타내는 부호 있는 32비트 정수를 반환합니다.  
  
|값|조건|  
|-----------|---------------|  
|0보다 작음|첫 번째 부분 정렬 순서에서 두 번째 부분 문자열 앞에 있습니다.|  
|0|부분 문자열이 정렬 순서에서 같은 위치에 나오거나 `length`가 0인 경우|  
|0보다 큼|첫 번째 부분 문자열이 정렬 순서에서 두 번째 부분 문자열을 따릅니다.|  
  
> [!WARNING]
>  가능한 경우 항상 오버 로드를 호출 해야 합니다 <xref:System.String.Compare%2A> 포함 하는 메서드를 <xref:System.StringComparison> 매개 변수. 자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">.NET Framework에서 문자열 사용에 대한 유용한 정보</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">비교할 첫째 문자열입니다.</param>
        <param name="strB">비교할 둘째 문자열입니다.</param>
        <summary>지정된 두 <see cref="T:System.String" /> 개체를 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 오는 경우  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에서 발생합니다.  
  
 </description></item><item><term> 0보다 큼 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 오는 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교는 대/소문자 규칙 등의 개별 문자가 사전순 문화권별 형식 정보를 가져올 현재 문화권을 사용 합니다. 예를 들어, 특정 문자 조합의 단일 문자로 처리 되거나 대 문자와 소문자를 특정 방식으로 비교는 문화권을 지정할 수 있습니다 또는 문자의 정렬 순서 앞에 있는 문자에 따라 달라 지는 또는 따라서 이동 합니다.  
  
 단어 정렬 규칙을 사용 하 여 비교를 수행 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
> [!WARNING]
>  문자열을 비교할 때 호출 해야 합니다 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드를 메서드를 사용 하는 문자열 비교의 형식을 명시적으로 지정 해야 합니다. 자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조일; 보다 큼 비교 와 두 null 참조가 서로 같은지 비교 합니다.  
  
 비교는 같지 않음 검색 하거나 두 문자열 요소가 비교 된 때를 종료 합니다. 그러나 두 문자열을 비교 하 여 한 문자열의 끝을 다른 문자열에 문자가 남아 다음 나머지 문자를 사용 하 여 문자열은 큰 것으로 간주 합니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 문화권별 대/소문자 규칙에 의해 영향을 받는 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "파일"에서 합니다.  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 "File"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다. 이렇게 하려면 올바른 코드를 아래와 같습니다.  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.Compare%28System.String%2CSystem.String%29> 세 가지 문자열을 비교 하는 방법입니다.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 다음 예제에서는 `ReverseStringComparer` 클래스에서는 두 문자열을 계산 하는 방법을 보여 줍니다.를 <xref:System.String.Compare%2A> 메서드.  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함됩니다. <see cref="M:System.String.Compare(System.String,System.String)" /> 메서드 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 예를 들어 다음 코드에서 실행 되는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 나중 "ani-잘못 되었습니다." (사용자 지정 하이픈, 또는 U + 00AD 사용)를 사용 하 여 "animal"의 문화권 구분 비교를 나타내는 두 문자열을 해당 하는 또는 합니다.  
  
[! 코드 csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [! 코드 vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
문자열 비교에서 무시할 수 있는 문자를 인식 하도록 호출 합니다 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 메서드와의 값을 제공 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 `comparisonType` 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">비교할 첫째 문자열입니다.</param>
        <param name="strB">비교할 둘째 문자열입니다.</param>
        <param name="ignoreCase">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>대/소문자를 구분하거나 구분하지 않고 지정된 두 <see cref="T:System.String" /> 개체를 비교하여 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 오는 경우  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에서 발생합니다.  
  
 </description></item><item><term> 0보다 큼 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 오는 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교는 대/소문자 규칙 등의 개별 문자가 사전순 문화권별 형식 정보를 가져올 현재 문화권을 사용 합니다. 예를 들어, 특정 문자 조합의 단일 문자로 처리 되거나 대 문자와 소문자를 특정 방식으로 비교는 문화권을 지정할 수 있습니다 또는 문자의 정렬 순서 앞에 있는 문자에 따라 달라 지는 또는 따라서 이동 합니다.  
  
 단어 정렬 규칙을 사용 하 여 비교를 수행 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
> [!WARNING]
>  문자열을 비교할 때 호출 해야 합니다 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드를 메서드를 사용 하는 문자열 비교의 형식을 명시적으로 지정 해야 합니다. 자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조일; 보다 큼 비교 와 두 null 참조가 서로 같은지 비교 합니다.  
  
 비교는 같지 않음 검색 하거나 두 문자열 요소가 비교 된 때를 종료 합니다. 그러나 두 문자열을 비교 하 여 한 문자열의 끝을 다른 문자열에 문자가 남아 다음 나머지 문자를 사용 하 여 문자열은 큰 것으로 간주 합니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 문화권별 대/소문자 규칙에 의해 영향을 받는 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "파일"에서 합니다.  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 "File"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다. 이렇게 하려면 올바른 코드를 아래와 같습니다.  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 다음 예제에 나와 있는 합니다 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> 사용 하는 것과 같습니다 <xref:System.String.ToUpper%2A> 또는 <xref:System.String.ToLower%2A> 문자열을 비교할 때.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함됩니다. <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> 메서드 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 예를 들어 다음 코드에서 실행 되는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 하거나 나중에 "Ani-잘못 되었습니다." (사용자 지정 하이픈, 또는 U + 00AD 사용)를 사용 하 여 "animal"의 문화권 구분 및 대/소문자 구분 비교를 두 문자열이 같은지를 나타냅니다.  
  
[! 코드 csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [! 코드 vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
문자열 비교에서 무시할 수 있는 문자를 인식 하도록 호출 합니다 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 메서드와의 값을 제공 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">비교할 첫째 문자열입니다.</param>
        <param name="strB">비교할 둘째 문자열입니다.</param>
        <param name="comparisonType">비교에 사용할 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 규칙을 사용하여 지정된 두 <see cref="T:System.String" /> 개체를 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 오는 경우  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에 있는 경우  
  
 </description></item><item><term> 0보다 큼 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 오는 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` 매개 변수 여부를 나타냅니다 비교에서 현재 또는 고정 문화권을 사용 해야 인식 또는 비교 대상을의 대/소문자 무시 (문화권별) 단어를 사용 하 여 또는 서 수 (문화권) 정렬 규칙.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조일; 보다 큼 비교 와 두 null 참조가 서로 같은지 비교 합니다.  
  
 비교는 같지 않음 검색 하거나 두 문자열 요소가 비교 된 때를 종료 합니다. 그러나 두 문자열을 비교 하 여 한 문자열의 끝을 다른 문자열에 문자가 남아 경우 나머지 문자를 사용 하 여 문자열 큰 간주 됩니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 문화권별 대/소문자 규칙에 의해 영향을 받는 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "파일"에서 합니다.  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 "File"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다. 이렇게 하려면 올바른 코드를 아래와 같습니다.  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 다음 예제에서는 세 가지 버전의 문자를 비교 "I" 합니다. 문화권, 대/소문자가 무시 여부 및 서 수 비교를 수행 하는 지 여부를 선택 하면 영향을 받습니다.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.StringComparison" />은 지원되지 않습니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함됩니다. <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 메서드 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 비교에서 무시할 수 있는 문자를 인식 하도록 값을 제공 <see cref="F:System.StringComparison.Ordinal" /> 나 <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">비교할 첫째 문자열입니다.</param>
        <param name="strB">비교할 둘째 문자열입니다.</param>
        <param name="ignoreCase">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <param name="culture">문화권별 비교 정보를 제공하는 개체입니다.</param>
        <summary>대/소문자를 구분하거나 구분하지 않고 지정된 두 <see cref="T:System.String" /> 개체를 비교하여 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다. 문화권별 정보가 비교에 영향을 줍니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 오는 경우  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에서 발생합니다.  
  
 </description></item><item><term> 0보다 큼 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 오는 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교를 사용 하 여 `culture` 대/소문자 규칙 등의 개별 문자가 사전순 문화권별 형식 정보를 얻으려면 매개 변수. 예를 들어, 특정 문자 조합의 단일 문자로 처리 되거나 대 문자와 소문자를 특정 방식으로 비교는 문화권을 지정할 수 있습니다 또는 문자의 정렬 순서 앞에 있는 문자에 따라 달라 지는 또는 따라서 이동 합니다.  
  
 단어 정렬 규칙을 사용 하 여 비교를 수행 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조일; 보다 큼 비교 와 두 null 참조가 서로 같은지 비교 합니다.  
  
 비교는 같지 않음 검색 하거나 두 문자열 요소가 비교 된 때를 종료 합니다. 그러나 두 문자열을 비교 하 여 한 문자열의 끝을 다른 문자열에 문자가 남아 다음 나머지 문자를 사용 하 여 문자열은 큰 것으로 간주 합니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 문화권별 대/소문자 규칙에 의해 영향을 받는 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "파일"에서 합니다.  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 "File"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다. 이렇게 하려면 올바른 코드를 아래와 같습니다.  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 다음 예제에서는 문화권 비교에 영향을 줄 수 하는 방법을 보여 줍니다. 체코어-체코 공화국 문화권 "ch" 단일 문자 "d" 보다 큰 경우 그러나 영어-미국 culture에서에서 두 문자의 "ch" 구성 되며 "c"를 사용 하면 "d" 보다 작습니다.  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함됩니다. <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> 메서드 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 예를 들어 다음 코드에서 실행 되는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] "Ani-잘못 되었습니다." (사용자 지정 하이픈, 또는 U + 00AD 사용)를 사용 하 여 "animal"의 대/소문자 구분 비교를 고정을 사용 하 여 나중에 또는 문화권 두 문자열이 같은지를 나타냅니다.  
  
[! 코드 csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [! 코드 vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
문자열 비교에서 무시할 수 있는 문자를 인식 하도록 호출 합니다 <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 메서드와의 값을 제공 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="options" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">비교할 첫째 문자열입니다.</param>
        <param name="strB">비교할 둘째 문자열입니다.</param>
        <param name="culture">문화권별 비교 정보를 제공하는 문화권입니다.</param>
        <param name="options">대/소문자 또는 기호 무시 여부와 같이 비교를 수행할 때 사용할 옵션입니다.</param>
        <summary>지정된 두 <see cref="T:System.String" /> 개체를 비교하고 정렬 순서에서 두 문자열 간의 관계를 나타내는 정수를 반환합니다. 지정된 비교 옵션 및 문화권별 정보가 비교에 영향을 줍니다.</summary>
        <returns>다음 표와 같이 <paramref name="strA" />와 <paramref name="strB" /> 간의 어휘 관계를 나타내는 부호 있는 32비트 정수입니다. 
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 앞에 오는 경우  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" />와 동일한 위치에서 발생합니다.  
  
 </description></item><item><term> 0보다 큼 
 </term><description><paramref name="strA" />가 정렬 순서에서 <paramref name="strB" /> 뒤에 오는 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교를 사용 하는 `culture` 대/소문자 규칙 등의 개별 문자가 사전순 문화권별 형식 정보를 얻는 매개 변수입니다. 예를 들어, 특정 문자 조합을 단일 문자로 처리 함을, 대 / 소문자를 특정 방식으로 비교는 특정 문화권을 지정할 수 있습니다 또는 문자의 정렬 순서 문자에 따라 달라 지는 앞 이나 뒤 합니다.  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 메서드 사용 되기 위한 주로 정렬 또는 작업을 사전순으로 정렬 합니다. 메서드 호출의 주요 목적은 (즉, 메서드 호출의 목적은 인 경우 반환 값이 0에 대 한 테스트를) 두 문자열이 같은지 여부를 결정할 때 하지 사용 해야 합니다. 두 문자열이 같은지 여부를 확인, 호출 된 <xref:System.String.Equals%2A> 메서드.  
  
 비교 하 여 추가로 지정할 수 있습니다 합니다 `options` 의 하나 이상의 멤버로 구성 하는 매개 변수는 <xref:System.Globalization.CompareOptions> 열거형입니다. 그러나이 메서드는 문화권 구분 문자열 비교를 수행 하는 것 이므로, 합니다 <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> 및 <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 값 효과가 없습니다.  
  
 하나 또는 모두 비교 대상이 될 수 있습니다 `null`합니다. 정의상, 모든 문자열을 포함 하 여 <xref:System.String.Empty?displayProperty=nameWithType>, 비교는 null 참조 및 두 개의 null 참조 보다 큰 서로 같은지 비교 합니다.  
  
 비교는 같지 않음 검색 하거나 두 문자열 요소가 비교 된 때를 종료 합니다. 그러나 두 문자열을 비교 하 여 한 문자열의 끝을 다른 문자열에 문자가 남아 경우 나머지 문자를 사용 하 여 문자열 큰 간주 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 세 가지 방법으로 두 문자열을 비교 합니다: 언어 비교를 사용 하 여 EN-US 문화권에 대 한 EN-US 문화권에 대 한 언어는 대/소문자 구분 비교를 사용 하 여 및 서 수 비교를 사용 합니다. 비교의 세 가지 방법에서 세 가지 다른 결과 생성 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" />이 <see cref="T:System.Globalization.CompareOptions" /> 값이 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 메서드 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 비교에서 무시할 수 있는 문자를 인식 하도록 값을 제공 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 나 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="options" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">비교에 사용할 첫 번째 문자열입니다.</param>
        <param name="indexA">
          <paramref name="strA" />에 있는 부분 문자열의 위치입니다.</param>
        <param name="strB">비교에 사용할 두 번째 문자열입니다.</param>
        <param name="indexB">
          <paramref name="strB" />에 있는 부분 문자열의 위치입니다.</param>
        <param name="length">비교할 부분 문자열의 최대 문자 수입니다.</param>
        <summary>지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 부호 있는 32비트 정수를 반환합니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 오는 경우  
  
 </description></item><item><term> 0 
 </term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" />가 0인 경우  
  
 </description></item><item><term> 0보다 큼 
 </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 다음에 오는 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교할 부분 문자열 시작 `strA` 언제 `indexA` 고 `strB` 에서 `indexB`합니다. 둘 다 `indexA` 하 고 `indexB` 는 0부터 시작, 즉 첫 번째 문자의 `strA` 및 `strB` 위치 0에 합니다. 첫 번째 부분 문자열의 길이가의 길이 같고 `strA` 빼기 `indexA` 1을 더한 값입니다. 두 번째 부분 문자열의 길이가의 길이 같고 `strB` 빼기 `indexB` 1을 더한 값입니다.  
  
 비교할 문자 수는 두 부분 문자열의 길이 중 더 작은 값 및 `length`합니다. 합니다 `indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.  
  
 비교는 대/소문자 규칙 등의 개별 문자가 사전순 문화권별 형식 정보를 가져올 현재 문화권을 사용 합니다. 예를 들어, 특정 문자 조합의 단일 문자로 처리 되거나 대 문자와 소문자를 특정 방식으로 비교는 문화권을 지정할 수 있습니다 또는 문자의 정렬 순서 앞에 있는 문자에 따라 달라 지는 또는 따라서 이동 합니다.  
  
 단어 정렬 규칙을 사용 하 여 비교를 수행 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
> [!WARNING]
>  문자열을 비교할 때 호출 해야 합니다 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> 메서드를 메서드를 사용 하는 문자열 비교의 형식을 명시적으로 지정 해야 합니다. 자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조일; 보다 큼 비교 와 두 null 참조가 서로 같은지 비교 합니다.  
  
 같지 않음 검색 하거나 두 부분 문자열 비교를 종료 합니다. 그러나 두 문자열을 비교 하 여 한 문자열의 끝을 다른 문자열에 문자가 남아 다음 나머지 문자를 사용 하 여 문자열은 큰 것으로 간주 합니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 문화권별 대/소문자 규칙에 의해 영향을 받는 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "파일"에서 합니다.  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 "File"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다. 이렇게 하려면 올바른 코드를 아래와 같습니다.  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 다음 예제에서는 두 부분 문자열을 비교 합니다.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.  
  
또는 
 <paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.  
  
또는 
 <paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.  
  
또는 
<paramref name="indexA" /> 또는 <paramref name="indexB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함됩니다. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> 메서드 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 비교에서 무시할 수 있는 문자를 인식 하도록 호출 합니다 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 값을 제공 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">비교에 사용할 첫 번째 문자열입니다.</param>
        <param name="indexA">
          <paramref name="strA" />에 있는 부분 문자열의 위치입니다.</param>
        <param name="strB">비교에 사용할 두 번째 문자열입니다.</param>
        <param name="indexB">
          <paramref name="strB" />에 있는 부분 문자열의 위치입니다.</param>
        <param name="length">비교할 부분 문자열의 최대 문자 수입니다.</param>
        <param name="ignoreCase">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>대/소문자를 구분하거나 구분하지 않고 지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하여 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 오는 경우  
  
 </description></item><item><term> 0 
 </term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" />가 0인 경우  
  
 </description></item><item><term> 0보다 큼 
 </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 다음에 오는 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교할 부분 문자열 시작 `strA` 언제 `indexA`, 및 `strB` 에서 `indexB`합니다. 둘 다 `indexA` 하 고 `indexB` 는 0부터 시작, 즉 첫 번째 문자의 `strA` 및 `strB` 위치 0에 합니다. 첫 번째 부분 문자열의 길이가의 길이 같고 `strA` 빼기 `indexA` 1을 더한 값입니다. 두 번째 부분 문자열의 길이가의 길이 같고 `strB` 빼기 `indexB` 1을 더한 값입니다.  
  
 비교할 문자 수는 두 부분 문자열의 길이 중 더 작은 값 및 `length`합니다. 합니다 `indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.  
  
 비교는 대/소문자 규칙 등의 개별 문자가 사전순 문화권별 형식 정보를 가져올 현재 문화권을 사용 합니다. 예를 들어, 특정 문자 조합의 단일 문자로 처리 되거나 대 문자와 소문자를 특정 방식으로 비교는 문화권을 지정할 수 있습니다 또는 문자의 정렬 순서 앞에 있는 문자에 따라 달라 지는 또는 따라서 이동 합니다.  
  
 단어 정렬 규칙을 사용 하 여 비교를 수행 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
> [!WARNING]
>  문자열을 비교할 때 호출 해야 합니다 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> 메서드를 메서드를 사용 하는 문자열 비교의 형식을 명시적으로 지정 해야 합니다. 자세한 내용은 [문자열 사용에 대한 모범 사례](~/docs/standard/base-types/best-practices-strings.md)를 참조하세요.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조일; 보다 큼 비교 와 두 null 참조가 서로 같은지 비교 합니다.  
  
 같지 않음 검색 하거나 두 부분 문자열 비교를 종료 합니다. 그러나 두 문자열을 비교 하 여 한 문자열의 끝을 다른 문자열에 문자가 남아 다음 나머지 문자를 사용 하 여 문자열은 큰 것으로 간주 합니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 문화권별 대/소문자 규칙에 의해 영향을 받는 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "파일"에서 합니다.  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 경로 이름에서 고정 된 방식으로 비교 해야 합니다. 이렇게 하려면 올바른 코드는 다음과 같습니다.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 다음 예제에서는에서는 대/소문자만 다른 두 부분 문자열의 두 가지 비교 합니다. 첫 번째 비교는 대/소문자를 무시 하 고 두 번째 비교는 대/소문자를 고려 합니다.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.  
  
또는 
 <paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.  
  
또는 
 <paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.  
  
또는 
<paramref name="indexA" /> 또는 <paramref name="indexB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함됩니다. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> 메서드 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 비교에서 무시할 수 있는 문자를 인식 하도록 호출 합니다 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 값을 제공 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">비교에 사용할 첫 번째 문자열입니다.</param>
        <param name="indexA">
          <paramref name="strA" />에 있는 부분 문자열의 위치입니다.</param>
        <param name="strB">비교에 사용할 두 번째 문자열입니다.</param>
        <param name="indexB">
          <paramref name="strB" />에 있는 부분 문자열의 위치입니다.</param>
        <param name="length">비교할 부분 문자열의 최대 문자 수입니다.</param>
        <param name="comparisonType">비교에 사용할 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 규칙을 사용하여 지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하고 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 오는 경우  
  
 </description></item><item><term> 0 
 </term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" /> 매개 변수가 0인 경우  
  
 </description></item><item><term> 0보다 큼 
 </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 다음에 오는 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교할 부분 문자열 시작 `strA` 언제 `indexA` 고 `strB` 에서 `indexB`합니다. 둘 다 `indexA` 하 고 `indexB` 는 0부터 시작, 즉 첫 번째 문자의 `strA` 및 `strB` 0 인 하나를 배치 하지. 첫 번째 부분 문자열의 길이가의 길이 같고 `strA` 빼기 `indexA` 1을 더한 값입니다. 두 번째 부분 문자열의 길이가의 길이 같고 `strB` 빼기 `indexB` 1을 더한 값입니다.  
  
 비교할 문자 수는 두 부분 문자열의 길이 중 더 작은 값 및 `length`합니다. 합니다 `indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.  
  
 `comparisonType` 매개 변수 여부를 나타냅니다 비교에서 현재 또는 고정 문화권을 사용 해야 인식 또는 비교 대상을의 대/소문자 무시 (문화권별) 단어를 사용 하 여 또는 서 수 (문화권) 정렬 규칙.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조일; 보다 큼 비교 와 두 null 참조가 서로 같은지 비교 합니다.  
  
 같지 않음 검색 하거나 두 부분 문자열 비교를 종료 합니다. 그러나 두 문자열을 비교 하 여 한 문자열의 끝을 다른 문자열에 문자가 남아 경우 나머지 문자를 사용 하 여 문자열 큰 간주 됩니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 문화권별 대/소문자 규칙에 의해 영향을 받는 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "파일"에서 합니다.  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 "File"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다. 이렇게 하려면 올바른 코드를 아래와 같습니다.  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 다음 예제에서는 두 부분 문자열을 비교 합니다.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.  
  
또는 
 <paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.  
  
또는 
 <paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.  
  
또는 
<paramref name="indexA" /> 또는 <paramref name="indexB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함됩니다. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 비교에서 무시할 수 있는 문자를 인식 하도록 값을 제공 <see cref="F:System.StringComparison.Ordinal" /> 나 <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">비교에 사용할 첫 번째 문자열입니다.</param>
        <param name="indexA">
          <paramref name="strA" />에 있는 부분 문자열의 위치입니다.</param>
        <param name="strB">비교에 사용할 두 번째 문자열입니다.</param>
        <param name="indexB">
          <paramref name="strB" />에 있는 부분 문자열의 위치입니다.</param>
        <param name="length">비교할 부분 문자열의 최대 문자 수입니다.</param>
        <param name="ignoreCase">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <param name="culture">문화권별 비교 정보를 제공하는 개체입니다.</param>
        <summary>대/소문자를 구분하거나 구분하지 않고 지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하여 정렬 순서에서 두 개체의 상대 위치를 나타내는 정수를 반환합니다. 문화권별 정보가 비교에 영향을 줍니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 정수입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 오는 경우  
  
 </description></item><item><term> 0 
 </term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" />가 0인 경우  
  
 </description></item><item><term> 0보다 큼 
 </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 다음에 오는 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교할 부분 문자열 시작 `strA` 언제 `indexA`, 및 `strB` 에서 `indexB`합니다. 둘 다 `indexA` 하 고 `indexB` 는 0부터 시작, 즉 첫 번째 문자의 `strA` 및 `strB` 0 인 하나를 배치 하지. 첫 번째 부분 문자열의 길이가의 길이 같고 `strA` 빼기 `indexA` 1을 더한 값입니다. 두 번째 부분 문자열의 길이가의 길이 같고 `strB` 빼기 `indexB` 1을 더한 값입니다.  
  
 비교할 문자 수는 두 부분 문자열의 길이 중 더 작은 값 및 `length`합니다. 합니다 `indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.  
  
 비교를 사용 하 여 `culture` 대/소문자 규칙 등의 개별 문자가 사전순 문화권별 형식 정보를 얻으려면 매개 변수. 예를 들어, 특정 문자 조합의 단일 문자로 처리 되거나 대 문자와 소문자를 특정 방식으로 비교는 문화권을 지정할 수 있습니다 또는 문자의 정렬 순서 앞에 있는 문자에 따라 달라 지는 또는 따라서 이동 합니다.  
  
 단어 정렬 규칙을 사용 하 여 비교를 수행 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
 하나 또는 둘 다 비교 대상이 `null`합니다. 기본적으로 모든 문자열을 포함 하 여 빈 문자열 (""), null 참조일; 보다 큼 비교 와 두 null 참조가 서로 같은지 비교 합니다.  
  
 같지 않음 검색 하거나 두 부분 문자열 비교를 종료 합니다. 그러나 두 문자열을 비교 하 여 한 문자열의 끝을 다른 문자열에 문자가 남아 다음 나머지 문자를 사용 하 여 문자열은 큰 것으로 간주 합니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
 비교는 문화권별 대/소문자 규칙에 의해 영향을 받는 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 터키어, 다음 예제에서는 잘못 된 결과가 발생의 파일 시스템에서 문자 "i"에 대 한 대/소문자 규칙을 사용 하지 않으므로 "파일"에서 합니다.  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 "File"는 서 수 비교를 사용 하 여 경로 이름을 비교 합니다. 이렇게 하려면 올바른 코드를 아래와 같습니다.  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 다음 예제에서는 두 부분 문자열을 비교 다른 문화권을 사용 하 여 부분 문자열의 대/소문자를 무시 합니다. 문화권 선택에 문자 "I"는 어떻게 영향을 비교 합니다.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.  
  
또는 
 <paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.  
  
또는 
 <paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.  
  
또는 
<paramref name="strA" /> 또는 <paramref name="strB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함됩니다. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> 메서드 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 비교에서 무시할 수 있는 문자를 인식 하도록 호출 합니다 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 메서드 값을 제공 하 고 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 또는 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="options" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">비교에 사용할 첫 번째 문자열입니다.</param>
        <param name="indexA">
          <paramref name="strA" />에 있는 부분 문자열의 시작 위치입니다.</param>
        <param name="strB">비교에 사용할 두 번째 문자열입니다.</param>
        <param name="indexB">
          <paramref name="strB" />에 있는 부분 문자열의 시작 위치입니다.</param>
        <param name="length">비교할 부분 문자열의 최대 문자 수입니다.</param>
        <param name="culture">문화권별 비교 정보를 제공하는 개체입니다.</param>
        <param name="options">대/소문자 또는 기호 무시 여부와 같이 비교를 수행할 때 사용할 옵션입니다.</param>
        <summary>지정된 두 <see cref="T:System.String" /> 개체의 부분 문자열을 비교하고 정렬 순서에서 두 부분 문자열 간의 관계를 나타내는 정수를 반환합니다. 지정된 비교 옵션 및 문화권별 정보가 비교에 영향을 줍니다.</summary>
        <returns>다음 표와 같이 두 부분 문자열 간의 어휘 관계를 나타내는 정수입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 앞에 오는 경우  
  
 </description></item><item><term> 0 
 </term><description> 부분 문자열이 정렬 순서에서 같은 위치에 나오거나 <paramref name="length" />가 0인 경우  
  
 </description></item><item><term> 0보다 큼 
 </term><description><paramref name="strA" />의 부분 문자열이 정렬 순서에서 <paramref name="strB" />의 부분 문자열 다음에 오는 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교할 부분 문자열 시작 `strA` 위치의 `indexA` 고 `strB` 위치의 `indexB`합니다. 첫 번째 부분 문자열의 길이가 길이의 `strA` 빼기 `indexA`합니다. 두 번째 부분 문자열의 길이가 길이의 `strB` 빼기 `indexB`합니다.  
  
 비교할 문자 수는 두 부분 문자열의 길이 중 더 작은 값 및 `length`합니다. 합니다 `indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.  
  
 비교를 사용 하는 `culture` 대/소문자 규칙 등의 개별 문자가 사전순 문화권별 형식 정보를 얻는 매개 변수입니다. 예를 들어, 특정 문자 조합을 단일 문자로 처리 함을, 대 / 소문자를 특정 방식으로 비교는 특정 문화권을 지정할 수 있습니다 또는 문자의 정렬 순서 문자에 따라 달라 지는 앞 이나 뒤 합니다.  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 메서드 사용 되기 위한 주로 정렬 또는 작업을 사전순으로 정렬 합니다. 메서드 호출의 주요 목적은 (즉, 메서드 호출의 목적은 인 경우 반환 값이 0에 대 한 테스트를) 두 부분 문자열이 같은지 여부를 결정할 때 하지 사용 해야 합니다. 두 문자열이 같은지 여부를 확인, 호출 된 <xref:System.String.Equals%2A> 메서드.  
  
 하나 또는 둘 다 `strA` 하 고 `strB` 수 `null`입니다. 정의상, 모든 문자열을 포함 하 여 <xref:System.String.Empty?displayProperty=nameWithType>, 비교는 null 참조 및 두 개의 null 참조 보다 큰 서로 같은지 비교 합니다.  
  
 비교 하 여 추가로 지정할 수 있습니다 합니다 `options` 의 하나 이상의 멤버로 구성 하는 매개 변수는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다. 그러나이 메서드는 문화권 구분 문자열 비교를 수행 하는 것 이므로, 합니다 <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> 및 <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 값 효과가 없습니다.  
  
 같지 않음 검색 하거나 두 부분 문자열 비교를 종료 합니다. 그러나 두 문자열을 비교 하 여 한 문자열의 끝을 다른 문자열에 문자가 남아 경우 나머지 문자를 사용 하 여 문자열 큰 간주 됩니다. 반환 값은 마지막으로 수행한 비교의 결과입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 마지막 두 사용자 이름을 비교 하는 방법입니다. 사전순에서으로 나열합니다.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" />이 <see cref="T:System.Globalization.CompareOptions" /> 값이 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" />가 <paramref name="strA" /><see langword=".Length" />보다 큽니다.  
  
또는 
 <paramref name="indexB" />가 <paramref name="strB" /><see langword=".Length" />보다 큽니다.  
  
또는 
 <paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.  
  
또는 
<paramref name="strA" /> 또는 <paramref name="strB" />가 <see langword="null" />이고 <paramref name="length" />가 0보다 큽니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함됩니다. <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 메서드 언어 또는 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 비교에서 무시할 수 있는 문자를 인식 하도록 값을 제공 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 나 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> 에 대 한는 <paramref name="options" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>각 문자열에서 해당하는 <see cref="T:System.String" /> 개체의 숫자 값을 계산해서 두 <see cref="T:System.Char" /> 개체를 비교합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">비교할 첫째 문자열입니다.</param>
        <param name="strB">비교할 둘째 문자열입니다.</param>
        <summary>각 문자열에서 해당하는 <see cref="T:System.String" /> 개체의 숫자 값을 계산해서 두 지정된 <see cref="T:System.Char" /> 개체를 비교합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 정수입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description><paramref name="strA" />가 <paramref name="strB" />보다 작은 경우  
  
 </description></item><item><term> 0 
 </term><description><paramref name="strA" />와 <paramref name="strB" />가 같은 경우  
  
 </description></item><item><term> 0보다 큼 
 </term><description><paramref name="strA" />가 <paramref name="strB" />보다 큰 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 서 수 정렬 규칙을 사용 하 여 대/소문자 구분 비교를 수행 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다. 서 수 정렬 규칙을 사용 하 여 대/소문자 구분 비교를 수행 하려면 호출을 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드를 `comparisonType` 인수와 함께 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>합니다.  
  
 때문에 <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> 는 정적 메서드입니다 `strA` 하 고 `strB` 수 `null`입니다. 두 값이 `null`, 메서드를 나타내는 0 (영)을 반환 합니다 `strA` 고 `strB` 같은지 합니다. 값 중 하나인 경우 `null`, 메서드는 null이 아닌 큰 값을 고려 합니다.  
  
   
  
## Examples  
 다음 예제에서는 수행 하 고 문자열 2의 서 수 비교에서 대/소문자만 다릅니다.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">비교에 사용할 첫 번째 문자열입니다.</param>
        <param name="indexA">
          <paramref name="strA" />에 있는 부분 문자열의 시작 인덱스입니다.</param>
        <param name="strB">비교에 사용할 두 번째 문자열입니다.</param>
        <param name="indexB">
          <paramref name="strB" />에 있는 부분 문자열의 시작 인덱스입니다.</param>
        <param name="length">비교할 부분 문자열의 최대 문자 수입니다.</param>
        <summary>각 부분 문자열에서 해당하는 <see cref="T:System.String" /> 개체의 숫자 값을 계산하여 지정된 두 <see cref="T:System.Char" /> 개체의 부분 문자열을 비교합니다.</summary>
        <returns>두 비교 대상 간의 어휘 관계를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description><paramref name="strA" />의 부분 문자열이 <paramref name="strB" />의 부분 문자열보다 작습니다.  
  
 </description></item><item><term> 0 
 </term><description> 부분 문자열이 같거나 <paramref name="length" />가 0입니다.  
  
 </description></item><item><term> 0보다 큼 
 </term><description><paramref name="strA" />의 부분 문자열이 <paramref name="strB" />의 부분 문자열보다 큽니다.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `indexA`, `indexB`, 및 `length` 매개 변수는 음수일 수 없습니다.  
  
 비교 되는 문자 수가 더 작고 길이 대 한 `strA` 적은 `indexA`, 길이의 `strB` less `indexB`, 및 `length`합니다.  
  
 이 메서드는 서 수 정렬 규칙을 사용 하 여 대/소문자 구분 비교를 수행 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다. 서 수 정렬 규칙을 사용 하 여 대/소문자 구분 비교를 수행 하려면 호출을 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> 메서드를 `comparisonType` 인수와 함께 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>합니다.  
  
 때문에 <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> 는 정적 메서드입니다 `strA` 하 고 `strB` 수 `null`입니다. 두 값이 `null`, 메서드를 나타내는 0 (영)을 반환 합니다 `strA` 고 `strB` 같은지 합니다. 값 중 하나인 경우 `null`, 메서드는 null이 아닌 큰 값을 고려 합니다.  
  
   
  
## Examples  
 다음 예제에서는 함을 <xref:System.String.CompareOrdinal%2A> 및 <xref:System.String.Compare%2A> 다른 정렬 순서를 사용 합니다.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="strA" />가 <see langword="null" />이 아니고, <paramref name="indexA" />가 <paramref name="strA" />.<see cref="P:System.String.Length" />보다 큽니다.  
  
또는 
 <paramref name="strB" />가 <see langword="null" />이 아니고, <paramref name="indexB" />가 <paramref name="strB" />.<see cref="P:System.String.Length" />보다 큽니다.  
  
또는 
 <paramref name="indexA" />, <paramref name="indexB" /> 또는 <paramref name="length" />가 음수입니다.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스를 지정된 개체 또는 <see cref="T:System.String" />과 비교하고 정렬 순서에서 이 인스턴스의 위치가 지정된 개체 또는 <see cref="T:System.String" />보다 앞인지, 뒤인지 또는 동일한지를 나타내는 정수를 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 두 오버 로드는 <xref:System.String.CompareTo%2A> 메서드는 문화권 구분 및 대/소문자 구분 비교를 수행 합니다. 문화권을 구분 또는 서 수 비교를 수행 하려면이 메서드를 사용할 수 없습니다. 코드의 명확성을 권장 하지 않는 합니다 <xref:System.String.CompareTo%2A> 메서드를 호출 합니다 <xref:System.String.Compare%2A> 메서드 대신 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.String" />이 되는 개체입니다.</param>
        <summary>이 인스턴스를 지정된 <see cref="T:System.Object" />와 비교하고 정렬 순서에서 이 인스턴스의 위치가 지정된 <see cref="T:System.Object" />보다 앞인지, 뒤인지 또는 동일한지를 나타냅니다.</summary>
        <returns>정렬 순서에서 이 인스턴스의 위치가 <paramref name="value" /> 매개 변수보다 앞인지, 뒤인지 또는 동일한지를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description> 이 인스턴스가 <paramref name="value" /> 앞에 오는 경우  
  
 </description></item><item><term> 0 
 </term><description> 이 인스턴스의 위치가 정렬 순서에서 <paramref name="value" />와 같은 경우  
  
 </description></item><item><term> 0보다 큼 
 </term><description> 이 인스턴스가 <paramref name="value" /> 다음에 오는 경우  
  
또는 
 <paramref name="value" />가 <see langword="null" />인 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 해야는 <xref:System.String> 개체입니다.  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A> 메서드를 사용 하도록 설계 된 주로 정렬 또는 작업을 사전순으로 정렬 합니다. 메서드 호출의 주요 목적은 두 문자열이 같은지 여부를 결정할 때 하지 사용 해야 합니다. 두 문자열이 같은지 여부를 확인, 호출 된 <xref:System.String.Equals%2A> 메서드.  
  
 이 메서드는 현재 문화권을 사용 하 여 단어 (대/소문자 구분 및 문화권) 비교를 수행 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
 이 메서드는 동작에 대 한 자세한 내용은의 설명 섹션을 참조 하세요.를 <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.String.CompareTo%2A> 메서드는 <xref:System.Object>합니다. 비교 하려고 했기 때문에 <xref:System.String> 인스턴스를 `TestClass` 개체에 메서드가 throw는 <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />가 <see cref="T:System.String" />가 아닌 경우</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함됩니다. <see cref="M:System.String.CompareTo(System.Object)" /> 메서드 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 예를 들어 다음 코드에서 실행 되는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 하거나 나중에 "ani-잘못 되었습니다." (사용자 지정 하이픈, 또는 U + 00AD 사용)를 사용 하 여 "animal" 비교 두 문자열이 같은지를 나타냅니다.  
  
[! 코드 csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [! 코드 vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
문자열 비교에서 무시할 수 있는 문자를 인식 하려면 호출을 <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> 메서드.</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">이 인스턴스와 비교할 문자열입니다.</param>
        <summary>이 인스턴스를 지정된 <see cref="T:System.String" /> 개체와 비교하고 정렬 순서에서 이 인스턴스의 위치가 지정된 문자열보다 앞인지, 뒤인지 또는 동일한지를 나타냅니다.</summary>
        <returns>정렬 순서에서 이 인스턴스의 위치가 <paramref name="strB" /> 매개 변수보다 앞인지, 뒤인지 또는 동일한지를 나타내는 32비트 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description> 이 인스턴스가 <paramref name="strB" /> 앞에 오는 경우  
  
 </description></item><item><term> 0 
 </term><description> 이 인스턴스의 위치가 정렬 순서에서 <paramref name="strB" />와 같은 경우  
  
 </description></item><item><term> 0보다 큼 
 </term><description> 이 인스턴스가 <paramref name="strB" /> 다음에 오는 경우  
  
또는 
 <paramref name="strB" />가 <see langword="null" />인 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 문화권을 사용 하 여 단어 (대/소문자 구분 및 문화권) 비교를 수행 합니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>합니다.  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A> 메서드를 사용 하도록 설계 된 주로 정렬 또는 작업을 사전순으로 정렬 합니다. 메서드 호출의 주요 목적은 두 문자열이 같은지 여부를 결정할 때 하지 사용 해야 합니다. 두 문자열이 같은지 여부를 확인, 호출 된 <xref:System.String.Equals%2A> 메서드.  
  
 이 메서드는 동작에 대 한 자세한 내용은의 설명 섹션을 참조 하세요.를 <xref:System.String.Compare%28System.String%2CSystem.String%29> 메서드.  
  
 이 메서드를 구현 하는 <xref:System.IComparable%601?displayProperty=nameWithType> 인터페이스 및 수행 보다 조금 더 나은 <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> 메서드를 확인할 필요가 없기 때문에 있는지 여부를 `strB` 인수가 넣을 해야 하는 변경할 수 있는 값 형식 및 캐스팅 하지 않아도 해당 매개 변수를 <xref:System.Object> 에 <xref:System.String>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.CompareTo%2A> 다른 문자열을 사용 하 여 현재 문자열 인스턴스를 비교 하는 방법입니다.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 다음 예제에서는 여러 값 및 참조 형식에 대 한 CompareTo 메서드의 제네릭 및 제네릭이 아닌 버전을 보여 줍니다.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함됩니다. <see cref="M:System.String.CompareTo(System.String)" /> 메서드 문화권 구분 비교를 수행 하는 경우 이러한 문자를 고려 하지 않습니다. 예를 들어 다음 코드에서 실행 되는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 하거나 나중에 "ani-잘못 되었습니다." (사용자 지정 하이픈, 또는 U + 00AD 사용)를 사용 하 여 "animal" 비교 두 문자열이 같은지를 나타냅니다.  
  
[! 코드 csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [! 코드 vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
문자열 비교에서 무시할 수 있는 문자를 인식 하려면 호출을 <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> 메서드.</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.String" />의 인스턴스를 하나 이상 연결하거나 <see cref="T:System.String" />의 인스턴스 값에 해당하는 <see cref="T:System.Object" /> 표현을 하나 이상 연결합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />을 구현하고 제네릭 형식 인수가 <see cref="T:System.String" />인 컬렉션 개체입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 형식의 생성된 <see cref="T:System.String" /> 컬렉션의 멤버를 연결합니다.</summary>
        <returns>
          <paramref name="values" />의 연결된 문자열이거나, <paramref name="values" />가 빈 <see langword="IEnumerable(Of String)" />이면 <see cref="F:System.String.Empty" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 개체에 연결 하는 메서드 `values`; 구분 기호를 추가 하지 않습니다. 각 멤버 사이 구분 기호를 지정 하려면 `values`를 호출 합니다 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 메서드.  
  
 <xref:System.String.Empty> 문자열에 있는 모든 null 요소 대신 사용 됩니다 `values`합니다.  
  
 하는 경우 `values` 빈 `IEnumerable(Of String)`, 메서드가 반환 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 하는 경우 `values` 됩니다 `null`, 메서드에서 throw는 <xref:System.ArgumentNullException> 예외입니다.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 각 요소에 연결할 수 있는 메서드는 `IEnumerable(Of String)` 문자열 배열에 첫 번째 요소를 변환 하지 않고 컬렉션입니다. LINQ (Language-Integrated Query) 쿼리 식을 사용 하 여 특히 유용합니다. 다음 예제에서는 전달 된 `List(Of String)` 알파벳 문자를 특정 문자 (예에서는 "M") 보다 크거나 같은 선택 하는 람다 식으로 대 / 소문자 구분 문자를 포함 하는 개체입니다. `IEnumerable(Of String)` 에서 반환 되는 컬렉션 합니다 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 메서드에 전달 됩니다는 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 단일 문자열로 결과 표시 하는 방법.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 다음 예에서는 소수 100 보다 작거나를 계산 하는 에라토스테네스의 체 알고리즘을 사용 합니다. 결과를 할당 한 <xref:System.Collections.Generic.List%601> 형식의 개체 <xref:System.String>에 전달 되는 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 메서드.  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">나타낼 개체나 <see langword="null" />입니다.</param>
        <summary>지정된 개체의 문자열 표현을 만듭니다.</summary>
        <returns>
          <paramref name="arg0" />이 <see cref="F:System.String.Empty" />인 경우 <paramref name="arg0" /> 또는 <see langword="null" /> 값의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.String.Concat%28System.Object%29> 메서드를 나타냅니다 `arg0` 는 매개 변수가 없는 호출 하 여 문자열로 `ToString` 메서드.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Concat%2A> 메서드.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">연결할 요소가 포함된 개체 배열입니다.</param>
        <summary>지정된 <see cref="T:System.Object" /> 배열에 있는 요소의 문자열 표현을 연결합니다.</summary>
        <returns>
          <paramref name="args" />에 있는 요소 값의 연결된 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 개체에 연결 하는 메서드 `args` 매개 변수가 없는 호출 하 여 `ToString` 메서드는 개체의 모든 구분 기호를 추가 하지 않습니다.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> 배열에 있는 빈 개체 대신 사용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 합니다 <xref:System.String.Concat%2A> 메서드는 <xref:System.Object> 배열입니다.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족합니다.</exception>
        <block subset="none" type="usage">
          <para>이 메서드는 c + + 코드에서 호출 되지 않습니다. C + + 컴파일러에 대 한 호출을 확인 <see cref="Overload:System.String.Concat" /> 호출으로 4 개 이상의 개체 매개 변수 있는 <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />합니다.</para>
        </block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">문자열 인스턴스의 배열입니다.</param>
        <summary>지정된 <see cref="T:System.String" /> 배열의 요소를 연결합니다.</summary>
        <returns>
          <paramref name="values" />의 연결된 요소를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 개체에 연결 하는 메서드 `values`; 구분 기호를 추가 하지 않습니다.  
  
 <xref:System.String.Empty> 문자열 배열에 있는 빈 개체 대신 사용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 합니다 <xref:System.String.Concat%2A> 메서드는 <xref:System.String> 배열입니다.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족합니다.</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">연결할 첫 번째 개체입니다.</param>
        <param name="arg1">연결할 두 번째 개체입니다.</param>
        <summary>지정된 두 개체의 문자열 표현을 연결합니다.</summary>
        <returns>
          <paramref name="arg0" /> 및 <paramref name="arg1" /> 값의 연결된 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드를 연결 `arg0` 하 고 `arg1` 매개 변수가 없는 호출 하 여 `ToString` 메서드의 `arg0` 및 `arg1`; 구분 기호를 추가 하지 않습니다.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> null 인수 대신 사용 됩니다.  
  
 경우 인수는 배열 참조, 해당 멤버 (예를 들어, "System.String[]") 대신 해당 배열을 나타내는 문자열을 연결 하는 메서드 중 하나.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Concat%2A> 메서드.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">연결할 첫 번째 문자열입니다.</param>
        <param name="str1">연결할 두 번째 문자열입니다.</param>
        <summary>
          <see cref="T:System.String" />의 지정된 두 인스턴스를 연결합니다.</summary>
        <returns>연결된 <paramref name="str0" /> 및 <paramref name="str1" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드를 연결 `str0` 고 `str1`; 구분 기호를 추가 하지 않습니다.  
  
> [!NOTE]
>  사용할 수도 있습니다 언어의 문자열 연결 연산자와 같은 `+` C#에서 또는 `&` 고 `+` Visual basic에서)  
>   
>  에서 문자열을 연결 합니다.  
  
 <xref:System.String.Empty> 문자열이 null 인수 대신 사용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 사용자의 첫 번째, 중간 및 마지막 이름을 연결합니다.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">연결할 첫 번째 개체입니다.</param>
        <param name="arg1">연결할 두 번째 개체입니다.</param>
        <param name="arg2">연결할 세 번째 개체입니다.</param>
        <summary>지정된 세 개체의 문자열 표현을 연결합니다.</summary>
        <returns>
          <paramref name="arg0" />, <paramref name="arg1" /> 및 <paramref name="arg2" /> 값의 연결된 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드를 연결 `arg0`, `arg1`, 및 `arg2` 매개 변수가 없는 호출 하 여 `ToString` 개체당; 메서드의 모든 구분 기호를 추가 하지 않습니다.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> null 인수 대신 사용 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Concat%2A> 메서드.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">연결할 첫 번째 문자열입니다.</param>
        <param name="str1">연결할 두 번째 문자열입니다.</param>
        <param name="str2">연결할 세 번째 문자열입니다.</param>
        <summary>
          <see cref="T:System.String" />의 지정된 세 인스턴스를 연결합니다.</summary>
        <returns>연결된 <paramref name="str0" />, <paramref name="str1" /> 및 <paramref name="str2" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드를 연결 `str0`, `str1`, 및 `str2`; 구분 기호를 추가 하지 않습니다.  
  
> [!NOTE]
>  사용할 수도 있습니다 언어의 문자열 연결 연산자와 같은 `+` C#에서 또는 `&` 고 `+` Visual basic에서)  
>   
>  에서 문자열을 연결 합니다.  
  
 <xref:System.String.Empty> 문자열이 null 인수 대신 사용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.Concat%2A> 메서드 3 개를 연결 문자열 및 결과 표시 합니다.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">연결할 첫 번째 개체입니다.</param>
        <param name="arg1">연결할 두 번째 개체입니다.</param>
        <param name="arg2">연결할 세 번째 개체입니다.</param>
        <param name="arg3">연결할 네 번째 개체입니다.</param>
        <summary>지정된 네 개체의 문자열 표현과 선택적 변수 길이 매개 변수 목록에 지정된 개체를 연결합니다.</summary>
        <returns>매개 변수 목록에서 각 값의 연결된 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 API는 CLS 규격이 아닙니다. CLS 규격 대체 항목은 <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>입니다. C# 및 Visual Basic 컴파일러에 대 한 호출으로이 메서드에 대 한 호출을 자동으로 해결 <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>합니다.  
  
 메서드는 매개 변수가 없는 호출 하 여 매개 변수 목록의 각 개체를 연결 `ToString` 메서드; 구분 기호를 추가 하지 않습니다.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> null 인수 대신 사용 됩니다.  
  
> [!NOTE]
>  마지막 매개 변수는 <xref:System.String.Concat%2A> 메서드는 연결할 하나 이상의 추가 개체의 선택적 쉼표로 구분 된 목록입니다.  
  
   
  
## Examples  
 다음 예제를 사용 하 여 <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 가변 매개 변수 목록을 연결 하는 방법. 이 경우에 메서드는 9 개의 매개 변수를 사용 하 여 호출 됩니다.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>이 메서드가로 표시는 <see langword="vararg" /> 가변 개수의 매개 변수를 지원함을 의미 하는 키워드입니다. Visual c + +에서 메서드를 호출할 수 있지만 C# 또는 Visual Basic 코드에서 호출할 수 없습니다. C# 및 Visual Basic 컴파일러에 대 한 호출을 해결할 <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> 호출로 <see cref="M:System.String.Concat(System.Object[])" />합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">연결할 첫 번째 문자열입니다.</param>
        <param name="str1">연결할 두 번째 문자열입니다.</param>
        <param name="str2">연결할 세 번째 문자열입니다.</param>
        <param name="str3">연결할 네 번째 문자열입니다.</param>
        <summary>
          <see cref="T:System.String" />의 지정된 네 인스턴스를 연결합니다.</summary>
        <returns>연결된 <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> 및 <paramref name="str3" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드를 연결 `str0`, `str1`를 `str2`, 및 `str3`; 구분 기호를 추가 하지 않습니다.  
  
> [!NOTE]
>  사용할 수도 있습니다 언어의 문자열 연결 연산자와 같은 `+` C#에서 또는 `&` 고 `+` Visual basic에서)  
>   
>  에서 문자열을 연결 합니다.  
  
 <xref:System.String.Empty> 문자열 배열에 있는 빈 개체 대신 사용 됩니다.  
  
   
  
## Examples  
 다음 예에서는 4 자 단어의 배열을 정의 하 고 스크램블 하기 위해 문자열 배열에 개별 문자를 저장 합니다. 그런 다음 호출 하 여 <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> 암호화 된 단어를 어셈블해야 하기 때문에 메서드.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <paramref name="values" /> 멤버의 형식입니다.</typeparam>
        <param name="values">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 인터페이스를 구현하는 컬렉션 개체입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 구현의 멤버를 연결합니다.</summary>
        <returns>
          <paramref name="values" />의 연결된 멤버입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 개체에 연결 하는 메서드 `values`; 구분 기호를 추가 하지 않습니다.  
  
 <xref:System.String.Empty> 문자열이 null 인수 대신 사용 됩니다.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 각 요소에 연결할 수 있는 메서드는 <xref:System.Collections.Generic.IEnumerable%601> 문자열에 첫 번째 요소를 변환 하지 않고 컬렉션입니다. 예제와 같이 것 LINQ (Language-Integrated Query) 쿼리 식을 사용 하 여 특히 유용 합니다. 각 개체의 문자열 표현 합니다 <xref:System.Collections.Generic.IEnumerable%601> 컬렉션 개체를 호출 하 여 파생 된 `ToString` 메서드.  
  
   
  
## Examples  
 다음 예제에서는 간단한 정의 `Animal` animal과 속한 주문의 이름을 포함 하는 클래스입니다. 그런 다음 정의 <xref:System.Collections.Generic.List%601> 개체의 번호를 포함 하도록 `Animal` 개체입니다. <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 추출에 확장 메서드를 호출 합니다 `Animal` 갖는 개체 `Order` 속성이 같으면 "바위"입니다. 결과에 전달 되는 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 메서드 및 콘솔에 표시 합니다.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <summary>이 문자열 내에서 지정한 하위 문자열이 발생하는지를 나타내는 값을 반환합니다.</summary>
        <returns>이 문자열 내에서 <see langword="true" /> 매개 변수가 발생하거나 <paramref name="value" />가 빈 문자열("")이면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행합니다. 검색이이 문자열의 첫 번째 문자 위치에서 시작 하 고 마지막 문자 위치부터 계속 됩니다.  
  
 문자열로 여부를 확인 하려면 이외의 문화권 구분 비교 또는 서 수 대/소문자 구분 비교와 같은 서 수 비교를 사용 하 여 지정된 된 부분 문자열을 포함, 사용자 지정 메서드를 만들 수 있습니다. 다음 예제에서는 이러한 한 가지 방법을 보여 줍니다. 정의 <xref:System.String> 포함 된 확장 메서드는 <xref:System.StringComparison> 매개 변수 지정 된 형식의 문자열 비교를 사용 하는 경우 문자열에 하위 문자열이 포함 하는지 여부를 나타냅니다.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 다음 예제에서는 호출 된 `Contains` 확장 메서드를 서 수 비교 및 대/소문자 서 수 비교를 사용 하는 경우 문자열의 부분 문자열은 찾을 지 여부를 결정 합니다.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 경우 관심 있는 부분 문자열의 위치 `value` 현재 인스턴스를 호출할 수 있습니다는 <xref:System.String.IndexOf%2A> 해당 첫 번째 발생의 시작 위치를 가져오는 메서드를 호출할 수는 <xref:System.String.LastIndexOf%2A> 가져오기 시작 하는 방법의 위치가 해당 마지막으로 발생 합니다. 예제에 대 한 호출을 포함 합니다 <xref:System.String.IndexOf%28System.String%29> 메서드 문자열 인스턴스에서 부분 문자열이 발견 되 면 합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열 "fox" 일반적인 따옴표 부분 인지 여부를 결정 합니다. 문자열에서 "fox" 발견 되는 경우 또한 해당 시작 위치를 표시 합니다.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">복사할 문자열입니다.</param>
        <summary>지정된 <see cref="T:System.String" />과 동일한 값을 갖는 <see cref="T:System.String" />의 새 인스턴스를 만듭니다.</summary>
        <returns>
          <paramref name="str" />과 동일한 값을 갖는 새 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.String.Copy%2A> 메서드가 반환 되는 <xref:System.String> 개체는 원래 문자열과 같은 값을 가지는 다른 개체 참조를 나타냅니다. 기존 문자열 참조 추가 개체 변수에 할당 하는 할당 작업에서 달라 집니다. 이 예제에서는 차이점을 보여 줍니다.  
  
   
  
## Examples  
 다음 예제에서는 값이 서로 다른 두 문자열 개체를 만듭니다. 호출할 때를 <xref:System.String.Copy%2A> 두 번째 문자열에 첫 번째 값을 할당 하는 메서드 출력 문자열을 나타내는 다른 개체 참조 하지만 해당 값이 같으면 이제 나타냅니다. 반면에 첫 번째 문자열이 두 번째 문자열에 할당할 때 두 문자열이 동일한 값을 갖는 같은 개체 참조를 나타내므로 합니다.  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">이 인스턴스에서 복사할 첫 번째 문자의 인덱스입니다.</param>
        <param name="destination">이 인스턴스의 문자가 복사되는 유니코드 문자의 배열입니다.</param>
        <param name="destinationIndex">
          <paramref name="destination" />에서 복사 작업이 시작되는 인덱스입니다.</param>
        <param name="count">이 인스턴스에서 <paramref name="destination" />에 복사할 문자의 수입니다.</param>
        <summary>이 인스턴스의 지정한 위치에 있는 지정한 수의 문자를 유니코드 문자 배열의 특정 위치에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 복사 `count` 에서 문자를 `sourceIndex` 이 인스턴스의 위치를 `destinationIndex` 의 위치가 `destination` 문자 배열입니다. 이 메서드는 크기를 조정 하지 합니다 `destination` 문자 배열; 요소는 복사한 문자에 맞게 충분 한 수 있어야 또는 메서드에서 throw는 <xref:System.ArgumentOutOfRangeException>합니다.  
  
 `sourceIndex` 및 `destinationIndex` 0부터 시작 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.CopyTo%2A> 메서드.  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" />또는 <paramref name="count" />이(가) 음수입니다. 
또는 
 <paramref name="sourceIndex" />이(가) 현재 인스턴스의 위치를 식별하지 않습니다.  
  
또는 
 <paramref name="destinationIndex" />이(가) <paramref name="destination" /> 배열에서 유효한 인덱스를 식별하지 않습니다.  
  
또는 
 <paramref name="count" />이(가) <paramref name="sourceIndex" />부터 이 인스턴스 끝까지의 하위 문자열 길이보다 큽니다. 
또는 
 <paramref name="count" />이(가) <paramref name="destinationIndex" />부터 <paramref name="destination" /> 배열 끝까지의 하위 문자열 길이보다 큽니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>빈 문자열을 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 필드의 값 길이가 0 인 문자열인 ""입니다.  
  
 응용 프로그램 코드에서이 필드는 가장 일반적으로 할당에 문자열 변수를 빈 문자열로 초기화에 사용 됩니다. 문자열의 값이 있는지 여부를 테스트할 `null` 또는 <xref:System.String.Empty?displayProperty=nameWithType>를 사용 하 여를 <xref:System.String.IsNullOrEmpty%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 문자열 인스턴스의 끝 부분과 지정한 문자열이 일치하는지를 확인합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">이 인스턴스의 끝 부분에 있는 부분 문자열과 비교할 문자열입니다.</param>
        <summary>이 문자열 인스턴스의 끝 부분과 지정한 문자열이 일치하는지를 확인합니다.</summary>
        <returns>이 인스턴스의 끝이 <see langword="true" />와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비교 `value` 와 같은 길이이 인스턴스의 끝에 있는 부분 문자열과 `value`와 같은지 여부를 나타내는 값을 반환 합니다. 같은 문자로 `value` 이 동일한 인스턴스에 대 한 참조 이거나이 인스턴스의 끝 부분과 일치 해야 합니다.  
  
 이 메서드는 현재 문화권을 사용 하 여 단어 (대/소문자 구분 및 문화권) 비교를 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 배열의 각 문자열을 기간으로 끝나는지 여부를 나타냅니다 (".").  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 다음 예제에서는 정의 `StripEndTags` 메서드를 사용 하는 <xref:System.String.EndsWith%28System.String%29> 줄의 끝에서 끝 태그를 HTML을 제거 하는 방법입니다. `StripEndTags` 줄의 끝에 여러 HTML 끝 태그가 제거 되도록에 재귀적으로 호출 됩니다.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 문자열에 대 한 모범 사례](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다. 현재 문화권의 문자열 비교 규칙을 사용 하 여 특정 문자열이 부분 문자열로 끝나는지 여부를 결정할 호출을 <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> 값을 사용 하 여 메서드 오버 로드 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">이 인스턴스의 끝 부분에 있는 부분 문자열과 비교할 문자열입니다.</param>
        <param name="comparisonType">이 문자열과 <paramref name="value" />를 비교하는 방법을 결정하는 열거형 값 중 하나입니다.</param>
        <summary>지정한 비교 옵션을 사용하여 비교할 때 지정한 문자열과 이 문자열 인스턴스의 끝 부분이 일치하는지를 확인합니다.</summary>
        <returns>이 문자열의 끝이 <see langword="true" /> 매개 변수와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.String.EndsWith%2A> 메서드 비교는 `value` 이 문자열의 끝에 있는 부분 문자열과 매개 변수 같은지 여부를 나타내는 값을 반환 합니다. 같은 문자로 `value` 이 동일한 문자열에 대 한 참조를 여야 하며, 빈 문자열 이어야 합니다 (""), 또는이 문자열의 끝과 일치 해야 합니다. 수행할 비교 유형을 합니다 <xref:System.String.EndsWith%2A> 메서드 값에 따라 달라 집니다는 `comparisonType` 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 특정 하위 문자열로 끝나는지 여부를 결정 합니다. 문화권, 대/소문자가 무시 여부 및 서 수 비교를 수행 하는 지 여부를 선택 하면 영향을 받습니다.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">이 인스턴스의 끝 부분에 있는 부분 문자열과 비교할 문자열입니다.</param>
        <param name="ignoreCase">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <param name="culture">이 인스턴스와 <paramref name="value" />의 비교 방법을 결정하는 문화권 정보입니다. <paramref name="culture" />가 <see langword="null" />이면 현재 문화권이 사용됩니다.</param>
        <summary>지정한 문화권을 사용하여 비교할 때 이 문자열 인스턴스의 끝 부분과 지정한 문자열이 일치하는지를 확인합니다.</summary>
        <returns>이 문자열의 끝이 <see langword="true" /> 매개 변수와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 비교 합니다 `value` 와 같은 길이이 문자열의 끝에 있는 부분 문자열과 매개 변수 `value`, 같은지 여부를 나타내는 값을 반환 합니다. 같은 문자로 `value` 이 동일한 인스턴스에 대 한 참조 하거나이 문자열의 끝과 일치 해야 합니다.  
  
 이 메서드는 지정 된 대/소문자 구분 및 문화권을 사용 하 여 단어 (문화권별) 비교를 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열을 다른 문자열의 끝에서 발생 하는지 여부를 결정 합니다. <xref:System.String.EndsWith%2A> 메서드가 여러 번 대/소문자 구분, 소문자, 및 검색 결과 영향을 주는 다른 문화권을 사용 하 여 호출 됩니다.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>두 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">이 인스턴스와 비교할 문자열입니다.</param>
        <summary>이 인스턴스와 지정한 개체의 값이 같은지를 확인합니다. 이 개체도 <see cref="T:System.String" /> 개체여야 합니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="obj" />이고 이 인스턴스와 같은 값을 가지면 <see cref="T:System.String" />이고, 그러지 않으면 <see langword="false" />입니다.  <paramref name="obj" />가 <see langword="null" />이면 메서드에서 <see langword="false" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Equals%2A> 메서드.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">이 인스턴스와 비교할 문자열입니다.</param>
        <summary>이 인스턴스와 지정한 다른 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다.</summary>
        <returns>
          <see langword="true" /> 매개 변수와 이 인스턴스의 값이 같으면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다. <paramref name="value" />가 <see langword="null" />이면 메서드에서 <see langword="false" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Equals%2A> 메서드. 와 해당 단어를 해당 소문자로, 해당 대문자로 라틴 작은 문자 점 없는 I를 포함 하는 단어 "File"을 제목 대/소문자 단어 비교 (U + 0131) 대신 라틴어 작은 문자 I (라는). 때문에 합니다 <xref:System.String.Equals%28System.String%29> 서 수 비교를 수행 하는 메서드를 동일한 단어를 사용 하 여 비교만 반환 `true`합니다.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">비교할 첫 번째 문자열 또는 <see langword="null" />입니다.</param>
        <param name="b">비교할 두 번째 문자열 또는 <see langword="null" />입니다.</param>
        <summary>지정된 두 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다.</summary>
        <returns>
          <see langword="true" />의 값이 <paramref name="a" />의 값과 같으면 <paramref name="b" />를 반환하고, 그러지 않으면 <see langword="false" />를 반환합니다. <paramref name="a" /> 및 <paramref name="b" />가 <see langword="null" />인 경우 이 메서드는 <see langword="true" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Equals%2A> 메서드.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">이 인스턴스와 비교할 문자열입니다.</param>
        <param name="comparisonType">문자열 비교 방법을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>이 문자열과 지정한 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다. 매개 변수는 비교에 사용되는 문화권, 대/소문자 및 정렬 규칙을 지정합니다.</summary>
        <returns>
          <see langword="true" /> 매개 변수와 이 문자열의 값이 같으면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` 매개 변수 인지를 나타냅니다 비교에서 현재 또는 고정 문화권을 사용 해야 인식 또는 비교 되는 두 문자열의 대/소문자 무시 단어 또는 서 수 정렬 규칙을 사용 합니다.  
  
   
  
## Examples  
 다음 예제에는 "I", "i", 소문자 및 점 "ı"의 대문자 구성 된 문자열 배열을 만듭니다. 그런 다음 호출 하는 <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> 각 가능한을 사용 하 여 비교할 메서드 <xref:System.StringComparison> 열거형 값입니다.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 다음 예제에서는 각 멤버를 사용 하 여 4 개의 집합이 단어 비교는 <xref:System.StringComparison> 열거형입니다.  영어 (미국) 및 라프어 (위 스웨덴) 문화권의 규칙을 사용 하는 비교 합니다. Note encyclopædia"문자열" 및 "백과 사전"는 EN-US 문화권 있지만 라프어 (북부 스웨덴) 문화권에 없는 해당 간주 됩니다.  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">비교할 첫 번째 문자열 또는 <see langword="null" />입니다.</param>
        <param name="b">비교할 두 번째 문자열 또는 <see langword="null" />입니다.</param>
        <param name="comparisonType">비교 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 두 <see cref="T:System.String" /> 개체의 값이 같은지를 확인합니다. 매개 변수는 비교에 사용되는 문화권, 대/소문자 및 정렬 규칙을 지정합니다.</summary>
        <returns>
          <see langword="true" /> 매개 변수와 <paramref name="a" /> 매개 변수의 값이 같으면 <paramref name="b" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType` 매개 변수 인지를 나타냅니다 비교에서 현재 또는 고정 문화권을 사용 해야 인식 또는 비교 되는 두 문자열의 대/소문자 무시 단어 또는 서 수 정렬 규칙을 사용 합니다.  
  
   
  
## Examples  
 다음 예제에서는 각 멤버를 사용 하 여 4 개의 집합이 단어 비교는 <xref:System.StringComparison> 열거형입니다.  영어 (미국) 및 라프어 (위 스웨덴) 문화권의 규칙을 사용 하는 비교 합니다. Note encyclopædia"문자열" 및 "백과 사전"는 EN-US 문화권 있지만 라프어 (북부 스웨덴) 문화권에 없는 해당 간주 됩니다.  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 형식에 따라 개체의 값을 문자열로 변환하여 다른 문자열에 삽입 합니다.  
  
`String.Format` 메서드를 처음 사용하는 경우 [String.Format 메서드 시작](#Starting) 섹션에서 대략적인 내용을 살펴보세요.  
  
`String.Format` 메서드에 대한 일반 설명서는 [설명](#remarks-top) 섹션을 참조하세요.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 섹션 내용  
  
 [String.Format 메서드 시작](#Starting)   
 [메서드 호출 합니까?](#FTaskList)   
 [개요에서 Format 메서드](#Format_Brief)   
 [형식 항목](#FormatItem)   
 [인수 형식 지정 방법을](#HowFormatted)   
 [동일한 인덱스에 있는 형식 항목](#SameIndex)   
 [서식 지정 및 문화권](#Format_Culture)   
 [사용자 지정 서식 지정 작업](#Format_Custom)   
 [String.Format q&a](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>String.Format 메서드 시작  
 사용 하 여 <xref:System.String.Format%2A?displayProperty=nameWithType> 다른 문자열에는 개체, 변수 또는 식의 값을 삽입 하는 경우. 예를 들어,의 값을 삽입할 수 있습니다를 <xref:System.Decimal> 값을 단일 문자열로 사용자에 게 표시할 문자열입니다.  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 및 해당 값의 서식을 제어할 수 있습니다.  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 서식 지정 하는 것 외에도 맞춤 및 간격을 제어할 수 있습니다.  
  
 ### <a name="inserting-a-string"></a>문자열을 삽입  

 <xref:System.String.Format%2A?displayProperty=nameWithType> 하나 이상의 개체 또는 문자열로 변환 되며 형식 문자열에서 지정된 된 위치에 삽입 하는 식 뒤에 형식 문자열을 사용 하 여 시작 합니다. 예:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 `{0}` 형식 문자열의 형식 항목입니다. `0` 문자열 값인 해당 위치에 삽입할 개체의 인덱스가입니다. (인덱스 0부터 시작)입니다. 삽입할 개체는 문자열이 아닌 경우 해당 `ToString` 메서드를 호출 하는 결과 문자열에 삽입 하기 전에 하나를 변환 합니다.  
  
 개체 목록에서 두 개의 형식 항목이 및 두 개의 개체를 사용 하는 또 다른 예는 다음과 같습니다.  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 만큼 서식 항목이 있을 수 있으며 모든 서식 항목의 인덱스 개체 목록에서 일치 하는 개체에 많은 개체와 개체 목록에서 원하는 합니다. 또한 필요가 걱정는 오버 로드에 대 한 호출입니다. 컴파일러는 적절 한 수를 선택 합니다.  
  
 ### <a name="controlling-formatting"></a>서식 제어  
 개체의 서식 지정 하는 방법을 제어 하는 서식 문자열을 사용 하 여 형식 항목의 인덱스를 따를 수 있습니다. 예를 들어 `{0:d}` "d" 서식 문자열 개체 목록의 첫 번째 개체에 적용 됩니다. 다음은 단일 개체를 사용 하 여 예제 및 두 항목의 서식을 지정 합니다.  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 형식 문자열, 모든 숫자 형식을 비롯 한 다양 한 형식 지원 (둘 다 [표준](~/docs/standard/base-types/standard-numeric-format-strings.md) 및 [사용자 지정](~/docs/standard/base-types/custom-numeric-format-strings.md) 형식 문자열), 모든 날짜 및 시간 (둘 다 [표준](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 하고[사용자 지정](~/docs/standard/base-types/custom-date-and-time-format-strings.md) 형식 문자열) 및 시간 간격 (둘 다 [표준](~/docs/standard/base-types/standard-timespan-format-strings.md) 하 고 [사용자 지정](~/docs/standard/base-types/custom-timespan-format-strings.md) 형식 문자열), 모든 열거형 형식은 [열거형 형식 ](~/docs/standard/base-types/enumeration-format-strings.md), 및 [Guid](https://msdn.microsoft.com/library/97af8hh4.aspx)합니다. 또한 사용자 고유의 형식에 형식 문자열에 대 한 지원을 추가할 수 있습니다.  
  
 ### <a name="controlling-spacing"></a>간격을 제어합니다.  
 와 같은 구문을 사용 하 여 결과 문자열에 삽입 되는 문자열의 너비를 정의할 수 있습니다 `{0,12}`, 12 문자열 삽입 합니다. 이 예제의 첫 번째 개체의 문자열 표현을 12 자 필드에 오른쪽 맞춤를 경우.  (첫 번째 개체의 문자열 표현을 길이가 12 개 이상의 문자 이면 그러나 기본 필드 너비를 무시 되 고 전체 문자열이 결과 문자열에 삽입 됩니다.)  
  
 다음 예제에서는 문자열을 보관할 6 자리 필드 정의 "Year" 및 일부 연도 문자열 뿐만 15 자 필드를 "채우기" 문자열을 보유할 수 및 일부 인구 데이터입니다. 문자는 오른쪽 맞춤 필드 note 합니다.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>맞춤을 제어합니다.  
 기본적으로 문자열은 해당 필드 내에서 오른쪽 정렬 필드 너비를 지정 하는 경우입니다. 문자열 필드에서를 왼쪽에 맞추려면 앞 음수 기호를 사용 하 여 필드 너비와 같은 `{0,-12}` 12 문자 왼쪽으로 맞춰져 있으며 필드를 정의 합니다.  
  
 다음 예제에서는 왼쪽 맞춤 레이블 및 데이터를 둘 다는 점을 제외 하 고 이전 쿼리와 비슷합니다.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> 에서는 복합 서식 지정 기능을 활용합니다. 자세한 내용은 [복합 서식 지정](~/docs/standard/base-types/composite-formatting.md)을 참조하세요.  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>메서드 호출 합니까?  
  
|대상|Call|  
|--------|----------|  
|현재 문화권의 규칙을 사용 하 여 하나 이상의 개체 형식을 지정 합니다.|포함 하는 오버 로드를 제외 하 고는 `provider` 매개 변수를 나머지 <xref:System.String.Format%2A> 오버 로드 포함을 <xref:System.String> 하나 이상의 개체 매개 변수 뒤에 매개 변수입니다. 이 인해 결정 필요가 <xref:System.String.Format%2A> 호출 하려는 오버 로드 합니다. 없는 오버 로드 중에서 적절 한 오버 로드를 선택 하는 언어 컴파일러는 `provider` 매개 변수를 인수 목록에 기반 합니다. 예를 들어, 인수 목록에 다섯 개의 인수, 있는 경우 컴파일러를 호출 합니다 <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> 메서드.|  
|특정 문화권의 규칙을 사용 하 여 하나 이상의 개체 형식을 지정 합니다.|각 <xref:System.String.Format%2A> 시작 하는 오버 로드 된 `provider` 뒤에 매개 변수를 <xref:System.String> 매개 변수 및 하나 이상의 매개 변수 개체입니다. 이 인해 특정 확인할 필요가 <xref:System.String.Format%2A> 호출 하려는 오버 로드 합니다. 언어 컴파일러는 오버 로드 중에서 적절 한 오버 로드를 선택는 `provider` 매개 변수를 인수 목록에 기반 합니다. 예를 들어, 인수 목록에 다섯 개의 인수, 있는 경우 컴파일러를 호출 합니다 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 메서드.|  
|사용 하 여 사용자 지정 서식 지정 작업 수행을 <xref:System.ICustomFormatter> 구현 또는 <xref:System.IFormattable> 구현 합니다.|4 개의 오버 로드 중 하나는 `provider` 매개 변수입니다. 컴파일러는 오버 로드 중에서 적절 한 오버 로드를 선택는 `provider` 매개 변수를 인수 목록에 기반 합니다.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>개요에서 Format 메서드 

 각 오버 로드는 <xref:System.String.Format%2A> 메서드를 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 호출부터 인덱싱된 자리 표시자를 포함 하도록 *항목의 서식을 지정*, 복합 형식 문자열에 합니다. 런타임 시 각 서식 항목 매개 변수 목록에서 해당 인수의 문자열 표현으로 바뀝니다. 인수의 값이 `null`, 형식 항목으로 바뀝니다. <xref:System.String.Empty?displayProperty=nameWithType>합니다. 다음을 호출 하는 예를 들어를 <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 메서드는 세 가지 형식 항목을 사용 하 여 형식 문자열을 포함할 {0}, {1}, 및 {2}, 및 세 개 항목으로 인수 목록.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>형식 항목  
 형식 항목에이 구문이 있습니다.  
  
```  
{index[,alignment][:formatString]}  
```  
 
 대괄호는 선택적 요소를 나타냅니다. 여는 태그와 닫는 중괄호는 필요 합니다. (리터럴 여 포함 하거나 참조 형식 문자열에서는 닫는 중괄호는 [중괄호 이스케이프](~/docs/standard/base-types/composite-formatting.md#escaping-braces) 섹션을 [복합 서식 지정](~/docs/standard/base-types/composite-formatting.md) 문서입니다.)  
  
 예를 들어 통화 값 서식을 지정 하려면 형식 항목은 다음과 같이 나타날 수 있습니다.  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 형식 항목에는 다음 요소가 있습니다.  
  
 *index*  
 문자열 표현의 인수의 인덱스 문자열의이 위치에 포함 합니다. 이 인수가 `null`, 빈 문자열은 문자열의이 위치에 포함 됩니다.  
  
 *alignment*  
 선택 사항입니다. 인수 삽입 되는 지, 오른쪽 맞춤 되 (양의 정수) 왼쪽 맞춤 (음의 정수)에 필드의 총 길이 나타내는 부호 있는 정수입니다. 생략 하면 *맞춤*, 선행 또는 후행 공백 없이 필드에 해당 인수의 문자열 표현을 삽입 됩니다.  
  
 경우 값 *맞춤* 삽입할 인수의 길이 보다 작으면 *맞춤* 무시 됩니다 및 인수의 문자열 표현의 길이가 필드 너비로 사용 됩니다.  
  
 *formatString*  
 선택 사항입니다. 해당 인수의 결과 문자열의 형식을 지정 하는 문자열입니다. 생략 하면 *formatString*에 해당 인수가 매개 변수가 없는 `ToString` 메서드를 호출 하는 문자열 표현을 생성 합니다. 지정 하는 경우 *formatString*, 형식 항목에서 참조 하는 인수를 구현 해야 합니다는 <xref:System.IFormattable> 인터페이스입니다. 형식 문자열을 지 원하는 형식이 포함 합니다.  
  
-   모든 정수 계열 및 부동 소수점 형식입니다. (참조 [표준 숫자 서식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   <xref:System.DateTime>와 <xref:System.DateTimeOffset>을 참조하세요. (참조 [표준 날짜 및 시간 형식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 하 고 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   모든 열거형 형식입니다. (참조 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   <xref:System.TimeSpan> 값 (참조 [표준 TimeSpan 서식 문자열](~/docs/standard/base-types/standard-timespan-format-strings.md) 하 고 [사용자 지정 TimeSpan 형식 문자열](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   GUID입니다. (참조는 <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> 메서드.)  
  
 그러나 모든 사용자 지정 형식을 구현할 수 있습니다 <xref:System.IFormattable> 기존 형식을 확장할 또는 <xref:System.IFormattable> 구현 합니다.  
  
 다음 예제에서는 합니다 `alignment` 및 `formatString` 인수 형식이 지정 된 출력을 생성 합니다.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>인수 형식 지정 방법을  
 형식 항목 문자열의 시작 부분에서 순차적으로 처리 됩니다. 각 서식 항목 메서드의 인수 목록에서 개체에 해당 하는 인덱스를 있습니다. <xref:System.String.Format%2A> 메서드 인수를 검색 하 고 해당 문자열 표현에 다음과 같이 파생 됩니다.  
  
-   인수가 `null`를 삽입 <xref:System.String.Empty?displayProperty=nameWithType> 결과 문자열에 있습니다. 처리에 신경 쓸 필요가 없습니다를 <xref:System.NullReferenceException> null 인수에 대 한 합니다. 
  
-   호출 하는 경우는 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 오버 로드 하며 `provider` 개체의 <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 구현은 null이 아닌 <xref:System.ICustomFormatter> 구현에는 전달 된 인수 해당 <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드. 형식 항목에 포함 된 경우는 *formatString* 인수 하는 첫 번째 인수로 메서드에 전달 합니다. 경우는 <xref:System.ICustomFormatter> 다음 단계 실행이 고, 그렇지 않으면 구현 제공 되며 문자열 인수를 문자열 표현으로 반환 되는 null이 아닌 문자열을 생성 합니다.  
  
-   인수를 구현 하는 경우는 <xref:System.IFormattable> 인터페이스를 해당 <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> 구현이 호출 됩니다.  
  
-   인수의 매개 변수가 없는 `ToString` 메서드를 재정의 하거나 기본 클래스 구현에서 상속, 라고 합니다.  
  
 에 대 한 호출을 가로채는 예는 <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> 메서드 어떤 정보를 볼 수 있습니다 합니다 <xref:System.String.Format%2A> 메서드가 전달 복합 형식 문자열의 각 서식 항목에 대 한 형식 지정 메서드를 참조 하세요 [예제: 절편 공급자로 및 로마 숫자 포맷터](#Format7_Example)합니다.  

 자세한 내용은 참조 하세요. 합니다 [처리 순서](~/docs/standard/base-types/composite-formatting.md##processing-order) 섹션을 [복합 서식 지정](~/docs/standard/base-types/composite-formatting.md) 문서.  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>동일한 인덱스에 있는 형식 항목  
 합니다 <xref:System.String.Format%2A> 메서드가 throw를 <xref:System.FormatException> 인덱스 항목의 인덱스는 인수 목록의 인수 개수 보다 크거나 같으면 예외입니다. 그러나 `format` 여러 서식 항목이 동일한 인덱스를가지고 있다면 인수가 있으면 것 보다 많은 수의 서식 항목이 포함 될 수 있습니다. 호출에는 <xref:System.String.Format%28System.String%2CSystem.Object%29> 다음 예제에서는 인수 목록에에서 메서드는 단일 인수를 갖지만 형식 문자열에 두 개의 형식 항목이 포함 되어: 숫자의 소수 값이 표시 됩니다 하나 및 다른 16 진수 값을 표시 합니다.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>서식 지정 및 문화권  
 일반적으로 인수 목록의 개체에서 반환 하는 현재 문화권의 규칙을 사용 하 여 해당 문자열 표현으로 변환 됩니다는 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 속성입니다. 오버 로드 중 하나를 호출 하 여이 동작을 제어할 수 있습니다 <xref:System.String.Format%2A> 포함 하는 한 `provider` 매개 변수입니다. 합니다 `provider` 매개 변수는는 <xref:System.IFormatProvider> 구현 형식을 조정 하는 데 사용 되는 사용자 지정 및 문화권별 형식 지정 정보를 제공 하는 프로세스입니다.  
  
 합니다 <xref:System.IFormatProvider> 인터페이스에는 단일 멤버인 <xref:System.IFormatProvider.GetFormat%2A>는 서식 지정 정보를 제공 하는 개체를 반환 하는 일을 담당 합니다. .NET에는 3 개의 <xref:System.IFormatProvider> culture 별 서식 지정을 제공 하는 구현 합니다.  
  
-   <xref:System.Globalization.CultureInfo>. 해당 <xref:System.Globalization.CultureInfo.GetFormat%2A> 메서드는 문화권별 <xref:System.Globalization.NumberFormatInfo> 숫자 값 및 culture 별 서식 지정에 대 한 개체 <xref:System.Globalization.DateTimeFormatInfo> 날짜 및 시간 값의 서식을 지정 하는 것에 대 한 개체입니다.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>에서 날짜 및 시간 값의 문화권별 서식 지정에 사용 됩니다. 해당 <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> 메서드 자체를 반환 합니다.  
  
-   <xref:System.Globalization.NumberFormatInfo>에서 숫자 값의 문화권별 서식 지정에 사용 됩니다. 해당 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 속성 자체를 반환 합니다. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>사용자 지정 서식 지정 작업  
 오버 로드 중 하나를 호출할 수도 있습니다는 <xref:System.String.Format%2A> 있는 메서드를 `provider` 형식의 매개 변수 <xref:System.IFormatProvider> 사용자 지정 서식 지정 작업을 수행 하 합니다. 예를 들어, 전화 번호 또는 id로 정수를 서식을 지정할 수 있습니다. 사용자 지정 형식 지정을 수행 하 여 `provider` 인수 둘 다 구현 해야 합니다는 <xref:System.IFormatProvider> 및 <xref:System.ICustomFormatter> 인터페이스입니다. 경우는 <xref:System.String.Format%2A> 메서드에 전달 됩니다는 <xref:System.ICustomFormatter> 구현으로는 `provider` 인수를를 <xref:System.String.Format%2A> 메서드 호출 해당 <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 구현 형식의 개체를 요청 하 고 <xref:System.ICustomFormatter>합니다. 그런 다음 반환 된 호출 <xref:System.ICustomFormatter> 개체의 <xref:System.ICustomFormatter.Format%2A> 복합 문자열의 각 서식 항목 형식을 지정 메서드를 전달 합니다.  
  
 사용자 지정 형식 지정 솔루션을 제공 하는 방법에 대 한 자세한 내용은 참조 하세요. [방법: 정의 및 사용 하 여 사용자 지정 숫자 서식 공급자](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) 고 <xref:System.ICustomFormatter>입니다. 서식이 지정 된 사용자 지정 숫자 정수를 변환 하는 예제를 보려면 [예제: 사용자 지정 서식 지정 작업](#Format6_Example)합니다. 부호 없는 바이트 로마 숫자 변환 하는 예제를 보려면 [예제: 절편 공급자 및 로마 숫자 포맷터를](#Format7_Example)입니다.  
  
<a name="Format6_Example" />  
### <a name="example-a-custom-formatting-operation"></a>예: 사용자 지정 서식 지정 작업  
 이 예제에서는 폼 x-xxxxx-xx에서 고객 계정 번호로 정수 값의 서식을 지정 하는 형식 공급자를 정의 합니다.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example" />  
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>예:는 절편 공급자 및 로마 숫자 포맷터  
 구현 하는 사용자 지정 형식 공급자를 정의 하는이 예제는 <xref:System.ICustomFormatter> 고 <xref:System.IFormatProvider> 두 작업을 수행 하는 인터페이스:  
  
-   전달 된 매개 변수 표시 해당 <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> 구현 합니다. 매개 변수를 볼 수 있게 된 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 메서드 형식을 지정 하려고 하는 각 개체에 대 한 사용자 지정 서식 지정 구현에 전달 됩니다. 이 응용 프로그램을 디버깅할 때 유용할 수 있습니다.  
  
-   서식을 지정할 개체는 "R" 표준 서식 문자열을 사용 하 여 형식을 지정할 수 있는 부호 없는 바이트 값 이면 사용자 지정 포맷터 서식을 로마 숫자를 숫자 값을 지정 합니다.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String.Format q&a  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>왜 합니까 문자열 보간에 대 한 호출을 통해는 `String.Format` 메서드?

문자열 보간 다음과 같습니다.

- 더 유연 합니다. 사용할 수 있습니다 임의의 문자열 합성 서식 지정을 지 원하는 메서드를 호출 하지 않아도 됩니다. 호출 해야 하는 고, 그렇지 합니다 <xref:System.String.Format%2A> 와 같은 복합 서식 지정을 지 원하는 다른 메서드나 메서드 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 또는 <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>합니다. 

- 더 쉽게 읽을 수 있습니다. 식을 문자열에 삽입 하려면 보간된 식에서 보다 인수 목록에 나타나므로 보간된 문자열은 코드를 읽기를 훨씬 간단 합니다. 큰 가독성을 위해 인해 보간된 문자열 뿐만 아니라 메서드 호출을 복합 형식, 바꿀 있지만 데도 사용할 수 있습니다 문자열 연결 연산에서 보다 간결 하 고 명확 하 게 코드를 생성 합니다. 

다음 두 코드 예제에서는 비교 문자열 연결 및 복합 형식 지정 메서드 호출을 통해 보간된 문자열의 우월성을 보여 줍니다. 다음 예제에서는 여러 문자열 연결 작업 사용 세부 정보 표시 및 읽기에 하드 코드를 생성합니다.

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

다음 예제에서 보간된 문자열을 사용할 문자열 연결 문 및 호출 보다 훨씬 명확 하 게, 더 간결한 코드를 생성 하는 반면,는 <xref:System.String.Format%2A> 이전 예제의 메서드.

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>형식 항목을 사용 하 여 사용할 수 있는 미리 정의 된 형식 문자열 목록을 찾기  
  
-   모든 정수 계열 및 부동 소수점 형식에 대 한 참조 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   날짜 및 시간 값에 대 한 참조 [표준 날짜 및 시간 서식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 하 고 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다.  
  
-   열거형 값을 참조 하세요 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
-   에 대 한 <xref:System.TimeSpan> 값을 참조 하세요 [표준 TimeSpan 서식 문자열](~/docs/standard/base-types/standard-timespan-format-strings.md) 하 고 [사용자 지정 TimeSpan 서식 문자열](~/docs/standard/base-types/custom-timespan-format-strings.md)합니다.  
  
-   에 대 한 <xref:System.Guid> 의 설명 섹션을 참조 하는 값은 <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> 참조 페이지입니다.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>형식 항목을 대체 하는 결과 문자열의 맞춤을 제어 하는 방법  
 형식 항목의 일반 구문은 다음과 같습니다.  
  
```  
{index[,alignment][: formatString]}  
```  
  
 여기서 *맞춤* 필드 너비를 정의 하는 부호 있는 정수입니다. 이 값이 음수 이면 필드의 텍스트를 왼쪽에 맞춥니다. 양수 이면 텍스트를 오른쪽에 맞춥니다.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>소수 구분 기호 뒤의 자릿수를 제어 하는 방법  
 모든 [표준 숫자 서식 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md) (정수로 사용 됨)는 "D", "G", "R"을 제외 하 고 및 "X"는 결과 문자열의 소수 자릿수를 정의 하는 전체 자릿수 지정자를 허용 합니다. 다음 예제에서는 결과 문자열의 소수 자릿수의 수를 제어 하려면 표준 숫자 서식 문자열을 사용 합니다.  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 사용 중인 경우는 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md), "0" 형식 지정자를 사용 하 여 다음 예와 같이 결과 문자열에서 소수 자릿수를 제어 합니다.  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>정수 자릿수를 제어 하는 방법  
 기본적으로 서식 지정 작업만 0이 아닌 정수 자릿수를 표시 합니다. 정수 형식을 지정 하는 경우 소수 자릿수를 제어 하는 전체 자릿수 지정자 "D"와 "X" 표준 서식 문자열을 사용할 수 있습니다.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 "0"을 사용 하 여 지정된 된 수의 정수 자릿수를 사용 하 여 결과 문자열을 생성 하는 정수 또는 부동 소수점 숫자 앞에 오는 0를 채울 수 있습니다 [사용자 지정 숫자 서식 지정자](~/docs/standard/base-types/custom-numeric-format-strings.md)다음 예제와 같이 합니다.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>형식 목록에서 포함할 수 있는 항목 수는 있습니까?  
 실용적인 제한은 없습니다. 두 번째 매개 변수를 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 메서드는으로 태그가 지정 됩니다는 <xref:System.ParamArrayAttribute> 특성을 구분 기호로 분리 된 목록 또는 형식 목록으로 개체 배열을 포함할 수 있습니다.  
  
<a name="braces" />
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>리터럴 중괄호를 포함 하는 방법 ("{" 및 "}")는 결과 문자열에?  
 예를 들어, 영향을 최소화 하는 다음 메서드 호출에서 throw 된 <xref:System.FormatException> 예외?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 항상 여는 중괄호와 닫는 중괄호의 단일 시작 또는 형식 항목의 끝으로 해석 됩니다. 문자 그대로 해석 되도록 이스케이프 되어야 합니다. 다른 중괄호를 추가 하 여 중괄호를 이스케이프 ("{{" 및 "}}" 대신 "{0}" 및 "}"), 다음 메서드 호출 에서처럼에서:  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 그러나 이스케이프 된 중괄호는 쉽게 잘못 해석 된 합니다. 형식 목록에서 중괄호를 포함 하는 형식 항목을 사용 하 여 다음 예와 같이 결과 문자열에 삽입 하는 것이 좋습니다.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>String.Format 메서드 호출 내는 FormatException를 throw 하는 이유  
 예외는 가장 일반적인 원인은 아니지만 형식 항목의 인덱스 형식 목록에서 개체에 해당 하지 않습니다. 일반적으로이 형식 항목의 인덱스를 misnumbered 했습니다 또는 형식 목록에서 개체를 포함 하려면 잊어버린 나타냅니다. 문자는 이스케이프 되지 않은 왼쪽 또는 오른쪽 중괄호를 포함 하는 동안도 throw를 <xref:System.FormatException>입니다. 경우에 따라 예외 결과인 오타가; 일반적인 실수를 잘못 입력 방법은 예를 들어, "[" (왼쪽된 대괄호) 대신 "{0}" (왼쪽된 중괄호).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Format(System.IFormatProvider,System.String,System.Object[]) 메서드 매개 변수 배열을 지 원하는 경우 이유 코드 예외를 throw지 않습니다 배열을 사용 하는 경우?  
 예를 들어, 다음 코드 throw를 <xref:System.FormatException> 예외:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 이 컴파일러 오버 로드 확인에 문제가 있는 경우 호출 하므로 정수 배열을 단일 인수로 처리 컴파일러 정수 배열을 개체 배열을으로 변환할 수 없는 때문에 <xref:System.String.Format%28System.String%2CSystem.Object%29> 메서드. 4 개의 형식 항목이 있지만 형식 목록에서 항목을 단일 있기 때문에 예외가 발생 합니다.  
  
 호출 하기 전에 사용자가 직접 변환을 수행 해야 하는 Visual Basic 또는 C# 모두 정수 배열을 개체 배열로 변환할 수, 있으므로 <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> 메서드. 다음 예제에는 하나의 구현을 제공합니다.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

호출 하는 다양 한 예제는 <xref:System.String.Format%2A> 메서드를 통해 섞여는 합니다 [주의](#remarks) 이 문서의 섹션입니다.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

전체 집합을 다운로드할 수도 있습니다 `String.Format` 포함 된 예는 [C#에 대 한.NET Core 2.0 프로젝트](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) 와 [Visual basic.NET Core 2.0 프로젝트](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip)에서 [dotnet / 샘플 GitHub 리포지토리](https://github.com/dotnet/samples)합니다.

다음은 일부 문서에 포함 된 예제입니다.

### <a name="create-a-format-string"></a>형식 문자열을 만들려면

[문자열을 삽입](#inserting-a-string)  
[형식 항목](#the-format-item)  
[동일한 인덱스에 있는 형식 항목](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>서식이 지정 된 출력 제어

[서식 제어](#controlling-formatting)  
[간격을 제어합니다.](#controlling-spacing)  
[맞춤을 제어합니다.](#controlling-alignment)  
[정수 자릿수를 제어합니다.](#how-do-i-control-the-number-of-integral-digits)  
[소수 자릿수를 소수 구분 기호 뒤 제어](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[결과 문자열에 리터럴 중괄호를 포함 하 여](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>문화권 구분 서식 문자열 확인

[문화권 구분 서식 지정](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>서식 지정 작업을 사용자 지정

[사용자 지정 서식 지정 작업](#example-a-custom-formatting-operation)  
[절편 공급자 및 로마 숫자 포맷터](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">표준 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">사용자 지정 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">표준 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">사용자 지정 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">열거형 형식 문자열</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="arg0">형식을 지정할 개체입니다.</param>
        <summary>문자열에 있는 하나 이상의 형식 항목을 지정된 개체의 문자열 표현으로 바꿉니다.</summary>
        <returns>서식 지정 항목이 <paramref name="format" />의 문자열 표현으로 바뀌는 <paramref name="arg0" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 값 식의 문자열 표현으로 변환 하 고 문자열에서 표현을 포함 합니다. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>예: 단일 인수를 서식 지정  
 
 다음 예제에서는 <xref:System.String.Format%28System.String%2CSystem.Object%29> 문자열 중 개인의 기간을 포함 하는 방법입니다.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />의 서식 항목이 올바르지 않습니다.  
  
또는 
서식 항목의 인덱스가 0이 아닙니다.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">표준 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">사용자 지정 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">표준 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">사용자 지정 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">열거형 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="args">형식을 지정할 개체를 0개 이상 포함하는 개체 배열입니다.</param>
        <summary>지정된 문자열의 형식 항목을 지정된 배열에 있는 해당 개체의 문자열 표현으로 바꿉니다.</summary>
        <returns>형식 항목을 <paramref name="format" />에 있는 해당 개체의 문자열 표현으로 바꾼 <paramref name="args" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 4 개 이상의 식의 값을 해당 문자열 표현으로 변환 하 고 문자열에 이러한 표현이 포함 합니다. 하므로 합니다 `args` 매개 변수를 사용 하 여으로 <xref:System.ParamArrayAttribute?displayProperty=nameWithType> 특성을 전달할 수 있습니다 개체 메서드 또는 개별 인수로 <xref:System.Object> 배열 합니다. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>예: 세 개 이상의 인수를 서식 지정  
 
 이 예제에서는 특정 날짜에서 최고 / 최저 온도 데이터를 포함 하는 문자열을 만듭니다. 복합 형식 문자열에 C# 예제에서 5 개의 형식 항목이 및 Visual Basic 예제에서 6 개 있습니다. 해당 값의 문자열 표현 너비를 정의 하는 형식 항목의 두 및 첫 번째 형식 항목인 표준 날짜 및 시간 서식 문자열도 포함 합니다.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 배열 형식을 지정할 개체를 전달할 수도 있습니다 아니라 인수 목록입니다.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 또는 <paramref name="args" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
또는 
형식 항목의 인덱스가 0보다 작거나 <paramref name="args" /> 배열의 길이보다 크거나 같습니다.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">표준 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">사용자 지정 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">표준 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">사용자 지정 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">열거형 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="arg0">형식을 지정할 개체입니다.</param>
        <summary>지정된 문자열에 있는 하나의 형식 항목 또는 여러 개의 형식 항목을 해당하는 개체의 문자열 표현으로 바꿉니다. 매개 변수에서 문화권별 서식 지정 정보를 제공합니다.</summary>
        <returns>하나의 형식 항목 또는 여러 개의 형식 항목이 <paramref name="format" />의 문자열 표현으로 바뀌는 <paramref name="arg0" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 값 식의 문자열 표현으로 변환 하 고 문자열에서 표현을 포함 합니다. 변환 수행, 메서드가 문화권 구분 서식 지정 또는 사용자 지정 포맷터를 사용 합니다. 메서드 변환 `arg0` 를 호출 하 여 해당 문자열 표현에 해당 **ToString(IFormatProvider)** 메서드 또는 서식 항목 형식 문자열을 호출 하 여 포함 개체의 해당 하는 경우 해당 **ToString ( String, IFormatProvider)** 메서드. 이러한 메서드는 존재 하지 않거나, 호출 개체의 매개 변수가 없는 **ToString** 메서드.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
또는 
서식 항목의 인덱스가 0이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="args">형식을 지정할 개체를 0개 이상 포함하는 개체 배열입니다.</param>
        <summary>문자열의 형식 항목을 지정된 배열에 있는 해당 개체의 문자열 표현으로 바꿉니다. 매개 변수에서 문화권별 서식 지정 정보를 제공합니다.</summary>
        <returns>형식 항목을 <paramref name="format" />에 있는 해당 개체의 문자열 표현으로 바꾼 <paramref name="args" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 4 개 이상의 식을 해당 문자열 표현으로 변환 하 고 이러한 표현이 문자열에 포함 합니다. 변환 수행, 메서드가 문화권 구분 서식 지정 또는 사용자 지정 포맷터를 사용 합니다. 메서드가 변환 하는 각 <xref:System.Object> 인수를 호출 하 여 해당 문자열 표현에 해당 **ToString(IFormatProvider)** 메서드 서식 항목 형식 문자열을 해당 를호출하여포함개체의해당하는경우또는**ToString(String,IFormatProvider)** 메서드. 이러한 메서드는 존재 하지 않거나, 호출 개체의 매개 변수가 없는 **ToString** 메서드.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>예: 문화권 구분 서식 지정  
 이 예제에서는 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 몇 가지 다른 문화권을 사용 하 여 일부 날짜 및 시간 값 및 숫자 값의 문자열 표현을 표시 하는 방법입니다.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 또는 <paramref name="args" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
또는 
형식 항목의 인덱스가 0보다 작거나 <paramref name="args" /> 배열의 길이보다 크거나 같습니다.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">표준 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">사용자 지정 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">표준 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">사용자 지정 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">열거형 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <summary>문자열에 있는 서식 지정 항목을 지정된 두 개체의 문자열 표현으로 바꿉니다.</summary>
        <returns>서식 지정 항목이 <paramref name="format" /> 및 <paramref name="arg0" />의 문자열 표현으로 바뀌는 <paramref name="arg1" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 두 식의 값을 해당 문자열 표현으로 변환 하 고 이러한 표현이 문자열에 포함 합니다. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>예: 두 개의 인수를 서식 지정  
 
 이 예제에서는 합니다 <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> 제네릭에 저장 하는 시간 및 온도 데이터를 표시 하는 방법 <xref:System.Collections.Generic.Dictionary%602> 개체입니다. 형식 문자열에 세 개의 형식 항목이 있더라도 다음 두 개의 형식을 지정할 개체를 참고 합니다. (날짜 및 시간 값) 목록에서 첫 번째 개체를 사용 하는 두 형식 항목 이므로: 첫 번째 형식 항목 표시 하는 시간 및 두 번째 날짜를 표시 합니다.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
또는 
형식 항목의 인덱스가 0 또는 1입니다.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">표준 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">사용자 지정 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">표준 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">사용자 지정 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">열거형 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <summary>문자열에 있는 서식 지정 항목을 지정된 두 개체의 문자열 표현으로 바꿉니다. 매개 변수에서 문화권별 서식 지정 정보를 제공합니다.</summary>
        <returns>서식 지정 항목이 <paramref name="format" /> 및 <paramref name="arg0" />의 문자열 표현으로 바뀌는 <paramref name="arg1" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 두 식을 해당 문자열 표현으로 변환 하 고 이러한 표현이 문자열에 포함 합니다. 변환 수행, 메서드가 문화권 구분 서식 지정 또는 사용자 지정 포맷터를 사용 합니다. 메서드가 변환 하는 각 <xref:System.Object> 인수를 호출 하 여 해당 문자열 표현에 해당 **ToString(IFormatProvider)** 메서드 서식 항목 형식 문자열을 해당 를호출하여포함개체의해당하는경우또는**ToString(String,IFormatProvider)** 메서드. 이러한 메서드는 존재 하지 않거나, 호출 개체의 매개 변수가 없는 **ToString** 메서드.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
또는 
형식 항목의 인덱스가 0 또는 1입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <param name="arg2">서식을 지정할 세 번째 개체입니다.</param>
        <summary>문자열에 있는 서식 지정 항목을 지정된 세 개체의 문자열 표현으로 바꿉니다.</summary>
        <returns>형식 항목이 <paramref name="format" />, <paramref name="arg0" /> 및 <paramref name="arg1" />의 문자열 표현으로 바뀌는 <paramref name="arg2" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 세 가지 식의 값을 해당 문자열 표현으로 변환 하 고 문자열에 이러한 표현이 포함 합니다. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>예: 세 개의 인수를 서식 지정  
 
 이 예제에서는 합니다 <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 메서드는 부울 결과 보여 주는 문자열을 만들려면 `And` 두 정수 값을 사용 하 여 작업 합니다. 두 가지 방법으로 각 항목 형식이 있으므로 형식 문자열에 6 개의 형식 항목이 포함 되지만 메서드 매개 변수 목록에서 세 개의 항목이 note 합니다.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
또는 
형식 항목의 인덱스가 0보다 작거나, 2보다 큽니다.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">[복합 형식 문자열](~/docs/standard/base-types/composite-formatting.md)입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <param name="arg2">서식을 지정할 세 번째 개체입니다.</param>
        <summary>문자열에 있는 서식 지정 항목을 지정된 세 개체의 문자열 표현으로 바꿉니다. 매개 변수에서 문화권별 형식 지정 정보를 제공합니다.</summary>
        <returns>형식 항목이 <paramref name="format" />, <paramref name="arg0" /> 및 <paramref name="arg1" />의 문자열 표현으로 바뀌는 <paramref name="arg2" />의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 세 개의 식을 해당 문자열 표현으로 변환 하 고 이러한 표현이 문자열에 포함 합니다. 변환 수행, 메서드가 문화권 구분 서식 지정 또는 사용자 지정 포맷터를 사용 합니다. 메서드가 변환 하는 각 <xref:System.Object> 인수를 호출 하 여 해당 문자열 표현에 해당 **ToString(IFormatProvider)** 메서드 서식 항목 형식 문자열을 해당 를호출하여포함개체의해당하는경우또는**ToString(String,IFormatProvider)** 메서드. 이러한 메서드는 존재 하지 않거나, 호출 개체의 매개 변수가 없는 **ToString** 메서드.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" />이 잘못되었습니다.  
  
또는 
형식 항목의 인덱스가 0보다 작거나, 2보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 문자열의 개별 문자에서 반복될 수 있는 개체를 검색합니다.</summary>
        <returns>열거자 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> 호출 하는 대신 합니다 <xref:System.String.GetEnumerator%2A> 검색 하는 메서드를 <xref:System.CharEnumerator> 개체는 다음 문자열을 열거 하려면 사용할 언어의 반복 구문을 대신 사용 해야 (C#, C + + CLR 및 Visual Basic). [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) C#에서는 [각각에 대해](/cpp/dotnet/for-each-in) C + + CLR 및 [각각에 대해](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) Visual basic에서).
  
 이 메서드를 사용 하면 문자열의 개별 문자를 반복할 수 있습니다. 예를 들어, Visual Basic `For Each` 및 C# `foreach` 문을 반환 하도록이 메서드를 호출을 <xref:System.CharEnumerator> 이 문자열 인스턴스의 문자에 대 한 읽기 전용 액세스를 제공할 수 있는 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 여러 문자열의 문자를 반복 하 고 해당 개별 문자에 대 한 정보를 표시 합니다. 호출 하지 않고 언어 반복 구문을 사용 하 여는 <xref:System.String.GetEnumerator%2A> 메서드.  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>해당 문자열에 대한 해시 코드를 반환합니다.</summary>
        <returns>부호 있는 32비트 정수 해시 코드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동작 <xref:System.String.GetHashCode%2A> 다른 공용 언어 런타임의 버전 간에 변경 될 수 있는 해당 구현에 따라 달라 집니다. 이 문제가 발생 하는 이유는 성능을 개선 하기 위해 <xref:System.String.GetHashCode%2A>합니다.  
  
> [!IMPORTANT]
>  두 string 개체 같으면는 <xref:System.String.GetHashCode%2A> 메서드 같은 값을 반환 합니다. 그러나 각 고유한 문자열 값에 대 한 고유 해시 코드 값 하지입니다. 다른 문자열에는 같은 해시 코드를 반환할 수 있습니다.  
>   
>  자체 해시 코드를 안정적인 것으로 보장 되지 않습니다. 동일한 문자열에 대 한 해시 코드는.NET 구현에서.NET 버전 간에 및 단일 버전의.NET에 대 한.NET 플랫폼 (예: 32 비트 및 64 비트) 간에 달라질 수 있습니다. 일부 경우에도 응용 프로그램 도메인 별로 다릅니다 수 있습니다. 즉, 동일한 프로그램의 후속 실행을 두는 서로 다른 해시 코드를 반환할 수 있습니다.  
>   
>  결과적으로 코드 생성 된 응용 프로그램 도메인 외부에서 사용 되지 않아야 하는 해시 컬렉션의 키 필드를 사용 하지 않아야 및 유지 되지 해야 합니다.  
>   
>  마지막으로 없는 암호화 된 강력한 해시 해야 하는 경우 암호화 해시 함수에서 반환 된 값 대신 해시 코드를 사용 합니다. 암호화 해시, 파생 클래스를 사용 합니다 <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> 또는 <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> 클래스입니다.  
>   
>  해시 코드에 대 한 자세한 내용은 참조 하세요. <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
 데스크톱 앱에서 사용할 수 있습니다 합니다 [ \<UseRandomizedStringHashAlgorithm > 요소](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) 의 고유 해시 코드를 생성 하는 응용 프로그램 도메인 별로 합니다. 이 충돌을 줄이려면 하 고 삽입 및 해시 테이블을 사용 하는 조회의 전반적인 성능을 향상 시킬 수 있습니다. 다음 예제에서는 사용 하는 방법을 보여 줍니다 합니다 [ \<UseRandomizedStringHashAlgorithm > 요소](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)합니다. 정의의 고유 해시 코드를 생성 하는 응용 프로그램 도메인 별로 합니다. 이 충돌을 줄이려면 하 고 삽입 및 해시 테이블을 사용 하는 조회의 전반적인 성능을 향상 시킬 수 있습니다. 다음 예제에서는 사용 하는 방법을 표시 합니다. 정의 된 `DisplayString` private 문자열 상수를 포함 하는 클래스 `s`, 값인 "는 문자열입니다." 메서드를 실행하는 응용 프로그램 도메인의 이름과 함께 문자열 값 및 해시 코드를 표시하는 `ShowStringHashCode` 메서드도 포함합니다.  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 구성 파일을 지정하지 않고 이 예제를 실행할 경우 다음과 유사한 출력이 표시됩니다. 문자열의 해시 코드는 두 응용 프로그램 도메인에서 동일합니다.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 하지만 샘플 디렉터리에 다음의 구성을 추가하고 샘플을 실행하는 경우 동일 문자열의 해시 코드는 응용 프로그램 도메인에 의해 달라집니다.  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 구성 파일이 있는 경우 예제는 다음과 같은 출력을 표시합니다.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  해시 코드는 삽입 및 해시 테이블에서 키가 지정 된 개체를 효율적으로 검색에 사용 됩니다. 그러나 해시 코드 문자열을 고유 하 게 식별 하지 않습니다. 동일한 문자열은 같은 해시 코드를 갖지만 공용 언어 런타임에서 다른 문자열에는 같은 해시 코드를 할당할 수도 있습니다. 또한, 해시 코드는.NET 버전, 단일 버전 내에서 플랫폼 및 응용 프로그램 도메인 별로 달라질 수 있습니다. 이 인해 직렬화 또는 해시 코드 값을 유지 해야 하거나 해시 테이블 또는 사전에서 키로 사용 합니다.  
  
 해시 코드를 사용 하는 방법에 대 한 자세한 내용은 하며 `GetHashCode` 메서드를 참조 하세요 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.GetHashCode%2A> 다양 한를 사용 하 여 메서드 입력 문자열입니다.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>반환한 값 <see cref="M:System.String.GetHashCode" /> 은 플랫폼에 따라 다릅니다. 32 비트 및 64 비트 버전의.NET Framework에서 달라 집니다. .NET Core와.NET Framework의 버전 간에 달라질 수 있습니다 것입니다.</para>
        </block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; 요소</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.TypeCode" /> 클래스에 대한 <see cref="T:System.String" />를 반환합니다.</summary>
        <returns>열거형 상수인 <see cref="F:System.TypeCode.String" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 표시를 <xref:System.TypeCode> 에 대 한 열거 된 상수를 <xref:System.String> 형식.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스에서 맨 처음 발견되는 지정된 유니코드 문자 또는 문자열의 0부터 시작하는 인덱스를 보고합니다. 이 인스턴스에 해당 문자나 문자열이 없으면 이 메서드는 -1을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">검색할 유니코드 문자입니다.</param>
        <summary>이 문자열에서 맨 처음 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스를 보고합니다.</summary>
        <returns>해당 문자가 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 그러지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면 사용 합니다 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드, 여기서는 미리 구성 된 문자를 나타내는 합자 "→"와 같은 (U + 00 6), 유니코드 스칼라 값 간주 될 수 있습니다 문자 구성 요소에서의 모든 항목에는 "AE" 등 시퀀스를 수정 (u+0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 방법을 검색할 수 있습니다는 <xref:System.String> 사용 하 여 문자를 <xref:System.String.IndexOf%2A> 메서드.  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <summary>이 인스턴스에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 그러지 않으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 0입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다.  
  
 이 메서드는 현재 문화권을 사용 하는 단어 (대/소문자 구분 및 문화권) 검색을 수행 합니다. 검색이 인스턴스의 첫 번째 문자 위치에서 시작 하 고 마지막 문자 위치까지 계속 됩니다.  
  
 문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 하는 경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어 합니다 <xref:System.String.IndexOf%28System.String%29> 메서드는 항상 일치 항목은 현재 인스턴스의 시작 부분에 있음을 나타내기 위해 0 (영)을 반환 합니다. 다음 예제에서는 <xref:System.String.IndexOf%28System.String%29> 메서드는 두 문자열의 세 가지 부분 문자열 (하이픈이 (U + 00AD), "n" 뒤에 하이픈이 및 하이픈이 뒤에 "m")을 찾는 데 사용 됩니다. 문자열 중 하나에만 사용자 지정 하이픈이 포함되어 있습니다. 예제를 실행 합니다 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상 버전을 각각의 경우에서 사용자 지정 하이픈은 무시할 수 있는 문자 때문에 결과 동일한 사용자 지정 하이픈의 포함 되지 않았던 것 처럼 `value`합니다. 하이픈이을 검색할 때 메서드는 문자열의 시작 부분에서 일치 항목을 발견 했다는 것을 나타내려면 0 (영)을 반환 합니다.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 다음 예제에서는 "animal"에서 "n"를 검색합니다. 문자열 인덱스를 보다는 0부터 시작 하므로 <xref:System.String.IndexOf%28System.String%29> 메서드 "n" 위치 1 임을 나타냅니다.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 다음 예제에서는 <xref:System.String.IndexOf%2A> 문장에서 동물 이름의 시작 위치를 결정 하는 방법입니다. 그런 다음이 위치를 사용 하 여 형용사를 문장에 동물을 설명 하는 삽입 합니다.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 문자열에 대 한 모범 사례](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다. 현재 문화권의 비교 규칙을 사용 하 여 문자열 인스턴스 내에서 부분 문자열의 첫 번째 인덱스를 찾으려고 호출을 <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 값을 사용 하 여 메서드 오버 로드 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 `comparisonType` 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 유니코드 문자입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <summary>이 문자열에서 맨 처음 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스를 보고합니다. 검색은 지정된 문자 위치에서 시작됩니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치는 문자열의 시작 부분에서 0부터 시작되고 해당 문자열이 없으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호 0부터 시작 합니다. `startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다. 경우 `startIndex` 문자열 인스턴스 길이 같으면,-1을 반환 합니다.  
  
 검색 범위에서 `startIndex` 문자열의 끝에 있습니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면 사용 합니다 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드, 여기서는 미리 구성 된 문자를 나타내는 합자 "→"와 같은 (U + 00 6), 유니코드 스칼라 값 간주 될 수 있습니다 문자 구성 요소에서의 모든 항목에는 "AE" 등 시퀀스를 수정 (u+0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.IndexOf%2A> 메서드.  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />이(가) 0보다 작거나 문자열의 길이보다 큽니다.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">찾을 문자입니다.</param>
        <param name="comparisonType">검색의 규칙을 지정하는 열거형 값입니다.</param>
        <summary>이 문자열에서 맨 처음 발견되는 지정된 유니코드 문자의 인덱스(0부터 시작)를 보고합니다. 매개 변수는 지정된 문자에 사용할 검색 형식을 지정합니다.</summary>
        <returns>해당 문자가 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

인덱스 번호는 0부터 시작합니다.  
  
`comparisonType` 매개 변수는를 <xref:System.StringComparison> 지정 하는 열거형 멤버 여부를 검색 합니다 `value` 인수는 대/소문자 구분 또는 대/소문자를, 단어 또는 서 수 비교 규칙을 사용 하 여 현재 또는 고정 문화권을 사용 합니다.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <summary>이 인스턴스에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다. 검색은 지정된 문자 위치에서 시작됩니다.</summary>
        <returns>해당 문자열이 있으면 현재 인스턴스의 시작 부분에서 <paramref name="value" /> 인덱스 위치(0부터 시작)이고, 해당 문자열이 없으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 <paramref name="startIndex" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호 0부터 시작 합니다. `startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다. 경우 `startIndex` 문자열 인스턴스 길이 같으면,-1을 반환 합니다.  
  
 이 메서드는 현재 문화권을 사용 하는 단어 (대/소문자 구분 및 문화권) 검색을 수행 합니다. 검색이 시작 된 `startIndex` 문자이 인스턴스의 위치 및 마지막 문자 위치까지 합니다.  
  
 문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 하는 경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어 합니다 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> 메서드는 항상 반환 `startIndex`, 검색을 시작할 문자 위치는입니다. 다음 예제에서는 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> 메서드는 두 문자열의 "m" 뒤에 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다. 문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다. 예제를 실행 하는 경우는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 사용자 지정 하이픈은 무시할 수 있는 문자 때문에 메서드 반환 문자열에 "m"의 인덱스입니다. "m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다.  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 다음 예제에서는 대상 문자열에 지정된 된 문자열의 모든 항목에 대 한 검색합니다.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 0보다 작거나 이 문자열의 길이보다 큽니다.</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 문자열에 대 한 모범 사례](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다. 현재 문화권의 비교 규칙을 사용 하 여 특정 문자 위치 후 발생 하는 부분 문자열의 첫 번째 인덱스를 찾으려면, 호출 된 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 값을 사용 하 여 메서드 오버 로드 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 `comparisonType` 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="comparisonType">검색 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다. 매개 변수는 지정된 문자열에 사용할 검색 유형을 지정합니다.</summary>
        <returns>문자열이 있으면 <paramref name="value" /> 매개 변수의 인덱스 위치이고, 그러지 않으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 0입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다.  
  
 합니다 `comparisonType` 매개 변수를 검색 하도록 지정 합니다 `value` 현재 또는 고정 문화권을 사용 하 고 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 오버 로드는 <xref:System.String.IndexOf%2A> 의 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 처음 발견 하는 메서드를 <xref:System.StringComparison> 열거형입니다.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 하는 경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어 합니다 <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 메서드는 항상 일치 항목은 현재 인스턴스의 시작 부분에 있음을 나타내기 위해 0 (영)을 반환 합니다.  
  
다음 예제에서는 <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 메서드는 두 문자열의 세 가지 부분 문자열 (하이픈이 (U + 00AD), "n" 뒤에 하이픈이 및 하이픈이 뒤에 "m")을 찾는 데 사용 됩니다. 문자열 중 하나에만 사용자 지정 하이픈이 포함되어 있습니다. 예제를 실행 하는 경우는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 나중에 사용자 지정 하이픈을 무시할 수 있는 문자 이기 때문에 문화권 구분 검색을 반환 하거나 검색 문자열에 사용자 지정 하이픈이 포함 되지 않은 경우 반환 된 값과 같아야 합니다. 그러나 서 수 검색을 성공적으로 사용자 지정 하이픈 한 문자열에서 찾아 보고 없는 것에서 두 번째 문자열입니다.  
  
[! 코드 csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [! 코드 vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 유니코드 문자입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <summary>이 인스턴스에서 맨 처음 발견되는 지정된 문자의 0부터 시작하는 인덱스를 보고합니다. 검색은 지정된 문자 위치에서 시작하여 지정된 수의 문자 위치를 검사합니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치는 문자열의 시작 부분에서 0부터 시작되고 해당 문자열이 없으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검색이 시작 `startIndex` 계속 `startIndex`  +  `count` -1입니다. 에 있는 문자가 `startIndex`  +  `count` 검색에 포함 되지 않습니다.  
  
 인덱스 번호 0 (영)부터 시작 합니다. `startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면 사용 합니다 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드, 여기서는 미리 구성 된 문자를 나타내는 합자 "→"와 같은 (U + 00 6), 유니코드 스칼라 값 간주 될 수 있습니다 문자 구성 요소에서의 모든 항목에는 "AE" 등 시퀀스를 수정 (u+0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.IndexOf%2A> 메서드.  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.  
  
또는 
 <paramref name="startIndex" />가 이 문자열의 길이보다 큽니다.  
  
또는 
 <paramref name="count" />가 이 문자열의 길이에서 <paramref name="startIndex" />를 뺀 값보다 큽니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <summary>이 인스턴스에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다. 검색은 지정된 문자 위치에서 시작하여 지정된 수의 문자 위치를 검사합니다.</summary>
        <returns>해당 문자열이 있으면 현재 인스턴스의 시작 부분에서 <paramref name="value" /> 인덱스 위치(0부터 시작)이고, 해당 문자열이 없으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 <paramref name="startIndex" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호 0 (영)부터 시작 합니다. `startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다.  
  
 이 메서드는 현재 문화권을 사용 하는 단어 (대/소문자 구분 및 문화권) 검색을 수행 합니다. 검색이 시작 `startIndex` 계속 `startIndex`  +  `count` -1입니다. 에 있는 문자가 `startIndex`  +  `count` 검색에 포함 되지 않습니다.  
  
 문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 하는 경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어 합니다 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> 메서드는 항상 반환 `startIndex`, 검색을 시작할 문자 위치는입니다. 다음 예제에서는 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> 메서드는 두 문자열의 여섯 번째 문자 위치부터 세 번째에서 시작 "m" 뒤에 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다. 문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다. 예제를 실행 하는 경우는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 사용자 지정 하이픈은 무시할 수 있는 문자 때문에 메서드 반환 문자열에 "m"의 인덱스 문화권 구분 비교를 수행 하는 경우. "m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다.  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 다음 예제에서는 문자열의 모든 항목의 인덱스를 찾습니다 다른 문자열의 부분 문자열에 있는 "he"입니다. 참고 검색할 문자의 수 검색 반복할 때마다 다시 계산 되어야 합니다.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.  
  
또는 
 <paramref name="startIndex" />가 이 문자열의 길이보다 큽니다.  
  
또는 
 <paramref name="count" />가 이 문자열의 길이에서 <paramref name="startIndex" />를 뺀 값보다 큽니다.</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 문자열에 대 한 모범 사례](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다. 이 작업을 수행 하려면 현재 문화권의 비교 규칙을 사용 하려면 호출을 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 값을 사용 하 여 메서드 오버 로드 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 `comparisonType` 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <param name="comparisonType">검색 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다. 매개 변수는 현재 문자열의 검색 시작 위치와 지정된 문자열에 사용할 검색 유형을 지정합니다.</summary>
        <returns>해당 문자열이 있으면 현재 인스턴스의 시작 부분에서 <paramref name="value" /> 매개 변수의 인덱스 위치(0부터 시작)이고, 없으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 <paramref name="startIndex" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호 0부터 시작 합니다. `startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다. 경우 `startIndex` 문자열 인스턴스 길이 같으면,-1을 반환 합니다.  
  
 합니다 `comparisonType` 매개 변수를 검색 하도록 지정 합니다 `value` 현재 또는 고정 문화권을 사용 하 고 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.  
  
   
  
## Examples  
 다음 exampledemonstrates 세 오버 로드는 <xref:System.String.IndexOf%2A> 의 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 처음 발견 하는 메서드를 <xref:System.StringComparison> 열거형입니다.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 0보다 작거나 이 문자열의 길이보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 하는 경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어 합니다 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드는 항상 반환 <paramref name="startIndex" />, 검색을 시작할 문자 위치는입니다.  
  
다음 예제에서는 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드는 "m"가 포함 된 두 문자열의 세 번째 문자 위치부터 뒤에 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다. 문자열 중 하나에만 필수 부분 문자열이 포함 되어 있습니다. 예제를 실행 하는 경우는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 사용자 지정 하이픈은 무시할 수 있는 문자 때문에 메서드 반환 문자열에 "m"의 인덱스 문화권 구분 비교를 수행 하는 경우. "m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다. 메서드는 서수 비교를 수행하는 경우에만 첫 번째 문자열에서 사용자 지정 하이픈의 인덱스를 반환합니다.  
  
[! 코드 csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [! 코드 vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <param name="comparisonType">검색 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 맨 처음 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다. 매개 변수는 현재 문자열의 검색 시작 위치, 검색할 현재 문자열의 문자 수 및 지정된 문자열에 사용할 검색 유형을 지정합니다.</summary>
        <returns>해당 문자열이 있으면 현재 인스턴스의 시작 부분에서 <paramref name="value" /> 매개 변수의 인덱스 위치(0부터 시작)이고, 없으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />인 경우 반환 값은 <paramref name="startIndex" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호 0 (영)부터 시작 합니다. `startIndex` 매개 변수의 범위는 0에서 문자열 인스턴스 길이 사이입니다.  
  
 검색이 시작 `startIndex` 계속 `startIndex`  +  `count` -1입니다. 에 있는 문자가 `startIndex`  +  `count` 검색에 포함 되지 않습니다.  
  
 합니다 `comparisonType` 매개 변수를 검색 하도록 지정 합니다 `value` 현재 또는 고정 문화권을 사용 하 고 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.  
  
   
  
## Examples  
 다음 exampledemonstrates 세 오버 로드는 <xref:System.String.IndexOf%2A> 의 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 처음 발견 하는 메서드를 <xref:System.StringComparison> 열거형입니다.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.  
  
또는 
 <paramref name="startIndex" />가 이 인스턴스의 길이보다 큽니다.  
  
또는 
 <paramref name="count" />가 이 문자열의 길이에서 <paramref name="startIndex" />를 뺀 값보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 하는 경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어 합니다 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드는 항상 반환 <paramref name="startIndex" />, 검색을 시작할 문자 위치는입니다.  
  
다음 예제에서는 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드는 두 문자열의 여섯 번째 문자 위치부터 세 번째에서 시작 "m" 뒤에 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다. 문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다. 예제를 실행 하는 경우는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 사용자 지정 하이픈은 무시할 수 있는 문자 때문에 메서드 반환 문자열에 "m"의 인덱스 문화권 구분 비교를 수행 하는 경우. 그러나 서 수 비교를 수행할 때 부분만에서 찾은 첫 번째 문자열입니다. 참고 첫 번째 문자열 뒤에 "m" 사용자 지정 하이픈을 포함 하는 메서드를 사용자 지정 하이픈의 인덱스를 반환 하지 못하고 있지만 문화권 구분 비교를 수행 하는 경우 대신 "m"의 인덱스를 반환 합니다. 메서드는 서수 비교를 수행하는 경우에만 첫 번째 문자열에서 사용자 지정 하이픈의 인덱스를 반환합니다.  
  
[! 코드 csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [! 코드 vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 유니코드 문자 배열에 있는 문자 중에서 이 인스턴스에서 맨 처음 발견되는 문자의 인덱스를 보고합니다. 이 인스턴스에 해당 문자가 없으면 메서드는 -1을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</param>
        <summary>지정된 유니코드 문자 배열에 있는 문자 중에 이 인스턴스에서 맨 처음 발견되는 문자의 0부터 시작하는 인덱스를 보고합니다.</summary>
        <returns>이 인스턴스에서 <paramref name="anyOf" />의 문자가 처음 발견된 인덱스 위치(0부터 시작)입니다. <paramref name="anyOf" />의 문자가 발견되지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다.  
  
 검색 `anyOf` 대/소문자 구분 합니다. 경우 `anyOf` 빈 배열에서 문자열의 시작 부분에서 일치 하는 방법 찾습니다 (즉, 인덱스 0에).  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면 사용 합니다 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드, 여기서는 미리 구성 된 문자를 나타내는 합자 "→"와 같은 (U + 00 6), 유니코드 스칼라 값 간주 될 수 있습니다 문자 구성 요소에서의 모든 항목에는 "AE" 등 시퀀스를 수정 (u+0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열에서 첫 번째 자음을 찾습니다.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <summary>지정된 유니코드 문자 배열에 있는 문자 중에 이 인스턴스에서 맨 처음 발견되는 문자의 0부터 시작하는 인덱스를 보고합니다. 검색은 지정된 문자 위치에서 시작됩니다.</summary>
        <returns>이 인스턴스에서 <paramref name="anyOf" />의 문자가 처음 발견된 인덱스 위치(0부터 시작)입니다. <paramref name="anyOf" />의 문자가 발견되지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. `startIndex` 매개 변수의 범위는 0에서 1 문자열 인스턴스 길이 보다 작은 값입니다.  
  
 검색 범위에서 `startIndex` 문자열의 끝에 있습니다.  
  
 검색 `anyOf` 대/소문자 구분 합니다.  
  
 이 메서드는 유니코드 스칼라 값은 동일한 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면 사용 합니다 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드, 여기서는 미리 구성 된 문자를 나타내는 합자 "→"와 같은 (U + 00 6), 유니코드 스칼라 값 간주 될 수 있습니다 문자 구성 요소에서의 모든 항목에는 "AE" 등 시퀀스를 수정 (u+0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다른 문자열의 부분 문자열에 있는 "is"는 문자열의 문자 인덱스를 찾습니다.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 음수입니다.  
  
또는 
 <paramref name="startIndex" />가 이 인스턴스의 문자 수보다 큽니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <summary>지정된 유니코드 문자 배열에 있는 문자 중에 이 인스턴스에서 맨 처음 발견되는 문자의 0부터 시작하는 인덱스를 보고합니다. 검색은 지정된 문자 위치에서 시작하여 지정된 수의 문자 위치를 검사합니다.</summary>
        <returns>이 인스턴스에서 <paramref name="anyOf" />의 문자가 처음 발견된 인덱스 위치(0부터 시작)입니다. <paramref name="anyOf" />의 문자가 발견되지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검색이 시작 `startIndex` 계속 `startIndex`  +  `count` -1입니다. 에 있는 문자가 `startIndex`  +  `count` 검색에 포함 되지 않습니다.  
  
 인덱스 번호는 0부터 시작합니다. `startIndex` 매개 변수의 범위는 0에서 1 문자열 인스턴스 길이 보다 작은 값입니다.  
  
 검색 `anyOf` 대/소문자 구분 합니다.  
  
 이 메서드는 유니코드 스칼라 값은 동일한 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면 사용 합니다 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 메서드, 여기서는 미리 구성 된 문자를 나타내는 합자 "→"와 같은 (U + 00 6), 유니코드 스칼라 값 간주 될 수 있습니다 문자 구성 요소에서의 모든 항목에는 "AE" 등 시퀀스를 수정 (u+0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다른 문자열의 부분 문자열에 있는 "참조" 문자열의 문자 검색 된 항목의 인덱스를 찾습니다.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.  
  
또는 
 <paramref name="count" /> + <paramref name="startIndex" />가 이 인스턴스의 문자 수보다 큽니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">삽입의 0부터 시작하는 인덱스 위치입니다.</param>
        <param name="value">삽입할 문자열입니다.</param>
        <summary>이 인스턴스의 지정된 인덱스 위치에 지정한 문자열이 삽입되는 새 문자열을 반환합니다.</summary>
        <returns>이 인스턴스와 동일하지만 <paramref name="value" /> 위치에 <paramref name="startIndex" />가 삽입된 새 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 `startIndex` 가이 인스턴스의 길이 같고 `value` 이 인스턴스의 끝에 추가 됩니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 새 문자열을 반환 하는 대신 `value` 가 현재 인스턴스에 삽입 합니다.  
  
 반환 값의 예를 들어 `"abc".Insert(2, "XYZ")` "abXYZc" 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 네 번째 문자 위치에 있는 (인덱스 3에는 문자) 문자열의 공백 문자를 삽입합니다.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 다음 콘솔 응용 프로그램 사용자에 게 두 동물을 설명 하기 위해 하나 이상의 형용사를 입력 합니다. 라는 메시지가 표시 됩니다. 그런 다음 호출 하 여 <xref:System.String.Insert%2A> 문자열로 사용자가 입력 한 텍스트를 삽입 하는 방법입니다.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 음수이거나 이 인스턴스의 길이보다 큽니다.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">내부 풀에서 검색할 문자열입니다.</param>
        <summary>지정된 <see cref="T:System.String" />에 대한 시스템의 참조를 검색합니다.</summary>
        <returns>
          <paramref name="str" />이 내부 풀에 추가되었으면 해당 시스템 참조이고, 그러지 않으면 <paramref name="str" /> 값을 가진 문자열에 대한 새 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 공용 언어 런타임 내부 풀 고유한 각 리터럴 문자열 선언 또는 프로그램에서 프로그래밍 방식으로 생성에 대 한 단일 참조를 포함 하는 라는 테이블을 유지 하 여 문자열 저장소를 절약 합니다. 따라서 특정 값을 사용 하 여 리터럴 문자열의 인스턴스만 한 번 시스템에 존재 합니다.  
  
 예를 들어, 여러 변수에 동일한 리터럴 문자열을 할당 하는 경우 런타임 내부 풀에서 리터럴 문자열에 같은 참조를 검색 및 각 변수에 할당 합니다.  
  
 합니다 <xref:System.String.Intern%2A> 메서드 내부 풀을 사용 하 여 문자열의 값을 검색 하려면 `str`합니다. 해당 문자열이 있으면 내부 풀에 해당 참조가 반환 됩니다. 문자열 존재 하지 않는 경우에 대 한 참조를 `str` 반환 되 고 참조 하는 내부 풀에 추가 됩니다.  
  
 다음 예제에서는 "MyTest"의 값에는 문자열 s1에 프로그램의 리터럴 이기 때문에 인턴 지정 이미 됩니다. <xref:System.Text.StringBuilder?displayProperty=nameWithType> 클래스 s1으로 동일한 값을 갖는 새 문자열 개체를 생성 합니다. 이 문자열에 대 한 참조는 s2에 할당 됩니다. <xref:System.String.Intern%2A> 메서드는 s2와 같은 값을 가진 문자열을 검색 합니다. 이러한 문자열에서 알 수 있으므로 메서드 s1에 할당 되는 동일한 참조를 반환 합니다. 참조 하는 s3에 할당 됩니다. 참조 s1 및 s2의 경우 같지 않은 다른 개체를 참조 하므로 동일한 문자열을 참조 하기 때문에 참조 s1과 s3 같다고 간주 합니다.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 이 메서드를 비교 합니다 <xref:System.String.IsInterned%2A> 메서드.  
  
## <a name="version-considerations"></a>버전 고려 사항  
 에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], <xref:System.String.Intern%2A> 메서드.NET Framework 1.0 및 1.1 빈 문자열 인터닝 관련 하 여 해당 동작으로 돌아갑니다. 다음 예에서 변수 `str1` 에 대 한 참조를 할당 됩니다 <xref:System.String.Empty>, 및 변수 `str2` 에 대 한 참조를 할당 하는 <xref:System.String.Empty> 호출 하 여 반환 되는 <xref:System.String.Intern%2A> 메서드는 변환한후<xref:System.Text.StringBuilder>값인 개체 <xref:System.String.Empty> 문자열로 합니다. 에 포함 된 참조 한 다음 `str1` 고 `str2` 서로 같은지 비교 합니다.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 에 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], 및 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]를 `str1` 및 `str2` 같은지 합니다. 에 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] 하 고 [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` 및 `str2` 같지 않습니다.  
  
## <a name="performance-considerations"></a>성능 고려 사항  
 총 메모리 양을 줄이기 위해 시도 하는 경우 응용 프로그램 할당, 문자열 인터닝 두 원치 않는 부작용을 염두에 둡니다. 인턴 지정에 대 한 메모리가 할당 하는 먼저 <xref:System.String> 개체는 CLR (공용 언어 런타임)이 종료 될 때까지 해제 될 가능성이 없습니다. 이유는 풀에 대 한 참조를 CLR의 <xref:System.String> 개체 후 응용 프로그램 또는 응용 프로그램 도메인도 유지할 수 있습니다, 종료 합니다. 둘째, 문자열, 내부 화 하려면 문자열을 먼저 만들어야 합니다. 사용 하는 메모리는 <xref:System.String> 개체 해야 계속를 할당할 수 있지만 메모리는 결국 가비지 수집 됩니다.  
  
 .NET Framework 버전 2.0에 도입 된 <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> 열거형 멤버입니다. <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> 멤버 문자열 리터럴 인터닝을 요구 하지 않는 어셈블리를 표시 합니다. 적용할 수 있습니다 <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> 를 사용 하 여 어셈블리에는 <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> 특성입니다. 또한 사용 하는 경우는 [Ngen.exe (네이티브 이미지 생성기)](~/docs/framework/tools/ngen-exe-native-image-generator.md) 런타임 이전에 어셈블리를 컴파일하려면 문자열은 인턴 지정 되지 모듈에서.  
  
   
  
## Examples  
 다음 예제에서는 새로 만든된 문자열로 지 여부를 결정 하는 값과 동일한 3 개의 문자열 및 인턴 지정된 문자열을 동일 합니다.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">내부 풀에서 검색할 문자열입니다.</param>
        <summary>지정된 <see cref="T:System.String" />에 대한 참조를 검색합니다.</summary>
        <returns>
          <paramref name="str" />이 공용 언어 런타임 내부 풀에 있으면 해당 참조이고, 그렇지 않으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 공용 언어 런타임 내부 풀의 모든 고유한 인스턴스를 비롯 하 여 프로그램에 선언 된 각 고유 리터럴 문자열 상수의 단일 인스턴스를 포함 하는 라는 테이블을를 자동으로 유지 관리 <xref:System.String> 호출 하 여 프로그래밍 방식으로 추가 <xref:System.String.Intern%2A> 메서드.  
  
 내부 풀 문자열 저장소를 절약합니다. 각 변수를 내부 풀의 여러 인스턴스를 참조 하는 대신 동일한 상수 참조로 여러 변수에 리터럴 문자열 상수를 할당 하는 경우 <xref:System.String> 동일한 값을 갖습니다.  
  
 이 메서드를 조회 `str` 내부 풀에 있습니다. 하는 경우 `str` 이미이 고, 그렇지 않으면 해당 인스턴스에 대 한 참조는 인턴 지정, `null` 반환 됩니다.  
  
 이 메서드를 비교 합니다 <xref:System.String.Intern%2A> 메서드.  
  
 이 메서드는 부울 값을 반환 하지 않습니다. 특정 문자열은 인턴 지정 하는지 여부를 나타내는 부울 값 때문에 메서드를 호출 하는 경우에 다음과 같은 코드를 사용할 수 있습니다.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  .NET Framework 버전 2.0부터 재정의할 수 있습니다 내부 풀 사용 사용 하는 경우는 [Ngen.exe (네이티브 이미지 생성기)](~/docs/framework/tools/ngen-exe-native-image-generator.md) 로컬 컴퓨터에서 네이티브 이미지 캐시에 어셈블리를 설치 합니다. 자세한 내용은 설명 섹션의 성능 고려 사항을 참조 합니다 <xref:System.String.Intern%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예에서는 리터럴 문자열은 컴파일러에 의해 자동으로 인턴 지정 하는 방법을 보여 줍니다.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 문자열의 형식이 특정 유니코드 정규화 형식인지를 나타냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 문자열의 형식이 유니코드 정규화 형식 C인지를 나타냅니다.</summary>
        <returns>이 문자열의 형식이 정규화 형식 C이면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 유니코드 문자는 해당 집합 조합으로 구성 된 여러 이진 표현 및/또는 복합 유니코드 문자입니다. 단일 문자에 대 한 여러 표현이 검색, 정렬, 일치 및 기타 작업을 복잡 하 게 합니다.  
  
 표준 유니코드 문자의 해당 이진 표현을 제공 하는 경우 하나의 이진 표현을 반환 하는 정규화 라고 하는 프로세스를 정의 합니다. 다른 규칙을 따르는 정규화 형식 이라는 다양 한 알고리즘을 사용 하 여 정규화를 수행할 수 있습니다. 현재.NET 정규화 형식 C, D, KC 및 KD를 지원합니다.  
  
 지원 되는 유니코드 정규화 형식에 대 한 참조 <xref:System.Text.NormalizationForm?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 정규화 형식으로 문자열을 성공적으로 정규화 되는지 여부를 결정 합니다.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 인스턴스에 잘못된 유니코드 문자가 포함되어 있습니다.</exception>
        <block subset="none" type="usage">
          <para>합니다 <see cref="Overload:System.String.IsNormalized" /> 메서드가 반환 되는 <see langword="false" /> 문자열의 첫 번째 정규화 되지 않은 문자가 발견 되는 즉시 합니다. 따라서 문자열 뒤에 잘못 된 유니코드 문자를 정규화 되지 않은 문자를 포함 하는 경우는 <see cref="Overload:System.String.Normalize" /> 메서드는 throw를 <see cref="T:System.ArgumentException" /> 있지만 <see cref="Overload:System.String.IsNormalized" /> 반환 <see langword="false" />합니다.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">유니코드 정규화 형식입니다.</param>
        <summary>이 문자열의 형식이 지정한 유니코드 정규화 형식인지를 나타냅니다.</summary>
        <returns>이 문자열의 형식이 <see langword="true" /> 매개 변수로 지정된 정규화 형식이면 <paramref name="normalizationForm" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 유니코드 문자는 해당 집합 조합으로 구성 된 여러 이진 표현 및/또는 복합 유니코드 문자입니다. 단일 문자에 대 한 여러 표현이 검색, 정렬, 일치 및 기타 작업을 복잡 하 게 합니다.  
  
 표준 유니코드 문자의 해당 이진 표현을 제공 하는 경우 하나의 이진 표현을 반환 하는 정규화 라고 하는 프로세스를 정의 합니다. 다른 규칙을 따르는 정규화 형식 이라는 다양 한 알고리즘을 사용 하 여 정규화를 수행할 수 있습니다. 현재.NET 정규화 형식 C, D, KC 및 KD를 지원합니다.  
  
 지원 되는 유니코드 정규화 형식에 대 한 참조 <xref:System.Text.NormalizationForm?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.IsNormalized%2A> 고 <xref:System.String.Normalize%2A> 메서드.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 인스턴스에 잘못된 유니코드 문자가 포함되어 있습니다.</exception>
        <block subset="none" type="usage">
          <para>합니다 <see cref="Overload:System.String.IsNormalized" /> 메서드가 반환 되는 <see langword="false" /> 문자열의 첫 번째 정규화 되지 않은 문자가 발견 되는 즉시 합니다. 따라서 문자열 뒤에 잘못 된 유니코드 문자를 정규화 되지 않은 문자를 포함 하는 경우는 <see cref="Overload:System.String.Normalize" /> 메서드는 throw를 <see cref="T:System.ArgumentException" /> 있지만 <see cref="Overload:System.String.IsNormalized" /> 반환 <see langword="false" />합니다.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">테스트할 문자열입니다.</param>
        <summary>지정된 문자열이 <see langword="null" />이거나 빈 문자열("")인지를 나타냅니다.</summary>
        <returns>
          <see langword="true" /> 매개 변수가 <paramref name="value" />이거나 빈 문자열("")이면 <see langword="null" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> 동시에 테스트할 수 있는 편리한 메서드입니다 여부를 <xref:System.String> 됩니다 `null` 여부나 해당 값이 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 다음 코드는 동일 합니다.  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 사용할 수는 <xref:System.String.IsNullOrWhiteSpace%2A> 문자열 인지 여부를 테스트 하는 방법 `null`, 해당 값은 <xref:System.String.Empty?displayProperty=nameWithType>, 공백 문자 으로만 구성 또는 합니다.  
  
## <a name="what-is-a-null-string"></a>Null 문자열 이란?

문자열이 `null` 값 (c + + 및 Visual Basic) 할당 되지 않은 경우 또는 명시적으로 할당 된 값의 경우 `null`합니다. 하지만 합니다 [복합 서식 지정](~/docs/standard/base-types/composite-formatting.md) 기능 해당 멤버를 throw 하는 경우 하나를 호출 하는 동안, 다음 예제와 같이 null 문자열을 정상적으로 처리할 수는 <xref:System.NullReferenceException>.  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>빈 문자열 이란?  

문자열은 빈 문자열을 명시적으로 할당 하는 경우 빈 ("") 또는 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 빈 문자열에는 <xref:System.String.Length%2A> 0입니다.  다음 예제에서는 빈 문자열을 만들고 해당 값 및 해당 길이 표시 합니다.  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 다음 예제에서는 세 개의 문자열을 검사 하 고 각 문자열 값, 빈 문자열이 면 중인지 여부를 결정 `null`합니다.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">테스트할 문자열입니다.</param>
        <summary>지정된 문자열이 <see langword="null" />이거나 비어 있거나 공백 문자로만 구성되어 있는지를 나타냅니다.</summary>
        <returns>
          <see langword="true" /> 매개 변수가 <paramref name="value" /> 또는 <see langword="null" />이거나, <see cref="F:System.String.Empty" />가 모두 공백 문자로 구성되어 있으면 <paramref name="value" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> 메서드는 뛰어난 성능을 제공 한다는 점을 제외 하면 다음 코드는 비슷합니다는 같습니다.  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 공백 문자는 유니코드 표준에서 정의 됩니다. 합니다 <xref:System.String.IsNullOrWhiteSpace%2A> 메서드 값을 반환 하는 모든 문자를 해석 `true` 에 전달 될 때를 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 공백 문자로 메서드.  
  
   
  
## Examples  
 다음 예제에서는 문자열 배열에 연결을 만들고 다음 배열의 각 요소를 전달 합니다 <xref:System.String.IsNullOrWhiteSpace%2A> 메서드.  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>각 요소 또는 멤버 사이에 지정된 구분 기호를 사용하여 지정된 배열 요소나 컬렉션 멤버를 연결합니다.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">구분 기호로 사용할 문자열입니다.<paramref name="separator" />는 <paramref name="values" />에 둘 이상의 요소가 있는 경우에만 반환된 문자열에 포함됩니다.</param>
        <param name="values">연결할 문자열을 포함하는 컬렉션입니다.</param>
        <summary>각 멤버 사이에 지정된 구분 기호를 사용하여 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 형식의 생성된 <see cref="T:System.String" /> 컬렉션의 멤버를 연결합니다.</summary>
        <returns>
          <paramref name="values" /> 문자열로 구분된 <paramref name="separator" />의 멤버로 구성된 문자열입니다. <paramref name="values" />에 멤버가 없는 경우 이 메서드는 <see cref="F:System.String.Empty" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 `separator` 됩니다 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다. 하는 경우 모든 소속 `values` 는 `null`, 빈 문자열을 대신 사용 됩니다.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 각 요소에 연결할 수 있는 메서드는 `IEnumerable(Of String)` 문자열 배열에 첫 번째 요소를 변환 하지 않고 컬렉션입니다. LINQ (Language-Integrated Query) 쿼리 식을 사용 하 여 특히 유용합니다. 다음 예제에서는 전달 된 `List(Of String)` 알파벳 문자를 특정 문자 (예에서는 "M") 보다 크거나 같은 선택 하는 람다 식으로 대 / 소문자 구분 문자를 포함 하는 개체입니다. `IEnumerable(Of String)` 에서 반환 된 컬렉션을 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 메서드에 전달 됩니다는 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 단일 문자열로 결과 표시 하는 방법.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 다음 예에서는 소수 100 보다 작거나를 계산 하는 에라토스테네스의 체 알고리즘을 사용 합니다. 결과를 할당 한 <xref:System.Collections.Generic.List%601> 형식의 개체 <xref:System.String>에 전달 되는 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 메서드.  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">구분 기호로 사용할 문자열입니다. <paramref name="values" />에 둘 이상의 요소가 있는 경우에만 <paramref name="separator" />가 반환된 문자열에 포함됩니다.</param>
        <param name="values">연결할 요소가 포함된 배열입니다.</param>
        <summary>각 요소 사이에 지정된 구분 기호를 사용하여 개체 배열의 요소를 연결합니다.</summary>
        <returns>
          <paramref name="values" /> 문자열로 구분된 <paramref name="separator" />의 요소로 구성된 문자열입니다. <paramref name="values" />가 빈 배열인 경우 이 메서드는 <see cref="F:System.String.Empty" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `separator` 은 `null` 이거나 모든 요소의 `values` 첫 번째 요소는 이외의 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다. 경우 호출자에 게 섹션에 대 한 참고를 참조 하세요. 첫 번째 요소 `values` 는 `null`합니다.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> 문자열에 해당 요소를 명시적으로 변환 하지 않고 개체 배열의 각 요소를 연결할 수 있는 편리한 메서드입니다. 배열의 각 개체의 문자열 표현을 해당 개체를 호출 하 여 파생 된 `ToString` 메서드.  
  
   
  
## Examples  
 다음 예에서는 소수 100 보다 작거나를 계산 하는 에라토스테네스의 체 알고리즘을 사용 합니다. 에 전달 되는 정수 배열에 결과 할당 합니다 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> 메서드.  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>경우 첫 번째 요소 <paramref name="values" /> 됩니다 <see langword="null" />의 <see cref="M:System.String.Join(System.String,System.Object[])" /> 메서드의 요소를 연결 하지 않습니다 <paramref name="values" /> 대신 반환 하지만 <see cref="F:System.String.Empty" />. 다양 한이 문제에 대 한 해결 방법 사용할 수 있습니다. 값을 할당 하는 방법이 가장 쉬운 <see cref="F:System.String.Empty" /> 배열의 첫 번째 요소를 다음 예제와 같이 보여 줍니다.  
  
[! 코드 csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [! 코드 vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">구분 기호로 사용할 문자열입니다. <paramref name="value" />에 둘 이상의 요소가 있는 경우에만 <paramref name="separator" />가 반환된 문자열에 포함됩니다.</param>
        <param name="value">연결할 요소가 포함된 배열입니다.</param>
        <summary>각 요소 사이에 지정된 구분 기호를 사용하여 문자열 배열의 모든 요소를 연결합니다.</summary>
        <returns>
          <paramref name="value" /> 문자열로 구분된 <paramref name="separator" />의 요소로 구성된 문자열입니다. <paramref name="value" />가 빈 배열인 경우 이 메서드는 <see cref="F:System.String.Empty" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예를 들어 경우 `separator` 는 "," 요소 `value` 은 "apple", "주황색", "grape" 및 "pear" `Join(separator, value)` "apple, orange, grape, pear"를 반환 합니다.  
  
 하는 경우 `separator` 됩니다 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다. 경우에 있는 모든 요소 `value` 는 `null`, 빈 문자열을 대신 사용 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Join%2A> 메서드.  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">구분 기호로 사용할 문자열입니다. <paramref name="value" />에 둘 이상의 요소가 있는 경우에만 <paramref name="separator" />가 반환된 문자열에 포함됩니다.</param>
        <param name="value">연결할 요소가 포함된 배열입니다.</param>
        <param name="startIndex">사용할 <paramref name="value" />의 첫 번째 요소입니다.</param>
        <param name="count">
          <paramref name="value" /> 중에서 사용할 요소의 수입니다.</param>
        <summary>각 요소 사이에 지정된 구분 기호를 사용하여 문자열 배열의 지정된 요소를 연결합니다.</summary>
        <returns>
          <paramref name="value" /> 문자열로 구분된 <paramref name="separator" />의 문자열로 구성된 문자열입니다.  
  
또는 
 <see cref="F:System.String.Empty" />가 0이거나, <paramref name="count" />에 요소가 없거나, <paramref name="value" />와 <paramref name="separator" />의 모든 요소가 <paramref name="value" />면 <see cref="F:System.String.Empty" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예를 들어 경우 `separator` 는 "," 요소 `value` 은 "apple", "주황색", "grape" 및 "pear" `Join(separator, value, 1, 2)` 반환 "주황색, grape"입니다.  
  
 하는 경우 `separator` 됩니다 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다. 경우에 있는 모든 요소 `value` 는 `null`, 빈 문자열을 대신 사용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 과일 이름의 배열에서 두 요소를 연결합니다.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="count" />가 0 미만입니다.  
  
또는 
 <paramref name="startIndex" /> + <paramref name="count" />가 <paramref name="value" />의 요소 수보다 큽니다.</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족합니다.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <paramref name="values" /> 멤버의 형식입니다.</typeparam>
        <param name="separator">구분 기호로 사용할 문자열입니다.<paramref name="separator" />는 <paramref name="values" />에 둘 이상의 요소가 있는 경우에만 반환된 문자열에 포함됩니다.</param>
        <param name="values">연결할 개체를 포함하는 컬렉션입니다.</param>
        <summary>각 멤버 사이에 지정된 구분 기호를 사용하여 컬렉션의 멤버를 연결합니다.</summary>
        <returns>
          <paramref name="values" /> 문자열로 구분된 <paramref name="separator" />의 멤버로 구성된 문자열입니다. <paramref name="values" />에 멤버가 없는 경우 이 메서드는 <see cref="F:System.String.Empty" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 `separator` 됩니다 `null`, 빈 문자열 (<xref:System.String.Empty?displayProperty=nameWithType>) 대신 사용 됩니다. 하는 경우 모든 소속 `values` 는 `null`, 빈 문자열을 대신 사용 됩니다.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 각 멤버를 연결할 수 있는 메서드는 <xref:System.Collections.Generic.IEnumerable%601> 첫 번째 요소를 문자열로 변환 하지 않고 컬렉션입니다. 각 개체의 문자열 표현 합니다 <xref:System.Collections.Generic.IEnumerable%601> 컬렉션 개체를 호출 하 여 파생 된 `ToString` 메서드.  
  
 이 메서드는 특정 LINQ (Language-Integrated Query) 쿼리 식을 사용 하 여 유용 합니다. 예를 들어 다음 코드는 매우 간단한 정의 `Animal` animal과 속한 주문의 이름을 포함 하는 클래스입니다. 그런 다음 정의 <xref:System.Collections.Generic.List%601> 의 번호가 포함 된 개체 `Animal` 개체입니다. <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 추출에 확장 메서드를 호출 합니다 `Animal` 갖는 개체 `Order` 속성이 같으면 "바위"입니다. 결과에 전달 되는 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 메서드.  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 다음 예에서는 소수 100 보다 작거나를 계산 하는 에라토스테네스의 체 알고리즘을 사용 합니다. 결과를 할당 한 <xref:System.Collections.Generic.List%601> 에 전달 되는 정수 형식의 개체는 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 메서드.  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스에서 마지막으로 발견되는 지정된 유니코드 문자 또는 문자열의 0부터 시작하는 인덱스 위치를 보고합니다. 이 인스턴스에 해당 문자나 문자열이 없으면 이 메서드는 -1을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">검색할 유니코드 문자입니다.</param>
        <summary>이 인스턴스에서 마지막으로 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스 위치를 보고합니다.</summary>
        <returns>해당 문자가 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 그러지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 번째 문자 인덱스 0 이며 마지막에 <xref:System.String.Length%2A> -1입니다.  
  
 이 메서드는이 인스턴스의 마지막 문자 위치에 있는 검색을 시작 하 고 될 때까지 시작 부분을 향해 뒤로 `value` 가 찾거나 첫 번째 문자 위치입니다. 검색은 대/소문자 구분 합니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면 사용 합니다 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드, 여기서는 미리 구성 된 문자를 나타내는 합자 "→"와 같은 (U + 00 6), 유니코드 스칼라 값 간주 될 수 있습니다 문자 구성 요소에서의 모든 항목에는 "AE" 등 시퀀스를 수정 (u+0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 `ExtractFilename` 메서드를 사용 하는 <xref:System.String.LastIndexOf%28System.Char%29> 문자열의 파일 이름을 추출 하려면 메서드를 문자열에서 마지막 디렉터리 구분 문자를 찾습니다. 파일이 존재 하는 경우 메서드는 해당 경로 없이 파일 이름만 반환 합니다.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <summary>이 인스턴스에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스 위치를 보고합니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" />의 0부터 시작하는 인덱스 위치이고, 그러지 않으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />이면 이 인스턴스의 마지막 인덱스 위치를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 번째 문자 인덱스 0 이며 마지막에 <xref:System.String.Length%2A> -1입니다.  
  
 검색이 인스턴스의 마지막 문자 위치에서 시작 하 고 될 때까지 시작 부분을 향해 뒤로 `value` 가 찾거나 첫 번째 문자 위치입니다.  
  
 이 메서드는 현재 문화권을 사용 하는 단어 (대/소문자 구분 및 문화권) 검색을 수행 합니다.  
  
 문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 하는 경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어 합니다 <xref:System.String.LastIndexOf%28System.String%29> 메서드는 항상 반환 <xref:System.String.Length%2A?displayProperty=nameWithType> – 현재 인스턴스의 마지막 인덱스 위치를 나타내는 1입니다. 다음 예제에서는 <xref:System.String.LastIndexOf%28System.String%29> 메서드는 두 문자열의 세 가지 부분 문자열 (하이픈이 (U + 00AD), "n" 뒤에 하이픈이 및 하이픈이 뒤에 "m")을 찾는 데 사용 됩니다. 문자열 중 하나에만 사용자 지정 하이픈이 포함되어 있습니다. 예제를 실행 합니다 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상 버전을 각각의 경우에서 사용자 지정 하이픈은 무시할 수 있는 문자 때문에 결과 동일한 사용자 지정 하이픈의 포함 되지 않았던 것 처럼 `value`합니다. 하이픈이을 검색할 때 메서드 6 및 5를 반환 합니다. 이러한 값의 두 문자열의 마지막 문자 인덱스에 해당합니다.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 다음 예제에서는 태그 및 닫는 태그를 시작 하는 경우 문자열 및 문자열 끝에서 HTML 태그를 제거 합니다. 문자열에 닫는 끝나는 경우 괄호 문자 (">")를 사용 하 여는 <xref:System.String.LastIndexOf%2A> 끝 태그의 시작 부분을 찾는 방법.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 문자열에 대 한 모범 사례](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다. 현재 문화권의 비교 규칙을 사용 하 여 문자열 인스턴스 내에서 부분 문자열의 마지막 인덱스를 찾으려고 호출을 <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> 값을 사용 하 여 메서드 오버 로드 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 유니코드 문자입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <paramref name="startIndex" />에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <summary>이 인스턴스에서 마지막으로 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스 위치를 보고합니다. 지정된 문자 위치에서 시작하고 문자열의 시작 부분을 향해 뒤로 검색이 진행됩니다.</summary>
        <returns>해당 문자가 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 해당 문자가 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 번째 문자 인덱스 0 이며 마지막에 <xref:System.String.Length%2A> -1.가이 메서드 검색 시작 위치를 `startIndex` 문자이 인스턴스와 될 때까지 현재 인스턴스의 시작 부분을 향해 뒤로 위치 `value` 가 찾거나 첫 번째 문자 위치입니다. 예를 들어 있으면 `startIndex` 는 <xref:System.String.Length%2A> -1 메서드 시작 부분 문자열의 마지막 문자에서 모든 문자를 검색 합니다. 검색은 대/소문자 구분 합니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면 사용 합니다 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드, 여기서는 미리 구성 된 문자를 나타내는 합자 "→"와 같은 (U + 00 6), 유니코드 스칼라 값 간주 될 수 있습니다 문자 구성 요소에서의 모든 항목에는 "AE" 등 시퀀스를 수정 (u+0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열의 끝에서 작업 하는 문자열의 시작 문자열에서 문자의 모든 항목의 인덱스를 찾습니다.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 0보다 작거나 이 인스턴스의 길이보다 크거나 같습니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <paramref name="startIndex" />에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <summary>이 인스턴스에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스 위치를 보고합니다. 지정된 문자 위치에서 시작하고 문자열의 시작 부분을 향해 뒤로 검색이 진행됩니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 해당 문자열이 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />이면 반환 값은 <paramref name="startIndex" />와 이 인스턴스의 마지막 인덱스 위치 중 작은 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 번째 문자 인덱스 0 이며 마지막에 <xref:System.String.Length%2A> -1입니다.  
  
 검색이 시작 합니다 `startIndex` 문자 및 시작 될 때까지 뒤로이 인스턴스의 위치 `value` 가 찾거나 첫 번째 문자 위치. 예를 들어 있으면 `startIndex` 는 <xref:System.String.Length%2A> -1 메서드 시작 부분 문자열의 마지막 문자에서 모든 문자를 검색 합니다.  
  
 이 메서드는 현재 문화권을 사용 하는 단어 (대/소문자 구분 및 문화권) 검색을 수행 합니다.  
  
 문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 하는 경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어 합니다 <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> 메서드는 항상 반환 `startIndex`, 검색을 시작할 문자 위치는입니다. 다음 예제에서는 <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> 메서드 (U + 00AD) 하이픈을 포함 하 고 앞 또는 마지막 "m" 문자열에 포함 하는 부분 문자열을 찾는 데 사용 됩니다. 예제를 실행 하는 경우는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 하거나 검색 문자열에 사용자 지정 하이픈은 무시 되므로 나중에 substrin를 찾으려고 호출 하는 반면 문자열에서 "m"의 위치를 반환 하는 사용자 지정 하이픈 및 "m"으로 구성 된 부분 문자열을 찾으려면 메서드를 호출 사용자 지정 하이픈 및 "n"으로 구성 된 g "n"의 위치를 반환 합니다. 검색 문자열에만 사용자 지정 하이픈이 포함 하는 경우 메서드는 "m"의 값을 나타내는의 인덱스를 반환 하는 `startIndex`합니다.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 다음 예제에서는 대상 문자열에 대상 문자열의 끝에서 작업 하는 대상 문자열의 시작 부분 문자열의 모든 항목의 인덱스를 찾습니다.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 0보다 작거나 현재 인스턴스의 길이보다 큽니다.  
  
또는 
현재 인스턴스가 <see cref="F:System.String.Empty" />와 같고 <paramref name="startIndex" />가 -1보다 작거나 0보다 큽니다.</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 문자열에 대 한 모범 사례](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다. 현재 문화권의 비교 규칙을 사용 하 여 특정 문자 위치를 앞에 있는 부분 문자열의 인덱스를 찾으려고 호출을 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> 값을 사용 하 여 메서드 오버 로드 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="comparisonType">검색 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다. 매개 변수는 지정된 문자열에 사용할 검색 유형을 지정합니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" /> 매개 변수의 0부터 시작하는 인덱스 위치이고, 그러지 않으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />이면 이 인스턴스의 마지막 인덱스 위치를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 번째 문자 인덱스 0 이며 마지막에 <xref:System.String.Length%2A> -1입니다.  
  
 합니다 `comparisonType` 매개 변수를 검색 하도록 지정 합니다 `value` 현재 또는 고정 문화권을 사용 하 고 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.  
  
 검색이 인스턴스의 마지막 문자 위치에서 시작 하 고 될 때까지 시작 부분을 향해 뒤로 `value` 가 찾거나 첫 번째 문자 위치입니다.  
  
   
  
## Examples  
 다음 exampledemonstrates 세 오버 로드 된 <xref:System.String.LastIndexOf%2A> 메서드를 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 마지막 항목을 찾을 <xref:System.StringComparison> 열거형입니다.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색(즉, <paramref name="options" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 하는 경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어 합니다 <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> 메서드는 항상 반환 <see cref="P:System.String.Length" /> – 현재 인스턴스의 마지막 인덱스 위치를 나타내는 1입니다.  
  
다음 예제에서는 <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> 메서드는 두 문자열의 세 가지 부분 문자열 (하이픈이 (U + 00AD), "n" 뒤에 하이픈이 및 하이픈이 뒤에 "m")을 찾는 데 사용 됩니다. 문자열 중 하나에만 사용자 지정 하이픈이 포함되어 있습니다. 예제를 실행 하는 경우는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 나중에 사용자 지정 하이픈을 무시할 수 있는 문자 이기 때문에 문화권 구분 검색을 반환 하거나 검색 문자열에 사용자 지정 하이픈이 포함 되지 않은 경우 반환 된 값과 같아야 합니다. 그러나 서 수 검색을 성공적으로 사용자 지정 하이픈 한 문자열에서 찾아 보고 없는 것에서 두 번째 문자열입니다.  
  
[! 코드 csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [! 코드 vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 유니코드 문자입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <paramref name="startIndex" />에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <summary>이 인스턴스의 부분 문자열에서 마지막으로 발견되는 지정된 유니코드 문자의 0부터 시작하는 인덱스 위치를 보고합니다. 지정된 문자 위치에서 검색을 시작하여 지정된 수의 문자 위치에 대한 문자열의 시작 부분 쪽으로 뒤로 검색합니다.</summary>
        <returns>해당 문자가 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 해당 문자가 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 번째 문자 인덱스 0 이며 마지막에 <xref:System.String.Length%2A> -1입니다.  
  
 이 메서드 검색을 시작 합니다 `startIndex` 문자 위치 및 될 때까지이 인스턴스의 시작 부분을 향해 뒤로 `value` 가 또는 `count` 문자 위치를 검토 합니다. 예를 들어 경우 `startIndex` 됩니다 <xref:System.String.Length%2A> -1 메서드 뒤로 검색 `count` 문자열의 마지막 문자에서는 문자입니다. 검색은 대/소문자 구분 합니다.  
  
 이 메서드는 유니코드 스칼라 값은 동일한 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면 사용 합니다 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드, 여기서는 미리 구성 된 문자를 나타내는 합자 "→"와 같은 (U + 00 6), 유니코드 스칼라 값 간주 될 수 있습니다 문자 구성 요소에서의 모든 항목에는 "AE" 등 시퀀스를 수정 (u+0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 부분 문자열의 끝에서 작업 하는 부분 문자열의 시작 부분 문자열에서 문자의 모든 항목의 인덱스를 찾습니다.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 0보다 작거나 이 인스턴스의 길이보다 크거나 같습니다.  
  
또는 
현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" /> - <paramref name="count" /> + 1이 0보다 작습니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <paramref name="startIndex" />에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <summary>이 인스턴스에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스 위치를 보고합니다. 지정된 문자 위치에서 검색을 시작하여 지정된 수의 문자 위치에 대한 문자열의 시작 부분 쪽으로 뒤로 검색합니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" />의 인덱스 위치(0부터 시작)이고, 해당 문자열이 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />이면 반환 값은 <paramref name="startIndex" />와 이 인스턴스의 마지막 인덱스 위치 중 작은 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 번째 문자 인덱스 0 이며 마지막에 <xref:System.String.Length%2A> -1입니다.  
  
 검색이 시작 합니다 `startIndex` 문자 및 시작 될 때까지 뒤로이 인스턴스의 위치 `value` 가 또는 `count` 문자 위치를 검토 합니다. 예를 들어 경우 `startIndex` 됩니다 <xref:System.String.Length%2A> -1 메서드 뒤로 검색 `count` 문자열의 마지막 문자에서는 문자입니다.  
  
 이 메서드는 현재 문화권을 사용 하는 단어 (대/소문자 구분 및 문화권) 검색을 수행 합니다.  
  
 문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색에서는 `value`에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 하는 경우 `value` 하나 이상의 무시할 수 있는 문자로 구성 되어 합니다 <xref:System.String.LastIndexOf%2A> 메서드는 항상 반환 `startIndex`, 검색을 시작할 문자 위치는입니다. 다음 예제에서는 <xref:System.String.LastIndexOf%2A> 메서드 두 문자열의 마지막 "m" 앞에 있는 두 문자에는 사용자 지정 하이픈 (U + 00AD)의 위치를 찾는 데 사용 됩니다. 문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다. 예제를 실행 하는 경우는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 사용자 지정 하이픈은 무시할 수 있는 문자 때문에 메서드 반환 문자열에 "m"의 인덱스 문화권 구분 비교를 수행 하는 경우. "m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다.  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 다음 예제에서는 부분 문자열의 시작 부분 문자열의 끝에서 작업 하는 부분 문자열에서 문자열의 모든 항목의 인덱스를 찾습니다.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />가 음수입니다.  
  
또는 
현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 음수입니다.  
  
또는 
현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 이 인스턴스의 길이보다 큽니다.  
  
또는 
현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" /> - <paramref name="count" /> + 1이 이 인스턴스 외부의 위치를 지정합니다.  
  
또는 
현재 인스턴스가 <see cref="F:System.String.Empty" />이고 <paramref name="start" />가 -1보다 작거나 0보다 큽니다.  
  
또는 
현재 인스턴스가 <see cref="F:System.String.Empty" />이고 <paramref name="count" />가 1보다 큽니다.</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 문자열에 대 한 모범 사례](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다. 현재 문화권의 비교 규칙을 사용 하 여이 작업을 수행 하려면 호출을 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 값을 사용 하 여 메서드 오버 로드 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <paramref name="startIndex" />에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <param name="comparisonType">검색 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스를 보고합니다. 지정된 문자 위치에서 시작하고 문자열의 시작 부분을 향해 뒤로 검색이 진행됩니다. 매개 변수는 지정된 문자열을 검색할 때 수행할 비교 유형을 지정합니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" /> 매개 변수의 인덱스 위치(0부터 시작)이고, 해당 문자열이 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />이면 반환 값은 <paramref name="startIndex" />와 이 인스턴스의 마지막 인덱스 위치 중 작은 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 번째 문자 인덱스 0 이며 마지막에 <xref:System.String.Length%2A> -1입니다.  
  
 검색이 시작 합니다 `startIndex` 문자 위치 및 진행 될 때까지 이전 버전과 `value` 가 찾거나 첫 번째 문자 위치입니다. 예를 들어 있으면 `startIndex` 는 <xref:System.String.Length%2A> -1 메서드 시작 부분 문자열의 마지막 문자에서 모든 문자를 검색 합니다.  
  
 합니다 `comparisonType` 매개 변수를 검색 하도록 지정 합니다 `value` 현재 또는 고정 문화권을 사용 하 고 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.  
  
   
  
## Examples  
 다음 exampledemonstrates 세 오버 로드 된 <xref:System.String.LastIndexOf%2A> 메서드를 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 마지막 항목을 찾을 <xref:System.StringComparison> 열거형입니다.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 0보다 작거나 현재 인스턴스의 길이보다 큽니다.  
  
또는 
현재 인스턴스가 <see cref="F:System.String.Empty" />와 같고 <paramref name="startIndex" />가 -1보다 작거나 0보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 하는 경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어 합니다 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드는 항상 반환 <paramref name="startIndex" />, 검색을 시작할 문자 위치는입니다.  
  
다음 예제에서는 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> 메서드는 "m", 두 문자열의 마지막 "m"부터 뒤에 하이픈이 (U + 00AD)의 위치를 찾는 데 사용 됩니다. 문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다. 예제를 실행 하는 경우는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 사용자 지정 하이픈은 무시할 수 있는 문자 때문에 메서드 반환 문자열에 "m"의 인덱스 문화권 구분 비교를 수행 하는 경우. "m"이 앞에 붙은 사용자 지정 하이픈이 포함된 첫 번째 문자열의 경우, 메서드가 사용자 지정 하이픈의 인덱스를 반환하지 못하고 대신 "m"의 인덱스를 반환합니다. 메서드는 서수 비교를 수행하는 경우에만 첫 번째 문자열에서 사용자 지정 하이픈의 인덱스를 반환합니다.  
  
[! 코드 csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [! 코드 vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">검색할 문자열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <paramref name="startIndex" />에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <param name="comparisonType">검색 규칙을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>이 인스턴스에서 마지막으로 발견되는 지정된 문자열의 0부터 시작하는 인덱스 위치를 보고합니다. 지정된 문자 위치에서 검색을 시작하여 지정된 수의 문자 위치에 대한 문자열의 시작 부분 쪽으로 뒤로 검색합니다. 매개 변수는 지정된 문자열을 검색할 때 수행할 비교 유형을 지정합니다.</summary>
        <returns>해당 문자열이 있으면 <paramref name="value" /> 매개 변수의 인덱스 위치(0부터 시작)이고, 해당 문자열이 없거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 같으면 -1입니다. <paramref name="value" />가 <see cref="F:System.String.Empty" />이면 반환 값은 <paramref name="startIndex" />와 이 인스턴스의 마지막 인덱스 위치 중 작은 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다. 즉, 문자열의 첫 번째 문자 인덱스 0 이며 마지막에 <xref:System.String.Length%2A> -1입니다.  
  
 검색이 시작 합니다 `startIndex` 문자 위치 및 진행 될 때까지 이전 버전과 `value` 가 또는 `count` 문자 위치를 검토 합니다. 예를 들어 경우 `startIndex` 됩니다 <xref:System.String.Length%2A> -1 메서드 뒤로 검색 `count` 문자열의 마지막 문자에서는 문자입니다.  
  
 합니다 `comparisonType` 매개 변수를 검색 하도록 지정 합니다 `value` 현재 또는 고정 문화권을 사용 하 고 대/소문자 구분 또는 대/소문자 구분 검색을 사용 하 여 단어 또는 서 수 비교 규칙을 사용 하 여 매개 변수입니다.  
  
   
  
## Examples  
 다음 exampledemonstrates 세 오버 로드 된 <xref:System.String.LastIndexOf%2A> 메서드를 다른 값을 사용 하 여 다른 문자열 내에 있는 문자열의 마지막 항목을 찾을 <xref:System.StringComparison> 열거형입니다.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />가 음수입니다.  
  
또는 
현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 음수입니다.  
  
또는 
현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 이 인스턴스의 길이보다 큽니다.  
  
또는 
현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" /> - <paramref name="count" /> + 1이 이 인스턴스 외부의 위치를 지정합니다.  
  
또는 
현재 인스턴스가 <see cref="F:System.String.Empty" />이고 <paramref name="start" />가 -1보다 작거나 0보다 큽니다.  
  
또는 
현재 인스턴스가 <see cref="F:System.String.Empty" />이고 <paramref name="count" />가 1보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>문자 집합에는 무시할 수 있는 문자가 포함되며, 이들 문자는 언어 또는 문화권 구분 비교를 수행하는 경우 고려되지 않습니다. 문화권 구분 검색(즉, <paramref name="comparisonType" />이 <see cref="F:System.StringComparison.Ordinal" /> 또는 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />가 아닌 경우)에서는 <paramref name="value" />에 무시할 수 있는 문자가 포함된 경우 결과는 해당 문자가 제거된 대상을 검색하는 것과 같습니다. 하는 경우 <paramref name="value" /> 하나 이상의 무시할 수 있는 문자로 구성 되어 합니다 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드는 항상 반환 <paramref name="startIndex" />, 검색을 시작할 문자 위치는입니다.  
  
다음 예제에서는 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 메서드는 두 문자열의 모든 "m"을 뒤 하이픈이 (U + 00AD)의 위치 하지만 최종 "m" 앞의 첫 번째 문자 위치를 찾는 데 사용 됩니다. 문자열 중 하나에만 필수 부분 문자열이 포함되어 있습니다. 예제를 실행 하는 경우는 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 이상, 두 경우 모두 사용자 지정 하이픈은 무시할 수 있는 문자 때문에 메서드 반환 문자열에 "m"의 인덱스 문화권 구분 비교를 수행 하는 경우. 그러나 서 수 비교를 수행할 때 부분만에서 찾은 첫 번째 문자열입니다. 참고 첫 번째 문자열 뒤에 "m" 사용자 지정 하이픈을 포함 하는 메서드를 사용자 지정 하이픈의 인덱스를 반환 하지 못하고 있지만 문화권 구분 비교를 수행 하는 경우 대신 "m"의 인덱스를 반환 합니다. 메서드는 서수 비교를 수행하는 경우에만 첫 번째 문자열에서 사용자 지정 하이픈의 인덱스를 반환합니다.  
  
[! 코드 csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [! 코드 vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>유니코드 배열에서 지정된 하나 이상의 문자 중에 이 인스턴스에서 마지막으로 발견되는 문자의 0부터 시작하는 인덱스 위치를 보고합니다. 이 인스턴스에 해당 문자가 없으면 메서드는 -1을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</param>
        <summary>유니코드 배열에서 지정된 하나 이상의 문자 중에 이 인스턴스에서 마지막으로 발견되는 문자의 0부터 시작하는 인덱스 위치를 보고합니다.</summary>
        <returns>이 인스턴스에서 <paramref name="anyOf" />의 문자가 마지막으로 발견된 인덱스 위치입니다. <paramref name="anyOf" />의 문자가 발견되지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다.  
  
 이 메서드는이 인스턴스의 마지막 문자 위치에 있는 검색을 시작 하 고의 문자까지 시작 부분을 향해 뒤로 `anyOf` 가 찾거나 첫 번째 문자 위치입니다. 검색은 대/소문자 구분 합니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면 사용 합니다 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드, 여기서는 미리 구성 된 문자를 나타내는 합자 "→"와 같은 (U + 00 6), 유니코드 스칼라 값 간주 될 수 있습니다 문자 구성 요소에서의 모든 항목에는 "AE" 등 시퀀스를 수정 (u+0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다른 문자열 내에서 "is" 문자열에 있는 문자 중 마지막 요소의 인덱스를 찾습니다.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <paramref name="startIndex" />에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <summary>유니코드 배열에서 지정된 하나 이상의 문자 중에 이 인스턴스에서 마지막으로 발견되는 문자의 0부터 시작하는 인덱스 위치를 보고합니다. 지정된 문자 위치에서 시작하고 문자열의 시작 부분을 향해 뒤로 검색이 진행됩니다.</summary>
        <returns>이 인스턴스에서 <paramref name="anyOf" />의 문자가 마지막으로 발견된 인덱스 위치입니다. <paramref name="anyOf" />의 문자가 발견되지 않거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 동일하면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다.  
  
 이 메서드 검색을 시작 합니다 `startIndex` 문자이 인스턴스의 위치에 문자가 올 때까지 뒤로 `anyOf` 가 찾거나 첫 번째 문자 위치입니다. 검색은 대/소문자 구분 합니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면 사용 합니다 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드, 여기서는 미리 구성 된 문자를 나타내는 합자 "→"와 같은 (U + 00 6), 유니코드 스칼라 값 간주 될 수 있습니다 문자 구성 요소에서의 모든 항목에는 "AE" 등 시퀀스를 수정 (u+0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다른 문자열의 부분 문자열에 있는 "is" 문자열에 있는 문자 중 마지막 요소의 인덱스를 찾습니다.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" />가 인스턴스 외부의 위치를 지정합니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">검색할 문자를 하나 이상 포함하는 유니코드 문자 배열입니다.</param>
        <param name="startIndex">검색을 시작할 위치입니다. <paramref name="startIndex" />에서 이 인스턴스의 시작 부분을 향해 검색이 진행됩니다.</param>
        <param name="count">검사할 문자 위치의 수입니다.</param>
        <summary>유니코드 배열에서 지정된 하나 이상의 문자 중에 이 인스턴스에서 마지막으로 발견되는 문자의 0부터 시작하는 인덱스 위치를 보고합니다. 지정된 문자 위치에서 검색을 시작하여 지정된 수의 문자 위치에 대한 문자열의 시작 부분 쪽으로 뒤로 검색합니다.</summary>
        <returns>이 인스턴스에서 <paramref name="anyOf" />의 문자가 마지막으로 발견된 인덱스 위치입니다. <paramref name="anyOf" />의 문자가 발견되지 않거나 현재 인스턴스가 <see cref="F:System.String.Empty" />와 동일하면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 번호는 0부터 시작합니다.  
  
 이 메서드 검색을 시작 합니다 `startIndex` 문자이 인스턴스의 위치에 문자가 올 때까지 뒤로 `anyOf` 가 또는 `count` 문자 위치를 검토 합니다. 검색은 대/소문자 구분 합니다.  
  
 이 메서드는 유니코드 스칼라 값이 같은 서 수 (문화권) 검색을 수행 합니다. 문화권 구분 검색을 수행 하려면 사용 합니다 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 메서드, 여기서는 미리 구성 된 문자를 나타내는 합자 "→"와 같은 (U + 00 6), 유니코드 스칼라 값 간주 될 수 있습니다 문자 구성 요소에서의 모든 항목에는 "AE" 등 시퀀스를 수정 (u+0041, U + 0045) 문화권에 따라 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다른 문자열의 부분 문자열에 있는 문자열 "참조"에 있는 문자 중 마지막 요소의 인덱스를 찾습니다.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">현재 인스턴스가 <see cref="F:System.String.Empty" /> 같지 않고 <paramref name="count" /> 또는 <paramref name="startIndex" />가 음수입니다.  
  
또는 
현재 인스턴스가 <see cref="F:System.String.Empty" />와 같지 않고 <paramref name="startIndex" /> - <paramref name="count" /> + 1이 음수입니다.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.String" /> 개체의 문자 수를 가져옵니다.</summary>
        <value>현재 문자열의 문자 수를 가져옵니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Length%2A> 속성의 수를 반환 합니다. <xref:System.Char> 이 인스턴스의 개체를 유니코드 문자 수가 없습니다. 이유는 둘 이상의 유니코드 문자를 표현 될 수 있습니다 <xref:System.Char>합니다. 사용 된 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 각 대신 각 유니코드 문자를 사용 하는 클래스 <xref:System.Char>합니다.  
  
 C 및 c + +와 같은 일부 언어에서 null 문자를 문자열의 끝을 나타냅니다. .NET에서 문자열에 null 문자를 포함할 수 있습니다. 문자열에서 하나 이상의 null 문자를 포함 하는 경우 전체 문자열의 길이가 포함 됩니다. 예를 들어 다음 문자열을 부분 문자열 "abc"와 "def" null 문자로 구분 됩니다에서. <xref:System.String.Length%2A> 속성 6 알파벳 문자 뿐만 아니라 null 문자를 포함 하는 것이 나타내는 7을 반환 합니다.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Length%2A> 속성입니다.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이진 표현의 형식이 특정 유니코드 정규화 형식인 새 문자열을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>텍스트 값이 이 문자열과 같지만 이진 표현의 형식이 유니코드 정규화 형식 C인 새 문자열을 반환합니다.</summary>
        <returns>텍스트 값이 이 문자열과 같지만 이진 표현의 형식이 정규화 형식 C인 정규화된 새 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 유니코드 문자는 해당 집합 조합으로 구성 된 여러 이진 표현 및/또는 복합 유니코드 문자입니다. 예를 들어, 다음 코드 지점 중 하나는 문자 "ắ"을 나타낼 수 있습니다.  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 단일 문자에 대 한 여러 표현이 검색, 정렬, 일치 및 기타 작업을 복잡 하 게 합니다.  
  
 표준 유니코드 문자의 해당 이진 표현을 제공 하는 경우 하나의 이진 표현을 반환 하는 정규화 라고 하는 프로세스를 정의 합니다. 다른 규칙을 따르는 정규화 형식 이라는 다양 한 알고리즘을 사용 하 여 정규화를 수행할 수 있습니다. .NET에는 네 가지 정규화 형식 (C, D, KC 및 KD) 유니코드 표준에서 정의 된 지원 합니다. 두 문자열이 동일한 정규화 형태로 표시 되는 경우 서 수 비교를 사용 하 여 비교할 수 있습니다.  
  
 정규화 하 고 두 문자열을 비교 하려면 다음을 수행 합니다.  
  
1.  파일 또는 사용자 입력된 장치와 같은 입력된 원본에서 비교할 문자열을 가져옵니다.  
  
2.  호출 된 <xref:System.String.Normalize> 문자열 정규화 C. 정규화 하는 방법  
  
3.  두 문자열을 비교 하려면 같은 서 수 문자열 비교를 지 원하는 메서드를 호출 합니다 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드 값을 제공 하 고 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 또는 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 으로 <xref:System.StringComparison> 인수. 정규화 된 문자열 배열을 정렬 하려면 전달 된 `comparer` 값 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> 또는 <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> 의 적절 한 오버 로드에 <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  이전 단계에서 표시 된 순서에 따라 정렬 된 출력에 문자열을 내보냅니다.  
  
 지원 되는 유니코드 정규화 형식에 대 한 참조 <xref:System.Text.NormalizationForm?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열을 각각 네 가지 정규화 형식으로 확인 문자열, 지정 된 정규화 형식인 정규화 된 한 다음 정규화 된 문자열에 코드 포인트를 나열 합니다.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 인스턴스에 잘못된 유니코드 문자가 포함되어 있습니다.</exception>
        <block subset="none" type="usage">
          <para>합니다 <see cref="Overload:System.String.IsNormalized" /> 메서드가 반환 되는 <see langword="false" /> 문자열의 첫 번째 정규화 되지 않은 문자가 발견 되는 즉시 합니다. 따라서 문자열 뒤에 잘못 된 유니코드 문자를 정규화 되지 않은 문자를 포함 하는 경우는 <see cref="Overload:System.String.Normalize" /> 메서드는 throw를 <see cref="T:System.ArgumentException" /> 있지만 <see cref="Overload:System.String.IsNormalized" /> 반환 <see langword="false" />합니다.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">유니코드 정규화 형식입니다.</param>
        <summary>텍스트 값이 이 문자열과 같지만 이진 표현의 형식이 지정한 유니코드 정규화 형식인 새 문자열을 반환합니다.</summary>
        <returns>텍스트 값이 이 문자열과 같지만 이진 표현의 형식이 <paramref name="normalizationForm" /> 매개 변수로 지정된 정규화 형식인 새 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 유니코드 문자는 해당 집합 조합으로 구성 된 여러 이진 표현 및/또는 복합 유니코드 문자입니다. 단일 문자에 대 한 여러 표현이 검색, 정렬, 일치 및 기타 작업을 복잡 하 게 합니다.  
  
 표준 유니코드 문자의 해당 이진 표현을 제공 하는 경우 하나의 이진 표현을 반환 하는 정규화 라고 하는 프로세스를 정의 합니다. 다른 규칙을 따르는 정규화 형식 이라는 다양 한 알고리즘을 사용 하 여 정규화를 수행할 수 있습니다. .NET에는 네 가지 정규화 형식 (C, D, KC 및 KD) 유니코드 표준에서 정의 된 지원 합니다. 두 문자열이 동일한 정규화 형태로 표시 되는 경우 서 수 비교를 사용 하 여 비교할 수 있습니다.  
  
 정규화 하 고 두 문자열을 비교 하려면 다음을 수행 합니다.  
  
1.  파일 또는 사용자 입력된 장치와 같은 입력된 원본에서 비교할 문자열을 가져옵니다.  
  
2.  호출 된 <xref:System.String.Normalize%28System.Text.NormalizationForm%29> 문자열을 지정 된 정규화 형식인 정규화 하는 방법입니다.  
  
3.  두 문자열을 비교 하려면 같은 서 수 문자열 비교를 지 원하는 메서드를 호출 합니다 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 메서드 값을 제공 하 고 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 또는 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 으로 <xref:System.StringComparison> 인수. 정규화 된 문자열 배열을 정렬 하려면 전달 된 `comparer` 값 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> 또는 <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> 의 적절 한 오버 로드에 <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  이전 단계에서 표시 된 순서에 따라 정렬 된 출력에 문자열을 내보냅니다.  
  
 지원 되는 유니코드 정규화 형식에 대 한 참조 <xref:System.Text.NormalizationForm?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열을 각각 네 가지 정규화 형식으로 확인 문자열, 지정 된 정규화 형식인 정규화 된 한 다음 정규화 된 문자열에 코드 포인트를 나열 합니다.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 인스턴스에 잘못된 유니코드 문자가 포함되어 있습니다.</exception>
        <block subset="none" type="usage">
          <para>합니다 <see cref="Overload:System.String.IsNormalized" /> 메서드가 반환 되는 <see langword="false" /> 문자열의 첫 번째 정규화 되지 않은 문자가 발견 되는 즉시 합니다. 따라서 문자열 뒤에 잘못 된 유니코드 문자를 정규화 되지 않은 문자를 포함 하는 경우는 <see cref="Overload:System.String.Normalize" /> 메서드가 throw 할 수는 <see cref="T:System.ArgumentException" /> 있지만 <see cref="Overload:System.String.IsNormalized" /> 반환 <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">비교할 첫 번째 문자열 또는 <see langword="null" />입니다.</param>
        <param name="b">비교할 두 번째 문자열 또는 <see langword="null" />입니다.</param>
        <summary>지정된 두 문자열의 값이 같은지를 확인합니다.</summary>
        <returns>
          <see langword="true" />의 값이 <paramref name="a" />의 값과 같으면 <paramref name="b" />를 반환하고, 그러지 않으면 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.String.op_Equality%2A> 에 대 한 같음 연산자의 작업을 정의 하는 메서드를 <xref:System.String> 클래스입니다. 코드를 예제에서는 섹션에 나와 있는 것과 같은 수 있습니다. 연산자를 호출 하는 정적 <xref:System.String.Equals%28System.String%2CSystem.String%29> 메서드는 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행 합니다.  
  
> [!NOTE]
>  Visual Basic 컴파일러 같음 연산자에 대 한 호출으로 해결 되지 않으면를 <xref:System.String.op_Equality%2A> 메서드. 대신 같음 연산자에 대 한 호출을 래핑하는 <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 같음 연산자를 보여 줍니다.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">비교할 첫 번째 문자열 또는 <see langword="null" />입니다.</param>
        <param name="b">비교할 두 번째 문자열 또는 <see langword="null" />입니다.</param>
        <summary>지정된 두 문자열의 값이 다른지를 확인합니다.</summary>
        <returns>
          <see langword="true" />의 값이 <paramref name="a" />의 값과 다르면 <paramref name="b" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.String.op_Inequality%2A> 같지 않음 연산자에 대 한 작업을 정의 하는 메서드를 <xref:System.String> 클래스입니다.   코드를 예 섹션에 표시 된 것과 같은 수 있습니다.  
  
 합니다 <xref:System.String.op_Inequality%2A> 연산자 호출 정적 <xref:System.String.Equals%28System.String%2CSystem.String%29> 서 수 (대/소문자 구분 및 문화권을 구분 하지 않는) 비교를 수행 하는 메서드.  
  
> [!NOTE]
>  Visual Basic 컴파일러 같지 않음 연산자에 대 한 호출으로 해결 되지 않으면를 <xref:System.String.op_Inequality%2A> 메서드. 대신 같지 않음 연산자에 대 한 호출을 래핑하는 <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예에서는 같지 않음 연산자를 보여 줍니다.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 문자열의 시작 부분이 공백이나 지정된 유니코드 문자로 채워지는 지정된 길이의 새 문자열을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">결과 문자열에 있는 문자 수는 원래 문자 수와 추가 안쪽 여백 문자 수를 합한 값과 같습니다.</param>
        <summary>지정한 길이만큼 왼쪽의 안쪽 여백을 공백으로 채워서 이 인스턴스의 문자를 오른쪽에 맞추는 새 문자열을 반환합니다.</summary>
        <returns>이 인스턴스와 동일하지만 오른쪽으로 맞춰지고 왼쪽의 안쪽 여백이 <paramref name="totalWidth" />의 길이만큼 공백 문자로 채워진 새 문자열입니다. 그러나 <paramref name="totalWidth" />가 이 인스턴스의 길이보다 작을 경우 메서드는 기존 인스턴스에 대한 참조를 반환합니다. <paramref name="totalWidth" />가 이 인스턴스의 길이와 같을 경우 메서드는 이 인스턴스와 동일한 새 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 유니코드 공백 문자는 16 진수 0x0020으로 정의 됩니다.  
  
 <xref:System.String.PadLeft%28System.Int32%29> 메서드는 반환된 된 문자열의 시작 부분을 채웁니다. 즉, 오른쪽에서 왼쪽 언어를 사용할 때 문자열의 오른쪽 부분을 채웁니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.PadLeft%2A> 메서드 채웁니다 공백 문자를 사용 하 여 현재 인스턴스,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신, 전체 길이가 되도록 선행 공백을 채운 하는 새 문자열을 반환 합니다 `totalWidth` 문자입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.PadLeft%2A> 메서드.  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" />가 0보다 작은 경우</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">결과 문자열에 있는 문자 수는 원래 문자 수와 추가 안쪽 여백 문자 수를 합한 값과 같습니다.</param>
        <param name="paddingChar">유니코드 안쪽 여백 문자입니다.</param>
        <summary>지정한 길이만큼 왼쪽의 안쪽 여백을 지정된 유니코드 문자로 채워서 이 인스턴스의 문자를 오른쪽에 맞추는 새 문자열을 반환합니다.</summary>
        <returns>이 인스턴스와 동일하지만 오른쪽으로 맞춰지고 왼쪽의 안쪽 여백이 <paramref name="paddingChar" />의 길이만큼 <paramref name="totalWidth" /> 문자로 채워진 새 문자열입니다. 그러나 <paramref name="totalWidth" />가 이 인스턴스의 길이보다 작을 경우 메서드는 기존 인스턴스에 대한 참조를 반환합니다. <paramref name="totalWidth" />가 이 인스턴스의 길이와 같을 경우 메서드는 이 인스턴스와 동일한 새 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> 메서드는 반환된 된 문자열의 시작 부분을 채웁니다. 즉, 오른쪽에서 왼쪽 언어를 사용할 때 문자열의 오른쪽 부분을 채웁니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.PadLeft%2A> 메서드 채웁니다 공백 문자를 사용 하 여 현재 인스턴스,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신 최고의 채워집니다 하는 새 문자열을 반환 합니다 `paddingChar` 자로 전체 길이가 `totalWidth` 문자입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.PadLeft%2A> 메서드.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" />가 0보다 작은 경우</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 문자열의 끝 부분이 공백이나 지정된 유니코드 문자로 채워지는 지정된 길이의 새 문자열을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">결과 문자열에 있는 문자 수는 원래 문자 수와 추가 안쪽 여백 문자 수를 합한 값과 같습니다.</param>
        <summary>지정한 길이만큼 오른쪽의 안쪽 여백을 공백으로 채워서 이 문자열의 문자를 왼쪽에 맞추는 새 문자열을 반환합니다.</summary>
        <returns>이 인스턴스와 동일하지만 왼쪽으로 맞춰지고 오른쪽의 안쪽 여백이 <paramref name="totalWidth" />의 길이만큼 공백 문자로 채워진 새 문자열입니다. 그러나 <paramref name="totalWidth" />가 이 인스턴스의 길이보다 작을 경우 메서드는 기존 인스턴스에 대한 참조를 반환합니다. <paramref name="totalWidth" />가 이 인스턴스의 길이와 같을 경우 메서드는 이 인스턴스와 동일한 새 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 유니코드 공백 문자는 16 진수 0x0020으로 정의 됩니다.  
  
 <xref:System.String.PadRight%28System.Int32%29> 메서드는 반환된 된 문자열의 끝을 채웁니다. 즉, 오른쪽에서 왼쪽 언어를 사용할 때 문자열의 왼쪽된 부분을 채웁니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.PadRight%2A> 메서드 채웁니다 공백 문자를 사용 하 여 현재 인스턴스,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 전체 길이가 되도록 후행 공백으로 채워집니다 있는 새 문자열을 반환 하는 대신 `totalWidth` 문자입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.PadRight%2A> 메서드.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" />가 0보다 작은 경우</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">결과 문자열에 있는 문자 수는 원래 문자 수와 추가 안쪽 여백 문자 수를 합한 값과 같습니다.</param>
        <param name="paddingChar">유니코드 안쪽 여백 문자입니다.</param>
        <summary>지정한 길이만큼 오른쪽의 안쪽 여백을 지정된 유니코드 문자로 채워서 이 문자열의 문자를 왼쪽에 맞추는 새 문자열을 반환합니다.</summary>
        <returns>이 인스턴스와 동일하지만 왼쪽으로 맞춰지고 오른쪽의 안쪽 여백이 <paramref name="paddingChar" />의 길이만큼 <paramref name="totalWidth" /> 문자로 채워진 새 문자열입니다. 그러나 <paramref name="totalWidth" />가 이 인스턴스의 길이보다 작을 경우 메서드는 기존 인스턴스에 대한 참조를 반환합니다. <paramref name="totalWidth" />가 이 인스턴스의 길이와 같을 경우 메서드는 이 인스턴스와 동일한 새 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> 메서드는 반환된 된 문자열의 끝을 채웁니다. 즉, 오른쪽에서 왼쪽 언어를 사용할 때 문자열의 왼쪽된 부분을 채웁니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.PadRight%2A> 메서드 채웁니다 공백 문자를 사용 하 여 현재 인스턴스,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신, 후행 채워집니다 하는 새 문자열을 반환 합니다 `paddingChar` 자로 전체 길이가 `totalWidth` 문자입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.PadRight%2A> 메서드.  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" />가 0보다 작은 경우</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 문자열에서 지정한 수의 문자가 삭제되는 새 문자열을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">문자 삭제를 0부터 시작할 위치입니다.</param>
        <summary>지정된 위치부터 마지막 위치 사이에 현재 인스턴스의 모든 문자가 삭제되었던 새 문자열을 반환합니다.</summary>
        <returns>제거된 문자를 제외하고 이 문자열과 동일한 새 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], 문자열은 0부터 시작 합니다. 값을 `startIndex` 매개 변수의 범위는 0부터 1 문자열 인스턴스 길이 보다 작은 값입니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신, 새 문자열 반환 되는 모든 문자에 위치에서 `startIndex` 원래 문자열의 끝에 제거 되었습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.Remove%2A> 메서드. 다음 마지막 경우 문자열의 끝까지 지정된 된 인덱스에서 시작 하는 모든 텍스트를 제거 합니다. 마지막 경우 지정된 된 인덱스에서 시작 하는 세 개의 문자를 제거 합니다.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 0보다 작은 경우  
  
또는 
 <paramref name="startIndex" />이(가) 이 문자열 내에 없는 위치를 지정합니다.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">문자 삭제를 0부터 시작할 위치입니다.</param>
        <param name="count">삭제할 문자의 수입니다.</param>
        <summary>현재 인스턴스의 지정된 위치에서 시작하여 지정된 수의 문자가 삭제되었던 새 문자열을 반환합니다.</summary>
        <returns>제거된 문자를 제외하고 이 인스턴스와 동일한 새 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], 문자열은 0부터 시작 합니다. 값을 `startIndex` 매개 변수의 범위는 0부터 1 문자열 인스턴스 길이 보다 작은 값입니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신 하 여 문자 수가 지정 된 새 문자열을 반환 합니다 `count` 매개 변수가 제거 되었습니다. 문자에 지정 된 위치에서 제거 됩니다 `startIndex`합니다.  
  
   
  
## Examples  
 다음 예제에서는 전체 이름에서 중간 이름을 제거 하는 방법을 보여 줍니다.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="count" />이(가) 0보다 작습니다.  
  
또는 
 <paramref name="startIndex" />과(와) <paramref name="count" />이(가) 함께 사용되어 이 인스턴스 외부 위치를 지정합니다.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 문자열에서 발견되는 지정된 유니코드 문자 또는 <see cref="T:System.String" />을 모두 지정된 다른 유니코드 문자 또는 <see cref="T:System.String" />으로 바꾼 새 문자열을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">바꿀 유니코드 문자입니다.</param>
        <param name="newChar">모든 <paramref name="oldChar" />을 바꿀 유니코드 문자입니다.</param>
        <summary>현재 인스턴스의 지정된 유니코드 문자가 지정된 다른 유니코드 문자로 모두 바뀌는 새 문자열을 반환합니다.</summary>
        <returns>
          <paramref name="oldChar" />의 모든 인스턴스를 <paramref name="newChar" />로 바꾼다는 점을 제외하고 이 인스턴스와 동일한 문자열입니다. <paramref name="oldChar" />를 현재 인스턴스에서 찾을 수 없으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분) 찾기 검색을 수행 `oldChar`합니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 모두 바뀌는 새 문자열을 반환 하는 대신 `oldChar` 바뀝니다 `newChar`합니다.  
  
 이 메서드는 수정 된 문자열을 반환 하므로 연결할 수 있습니다를 연속적으로 호출 된 <xref:System.String.Replace%2A> 원래 문자열에서 여러 대체를 수행 하는 방법입니다. 메서드 호출 왼쪽에서 오른쪽으로 실행 됩니다. 다음 예제에서 이에 대해 설명합니다.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 다음 예제에서는 일련의 숫자 사이 있는 공백 쉼표로 대체 하 여 쉼표로 구분 된 값 목록을 만듭니다.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">바꿀 문자열입니다.</param>
        <param name="newValue">모든 <paramref name="oldValue" />를 바꿀 문자열입니다.</param>
        <summary>현재 인스턴스의 지정된 문자열이 지정된 다른 문자열로 모두 바뀌는 새 문자열을 반환합니다.</summary>
        <returns>
          <paramref name="oldValue" />의 모든 인스턴스를 <paramref name="newValue" />로 바꾼다는 점을 제외하고 현재 문자열과 동일한 문자열입니다. <paramref name="oldValue" />를 현재 인스턴스에서 찾을 수 없으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 `newValue` 됩니다 `null`, 모든 `oldValue` 제거 됩니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 모두 바뀌는 새 문자열을 반환 하는 대신 `oldValue` 바뀝니다 `newValue`합니다.  
  
 이 메서드는 서 수 (대/소문자 구분 및 문화권을 구분) 찾기 검색을 수행 `oldValue`합니다.  
  
 이 메서드는 수정 된 문자열을 반환 하므로 연결할 수 있습니다를 연속적으로 호출 된 <xref:System.String.Replace%2A> 원래 문자열에서 여러 대체를 수행 하는 방법입니다. 메서드 호출 왼쪽에서 오른쪽으로 실행 됩니다. 다음 예제에서 이에 대해 설명합니다.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다는 <xref:System.String.Replace%2A> 맞춤법 오류를 해결 하는 방법입니다.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" />가 빈 문자열("")입니다.</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 문자열 또는 유니코드 문자 배열의 요소로 구분된 이 인스턴스의 부분 문자열이 포함된 문자열 배열을 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> 문자열로 구분 된 문자열을 중단 하는 데 사용 됩니다. 문자 배열 중 하나를 사용 하 여 0, 1 또는 여러 구분 문자를 지정 하려면 (의 <xref:System.String.Split%28System.Char%5B%5D%29> 메서드), 0, 1 또는 여러 개의 구분 기호 문자열을 지정 하는 문자 배열에 사용할 수 있습니다. 오버 로드는 <xref:System.String.Split%2A> 메서드를 통해 메서드에서 반환 하는 부분 문자열의 수를 제한할 수 있습니다 (합니다 <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> 메서드) 빈 문자열이 반환 된 부분 문자열에 포함 되는지 여부를 확인 하기 (는 <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> 및 <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> 메서드 또는 작업을 모두 (합니다 <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> 및 <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> 메서드).  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a>String.Split에 대 한 대안

 <xref:System.String.Split%2A> 메서드는 항상 구분 된 문자열을 부분 문자열을 분할 하는 가장 좋은 방법은 없습니다. 모든 구분된 된 문자열의 부분 문자열을 추출 하지 않으려는 경우 또는 구분 기호 문자 집합이 아니라 패턴에 따라 문자열을 구문 분석 하려는 경우 다음 대안을 고려 합니다.  
  
### <a name="regular-expressions"></a>정규식  
 문자열 고정된 패턴을 준수 하는 경우 압축을 풀고 해당 요소를 처리 하는 정규식을 사용할 수 있습니다. 예를 들어 문자열 형태로 "*수* *피연산자* *번호*" 사용할 수는 [정규식](~/docs/standard/base-types/regular-expressions.md) 압축을 풀어 처리는 문자열의 요소입니다. 예를 들면 다음과 같습니다.  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 정규식 패턴 `(\d+)\s+([-+*/])\s+(\d+)` 다음과 같이 정의 됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`(\d+)`|하나 이상의 10진수 숫자가 일치하는지 확인합니다. 이 그룹은 첫 번째 캡처링 그룹입니다.|  
|`\s+`|하나 이상의 공백 문자를 찾습니다.|  
|`([-+*/])`|일치는 산술 연산자 기호 (+,-, *, 또는 /). 이 그룹은 두 번째 캡처링 그룹입니다.|  
|`\s+`|하나 이상의 공백 문자를 찾습니다.|  
|`(\d+)`|하나 이상의 10진수 숫자가 일치하는지 확인합니다. 이 그룹은 세 번째 캡처링 그룹입니다.|  
  
 또한 고정된 문자 집합이 아닌 패턴을 기반으로 문자열에서 부분 문자열을 추출 하는 정규식을 사용할 수 있습니다. 이러한 조건 중 하나가 발생 하면 일반적인 시나리오입니다.  
  
-   하나 이상의 구분 기호 문자를 처리 하지 않는 경우 항상에서 구분 기호로 <xref:System.String> 인스턴스.  
  
-   순서 및 구분 기호 문자의 수를 변수 이거나 알 수는 있습니다.  
  
 예를 들어, 합니다 <xref:System.String.Split%2A> 때문에 다음 문자열을 분할 메서드를 사용할 수 없습니다 수가 `\n` (에서 C#) 또는 `vbCrLf` (Visual Basic)의 문자는 변수 이며 항상 구분 기호로 사용 하지 않습니다.  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 정규식을 쉽게 다음 예와 같이이 문자열을 분할할 수 있습니다.  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 정규식 패턴 `\[([^\[\]]+)\]` 다음과 같이 정의 됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\[`|여는 대괄호와 일치 합니다.|  
|`([^\[\]]+)`|없는 열거나 닫는 대괄호를 한 번 이상 문자를 찾습니다. 이 그룹은 첫 번째 캡처링 그룹입니다.|  
|`\]`|닫는 괄호를 일치 합니다.|  
  
 합니다 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 거의 동일 <xref:System.String.Split%2A?displayProperty=nameWithType>고정된 문자 집합 대신 정규식 패턴에 따라 문자열을 분할 하는 점을 제외 하 고 있습니다. 예를 들어, 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 하이픈와 기타 문자 다양 한 조합으로 구분 하는 부분 문자열을 포함 하는 문자열을 분할 하는 방법입니다.  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 정규식 패턴 `\s-\s?[+*]?\s?-\s` 다음과 같이 정의 됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\s-`|하이픈 뒤에 공백 문자를 찾습니다.|  
|`\s?`|0번 이상 나오는 공백 문자를 찾습니다.|  
|`[+*]?`|0 번 이상 찾습니다는 + 또는 * 문자입니다.|  
|`\s?`|0번 이상 나오는 공백 문자를 찾습니다.|  
|`-\s`|공백 문자 뒤에 하이픈을 찾습니다.|  
  
### <a name="search-methods-and-the-substring-method"></a>검색 방법 및 Substring 메서드  
 문자열의 부분 문자열의 모든 관심이 아닌 경우에 일치 하는 시작 되는 인덱스를 반환 하는 문자열 비교 방법 중 하나를 사용 하는 것이 좋습니다. 호출할 수 있습니다는 <xref:System.String.Substring%2A> 원하는 하위 문자열을 추출 하는 방법입니다. 문자열 비교 메서드는 다음과 같습니다.  
  
-   <xref:System.String.IndexOf%2A>에서 맨 처음 발견 되는 문자 또는 문자열의 0부터 시작 인덱스 문자열 인스턴스를 반환 합니다.  
  
-   <xref:System.String.IndexOfAny%2A>에 현재 문자열 인스턴스가 문자 배열에 있는 문자 중 처음 나타나는 0부터 시작 인덱스를 반환 하는 합니다.  
  
-   <xref:System.String.LastIndexOf%2A>에 문자 또는 문자열의 마지막 요소의 0부터 시작 인덱스 문자열 인스턴스를 반환 합니다.  
  
-   <xref:System.String.LastIndexOfAny%2A>을 현재 문자열 인스턴스에서 모든 문자는 문자 배열에서 마지막 요소의 0부터 시작 인덱스를 반환 하는 합니다.  
  
 다음 예제에서는 <xref:System.String.IndexOf%2A> 메서드를 문자열에서 기간을 찾습니다. 사용 하 여는 <xref:System.String.Substring%2A> 전체 문장을 반환 하는 방법입니다.  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">이 문자열의 부분 문자열을 구분하는 문자 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</param>
        <summary>문자열을 배열 내 문자에 기초하는 하위 문자열로 분할합니다.</summary>
        <returns>요소에 <paramref name="separator" />에 있는 하나 이상의 문자로 구분되는 이 인스턴스의 부분 문자열이 포함된 배열입니다. 자세한 내용은 설명 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 문자열은 알려진된 문자 집합으로 구분 되 면 하는 경우 사용할 수 있습니다는 <xref:System.String.Split%28System.Char%5B%5D%29> 부분 문자열을 구분 하는 방법입니다.   
  
### <a name="return-value-details"></a>반환 값 정보  
 구분 기호 문자는 반환 된 배열의 요소에 포함 되지 않습니다. 예를 들어, 배열 구분 기호 문자를 포함 하는 경우 "-"는 현재 문자열 인스턴스가의 값은 "cc-aa-bb", 메서드 3 개 요소가 포함 된 배열을 반환 하 고: "aa", "bb" 및 "cc"입니다.  
  
 이 인스턴스가 없는 경우에 문자 `separator`, 반환된 된 배열에이 인스턴스를 포함 하는 단일 요소로 구성 됩니다.  
  
 각 요소의 `separator` 별도 구분 기호 문자를 정의 합니다. 반환 된 배열의 해당 요소를 포함 하는 경우 두 구분 기호는 서로 인접 하는 구분 기호의 시작과 끝이 인스턴스의 위치, <xref:System.String.Empty>합니다. 다음은 몇 가지 예입니다.  
  
|문자열 값|구분 기호|반환 된 배열|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|new Char {',', ' '} (C#)<br /><br /> Char () = {"," c "" c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|new 문자 {0} '.'} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"Banana"|new 문자 {0} '.'} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" vbLf & "Smarba" (Visual Basic)|new Char {} (C#)<br /><br /> Char () = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" vbLf & "Smarba" (Visual Basic)|null(C#)<br /><br /> Nothing(Visual Basic)|{"Darb", "Smarba"}|  
  
### <a name="the-separator-array"></a>구분 기호 배열  
 각 요소의 구분 기호는 단일 문자로 구성 된 별도 구분 기호를 정의 합니다. 경우는 `separator` 인수가 `null` 문자가 없는 또는 메서드는 구분 기호로 공백 문자를 처리 합니다. 공백 문자는 유니코드 표준; 정의 돌아왔을 `true` 에 전달 하는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a>String.Split(Char[]) 및 컴파일러 오버 로드 확인  
 하지만이 오버 로드에 대 한 단일 매개 변수 <xref:System.String.Split%2A?displayProperty=nameWithType> 를 문자 배열에는 다음 예제와 같이 단일 문자를 사용 하 여 호출할 수 있습니다.  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 때문에 `separator` 으로 데코 레이트 된 매개 변수는 <xref:System.ParamArrayAttribute> 특성인 컴파일러는 단일 요소 문자 배열로 단일 문자를 해석 합니다. 다른 경우 이것이 <xref:System.String.Split%2A?displayProperty=nameWithType> 포함 하는 오버 로드를 `separator` 매개 변수 명시적으로 전달 해야 이러한 오버 로드로 문자 배열은 `separator` 인수입니다.  
  
### <a name="comparison-details"></a>비교 세부 정보  
 합니다 <xref:System.String.Split%28System.Char%5B%5D%29> 의 문자를 하나 이상의 구분 되는이 문자열의 부분 문자열을 추출 하는 메서드는 `separator` 배열 및 배열 요소로 해당 부분 문자열을 반환 합니다.  
  
 <xref:System.String.Split%28System.Char%5B%5D%29> 메서드가 서 수 대/소문자 구분 정렬 규칙을 사용 하 여 비교를 수행 하 여 구분 기호를 찾습니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다.  
  
### <a name="performance-considerations"></a>성능 고려 사항  
 합니다 <xref:System.String.Split%2A> 메서드는 반환된 된 배열 개체에 대 한 메모리를 할당 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다. 응용 프로그램에 필요한 최적의 성능, 메모리 할당을 관리 하는 것이 중요 응용 프로그램 사용을 고려 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드. 사용 하는 옵션도 있습니다를 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법입니다.  
  
 구분 기호 문자에서 문자열을 분할 하려면 사용 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 문자열의 구분 기호 문자를 찾는 방법입니다. 구분 기호 문자열에서 문자열을 분할 하려면 사용 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 구분 기호 문자열의 첫 번째 문자를 찾기 위해 메서드. 사용 하 여는 <xref:System.String.Compare%2A> 첫 번째 문자는 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 하는 방법입니다.  
  
 또한 동일한 설정의 경우 문자는 여러에서 문자열을 분할 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다. 이렇게 하면 각 메서드 호출의 추가 오버 헤드를 크게 줄어듭니다.  
  
## Examples  
 다음 예제에서는 구분 기호로 공백 및 문장 부호를 처리 하 여 텍스트 블록에서 개별 단어를 추출 하는 방법에 설명 합니다. 문자 배열에 전달 합니다 `separator` 의 매개 변수는 <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> 메서드 공백 문자 및 일부 일반적인 문장 부호 기호 함께 탭 문자를 구성 합니다.  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 및 이전 버전에서 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다를 <paramref name="separator" /> 즉 <see langword="null" /> 문자가 없는 또는 메서드 약간 다른 문자 집합을 사용 하 여 분할 된 문자열 보다는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드를 수행 하지 않습니다 문자열을 자릅니다. .NET Framework 4 부터는 두 방법 모두 유니코드 공백 문자의 동일한 집합을 사용 합니다.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">이 문자열의 부분 문자열을 구분하는 문자 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</param>
        <param name="count">반환할 부분 문자열의 최대 수입니다.</param>
        <summary>배열에 있는 문자에 따라 최대 개수의 부분 문자열로 문자열을 분할합니다. 반환할 부분 문자열의 최대 수도 지정합니다.</summary>
        <returns>해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자로 구분되는 이 인스턴스의 부분 문자열이 포함된 배열입니다. 자세한 내용은 설명 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구분 기호 문자는 반환 된 배열의 요소에 포함 되지 않습니다.  
  
 이 인스턴스가 없는 경우에 문자 `separator`, 반환된 된 배열에이 인스턴스를 포함 하는 단일 요소로 구성 됩니다. 경우 `count` 가 0 이면 빈 배열이 반환 됩니다.  
  
 경우는 `separator` 매개 변수는 `null` 문자가 없는 또는 공백 문자를 구분 기호로 간주 됩니다. 공백 문자는 유니코드 표준 및 반환 정의한 `true` 에 전달 하는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.  
  
 각 요소의 `separator` 별도 구분 기호 문자를 정의 합니다. 해당 배열 요소를 포함 하는 경우 두 구분 기호는 서로 인접 하는 구분 기호의 시작과 끝이 인스턴스의 위치, <xref:System.String.Empty>합니다.  
  
 있는 경우 둘 `count` 이 인스턴스의 부분 문자열이 첫 번째 `count` 빼기 1 부분 문자열에서 첫 번째 반환 됩니다 `count` 반환 값을이 인스턴스의 나머지 문자 요소는 마지막에 반환 됩니다 반환 값의 요소입니다.  
  
 경우 `count` 수보다 큰 부분을 사용할 수 있는 부분 문자열 반환 되 고 예외가 throw 되지 않습니다.  
  
 다음 표에서 예제를 제공합니다.  
  
|문자열 값|구분 기호|개수|반환 된 배열|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|new Char {',', ' '} (C#)<br /><br /> Char () = {"," c "" c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|new 문자 {0} '.'} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"Banana"|new 문자 {0} '.'} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|2|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" vbLf & "Smarba" (Visual Basic)|new Char {} (C#)<br /><br /> Char () = {} (Visual Basic)|1|{"Darb\nSmarba"} (C#)<br /><br /> "Darb" vbLf & "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" vbLf & "Smarba" (Visual Basic)|null new Char (C#)<br /><br /> Char () = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" vbLf & "Smarba" (Visual Basic)|null new Char (C#)<br /><br /> Char () = Nothing|100|{"Darb", "Smarba"}|  
  
### <a name="performance-considerations"></a>성능 고려 사항  
 합니다 <xref:System.String.Split%2A> 메서드는 반환된 된 배열 개체에 대 한 메모리를 할당 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다. 응용 프로그램에 필요한 최적의 성능, 메모리 할당을 관리 하는 것이 중요 응용 프로그램 사용을 고려 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 및 필요에 따라는 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법입니다.  
  
 구분 기호 문자에서 문자열을 분할 하는 경우 사용 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 문자열의 구분 기호 문자를 찾는 방법입니다. 구분 기호 문자열에서 문자열을 분할 하는 경우 사용 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 구분 기호 문자열의 첫 번째 문자를 찾기 위해 메서드. 사용 하 여는 <xref:System.String.Compare%2A> 첫 번째 문자는 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 하는 방법입니다.  
  
 또한 동일한 설정의 경우 문자는 여러에서 문자열을 분할 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다. 이렇게 하면 각 메서드 호출의 추가 오버 헤드를 크게 줄어듭니다.  
  
   
  
## Examples  
 다음 예제에서는 어떻게 `count` 에서 반환 된 문자열의 영향을 줍니다 <xref:System.String.Split%2A>합니다.  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />가 음수입니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 및 이전 버전에서 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다를 <paramref name="separator" /> 즉 <see langword="null" /> 문자가 없는 또는 메서드 약간 다른 문자 집합을 사용 하 여 분할 된 문자열 보다는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드를 수행 하지 않습니다 문자열을 자릅니다. .NET Framework 4 부터는 두 방법 모두 유니코드 공백 문자의 동일한 집합을 사용 합니다.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">이 문자열의 부분 문자열을 구분하는 문자 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</param>
        <param name="options">반환된 배열에서 빈 배열 요소를 생략하려면 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />이고, 반환된 배열에 빈 배열 요소를 포함하려면 <see cref="F:System.StringSplitOptions.None" />입니다.</param>
        <summary>배열에 있는 문자에 따라 문자열을 부분 문자열로 분할합니다. 부분 문자열이 빈 배열 요소를 포함하는지 여부를 지정할 수 있습니다.</summary>
        <returns>해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자로 구분되는 이 문자열의 부분 문자열이 포함된 배열입니다. 자세한 내용은 설명 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>반환 값 정보  
 구분 기호 문자 (문자는 `separator` 배열) 반환 된 배열의 요소에 포함 되지 않습니다. 예를 들어 경우는 `separator` 문자를 포함 하는 배열 "-"는 현재 문자열 인스턴스가의 값은 "cc-aa-bb", 메서드 3 개 요소가 포함 된 배열을 반환 하 고: "aa", "bb" 및 "cc"입니다.  
  
 이 인스턴스가 없는 경우에 문자 `separator`, 반환된 된 배열에이 인스턴스를 포함 하는 단일 요소로 구성 됩니다.  
  
 경우는 `options` 매개 변수는 <xref:System.StringSplitOptions.RemoveEmptyEntries> 이 인스턴스의 길이 0을 메서드는 빈 배열을 반환 합니다.  
  
 각 요소의 `separator` 단일 문자로 구성 된 별도 구분 기호를 정의 합니다. 경우는 `options` 인수가 <xref:System.StringSplitOptions.None>, 및 두 구분 기호는 인접 한 있거나 구분 기호에 시작 또는 끝이 인스턴스의 해당 배열 요소에 포함 되어 <xref:System.String.Empty?displayProperty=nameWithType>입니다. 예를 들어, 경우 `separator` 두 요소를 포함 "-" 및 "\_", 문자열 인스턴스의 값이 "-\_aa-\_"의 값을 `options` 인수가 <xref:System.StringSplitOptions.None>, 메서드를 사용 하 여 문자열 배열을 반환 합니다. 다음 5 개 요소:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>를 앞에 있는 빈 문자열을 나타내는 "-" 인덱스 0에 문자입니다.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>사이의 빈 문자열을 나타내는 "-" 인덱스 0 및 1 인덱스에 있는 "_" 문자가 문자입니다.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>에서 인덱스 4에서 "_" 문자 뒤에 오는 빈 문자열을 나타냅니다.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>에 빈 문자열을 나타내는 "-" 5 인덱스 문자.  
  
### <a name="the-separator-array"></a>구분 기호 배열  
 경우는 `separator` 매개 변수는 `null` 문자가 없는 또는 공백 문자를 구분 기호로 간주 됩니다. 공백 문자는 유니코드 표준 및 반환 정의한 `true` 에 전달 하는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.  
  
 경우는 `separator` 이 메서드 오버 로드에 대 한 호출에서 매개 변수는 `null`, 컴파일러 오버 로드 확인에 실패 합니다. 호출된 된 메서드를 명확 하 게 식별 하려면 코드의 형식을 나타내야 합니다 `null`합니다. 다음 예제에서는이 오버 로드를 명확 하 게 식별 하는 여러 방법을 보여 줍니다.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a>비교 세부 정보  
 합니다 <xref:System.String.Split%2A> 의 문자를 하나 이상의 구분 되는이 문자열의 부분 문자열을 추출 하는 메서드는 `separator` 매개 변수를 배열 요소로 해당 부분 문자열을 반환 합니다.  
  
 <xref:System.String.Split%2A> 메서드가 서 수 대/소문자 구분 정렬 규칙을 사용 하 여 비교를 수행 하 여 구분 기호를 찾습니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다.  
  
### <a name="performance-considerations"></a>성능 고려 사항  
 합니다 <xref:System.String.Split%2A> 메서드는 반환된 된 배열 개체에 대 한 메모리를 할당 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다. 응용 프로그램에 필요한 최적의 성능, 메모리 할당을 관리 하는 것이 중요 응용 프로그램 사용을 고려 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 및 필요에 따라는 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법입니다.  
  
 구분 기호 문자에서 문자열을 분할 하는 경우 사용 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 문자열의 구분 기호 문자를 찾는 방법입니다. 구분 기호 문자열에서 문자열을 분할 하는 경우 사용 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 구분 기호 문자열의 첫 번째 문자를 찾기 위해 메서드. 사용 하 여는 <xref:System.String.Compare%2A> 첫 번째 문자는 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 하는 방법입니다.  
  
 또한 동일한 설정의 경우 문자는 여러에서 문자열을 분할 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다. 이렇게 하면 각 메서드 호출의 추가 오버 헤드를 크게 줄어듭니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.StringSplitOptions> 열거형을 포함 하거나 제외 하 여 생성 된 부분 문자열을 <xref:System.String.Split%2A> 메서드.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" />가 <see cref="T:System.StringSplitOptions" /> 값 중 하나가 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 및 이전 버전에서 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다를 <paramref name="separator" /> 즉 <see langword="null" /> 문자가 없는 또는 메서드 약간 다른 문자 집합을 사용 하 여 분할 된 문자열 보다는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드를 수행 하지 않습니다 문자열을 자릅니다. .NET Framework 4 부터는 두 방법 모두 유니코드 공백 문자의 동일한 집합을 사용 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">이 문자열의 부분 문자열을 구분하는 문자열 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</param>
        <param name="options">반환된 배열에서 빈 배열 요소를 생략하려면 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />이고, 반환된 배열에 빈 배열 요소를 포함하려면 <see cref="F:System.StringSplitOptions.None" />입니다.</param>
        <summary>배열에 있는 문자열에 따라 문자열을 부분 문자열로 분할합니다. 부분 문자열이 빈 배열 요소를 포함하는지 여부를 지정할 수 있습니다.</summary>
        <returns>해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자열로 구분되는 이 문자열의 부분 문자열이 포함된 배열입니다. 자세한 내용은 설명 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 문자열은 문자열의 알려진된 집합으로 구분 되 면 하는 경우 사용할 수 있습니다는 <xref:System.String.Split%2A> 부분 문자열을 구분 하는 방법입니다.  
  
### <a name="return-value-details"></a>반환 값 정보  
 구분 기호 문자열로 반환 된 배열의 요소에 포함 되지 않습니다. 예를 들어 경우는 `separator` 배열이 포함 된 문자열 "-"는 현재 문자열 인스턴스가의 값은 "aa-cc bb", 메서드 3 개 요소가 포함 된 배열을 반환 하 고: "aa", "bb" 및 "cc"입니다.  
  
 이 인스턴스가 없으면의 해당 문자열이 하나라 `separator`, 반환된 된 배열에이 인스턴스를 포함 하는 단일 요소로 구성 됩니다.  
  
 경우는 `options` 매개 변수는 <xref:System.StringSplitOptions.RemoveEmptyEntries> 이 인스턴스의 길이 0을 메서드는 빈 배열을 반환 합니다.  
  
 각 요소의 `separator` 하나 이상의 문자로 구성 된 별도 구분 기호를 정의 합니다. 경우는 `options` 인수가 <xref:System.StringSplitOptions.None>, 및 두 구분 기호는 인접 한 있거나 구분 기호에 시작 또는 끝이 인스턴스의 해당 배열 요소에 포함 되어 <xref:System.String.Empty?displayProperty=nameWithType>입니다. 예를 들어 경우 `separator` 두 요소를 포함 "-" "_", 문자열 인스턴스의 값이 "-_aa-\_", 값과는 `options` 인수가 <xref:System.StringSplitOptions.None>, 메서드를 다음 5 개 요소가 포함 된 문자열 배열을 반환 합니다:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>를 앞에 있는 빈 문자열을 나타내는 "-" 인덱스 0에 있는 부분 문자열입니다.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>사이의 빈 문자열을 나타내는 "-" 인덱스 0 및 1 인덱스 "_" 부분 문자열에 부분 문자열입니다.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>에서 인덱스 4에 있는 "_" 부분 문자열 뒤에 오는 빈 문자열을 나타냅니다.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>에 빈 문자열을 나타내는 "-" 5 인덱스 부분 문자열.  
  
### <a name="the-separator-array"></a>구분 기호 배열  
 요소 하나라 `separator` 구성 전체 부분 문자열이 구분 기호를 여러 개의 문자로 간주 됩니다. 예를 들어 하나에 있는 요소의 `separator` 은 "10", "This10is10a10string." 문자열을 분할 하려고 합니다. 다음 4 개 요소 배열을 반환 합니다: {"This", "is", "a", "문자열입니다." }.  
  
 경우는 `separator` 매개 변수는 `null` 문자가 없는 또는 공백 문자를 구분 기호로 간주 됩니다. 공백 문자는 유니코드 표준 및 반환 정의한 `true` 에 전달 하는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.  
  
 경우는 `separator` 이 메서드 오버 로드에 대 한 호출에서 매개 변수는 `null`, 컴파일러 오버 로드 확인에 실패 합니다. 호출된 된 메서드를 명확 하 게 식별 하려면 코드의 형식을 나타내야 합니다 `null`합니다. 다음 예제에서는이 오버 로드를 명확 하 게 식별 하는 여러 방법을 보여 줍니다.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a>비교 세부 정보  
 <xref:System.String.Split%2A> 에 있는 문자열 중 하나 이상의 구분 되는이 문자열의 부분 문자열을 추출 하는 메서드는 `separator` 매개 변수를 배열 요소로 해당 부분 문자열을 반환 합니다.  
  
 <xref:System.String.Split%2A> 메서드가 서 수 대/소문자 구분 정렬 규칙을 사용 하 여 비교를 수행 하 여 구분 기호를 찾습니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다.  
  
 합니다 <xref:System.String.Split%2A> 의 요소를 무시 하는 메서드 `separator` 값인 `null` 또는 빈 문자열 ("").  
  
 모호한 결과 방지 하기 때의 문자열 `separator` 문자를 공통적으로 합니다 <xref:System.String.Split%2A> 작업 인스턴스 값의 끝부터 진행 되 고 첫 번째 요소와 일치 `separator` 같은지에서 구분 기호를는 인스턴스입니다. 인스턴스에서 발생 하는 부분 문자열이 나타나는 순서에 있는 요소의 순서 보다 우선 `separator`합니다.  
  
 예를 들어 값인 "abcdef" 인스턴스에 것이 좋습니다. 경우에 첫 번째 요소 `separator` ef 및 두 번째 요소를 "bcde" 이면 split 작업의 결과 두 개의 요소를 포함 하는 문자열 배열 "a"와 "f"입니다. 이 "bcde" 인스턴스에 있는 부분 문자열은와 일치 하기 때문에 요소 `separator` 부분 문자열 "f"가 발생 하기 전에 합니다.  
  
 그러나 경우 첫 번째 요소 `separator` "bcd"와 두 번째 요소 "bc" 이면 split 작업의 결과 두 개의 요소를 포함 하는 문자열 배열 "a" 및 "ef"입니다. "Bcd"는 첫 번째 구분 기호 이므로이 `separator` 인스턴스 구분 기호와 일치 하는 합니다. 첫 번째 요소 "bc"는 구분 기호의 순서 거꾸로 되어 및 두 번째 요소가 "bcd" 이면 결과 두 개의 요소를 포함 하는 문자열 배열 하는 경우 "a"와 "def"입니다.  
  
### <a name="performance-considerations"></a>성능 고려 사항  
 합니다 <xref:System.String.Split%2A> 메서드는 반환된 된 배열 개체에 대 한 메모리를 할당 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다. 응용 프로그램에 필요한 최적의 성능, 메모리 할당을 관리 하는 것이 중요 응용 프로그램 사용을 고려 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 및 필요에 따라는 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법입니다.  
  
 구분 기호 문자에서 문자열을 분할 하는 경우 사용 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 문자열의 구분 기호 문자를 찾는 방법입니다. 구분 기호 문자열에서 문자열을 분할 하는 경우 사용 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 구분 기호 문자열의 첫 번째 문자를 찾기 위해 메서드. 사용 하 여는 <xref:System.String.Compare%2A> 첫 번째 문자는 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 하는 방법입니다.  
  
 또한 동일한 설정의 경우 문자는 여러에서 문자열을 분할 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다. 이렇게 하면 각 메서드 호출의 추가 오버 헤드를 크게 줄어듭니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열의 호출 하 여 반환 된 배열이 차이 보여 줍니다 <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> 메서드를 사용 하 여 해당 `options` 매개 변수를 <xref:System.StringSplitOptions.None?displayProperty=nameWithType> 고 <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>합니다.  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 다음 예제에서는 문장 부호 및 공백 문자를 포함 하는 구분 기호 배열을 정의 합니다. 값이 배열 전달 <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> 에 <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> 문자열에서 개별 단어로 구성 된 배열을 반환 합니다.  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 메서드를 사용 하 여 호출 되는 참고 합니다 `options` 인수와 함께 <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>입니다. 반환된 된 배열 등에서 이렇게 <xref:System.String.Empty?displayProperty=nameWithType> 문장 부호 및 공백 문자 사이 빈 부분 문자열 일치를 나타내는 값입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" />가 <see cref="T:System.StringSplitOptions" /> 값 중 하나가 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 및 이전 버전에서 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다를 <paramref name="separator" /> 즉 <see langword="null" /> 문자가 없는 또는 메서드 약간 다른 문자 집합을 사용 하 여 분할 된 문자열 보다는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드를 수행 하지 않습니다 문자열을 자릅니다. .NET Framework 4 부터는 두 방법 모두 유니코드 공백 문자의 동일한 집합을 사용 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">이 문자열의 부분 문자열을 구분하는 문자 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</param>
        <param name="count">반환할 부분 문자열의 최대 수입니다.</param>
        <param name="options">반환된 배열에서 빈 배열 요소를 생략하려면 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />이고, 반환된 배열에 빈 배열 요소를 포함하려면 <see cref="F:System.StringSplitOptions.None" />입니다.</param>
        <summary>배열에 있는 문자에 따라 최대 개수의 부분 문자열로 문자열을 분할합니다.</summary>
        <returns>해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자로 구분되는 이 문자열의 부분 문자열이 포함된 배열입니다. 자세한 내용은 설명 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구분 기호 문자는 반환 된 배열의 요소에 포함 되지 않습니다.  
  
 이 인스턴스가 없는 경우에 문자 `separator`, 또는 `count` 매개 변수가 1 이면 반환된 된 배열에이 인스턴스를 포함 하는 단일 요소로 구성 됩니다. 경우는 `separator` 매개 변수는 `null` 문자가 없는 또는 공백 문자를 구분 기호로 간주 됩니다. 공백 문자는 유니코드 표준 및 반환 정의한 `true` 에 전달 하는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드. 그러나 경우 합니다 `separator` 이 메서드 오버 로드에 대 한 호출에서 매개 변수는 `null`, 컴파일러 오버 로드 확인에 실패 합니다. 호출된 된 메서드를 명확 하 게 식별 하려면 코드는 null의 형식을 나타내야 합니다. 다음 예제에서는이 오버 로드를 명확 하 게 식별 하는 여러 방법을 보여 줍니다.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 경우는 `count` 매개 변수는 0 또는 `options` 매개 변수는 <xref:System.StringSplitOptions.RemoveEmptyEntries> 이 인스턴스의 길이 0 이면 빈 배열이 반환 됩니다.  
  
 각 요소의 `separator` 별도 구분 기호 문자를 정의 합니다. 경우는 `options` 매개 변수가 <xref:System.StringSplitOptions.None>, 및 두 구분 기호는 인접 한 있거나 구분 기호에 시작 또는 끝이 인스턴스의 해당 배열 요소에 포함 되어 <xref:System.String.Empty>입니다.  
  
 있는 경우 둘 `count` 이 인스턴스의 부분 문자열이 첫 번째 `count` 빼기 1 부분 문자열에서 첫 번째 반환 됩니다 `count` 반환 값을이 인스턴스의 나머지 문자 요소는 마지막에 반환 됩니다 반환 값의 요소입니다.  
  
 경우 `count` 수보다 큰 부분을 사용할 수 있는 부분 문자열 반환 되 고 예외가 throw 되지 않습니다.  
  
### <a name="performance-considerations"></a>성능 고려 사항  
 합니다 <xref:System.String.Split%2A> 메서드는 반환된 된 배열 개체에 대 한 메모리를 할당 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다. 응용 프로그램에 필요한 최적의 성능, 메모리 할당을 관리 하는 것이 중요 응용 프로그램 사용을 고려 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 및 필요에 따라는 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법입니다.  
  
 구분 기호 문자에서 문자열을 분할 하는 경우 사용 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 문자열의 구분 기호 문자를 찾는 방법입니다. 구분 기호 문자열에서 문자열을 분할 하는 경우 사용 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 구분 기호 문자열의 첫 번째 문자를 찾기 위해 메서드. 사용 하 여는 <xref:System.String.Compare%2A> 첫 번째 문자는 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 하는 방법입니다.  
  
 또한 동일한 설정의 경우 문자는 여러에서 문자열을 분할 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다. 이렇게 하면 각 메서드 호출의 추가 오버 헤드를 크게 줄어듭니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.StringSplitOptions> 열거형을 포함 하거나 제외 하 여 생성 된 부분 문자열을 <xref:System.String.Split%2A> 메서드.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />가 음수입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" />가 <see cref="T:System.StringSplitOptions" /> 값 중 하나가 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 및 이전 버전에서 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다를 <paramref name="separator" /> 즉 <see langword="null" /> 문자가 없는 또는 메서드 약간 다른 문자 집합을 사용 하 여 분할 된 문자열 보다는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드를 수행 하지 않습니다 문자열을 자릅니다. .NET Framework 4 부터는 두 방법 모두 유니코드 공백 문자의 동일한 집합을 사용 합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">이 문자열의 부분 문자열을 구분하는 문자열 배열, 구분 기호를 포함하지 않는 빈 배열 또는 <see langword="null" />입니다.</param>
        <param name="count">반환할 부분 문자열의 최대 수입니다.</param>
        <param name="options">반환된 배열에서 빈 배열 요소를 생략하려면 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />이고, 반환된 배열에 빈 배열 요소를 포함하려면 <see cref="F:System.StringSplitOptions.None" />입니다.</param>
        <summary>배열에 있는 문자열에 따라 최대 개수의 부분 문자열로 문자열을 분할합니다. 부분 문자열이 빈 배열 요소를 포함하는지 여부를 지정할 수 있습니다.</summary>
        <returns>해당 요소에 <paramref name="separator" />에 있는 하나 이상의 문자열로 구분되는 이 문자열의 부분 문자열이 포함된 배열입니다. 자세한 내용은 설명 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>반환 값 정보  
 구분 기호 문자열로 반환 된 배열의 요소에 포함 되지 않습니다.  
  
 이 인스턴스가 없으면의 해당 문자열이 하나라 `separator`, 또는 `count` 매개 변수가 1 이면 반환된 된 배열에이 인스턴스를 포함 하는 단일 요소로 구성 됩니다. 경우는 `separator` 매개 변수는 `null` 문자가 없는 또는 공백 문자를 구분 기호로 간주 됩니다. 공백 문자는 유니코드 표준 및 반환 정의한 `true` 에 전달 하는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드. 그러나 경우 합니다 `separator` 이 메서드 오버 로드에 대 한 호출에서 매개 변수는 `null`, 컴파일러 오버 로드 확인에 실패 합니다. 호출된 된 메서드를 명확 하 게 식별 하려면 코드의 형식을 나타내야 합니다 `null`합니다. 다음 예제에서는이 오버 로드를 명확 하 게 식별 하는 여러 방법을 보여 줍니다.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 경우는 `count` 매개 변수는 0 또는 `options` 매개 변수는 <xref:System.StringSplitOptions.RemoveEmptyEntries> 이 인스턴스의 길이 0 이면 빈 배열이 반환 됩니다.  
  
 각 요소의 `separator` 하나 이상의 문자로 구성 된 별도 구분 기호를 정의 합니다. 경우는 `options` 매개 변수가 <xref:System.StringSplitOptions.None>, 및 두 구분 기호는 인접 한 있거나 구분 기호에 시작 또는 끝이 인스턴스의 해당 배열 요소에 포함 되어 <xref:System.String.Empty>입니다.  
  
 있는 경우 둘 `count` 이 인스턴스의 부분 문자열이 첫 번째 `count` 빼기 1 부분 문자열에서 첫 번째 반환 됩니다 `count` 반환 값을이 인스턴스의 나머지 문자 요소는 마지막에 반환 됩니다 반환 값의 요소입니다.  
  
 경우 `count` 수보다 큰 부분을 사용할 수 있는 부분 문자열 반환 되 고 예외가 throw 되지 않습니다.  
  
### <a name="the-separator-array"></a>구분 기호 배열  
 요소 하나라 `separator` 구성 전체 부분 문자열이 구분 기호를 여러 개의 문자로 간주 됩니다. 예를 들어 하나에 있는 요소의 `separator` 은 "10", "This10is10a10string." 문자열을 분할 하려고 합니다. 이 4 개 요소 배열을 반환 합니다: {"This", "is", "a", "문자열입니다." }.  
  
### <a name="comparison-details"></a>비교 세부 정보  
 <xref:System.String.Split%2A> 에 있는 문자열 중 하나 이상의 구분 되는이 문자열의 부분 문자열을 추출 하는 메서드는 `separator` 매개 변수를 배열 요소로 해당 부분 문자열을 반환 합니다.  
  
 <xref:System.String.Split%2A> 메서드가 서 수 대/소문자 구분 정렬 규칙을 사용 하 여 비교를 수행 하 여 구분 기호를 찾습니다. Word, 문자열 및 서 수 정렬 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 열거형입니다.  
  
 합니다 <xref:System.String.Split%2A> 의 요소를 무시 하는 메서드 `separator` 값인 `null` 또는 빈 문자열 ("").  
  
 모호한 결과 방지 하기 때의 문자열 `separator` 문자를 공통적으로 합니다 <xref:System.String.Split%2A> 메서드 인스턴스 값의 끝부터 진행 되 고 첫 번째 요소와 일치 `separator` 같은지에서 구분 기호를는 인스턴스입니다. 인스턴스에서 발생 하는 부분 문자열이 나타나는 순서에 있는 요소의 순서 보다 우선 `separator`합니다.  
  
 예를 들어 값인 "abcdef" 인스턴스에 것이 좋습니다. 경우에 첫 번째 요소 `separator` ef 및 두 번째 요소를 "bcde" 이면 split 작업의 결과 "a"와 "f"입니다. 이 "bcde" 인스턴스에 있는 부분 문자열은와 일치 하기 때문에 요소 `separator` 부분 문자열 "f"가 발생 하기 전에 합니다.  
  
 그러나 경우 첫 번째 요소 `separator` "bcd"와 두 번째 요소 "bc" 이면 split 작업의 결과 "a" 및 "ef"입니다. "Bcd"는 첫 번째 구분 기호 이므로이 `separator` 인스턴스 구분 기호와 일치 하는 합니다. 첫 번째 요소 "bc"는 구분 기호의 순서 거꾸로 되어 있고 두 번째 요소가 "bcd", 결과 "a"와 "def"입니다.  
  
### <a name="performance-considerations"></a>성능 고려 사항  
 합니다 <xref:System.String.Split%2A> 메서드는 반환된 된 배열 개체에 대 한 메모리를 할당 및 <xref:System.String> 각 배열 요소에 대 한 개체입니다. 응용 프로그램에 필요한 최적의 성능, 메모리 할당을 관리 하는 것이 중요 응용 프로그램 사용을 고려 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 메서드 및 필요에 따라는 <xref:System.String.Compare%2A> 문자열 내에서 부분 문자열을 찾을 방법입니다.  
  
 구분 기호 문자에서 문자열을 분할 하는 경우 사용 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 문자열의 구분 기호 문자를 찾는 방법입니다. 구분 기호 문자열에서 문자열을 분할 하는 경우 사용 합니다 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOfAny%2A> 구분 기호 문자열의 첫 번째 문자를 찾기 위해 메서드. 사용 하 여는 <xref:System.String.Compare%2A> 첫 번째 문자는 다음 구분 기호 문자열의 나머지 문자는와 같은지 여부를 확인 하는 방법입니다.  
  
 또한 동일한 설정의 경우 문자는 여러에서 문자열을 분할 하 <xref:System.String.Split%2A> 메서드 호출을 단일 배열을 만들고 각 메서드 호출에서 참조 하는 것이 좋습니다. 이렇게 하면 각 메서드 호출의 추가 오버 헤드를 크게 줄어듭니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.StringSplitOptions> 열거형을 포함 하거나 제외 하 여 생성 된 부분 문자열을 <xref:System.String.Split%2A> 메서드.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />가 음수입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" />가 <see cref="T:System.StringSplitOptions" /> 값 중 하나가 아닙니다.</exception>
        <block subset="none" type="usage">
          <para>에 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 및 이전 버전에서 경우는 <see cref="M:System.String.Split(System.Char[])" /> 메서드에 전달 됩니다를 <paramref name="separator" /> 즉 <see langword="null" /> 문자가 없는 또는 메서드 약간 다른 문자 집합을 사용 하 여 분할 된 문자열 보다는 <see cref="M:System.String.Trim(System.Char[])" /> 메서드를 수행 하지 않습니다 문자열을 자릅니다. .NET Framework 4 부터는 두 방법 모두 유니코드 공백 문자의 동일한 집합을 사용 합니다.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 문자열 인스턴스의 시작 부분과 지정한 문자열이 일치하는지를 확인합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">비교할 문자열입니다.</param>
        <summary>이 문자열 인스턴스의 시작 부분과 지정한 문자열이 일치하는지를 확인합니다.</summary>
        <returns>이 문자열의 시작 부분이 <see langword="true" />와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비교 `value` 와 같은 길이이 인스턴스의 시작 부분에 있는 부분 문자열과 `value`와 같은지 여부를 나타내는 값을 반환 합니다. 같은 문자로 `value` 빈 문자열 이어야 합니다 (<xref:System.String.Empty?displayProperty=nameWithType>)이 동일한 인스턴스에 대 한 참조 이거나이 인스턴스의 시작 부분과 일치 해야 합니다.  
  
 이 메서드는 현재 문화권을 사용 하 여 단어 (대/소문자 구분 및 문화권) 비교를 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 `StripStartTags` 메서드를 사용 하는 <xref:System.String.StartsWith%28System.String%29> 문자열의 시작 부분에서 시작 태그를 HTML을 제거 하는 방법입니다. `StripStartTags` 줄의 시작 부분에 여러 HTML 시작 태그를 제거 해야에 재귀적으로 호출 됩니다. 이 예제에서는 문자열에 포함 된 HTML 태그를 제거 하지 않습니다.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 문자열에 대 한 모범 사례](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 비교 메서드를 호출 하지 않는 것이 좋습니다. 현재 문화권의 문자열 비교 규칙을 사용 하 여 특정 문자열이 부분 문자열로 시작 하는지 여부를 결정할 호출을 <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> 값을 사용 하 여 메서드 오버 로드 <see cref="F:System.StringComparison.CurrentCulture" /> 에 대 한 해당 <paramref name="comparisonType" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">비교할 문자열입니다.</param>
        <param name="comparisonType">이 문자열과 <paramref name="value" />를 비교하는 방법을 결정하는 열거형 값 중 하나입니다.</param>
        <summary>지정한 비교 옵션을 사용하여 비교할 때 지정한 문자열과 이 문자열 인스턴스의 시작 부분이 일치하는지를 확인합니다.</summary>
        <returns>이 인스턴스가 <see langword="true" />로 시작하는 경우 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.String.StartsWith%2A> 메서드 비교는 `value` 이 문자열의 시작 부분에 있는 부분 문자열과 매개 변수 같은지 여부를 나타내는 값을 반환 합니다. 같은 문자로 `value` 이 동일한 문자열에 대 한 참조를 여야 하며, 빈 문자열 이어야 합니다 (""), 또는이 문자열의 시작 일치 해야 합니다. 수행할 비교 유형을 합니다 <xref:System.String.StartsWith%2A> 메서드 값에 따라 달라 집니다는 `comparisonType` 매개 변수입니다. 비교는 현재 문화권의 규칙을 사용할 수 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> 하 고 <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) 또는 고정 문화권 (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 하 고 <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), 또는 코드 포인트를 문자 단위로 비교를 구성할 수 있습니다 (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 또는 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). 비교는 대/소문자 구분 될 수도 있습니다 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, 또는 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), 대/소문자를 무시할 수도 있습니다 (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>를 <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).  
  
   
  
## Examples  
 다음 예제에서는 문자열에 대 한 검색 단어로 시작 하는 긴 문자열의 시작 부분에 "the" "The"입니다. 예제에 대 한 호출의 출력으로는 <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> 메서드는 문화권을 구분 하지만 대/소문자 구분 비교를 수행 하는 문화권 및 case insensitive 비교를 수행 하는 호출 된 문자열과 일치 하는 동안 문자열 일치에 실패 합니다.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 다음 예제에서는 특정 하위 문자열로 시작 하는지 여부를 결정 합니다. 2 차원 문자열 배열을 초기화합니다. 두 번째 차원의 첫 번째 요소에는 문자열을 포함 하 고 문자열의 첫 번째 문자열의 시작 부분에 대 한 검색을 포함 하는 두 번째 요소입니다. 문화권, 대/소문자가 무시 여부 및 서 수 비교를 수행 하는 지 여부를 선택 하면 영향을 받습니다. 문자열 인스턴스는 합자에 포함 되어 있으면 해당 연속 된 문자를 사용 하 여 문화권 구분 비교 성공적으로 일치 하는지 note 합니다.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />이 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">비교할 문자열입니다.</param>
        <param name="ignoreCase">비교 시 대/소문자를 무시하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <param name="culture">이 문자열과 <paramref name="value" />의 비교 방법을 결정하는 문화권 정보입니다. <paramref name="culture" />가 <see langword="null" />이면 현재 문화권이 사용됩니다.</param>
        <summary>지정한 문화권을 사용하여 비교할 때 이 문자열 인스턴스의 시작 부분과 지정한 문자열이 일치하는지를 확인합니다.</summary>
        <returns>이 문자열의 시작 부분이 <see langword="true" /> 매개 변수와 일치하면 <paramref name="value" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 비교 합니다 `value` 와 같은 길이이 문자열의 시작 부분에 있는 부분 문자열과 매개 변수 `value`, 같은지 여부를 나타내는 값을 반환 합니다. 같은 문자로 `value` 빈 문자열 이어야 합니다 (<xref:System.String.Empty?displayProperty=nameWithType>)이 동일한 인스턴스에 대 한 참조 이거나이 인스턴스의 시작 부분과 일치 해야 합니다.  
  
 이 메서드는 지정 된 대/소문자 구분 및 문화권을 사용 하는 비교를 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열을 다른 문자열의 시작 부분에서 발생 하는지 여부를 결정 합니다. <xref:System.String.StartsWith%2A> 메서드가 여러 번 대/소문자 구분, 소문자, 및 검색 결과 영향을 주는 다른 문화권을 사용 하 여 호출 됩니다.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스에서 부분 문자열을 검색합니다.  
  
이 멤버는 오버로드됩니다. 구문, 사용법 및 예제를 비롯하여 이 멤버에 대한 자세한 내용을 보려면 오버로드 목록에서 이름을 클릭합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">이 인스턴스의 부분 문자열에 있는 0부터 시작할 문자 위치입니다.</param>
        <summary>이 인스턴스에서 부분 문자열을 검색합니다. 부분 문자열은 지정된 문자 위치에서 시작하고 문자열 끝까지 계속됩니다.</summary>
        <returns>이 인스턴스의 <paramref name="startIndex" />에서 시작하는 부분 문자열에 해당하는 문자열이거나, <see cref="F:System.String.Empty" />가 이 인스턴스의 길이와 같으면 <paramref name="startIndex" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하 여 <xref:System.String.Substring%28System.Int32%29> 지정된 된 문자 위치에서 시작 하 고 문자열의 끝에서 끝나는 문자열에서 부분 문자열을 추출 하는 방법입니다. 시작 문자 위치는 0부터 시작 합니다. 즉, 문자열의 첫 번째 문자를 인덱스 0, 1 인덱싱하지 않아야 합니다. 지정된 된 문자 위치에서 시작 하 고 문자열의 종료 되기 전에 끝나는 부분 문자열을 추출 하려면 호출을 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 메서드.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신, 시작 하는 새 문자열을 반환 합니다는 `startIndex` 현재 문자열의 위치입니다.  
  
 특정 문자 또는 문자 시퀀스를 시작 하는 부분 문자열을 추출 하려면 메서드를 같은 호출 <xref:System.String.IndexOf%2A> 나 <xref:System.String.IndexOf%2A> 의 값을 검색할 `startIndex`합니다. 두 번째 예제에서는이; "=" 문자 다음 문자를 시작 하는 키 값을 추출 합니다.  
  
 경우 `startIndex` 0, 원래 문자열을 변경 하지 않고 메서드가 반환 됩니다.  
   
  
## Examples  
 다음 예제에서는 문자열에서 부분 문자열을 얻는 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 다음 예제에서는 <xref:System.String.Substring%2A> 등호 구분 되는 키/값 쌍을 구분 하는 방법 ("=") 문자입니다.  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A> 메서드는 문자열의 같음 문자의 위치를 가져오는 데 사용 됩니다. 에 대 한 호출을 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 문자열의 첫 번째 문자에서 시작에 대 한 호출에서 반환 된 문자 수에 대 한 확장 하는 키 이름을 추출 하는 메서드를 <xref:System.String.IndexOf%2A> 메서드. 에 대 한 호출을 <xref:System.String.Substring%28System.Int32%29> 메서드 키에 할당 된 값을 추출 합니다. 이 문자를 넘어가는 하나의 문자 위치에서 시작 하 고 문자열의 끝까지 확장 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">이 인스턴스의 부분 문자열에 있는 0부터 시작할 문자 위치입니다.</param>
        <param name="length">부분 문자열에 있는 문자의 수입니다.</param>
        <summary>이 인스턴스에서 부분 문자열을 검색합니다. 부분 문자열은 지정된 문자 위치에서 시작하고 길이도 지정되어 있습니다.</summary>
        <returns>이 인스턴스의 <paramref name="length" />에서 시작하는 <paramref name="startIndex" /> 길이의 부분 문자열에 해당하는 문자열이거나, <see cref="F:System.String.Empty" />가 이 인스턴스의 길이와 같고 <paramref name="startIndex" />가 0이면 <paramref name="length" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하 여 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 지정된 된 문자 위치에서 시작 하 고 문자열의 종료 되기 전에 종료 하는 문자열에서 부분 문자열을 추출 하는 방법입니다. 시작 문자 위치는 0부터 시작 합니다. 즉, 문자열의 첫 번째 문자를 인덱스 0, 1 인덱싱하지 않아야 합니다. 지정된 된 문자 위치에서 시작 하 고 문자열의 끝까지 계속 된 부분 문자열을 추출 하려면 호출을 <xref:System.String.Substring%28System.Int32%29> 메서드.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신 사용 하 여 새 문자열을 반환 합니다 `length` 부터 문자는 `startIndex` 현재 문자열의 위치입니다.  
  
 `length` 매개 변수는 현재 문자열 인스턴스가에서 추출할 문자의 총 수를 나타냅니다. 인덱스에서 시작 문자가 여기에 `startIndex`합니다.  즉, 합니다 <xref:System.String.Substring%2A> 메서드는 인덱스에서 문자를 추출 하려고 시도 `startIndex` 인덱스로 `startIndex`  +  `length` -1입니다.  
  
 특정 문자 또는 문자 시퀀스를 시작 하는 부분 문자열을 추출 하려면 메서드를 같은 호출 <xref:System.String.IndexOf%2A> 나 <xref:System.String.LastIndexOf%2A> 의 값을 검색할 `startIndex`합니다.  
  
 부분 문자열에서 확장 하는 경우 `startIndex` 를 지정한 문자 시퀀스로 있습니다 메서드를 호출할 수와 같은 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.LastIndexOf%2A> 끝 문자 또는 문자 시퀀스의 인덱스를 가져오려고 합니다.  변환할 수 있습니다 다음 해당 값 문자열의 인덱스 위치는 다음과 같습니다.  
  
-   부분 문자열의 끝을 표시 하는 단일 문자에 대 한 검색 한 경우는 `length` 매개 변수가 같으면 `endIndex`  -  `startIndex` + 1 위치 `endIndex` 의 반환 값이를 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOf%2A> 메서드입니다. 다음 예제에서는 문자열에서 "b" 문자를 연속 블록을 추출합니다.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   부분 문자열의 끝을 표시 하는 여러 문자에 대 한 검색 한 경우는 `length` 매개 변수가 같으면 `endIndex`  +  `endMatchLength`  -  `startIndex`여기서 `endIndex` 합니다 의반환값<xref:System.String.IndexOf%2A> 나 <xref:System.String.IndexOf%2A> 메서드. 및 `endMatchLength` 부분 문자열의 끝을 표시 하는 문자 시퀀스의 길이입니다. 다음 예제에서는 XML을 포함 하는 텍스트 블록을 추출 `<definition>` 요소입니다.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   문자 또는 문자 시퀀스는 부분 문자열의 끝에 포함 되지 않은 경우는 `length` 매개 변수가 같으면 `endIndex`  -  `startIndex`여기서 `endIndex` 의 반환 값을 <xref:System.String.IndexOf%2A> 또는 <xref:System.String.IndexOf%2A> 메서드입니다.  
  
 경우 `startIndex` 0와 equals 메서드를 현재 문자열의 길이 변경 되지 않은 원래 문자열을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에 대 한 간단한 호출을 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 여섯 번째 문자 위치에서 시작 하는 문자열에서 두 개의 문자를 추출 하는 메서드 (즉,에서 인덱스 5).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 다음 예제에서는 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 메서드 다음 세 가지 경우 문자열 내에서 부분 문자열을 분리 합니다. 두 가지 경우에 부분 문자열 비교에 사용 되 고 세 번째 사례에서 잘못 된 매개 변수를 지정 하기 때문에 예외가 throw 됩니다.  
  
-   단일 문자 및 문자열 (인덱스 2)에서 세 번째 위치를 추출 하 고 "c"와 비교 합니다. 이 비교 반환 `true`합니다.  
  
-   문자열 (인덱스 3)에서 네 번째 위치에서 시작 하는 0 개의 문자를 추출 하 고 전달 된 <xref:System.String.IsNullOrEmpty%2A> 메서드. 이 true를 반환 하기 때문에 대 한 호출을 <xref:System.String.Substring%2A> 메서드가 반환 되는 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
-   문자열에서 네 번째 위치에서 시작 하는 한 문자를 추출 하려고 합니다. 해당 위치에 문자가 없는 이기 때문에 메서드 호출 throw는 <xref:System.ArgumentOutOfRangeException> 예외입니다.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 다음 예제에서는 <xref:System.String.Substring%2A> 등호 구분 되는 키/값 쌍을 구분 하는 방법 ("=") 문자입니다.  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A> 메서드는 문자열의 같음 문자의 위치를 가져오는 데 사용 됩니다. 에 대 한 호출을 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 문자열의 첫 번째 문자에서 시작에 대 한 호출에서 반환 된 문자 수에 대 한 확장 하는 키 이름을 추출 하는 메서드를 <xref:System.String.IndexOf%2A> 메서드. 에 대 한 호출을 <xref:System.String.Substring%28System.Int32%29> 메서드 키에 할당 된 값을 추출 합니다. 이 문자를 넘어가는 하나의 문자 위치에서 시작 하 고 문자열의 끝까지 확장 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> + <paramref name="length" />는 문자 위치가 이 인스턴스 안에 없음을 나타냅니다.  
  
또는 
 <paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.String" /> 개체를 반복하는 열거자를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체를 반복하는 데 사용할 수 있는 강력한 형식의 열거자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, 사용할 수 있습니다 경우에만 합니다 <xref:System.String> 캐스팅 된는 <xref:System.Collections.Generic.IEnumerable%601> 인터페이스 개체입니다. 자세한 내용은 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 메서드를 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.String" /> 개체를 반복하는 열거자를 반환합니다.</summary>
        <returns>현재 문자열을 반복하는 데 사용할 수 있는 열거자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.Collections.IEnumerable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 자세한 내용은 <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">이 매개 변수는 무시됩니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 문자열의 값이 <see langword="true" />이면 <see cref="F:System.Boolean.TrueString" />이고, 현재 문자열의 값이 <see langword="false" />이면 <see cref="F:System.Boolean.FalseString" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 문자열의 값이 <see cref="F:System.Boolean.TrueString" /> 또는 <see cref="F:System.Boolean.FalseString" />이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없습니다.</exception>
        <exception cref="T:System.OverflowException">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.Byte.MaxValue" />보다 크거나 <see cref="F:System.Byte.MinValue" />보다 작습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 인덱스 0에 있는 문자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없습니다.</exception>
        <exception cref="T:System.OverflowException">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.Decimal.MinValue" />보다 작거나 <see cref="F:System.Decimal.MaxValue" />보다 더 큰 수입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없습니다.</exception>
        <exception cref="T:System.OverflowException">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.Double.MinValue" />보다 작거나 <see cref="F:System.Double.MaxValue" />보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없습니다.</exception>
        <exception cref="T:System.OverflowException">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.Int16.MaxValue" />보다 크거나 <see cref="F:System.Int16.MinValue" />보다 작습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없습니다.</exception>
        <exception cref="T:System.OverflowException">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.SByte.MaxValue" />보다 크거나 <see cref="F:System.SByte.MinValue" />보다 작습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">반환되는 개체의 형식입니다.</param>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ChangeType%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidCastException">현재 <see cref="T:System.String" /> 개체의 값을 <paramref name="type" /> 매개 변수에 지정된 형식으로 변환할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없습니다.</exception>
        <exception cref="T:System.OverflowException">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.UInt16.MaxValue" />보다 크거나 <see cref="F:System.UInt16.MinValue" />보다 작습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">현재 <see cref="T:System.String" /> 개체의 값을 구문 분석할 수 없습니다.</exception>
        <exception cref="T:System.OverflowException">현재 <see cref="T:System.String" /> 개체의 값이 <see cref="F:System.UInt32.MaxValue" />보다 크거나 <see cref="F:System.UInt32.MinValue" />보다 작습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />를 참조하세요.</summary>
        <returns>현재 <see cref="T:System.String" /> 개체의 변환된 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.String> 인스턴스가 <xref:System.IConvertible> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다. 권장된 대안 호출 하는 것은 <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스의 문자를 유니코드 문자 배열에 복사합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 문자를 유니코드 문자 배열에 복사합니다.</summary>
        <returns>해당 요소가 이 인스턴스의 각 문자로 이루어진 유니코드 문자 배열을 반환합니다. 이 인스턴스가 빈 문자열이면 반환된 배열은 길이가 0인 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 각 문자를 복사 (즉, 각 <xref:System.Char> 개체)에서 문자 배열에는 문자열입니다. 반환 된 문자 배열의 인덱스 0에 있는 복사 첫 번째 문자는 복사할 마지막 문자 인덱스를 <xref:System.Array.Length%2A?displayProperty=nameWithType> – 1입니다.  
  
 문자 배열의 문자에서 문자열을 만들려면, 호출 된 <xref:System.String.%23ctor%28System.Char%5B%5D%29> 생성자입니다.  
  
 문자열에 인코딩된 문자를 포함 하는 바이트 배열을 만들려면 적절 한 인스턴스화 <xref:System.Text.Encoding> 개체와 호출 해당 <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> 메서드. .NET에서 사용할 수 있는 표준 인코딩 중 일부는 다음과 같습니다.  
  
|인코딩|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 자세한 내용은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.ToCharArray%2A> 문자 배열에 문자열의 문자를 추출 하는 방법입니다. 그런 다음 배열의 원래 문자열 및 요소를 표시합니다.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 다음 예제에서는 구분 기호로 분리 된 문자열의 구분 기호로 사용 되는 문자를 포함 하는 문자열을 정의 합니다. 그런 다음 호출 하는 <xref:System.String.ToCharArray%2A> 에 전달 될 수 있는 문자 배열을 만드는 방법의 <xref:System.String.Split%28System.Char%5B%5D%29> 해당 개별 부분 문자열로 구분 된 문자열을 구분 하는 방법.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">이 인스턴스에 있는 부분 문자열의 시작 위치입니다.</param>
        <param name="length">이 인스턴스에 있는 부분 문자열의 길이입니다.</param>
        <summary>이 인스턴스의 지정된 부분 문자열에 있는 문자를 유니코드 문자 배열에 복사합니다.</summary>
        <returns>해당 요소가 이 인스턴스의 <paramref name="length" /> 문자 위치부터 <paramref name="startIndex" /> 개의 문자로 이루어진 유니코드 문자 배열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 부분 문자열에서에서 문자 배열에 문자를 복사합니다. 문자열에서 문자 배열의 문자 범위를 만들려면 호출을 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 생성자입니다.  
  
 `startIndex` 매개 변수는 0부터 시작 합니다. 즉, 문자열 인스턴스의 첫 번째 문자의 인덱스는 0입니다.  
  
 경우 `length` 가 0 이면 반환 된 배열은 비어 있고 길이가 0입니다. 이 인스턴스가 `null` 또는 빈 문자열 (""), 반환 된 배열은 비어 있고 길이가 0입니다.  
  
 문자열의 부분에 인코딩된 문자를 포함 하는 바이트 배열을 만들려면 적절 한 인스턴스화 <xref:System.Text.Encoding> 개체와 호출 해당 <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> 메서드. .NET에서 사용할 수 있는 표준 인코딩 중 일부는 다음과 같습니다.  
  
|인코딩|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 자세한 내용은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열 내에서 부분 문자열을 문자 배열로 변환을 열거 하 고 배열의 요소를 표시 합니다.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.  
  
또는 
 <paramref name="startIndex" /> + <paramref name="length" />가 이 인스턴스의 길이보다 큽니다.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 문자열의 복사본을 소문자로 변환하여 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 문자열의 복사본을 소문자로 변환하여 반환합니다.</summary>
        <returns>소문자 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 문화권의 대/소문자 규칙을 고려 합니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,는 현재 인스턴스에서 모든 문자는 소문자로 변환 된 새 문자열을 반환 합니다.  
  
## <a name="security-considerations"></a>보안 고려 사항  
 호출에서 발생 하는 대/소문자 구분 작업을 <xref:System.String.ToLower> 메서드는 현재 문화권의 대/소문자 규칙을 고려 합니다. 파일 이름이 같은 운영 체제 식별자의 대 / 소문자 버전을 사용 해야 하는 경우 명명 된 파이프 또는 레지스트리 키를 사용 합니다 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드. 모든 문화권에서 동일한 결과 (달리는 <xref:System.String.ToLower> 메서드) 하 고 보다 효율적으로 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 소문자가 혼합된 되어 있는 여러 문자열 소문자로 변환합니다.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 문자열에 대 한 모범 사례](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 대/소문자 구분 메서드를 호출 하지 않는 것이 좋습니다. 문자를 현재 문화권의 대/소문자 규칙을 사용 하 여 소문자로 변환할 호출을 <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> 값을 사용 하 여 메서드 오버 로드 <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> 에 대 한 해당 <paramref name="culture" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">문화권별 대/소문자 규칙을 제공하는 개체입니다.</param>
        <summary>지정한 문화권의 대/소문자 규칙을 사용하여 소문자로 변환된 이 문자열의 복사본을 반환합니다.</summary>
        <returns>소문자로 표시된 현재 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 된 문화권의 대/소문자 규칙을 `culture` 매개 변수에 변경 되는 방식을 문자열의 대/소문자를 결정 합니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,는 현재 인스턴스에서 모든 문자는 소문자로 변환 된 새 문자열을 반환 합니다.  
  
## <a name="security-considerations"></a>보안 고려 사항  
 전달 하는 경우는 <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> 메서드를 <xref:System.Globalization.CultureInfo> 이외의 개체 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, 대/소문자 구분 작업 계정에는 culture 별 규칙 걸립니다. 파일 이름이 같은 운영 체제 식별자의 대 / 소문자 버전을 사용 해야 하는 경우 명명 된 파이프 또는 레지스트리 키를 사용 합니다 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드. 이 모든 문화권에서 동일한 결과 생성 하 고 보다 효율적으로 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 문자열의 대문자를 미국 및 터키어-터키 문화권을 사용 하 여 문자를 소문자로 변환한 다음 소문자 문자열을 비교 합니다. 대문자 문자열을 제외 하는 유니코드 LATIN CAPITAL LETTER I 한 문자열에서 각 발생을 다른 문자열 LATIN CAPITAL LETTER I와 점 위에 포함 동일 합니다.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>고정 문화권의 대/소문자 규칙을 사용하여 소문자로 변환된 이 <see cref="T:System.String" /> 개체의 복사본을 반환합니다.</summary>
        <returns>소문자로 표시된 현재 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 고정 문화권을 문화권을 구분 하는 문화권을 나타냅니다. 연결 된 영어와 있지만 특정 국가 또는 지역입니다. 자세한 내용은 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 속성을 참조하세요.  
  
 응용 프로그램 사용 하 여 현재 문화권에 의해 영향을 받지 않는 예측 가능한 방식으로 변경 되는 문자열의 대/소문자에 따라 달라 지는 <xref:System.String.ToLowerInvariant%2A> 메서드. 합니다 <xref:System.String.ToLowerInvariant%2A> 메서드는 `ToLower(CultureInfo.InvariantCulture)`합니다. 문자열의 컬렉션을 사용자 인터페이스 컨트롤에 예측 가능한 순서로 나타나야 하는 경우에 메서드는 것이 좋습니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,는 현재 인스턴스에서 모든 문자는 소문자로 변환 된 새 문자열을 반환 합니다.  
  
## <a name="security-considerations"></a>보안 고려 사항  
 파일 이름이 같은 운영 체제 식별자의 대 / 소문자 버전을 사용 해야 하는 경우 명명 된 파이프 또는 레지스트리 키를 사용 합니다 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 언어의에서 단어를 포함 하는 문자열 배열을 정의 합니다. <xref:System.String.ToLowerInvariant%2A> 메서드는 각 단어의 대/소문자 버전을 사용 하 여 병렬 배열의 요소를 채우는 데 사용 됩니다. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> 요소 언어에 관계 없이 동일한 순서로 표시 되도록 소문자 배열의 요소 순서에 따라 대/소문자 구분 배열을 정렬 메서드를 사용 합니다.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스의 값을 <see cref="T:System.String" />으로 변환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.String" />의 이 인스턴스를 반환하며, 이때 실제 변환은 수행되지 않습니다.</summary>
        <returns>현재 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 반환 하기만 하면 변경 하지 않고 현재 문자열 이므로 직접 호출할 필요가 없습니다. 복합 형식 지정 예제와 같이 작업에에서는 암시적으로 호출 일반적으로 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.String.ToString%2A> 메서드. 이 예제에서는 명시적으로 호출 하지 않는 참고를 <xref:System.String.ToString%2A> 메서드. 대신 메서드가 의해 암시적으로 호출 되는 [복합 서식 지정](~/docs/standard/base-types/composite-formatting.md) 기능입니다.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(예약됨) 문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>
          <see cref="T:System.String" />의 이 인스턴스를 반환하며, 이때 실제 변환은 수행되지 않습니다.</summary>
        <returns>현재 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` 예약 되며이 작업에 관여 하지 않습니다.  
  
 이 메서드가 반환 하기만 하면 변경 하지 않고 현재 문자열 이므로 직접 호출할 필요가 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 문자열의 복사본을 대문자로 변환하여 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 문자열의 복사본을 대문자로 변환하여 반환합니다.</summary>
        <returns>대문자로 표시된 현재 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 인스턴스의 각 문자를 해당 대문자로 변환할 현재 문화권의 대/소문자 규칙을 사용 합니다. 문자에 대문자로 변환할 항목이 없으면 포함 됩니다 반환된 된 문자열에서 변경 되지 않습니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,는 현재 인스턴스에서 모든 문자를 대문자로 변환 됩니다 새 문자열로 반환 합니다.  
  
 <xref:System.String.ToUpper%2A> 메서드는 종종 대/소문자 구분 비교에 사용할 수 있도록 하는 문자열을 대문자로 변환 하는 데 사용 됩니다. 대/소문자 구분 비교를 수행 하는 향상 된 방법을 있는 문자열 비교 메서드를 호출 하는 것을 <xref:System.StringComparison> 매개 변수를 설정한 값인 <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> 문화권 구분 및 대/소문자 구분 비교 합니다.  
  
## <a name="security-considerations"></a>보안 고려 사항  
 호출에서 발생 하는 대/소문자 구분 작업을 <xref:System.String.ToUpper> 메서드는 현재 문화권의 대/소문자 규칙을 고려 합니다. 파일 이름이 같은 운영 체제 식별자의 대 / 소문자 버전을 사용 해야 하는 경우 명명 된 파이프 또는 레지스트리 키를 사용 합니다 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드. 모든 문화권에서 동일한 결과 (달리는 <xref:System.String.ToUpper> 메서드) 하 고 보다 효율적으로 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.ToUpper%2A> 일련의 기본 라틴어, 라틴어-1 보충와 라틴어 확장-A 문자 집합의 각 문자를 포함 하는 단일 문자로 문자열을 변환 하는 방법입니다. 그런 다음 해당 대 문자와 소문자와에서 다릅니다. 각 문자열을 표시 합니다.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>에 설명 된 대로 [를 사용 하 여 문자열에 대 한 모범 사례](~/docs/standard/base-types/best-practices-strings.md), 기본 값으로 대체 하 고 대신 매개 변수를 명시적으로 지정 해야 하는 메서드를 호출 하는 문자열 대/소문자 구분 메서드를 호출 하지 않는 것이 좋습니다. 현재 문화권의 대/소문자 규칙을 사용 하 여 대문자 문자열을 변환할 호출을 <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> 값을 사용 하 여 메서드 오버 로드 <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> 에 대 한 해당 <paramref name="culture" /> 매개 변수입니다.</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">문화권별 대/소문자 규칙을 제공하는 개체입니다.</param>
        <summary>지정한 문화권의 대/소문자 규칙을 사용하여 대문자로 변환된 이 문자열의 복사본을 반환합니다.</summary>
        <returns>대문자로 표시된 현재 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 된 문화권의 대/소문자 규칙을 `culture` 매개 변수 변경 되는 문자열의 대/소문자는 방식을 결정 합니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,는 현재 인스턴스에서 모든 문자를 대문자로 변환 됩니다 새 문자열로 반환 합니다.  
  
## <a name="security-considerations"></a>보안 고려 사항  
 전달 하는 경우는 <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> 메서드를 <xref:System.Globalization.CultureInfo> 이외의 개체 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, 대/소문자 구분 작업 계정에는 culture 별 규칙 걸립니다. 파일 이름이 같은 운영 체제 식별자의 대 / 소문자 버전을 사용 해야 하는 경우 명명 된 파이프 또는 레지스트리 키를 사용 합니다 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드. 이 모든 문화권에서 동일한 결과 생성 하 고 보다 효율적으로 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 미국 및 터키어-터키 문화권을 사용 하 여 대문자 문자열을 소문자 문자열로 변환한 다음 대문자 문자열을 비교 합니다. 대문자 문자열을 제외 하는 유니코드 LATIN CAPITAL LETTER I 한 문자열에서 각 발생을 다른 문자열 LATIN CAPITAL LETTER I와 점 위에 포함 동일 합니다.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>고정 문화권의 대/소문자 규칙을 사용하여 대문자로 변환된 이 <see cref="T:System.String" /> 개체의 복사본을 반환합니다.</summary>
        <returns>대문자로 표시된 현재 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 고정 문화권을 문화권을 구분 하는 문화권을 나타냅니다. 연결 된 영어와 있지만 특정 국가 또는 지역입니다. 자세한 내용은 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 속성을 참조하세요.  
  
 응용 프로그램 사용 하 여 현재 문화권에 의해 영향을 받지 않는 예측 가능한 방식으로 변경 되는 문자열의 대/소문자에 따라 달라 지는 <xref:System.String.ToUpperInvariant%2A> 메서드. 합니다 <xref:System.String.ToUpperInvariant%2A> 메서드는 `ToUpper(CultureInfo.InvariantCulture)`합니다. 문자열의 컬렉션을 사용자 인터페이스 컨트롤에 예측 가능한 순서로 나타나야 하는 경우에 메서드는 것이 좋습니다.  
  
> [!NOTE]
>  이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신,는 현재 인스턴스에서 모든 문자를 대문자로 변환 됩니다 새 문자열로 반환 합니다.  
  
## <a name="security-considerations"></a>보안 고려 사항  
 파일 이름이 같은 운영 체제 식별자의 대 / 소문자 버전을 사용 해야 하는 경우 명명 된 파이프 또는 레지스트리 키를 사용 합니다 <xref:System.String.ToLowerInvariant%2A> 또는 <xref:System.String.ToUpperInvariant%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 언어의에서 단어를 포함 하는 문자열 배열을 정의 합니다. <xref:System.String.ToUpperInvariant%2A> 메서드는 각 단어의 대/소문자 버전을 사용 하 여 병렬 배열의 요소를 채우는 데 사용 됩니다. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> 요소 언어에 관계 없이 동일한 순서로 표시 되도록 대문자 배열의 요소 순서에 따라 대/소문자 구분 배열을 정렬 메서드를 사용 합니다.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.String" /> 개체에서 지정된 문자 집합의 선행 항목과 후행 항목이 모두 제거되는 새 문자열을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.String" /> 개체에서 선행 공백과 후행 공백을 모두 제거합니다.</summary>
        <returns>모든 공백 뒤에 있는 문자열이 현재 문자열의 시작 부분과 끝 부분에서 제거됩니다. 현재 인스턴스에서 어떠한 문자도 삭제할 수 없는 경우 이 메서드는 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A> 메서드 모든 선행 및 후행 공백 문자가 현재 문자열에서 제거 합니다. 공백이 아닌 문자가 발견 되는 각 선행 및 후행 지우기 작업이 중지 합니다. 예를 들어, 현재 문자열 "abc xyz" 이면는 <xref:System.String.Trim%2A> 메서드는 "abc xyz"를 반환 합니다. 문자열에서 단어 사이 공백 문자를 제거 하려면 사용 하 여 [.NET 정규식](~/docs/standard/base-types/regular-expressions.md)합니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.Trim%2A> 현재 인스턴스에서 모든 문자를 제거 하는 메서드,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신, 현재 인스턴스에 있는 모든 선행 및 후행 공백 문자가 제거 됩니다 새 문자열을 반환 합니다.  
  
 현재 문자열 같으면 <xref:System.String.Empty> 메서드에서 반환에 현재 인스턴스에 있는 모든 문자가 공백 문자로 구성 또는 <xref:System.String.Empty>합니다.  
  
 공백 문자는 유니코드 표준에서 정의 됩니다. <xref:System.String.Trim> 반환 값을 생성 하는 모든 선행 및 후행 문자를 제거 하는 메서드 `true` 에 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.Trim?displayProperty=nameWithType> 메서드를 연결 하기 전에 사용자가 입력 문자열에서 여분의 공백을 제거 합니다.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 및 이전 버전에는이 메서드가 트리밍하는 공백 문자의 내부 목록을 유지 관리 합니다. 부터 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 메서드 모든 유니코드 공백 문자를 트리밍하 (즉, 생성 하는 문자는 <see langword="true" /> 에 전달 될 때 값을 반환 합니다 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 메서드). 이러한 변경으로 인해를 <see cref="M:System.String.Trim" /> 에서 메서드를 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 이전 버전 두 문자, 0 너비 공간 (U + 200B) 및 0 너비 비분할 공간 (U + FEFF)를 제거 하 고는 합니다 <see cref="M:System.String.Trim" /> 에서 메서드를 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]이상 버전을 수행 제거 되지 않습니다. 또한 합니다 <see cref="M:System.String.Trim" /> 의 메서드를 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 버전 3 유니코드 공백 문자를 자르지 않는 및: 몽골어 자음 구분 기호 (U + 180E), 좁은 비분할 공간 (U + 202F), 및 중간 수학 공간 (U + 205F).</para>
        </block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">제거할 유니코드 문자 배열이거나 <see langword="null" />입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 배열에 지정된 문자 집합의 선행 항목과 후행 항목을 모두 제거합니다.</summary>
        <returns>
          <paramref name="trimChars" /> 매개 변수의 문자가 현재 문자열의 시작 부분과 끝 부분에서 모두 제거된 후 남아 있는 문자열입니다. <paramref name="trimChars" />가 <see langword="null" />이거나 빈 배열이면 공백 문자가 대신 제거됩니다. 현재 인스턴스에서 어떠한 문자도 삭제할 수 없는 경우 이 메서드는 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.String.Trim%2A> 메서드는 현재 문자열에서 선행 및 후행 문자를 모두 제거에 `trimChars` 매개 변수입니다. 각 선행 및 후행 trim 작업이 중지 되는 경우에 없는 문자 `trimChars` 발생 합니다. 예를 들어, 현재 문자열 "123abc456xyz789" 이면 및 `trimChars` 부터 "9", "1"에서 번호를 포함 합니다 <xref:System.String.Trim%2A> 메서드 "abc456xyz"를 반환 합니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.Trim%2A> 현재 인스턴스에서 모든 문자를 제거 하는 메서드,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 모든에서 새 문자열을 반환 하는 대신, 선행 및 후행 `trimChars` 현재 인스턴스에서 문자가 제거 됩니다.  
  
 현재 문자열이 같으면 <xref:System.String.Empty> 문자로 구성 된 현재 인스턴스의 모든 문자 또는 합니다 `trimChars` 메서드를 반환 배열 <xref:System.String.Empty>.  
  
 경우 `trimChars` 됩니다 `null` 빈 배열이 면이 메서드는 반환 하는 메서드에 선행 또는 후행 문자가 제거 하거나 `true` 에 전달 되는 경우는 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 메서드  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> 문자열에서 공간, 별표 (*) 및 아포스트로피 (') 문자를 제거 하는 방법입니다.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>합니다 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 하 고 이전 버전의 경우이 메서드가 트리밍하는 공백 문자 내부 목록을 유지 관리 <paramref name="trimChars" /> 는 <see langword="null" /> 이거나 빈 배열입니다. 부터 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]이면 <paramref name="trimChars" /> 은 <see langword="null" /> 또는 빈 배열인 경우 메서드는 모든 유니코드 공백 문자가 (즉, 생성 하는 문자를 <see langword="true" /> 에 전달 될 때 값을 반환 합니다 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 메서드). 이러한 변경으로 인해를 <see cref="M:System.String.Trim" /> 에서 메서드를 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 이전 버전 두 문자, 0 너비 공간 (U + 200B) 및 0 너비 비분할 공간 (U + FEFF)를 제거 하 고는 합니다 <see cref="M:System.String.Trim" /> 에서 메서드를 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]이상 버전을 수행 제거 되지 않습니다. 또한 합니다 <see cref="M:System.String.Trim" /> 의 메서드를 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 버전 3 유니코드 공백 문자를 자르지 않는 및: 몽골어 자음 구분 기호 (U + 180E), 좁은 비분할 공간 (U + 202F), 및 중간 수학 공간 (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">제거할 유니코드 문자 배열이거나 <see langword="null" />입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 배열에 지정된 문자 집합의 후행 항목을 모두 제거합니다.</summary>
        <returns>
          <paramref name="trimChars" /> 매개 변수의 문자가 현재 문자열의 끝 부분에서 모두 제거된 후 남아 있는 문자열입니다. <paramref name="trimChars" />가 <see langword="null" />이거나 빈 배열이면 유니코드 공백 문자가 대신 제거됩니다. 현재 인스턴스에서 어떠한 문자도 삭제할 수 없는 경우 이 메서드는 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimEnd%2A> 에 있는 모든 후행 문자가 현재 문자열에서 제거 메서드는 `trimChars` 매개 변수입니다. 첫 번째 문자에 있지 않은 지우기 작업이 중지 `trimChars` 문자열의 끝에 발생 합니다. 예를 들어, 현재 문자열 "123abc456xyz789" 이면 및 `trimChars` 부터 "9", "1"에서 번호를 포함 합니다 <xref:System.String.TrimEnd%2A> 메서드 "123abc456xyz"를 반환 합니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.TrimEnd%2A> 현재 인스턴스에서 모든 문자를 제거 하는 메서드,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 찾을 수 있는 모든 후행 문자에서 새 문자열을 반환 하는 대신 `trimChars` 현재 문자열에서 제거 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다는 <xref:System.String.TrimEnd%28System.Char%5B%5D%29> 공백이 나 문장 부호는 문자열의 끝에서 trim 방법입니다.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>합니다 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 하 고 이전 버전의 경우이 메서드가 트리밍하는 공백 문자 내부 목록을 유지 관리 <paramref name="trimChars" /> 는 <see langword="null" /> 이거나 빈 배열입니다. 부터 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]이면 <paramref name="trimChars" /> 은 <see langword="null" /> 또는 빈 배열인 경우 메서드는 모든 유니코드 공백 문자가 (즉, 생성 하는 문자를 <see langword="true" /> 에 전달 될 때 값을 반환 합니다 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 메서드). 이러한 변경으로 인해를 <see cref="M:System.String.Trim" /> 에서 메서드를 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 이전 버전 두 문자, 0 너비 공간 (U + 200B) 및 0 너비 비분할 공간 (U + FEFF)를 제거 하 고는 합니다 <see cref="M:System.String.Trim" /> 에서 메서드를 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 이상 버전을 수행 제거 되지 않습니다. 또한 합니다 <see cref="M:System.String.Trim" /> 의 메서드를 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 버전 3 유니코드 공백 문자를 자르지 않는 및: 몽골어 자음 구분 기호 (U + 180E), 좁은 비분할 공간 (U + 202F), 및 중간 수학 공간 (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">제거할 유니코드 문자 배열이거나 <see langword="null" />입니다.</param>
        <summary>현재 <see cref="T:System.String" /> 개체에서 배열에 지정된 문자 집합의 선행 항목을 모두 제거합니다.</summary>
        <returns>
          <paramref name="trimChars" /> 매개 변수의 문자가 현재 문자열의 시작 부분에서 모두 제거된 후 남아 있는 문자열입니다. <paramref name="trimChars" />가 <see langword="null" />이거나 빈 배열이면 공백 문자가 대신 제거됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.String.TrimStart%2A> 메서드는 현재 문자열에서 제거 중인 모든 선행 문자를 `trimChars` 매개 변수입니다. 경우에 없는 문자는 trim 작업 중지 `trimChars` 발생 합니다. 예를 들어, 현재 문자열 "123abc456xyz789" 이면 및 `trimChars` 부터 "9", "1"에서 번호를 포함 합니다 <xref:System.String.TrimStart%2A> 메서드 "abc456xyz789"를 반환 합니다.  
  
> [!NOTE]
>  경우는 <xref:System.String.TrimStart%2A> 현재 인스턴스에서 모든 문자를 제거 하는 메서드,이 메서드는 현재 인스턴스의 값을 수정 하지 않습니다. 대신 현재 인스턴스에서 찾을 수 있는 모든 선행 공백 문자는 제거 하는 새 문자열을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 기능을 <xref:System.String.TrimStart%2A> 메서드:

 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

 다음 예제에서는 <xref:System.String.TrimStart%2A> 공백 및 소스 코드 줄에서 주석 문자를 자르는 방법입니다. 합니다 `StripComments` 메서드 호출을 래핑한 <xref:System.String.TrimStart%2A> Visual Basic 및 C#에서 슬래시 (/)에서 공백 및 아포스트로피 (')는 주석 문자를 포함 하는 문자 배열을 전달 합니다. <xref:System.String.TrimStart%2A> 문자열 주석 인지 확인할 때 선행 공백을 제거할 메서드도 호출 됩니다.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 다음 예제에서는 `StripComments` 메서드를 호출하는 방법을 보여 줍니다.  
  
 [!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
 [!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>합니다 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 하 고 이전 버전의 경우이 메서드가 트리밍하는 공백 문자 내부 목록을 유지 관리 <paramref name="trimChars" /> 는 <see langword="null" /> 이거나 빈 배열입니다. 부터 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]이면 <paramref name="trimChars" /> 은 <see langword="null" /> 또는 빈 배열인 경우 메서드는 모든 유니코드 공백 문자가 (즉, 생성 하는 문자를 <see langword="true" /> 에 전달 될 때 값을 반환 합니다 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 메서드). 이러한 변경으로 인해를 <see cref="M:System.String.Trim" /> 에서 메서드를 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 이전 버전 두 문자, 0 너비 공간 (U + 200B) 및 0 너비 비분할 공간 (U + FEFF)를 제거 하 고는 합니다 <see cref="M:System.String.Trim" /> 에서 메서드를 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 이상 버전을 수행 제거 되지 않습니다. 또한 합니다 <see cref="M:System.String.Trim" /> 의 메서드를 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 버전 3 유니코드 공백 문자를 자르지 않는 및: 몽골어 자음 구분 기호 (U + 180E), 좁은 비분할 공간 (U + 202F), 및 중간 수학 공간 (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>