<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e02a5708b57cc55fbabd8950c0f3fc377238a18b" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52607341" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>클래스 형식, 인터페이스 형식, 배열 형식, 값 형식, 열거형 형식, 형식 매개 변수, 제네릭 형식 정의 및 개방형 생성 제네릭 형식이나 폐쇄형 생성 제네릭 형식에 대한 형식 선언을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` 루트를 <xref:System.Reflection> 기능 메타 데이터에 액세스 하는 기본 방법 이며 합니다. 멤버를 사용 하 여 <xref:System.Type> 뿐만 아니라 모듈 및 클래스는 배포 된 어셈블리 (예: 생성자, 메서드, 필드, 속성 및 클래스의 이벤트), 형식 멤버에 대 한 형식 선언에 대 한 정보를 가져오려고 합니다.  
  
 리플렉션을 사용 하 여 해당 액세스 수준에 관계 없이 형식 및 해당 멤버에 대 한 정보를 코드에 필요한 권한은 없습니다. 리플렉션을 사용 하 여 public 멤버 또는 액세스 수준을 볼 수 있도록 일반 컴파일하는 동안 다른 멤버에 액세스 하는 코드에 필요한 권한은 없습니다. 그러나 리플렉션을 사용 하는 일반적으로 액세스할 수 없습니다, private 또는 internal 메서드와 같은 보호 된 형식의 필드 또는 멤버에 액세스 하 여 코드에 대 한 클래스를 상속 하지 않습니다, 코드 있어야 <xref:System.Security.Permissions.ReflectionPermission>합니다. 참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다.  
  
 `Type` 여러 구현을 허용 하는 추상 기본 클래스 이며 시스템은 파생된 클래스를 항상 제공 `RuntimeType`합니다. 리플렉션에서 런타임 라는 단어로 시작 하는 모든 클래스는 시스템 및 지원 비교 작업에 대 한 개체당 한 번만 생성 됩니다.  
  
> [!NOTE]
>  다중 스레드 시나리오에서를 잠그지 마십시오 <xref:System.Type> 개체에 대 한 액세스를 동기화 하기 위해 `static` 데이터입니다. 제어 하지 않습니다 수 없는 다른 코드 클래스 형식이 잠글 수도 있습니다. 이 인해 교착 상태가 발생할 수 있습니다. 대신 개인을 잠그는 방식으로 정적 데이터에 대 한 액세스를 동기화 `static` 개체입니다.  
  
> [!NOTE]
>  파생된 클래스는 호출 코드의 기본 클래스의 protected 멤버를 액세스할 수 있습니다. 또한 호출 코드의 어셈블리의 어셈블리 구성원에 게 액세스가 허용 됩니다. 일반적으로 초기 바인딩 코드에서 액세스할 수 있는 경우 다음도 수 액세스 바인딩된 코드에서.  
  
> [!NOTE]
>  다른 인터페이스를 확장 하는 인터페이스에서 확장된 된 인터페이스에 정의 된 메서드를 상속 하지 않습니다.  
  
 섹션 내용  
  
 [유형을 형식 개체를 나타내지?](#WhatTypes)   
 [형식 개체를 검색합니다.](#Retrieve)   
 [같음에 대 한 형식 개체를 비교합니다.](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>유형을 형식 개체를 나타내지?  
 이 클래스는 스레드로부터 안전 합니다. 여러 스레드는이 형식의 인스턴스에서 동시에 읽을 수 있습니다. 인스턴스는 <xref:System.Type> 클래스 다음 형식 중 하나를 나타낼 수 있습니다.  
  
-   클래스  
  
-   값 형식  
  
-   배열  
  
-   인터페이스  
  
-   열거형  
  
-   대리자  
  
-   생성 된 제네릭 형식 및 제네릭 형식 정의  
  
-   인수를 입력 하 고 생성 된 제네릭 형식, 제네릭 형식 정 및 제네릭 메서드 정의의 매개 변수를 입력 합니다.  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>형식 개체를 검색합니다.  
 <xref:System.Type> 다음과 같이 특정 형식과 관련 된 개체를 가져올 수 있습니다.  
  
-   인스턴스 <xref:System.Object.GetType%2A?displayProperty=nameWithType> 메서드가 반환 되는 <xref:System.Type> 인스턴스의 형식을 나타내는 개체입니다. 모든 관리 되는 형식에서 파생 되므로 <xref:System.Object>, <xref:System.Object.GetType%2A> 형식일 인스턴스의 메서드를 호출할 수 있습니다.  
  
     다음 예제에서는 <xref:System.Object.GetType%2A?displayProperty=nameWithType> 개체 배열의 각 개체의 런타임 형식을 확인 하는 방법입니다.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   정적 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 메서드는 반환 된 <xref:System.Type> 정규화 된 이름을 사용 하 여 지정 된 형식을 나타내는 개체입니다.  
  
-   합니다 <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, 및 <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> 메서드는 반환 `Type` 모듈에 정의 된 형식을 나타내는 개체입니다. 첫 번째 메서드는 배열을 가져오는 데 사용할 수 있습니다 <xref:System.Type> 모듈에 정의 된 모든 공용 및 개인 형식에 대 한 개체입니다. (의 인스턴스를 가져올 수 있습니다 `Module` 를 통해 합니다 <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> 메서드를 또는 <xref:System.Type.Module%2A?displayProperty=nameWithType> 속성입니다.)  
  
-   합니다 <xref:System.Reflection.Assembly?displayProperty=nameWithType> 개체를 비롯 한 어셈블리에 정의 된 클래스를 검색 하는 방법의 번호가 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, 및 <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>합니다.  
  
-   <xref:System.Type.FindInterfaces%2A> 메서드 형식에서 지 원하는 인터페이스 형식의 필터링 된 목록을 반환 합니다.  
  
-   합니다 <xref:System.Type.GetElementType%2A> 메서드가 반환 되는 `Type` 요소를 나타내는 개체입니다.  
  
-   <xref:System.Type.GetInterfaces%2A> 하 고 <xref:System.Type.GetInterface%2A> 메서드는 반환 <xref:System.Type> 형식에서 지원 되는 인터페이스 형식을 나타내는 개체입니다.  
  
-   합니다 <xref:System.Type.GetTypeArray%2A> 메서드는 배열을 반환 <xref:System.Type> 임의의 개체 집합에서 지정 된 형식을 나타내는 개체입니다. 개체 형식의 배열을 사용 하 여 지정 된 <xref:System.Object>합니다.  
  
-   합니다 <xref:System.Type.GetTypeFromProgID%2A> 고 <xref:System.Type.GetTypeFromCLSID%2A> 메서드가 COM 상호 운용성을 위해 제공 됩니다. 반환 되는 <xref:System.Type> 로 지정 된 형식을 나타내는 개체를 `ProgID` 또는 `CLSID`.  
  
-   <xref:System.Type.GetTypeFromHandle%2A> 메서드는 상호 운용성을 위해 제공 됩니다. 반환 된 `Type` 클래스 핸들에 의해 지정 된 형식을 나타내는 개체입니다.  
  
-   C# `typeof` c + + 연산자 `typeid` 연산자 및 Visual Basic `GetType` 연산자 가져오기는 `Type` 형식에 대 한 개체입니다.  
  
-   <xref:System.Type.MakeGenericType%2A> 메서드가 반환 되는 <xref:System.Type> 개방형 생성된 형식은 생성 된 제네릭 형식을 나타내는 개체입니다 해당 <xref:System.Type.ContainsGenericParameters%2A> 속성에서 반환 `true`, 닫힌 생성 된 형식 그렇지 않은 경우 및 합니다. 이 닫혀 있는 경우에 제네릭 형식을 인스턴스화할 수 있습니다.  
  
-   합니다 <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, 및 <xref:System.Type.MakeByRefType%2A> 메서드는 반환 <xref:System.Type> 나타내는 개체를 각각 지정된 된 형식, 참조 매개 변수의 형식과 지정된 된 형식에 대 한 포인터의 배열 (`ref` C#에서는 `ByRef`Visual basic에서).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>같음에 대 한 형식 개체를 비교합니다.  
 A <xref:System.Type> 개체를 나타내는 형식이 고유한 지, 즉 두 <xref:System.Type> 동일한 형식을 나타내는 경우에 개체 참조가 동일한 개체를 참조 합니다. 이렇게 하면 비교 <xref:System.Type> 참조 같음을 사용 하 여 개체입니다. 다음 예제에서는 비교를 <xref:System.Type> 동일한 형식의 지 여부를 확인 하는 정수 값의 수를 나타내는 개체입니다.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 다음 예제에서는 몇 가지 대표적인 기능의 <xref:System.Type>합니다. C# `typeof` 연산자 (`GetType` Visual Basic의 연산자 `typeid` Visual c + +에서 연산자) 가져오는 데 사용 되는 <xref:System.Type> 개체를 나타내는 <xref:System.String>합니다. 이 <xref:System.Type> 개체를 <xref:System.Type.GetMethod%2A> 메서드 가져오는 데 사용 되는 <xref:System.Reflection.MethodInfo> 나타내는 <xref:System.String.Substring%2A> 시작 위치 및 길이 사용 하는 오버 로드 합니다.  
  
 오버 로드 시그니처를 식별 하려면 코드 예제는 두 가지를 포함 하는 임시 배열을 만듭니다 <xref:System.Type> 개체를 나타내는 `int` (`Integer` Visual basic에서).  
  
> [!NOTE]
>  배열에 두 개의 참조 인스턴스를 정확 하 게 포함 <xref:System.Type> 나타내는 `int` 현재 응용 프로그램 도메인입니다. 모든 형식에 대 한 인스턴스가 하나만 <xref:System.Type> 응용 프로그램 도메인당 합니다.  
  
 코드 예제에서는 합니다 <xref:System.Reflection.MethodInfo> 를 호출 하는 <xref:System.String.Substring%2A> 문자열 "Hello, World!", 메서드 결과 표시 합니다.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <block subset="none" type="overrides"><para>상속 하는 경우 <see langword="Type" />, 멤버를 재정의 해야 합니다. 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md">형식 정보 보기</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Type" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식 개체를 생성 하는 동안이 생성자는 파생된 클래스에서 호출 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>형식이 선언되는 <see cref="T:System.Reflection.Assembly" />를 가져옵니다. 제네릭 형식의 경우 제네릭 형식이 정의되는 <see cref="T:System.Reflection.Assembly" />를 가져옵니다.</summary>
        <value>현재 형식이 포함된 어셈블리를 설명하는 <see cref="T:System.Reflection.Assembly" /> 인스턴스입니다. 제네릭 형식의 경우 인스턴스는 특정한 생성된 형식을 만들고 사용하는 어셈블리가 아니라 제네릭 형식 정의가 포함된 어셈블리를 설명합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 개체가 생성 된 제네릭 형식을 나타내는지,이 속성에는 제네릭 형식 정의 포함 하는 어셈블리를 반환 합니다. 예를 들어, 제네릭 형식 정의 포함 하는 MyGenerics.dll 이라는 어셈블리를 만든 `MyGenericStack<T>` (`MyGenericStack(Of T)` Visual basic에서는 `generic<T> ref class MyGenericStack` c + +에서). 인스턴스를 만들면 `MyGenericStack<int>` (`MyGenericStack(Of Integer)` Visual Basic의) 다른 어셈블리에는 <xref:System.Type.Assembly%2A> 생성 된 형식에 대 한 속성을 반환 합니다는 <xref:System.Reflection.Assembly> MyGenerics.dll를 나타내는 개체입니다.  
  
 마찬가지로, 경우 현재 <xref:System.Type> 개체는 할당 되지 않은 제네릭 매개 변수를 나타내는 `T`,이 속성을 정의 하는 제네릭 형식이 포함 된 어셈블리를 반환 합니다. `T`합니다.  
  
 경우는 <xref:System.Type.Assembly%2A?displayProperty=nameWithType> 속성을 사용할 수 없습니다,.NET Core 또는 유니버설 Windows 플랫폼와 같은 특정.NET 구현에서 사용 하 여는 <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> 속성 대신 합니다.      
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제에서는 클래스와 연결 된 어셈블리 이름 및 형식의 정규화 된 이름을 표시 합니다.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Type" /> 개체가 로드된 어셈블리의 이름을 비롯하여 형식의 어셈블리 한정 이름을 가져옵니다.</summary>
        <value><see cref="T:System.Type" />이 로드된 어셈블리의 이름을 비롯한 <see cref="T:System.Type" />의 어셈블리 한정 이름입니다. 현재 인스턴스가 제네릭 형식 매개 변수를 나타낼 경우에는 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식의 정규화 된 어셈블리 이름을 형식 이름, 어셈블리의 표시 이름 뒤에 쉼표, 해당 네임 스페이스를 포함 하 여 구성 됩니다. 어셈블리의 표시 이름을 사용 하 여 가져온는 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 속성입니다.  
  
> [!NOTE]
>  .NET framework 버전 2.0에서 프로세서 아키텍처가 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다. 예를 들어, "ProcessorArchitecture = msil"입니다. 그러나 반환 하는 문자열에서 제외 됩니다는 <xref:System.Type.AssemblyQualifiedName%2A> 호환성을 위해 속성입니다. <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하세요.  
  
 공용 언어 런타임에서 지 원하는 모든 컴파일러는 중첩된 된 클래스의 단순한 이름 내보내고 리플렉션에서 다음 규칙에 따라 쿼리를 수행 하면 잘못 된 이름을 생성 합니다.  
  
|구분 기호|의미|  
|---------------|-------------|  
|백슬래시(\\)|이스케이프 문자입니다.|  
|쉼표 ()|어셈블리 이름을 앞에 옵니다.|  
|더하기 기호 (+)|중첩된 된 클래스 앞에 옵니다.|  
|마침표 (입니다.)|네임 스페이스 식별자를 나타냅니다.|  
|대괄호 ()|형식 이름을 후 해당 형식의 배열을 나타냅니다.<br /><br /> 또는<br /><br /> 제네릭 형식에 대 한 제네릭 형식 인수 목록을 포함합니다.<br /><br /> 또는<br /><br /> 형식 인수 목록을 내는 어셈블리의 정규화 된 형식을으로 둘러쌉니다.|  
  
 예를 들어, 클래스에 대 한 어셈블리의 정규화 된 이름을이 같습니다.  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 네임 스페이스에는 예를 들어 TopNamespace.Sub+Namespace 더하기 기호를 포함 된 경우 더하기 (+)는 뒤에 야 이스케이프 문자 (\\) 중첩 구분 기호로 해석 되지 않도록 합니다. 리플렉션이이 문자열을 다음과 같이 내보내기는:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 "+ +"가 "\\+\\+", 및 "\\"은 "\\\\"입니다.  
  
 이 정규화 된 이름은 유지 되었다가 나중에 로드 하는 데는 <xref:System.Type>합니다. 찾아 로드 하는 <xref:System.Type>를 사용 하 여 <xref:System.Type.GetType%2A> 만 또는 어셈블리 정규화 된 형식 이름의 이름 형식을 사용 하 여 합니다. <xref:System.Type.GetType%2A> 형식을 사용 하 여 이름을 찾을 것을 <xref:System.Type> 호출자의 어셈블리에서 찾은 다음 시스템 어셈블리에서. <xref:System.Type.GetType%2A> 어셈블리를 사용 하 여 정규화 된 형식 이름에 대 한 표시 됩니다는 <xref:System.Type> 모든 어셈블리에 있습니다.  
  
 형식 이름 형식이 참조 형식, 포인터 형식 또는 배열 형식 인지와 같은 형식에 대 한 추가 정보를 나타내는 후행 문자를 포함할 수 있습니다. 형식 이름 없이 이러한 후행 문자를 검색 하려면 사용 `t.GetElementType().ToString()`여기서 `t` 형식입니다.  
  
 공간은 어셈블리 이름 제외한 모든 형식 이름 구성 요소에 적용 됩니다. 어셈블리 이름에 ',' 구분 기호 앞의 공백은 관련이 있지만 ',' 구분 기호 뒤의 공백은 무시 됩니다.  
  
 제네릭 형식의 제네릭 인수는 어셈블리 이름으로 정규화 된 자체입니다. 에 대 한 어셈블리의 정규화 된 유형 이름에 예를 들어 `MyGenericClass<int>` (`MyGenericClass(Of Integer)` Visual basic에서), `int` 에 대 한 정규화 된 어셈블리 형식 이름으로 확장 됩니다 <xref:System.Int32>합니다.  
  
 하는 경우 현재 <xref:System.Type> 개체는 제네릭 매개 변수를 나타내는 경우이 속성은 반환 `null`합니다.  
  
   
  
## Examples  
 다음 예제에서는 클래스와 연결 된 어셈블리 이름 및 형식의 정규화 된 이름을 표시 합니다.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 다음 예제에서 반환 된 문자열을 비교 합니다 <xref:System.Type.ToString%2A> 메서드 및 `Name`, <xref:System.Type.FullName%2A>, 및 <xref:System.Type.AssemblyQualifiedName%2A> 속성.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">정규화된 형식 이름 지정</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />과 관련된 특성을 가져옵니다.</summary>
        <value><see cref="T:System.Reflection.TypeAttributes" />이 값이 지정되어 있지 않은 제네릭 형식 매개 변수를 나타내지 않는 경우 <see cref="T:System.Type" />의 특성 집합을 나타내는 <see cref="T:System.Type" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 멤버는 <xref:System.Reflection.TypeAttributes> 열거형 값의 그룹을 나타내는 마스크 됩니다. 각 그룹에는 기본 값이 0 인 멤버로 포함 됩니다. 예를 들어, 기본 값 합니다 <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> 멤버를 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 그룹은 0을 그대로 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> 멤버를 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 그룹. 이 때문에 이러한 값을 테스트 하기 전에 마스크를 사용 해야 합니다. 예제에서는 그림을 제공합니다.  
  
> [!TIP]
>  대부분의 경우 속성 같은 <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, 및 <xref:System.Type.IsSpecialName%2A> 유형 특성 보다 사용 하기가 더 쉽습니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성에는 제네릭 형식 정의의 특성을 반환 합니다. 예를 들어,에 대 한 반환 하는 특성 `MyGenericClass<int>` (`MyGenericClass(Of Integer)` Visual Basic의) 특성 `MyGenericClass<T>` (`MyGenericClass(Of T)` Visual basic에서).  
  
 경우 현재 <xref:System.Type> 제네릭 형식 매개 변수를 나타내는-즉, 경우는 <xref:System.Type.IsGenericParameter%2A> 속성에서 반환 `true` -는 <xref:System.Reflection.TypeAttributes> 이 속성에서 반환 된 값 지정 되지 않았습니다.  
  
   
  
## Examples  
 다음 예제에서는 용도 <xref:System.Type.Attributes%2A> 속성입니다.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />이 직접 상속된 형식을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Type" />이 직접 상속하는 <see cref="T:System.Type" />이거나, 현재 <see langword="null" />이 <see langword="Type" /> 클래스나 인터페이스를 나타내면 <see cref="T:System.Object" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 유형 현재 형식이 직접 상속 된 형식이입니다. <xref:System.Object> 되지 않은 기본 형식, 따라서 유형만 `null` 의 기본 형식으로 반환 됩니다 <xref:System.Object>합니다.  
  
 인터페이스는 0 개 이상의 기본 인터페이스;에서 상속 따라서이 속성은 반환 `null` 경우는 `Type` 개체 인터페이스를 나타냅니다. 기본 인터페이스를 사용 하 여 확인할 수 있습니다 <xref:System.Type.GetInterfaces%2A> 또는 <xref:System.Type.FindInterfaces%2A>합니다.  
  
 하는 경우 현재 <xref:System.Type> 은 생성 된 제네릭 형식을 나타내며, 기본 형식을 제네릭 인수를 반영 합니다. 예를 들어 다음 선언을 살펴보세요.  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 생성 된 형식에 대 한 `C<int>` (`C(Of Integer)` Visual basic에서), <xref:System.Type.BaseType%2A> 속성에서 반환 `B<int>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 제네릭 형식 정의의 형식 매개 변수를 나타내는 <xref:System.Type.BaseType%2A> 클래스 제약 조건, 즉, 형식 매개 변수를 상속 해야 클래스를 반환 합니다. 클래스 제약 조건이 없는 경우 <xref:System.Type.BaseType%2A> 반환 <xref:System.Object?displayProperty=nameWithType>합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Type.BaseType%2A> 속성입니다.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 다음 예제에서는 재귀를 사용 하 여 어셈블리에 있는 각 클래스의 완전 한 상속 계층 구조를 나열 합니다. 이 예제에서는 라는 클래스를 정의 `C` 라는 클래스에서 파생 되는 `B`는 라는 클래스에서 파생 됩니다, `A`합니다.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">리플렉션 및 제네릭 형식</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" /> 개체에 특정 형식으로 바뀌지 않은 형식 매개 변수가 있는지를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" /> 개체 자체가 제네릭 형식 매개 변수이거나 특정 형식이 적용되지 않은 형식 매개 변수이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식의 인스턴스를 만들기 위해 없는 제네릭 형식 정의 또는 형식 자체에서 모든 바깥쪽 제네릭 형식 또는 모든 요소 형식의 형식 인수에서 개방형 생성된 형식 여야 합니다. 두 번째 방법은 재귀적으로 검사 하는 경우, 형식에 제네릭 형식 매개 변수가 없는 있어야 합니다.  
  
 형식 일 수 있으므로 임의의 복잡 한이 결정을 내릴는 어렵습니다. 편의 위해 및 오류의 가능성을 줄이기 위해는 <xref:System.Type.ContainsGenericParameters%2A> 속성 제공를 인스턴스화할 수 있는 폐쇄형된 생성된 형식을 구분 하는 표준 방법 및 개방형 생성 형식 일 수 없습니다. 경우는 <xref:System.Type.ContainsGenericParameters%2A> 속성이 반환 `true`, 형식을 인스턴스화할 수 없습니다.  
  
 <xref:System.Type.ContainsGenericParameters%2A> 속성 형식 매개 변수를 재귀적으로 검색 합니다. 예를 들어 반환 `true` 요소가 들어 있는 형식 배열에 대 한 `A<T>` (`A(Of T)` Visual basic에서) 배열 되지 않더라도 제네릭 자체, 합니다. 동작을 사용 하 여이 대조해 보세요 합니다 <xref:System.Type.IsGenericType%2A> 반환 하는 속성 `false` 배열에 대 한 합니다.  
  
 예제에서는 클래스 및 값을 표시 하는 테이블 집합에 대 한 합니다 <xref:System.Type.ContainsGenericParameters%2A> 속성 참조 <xref:System.Type.IsGenericType%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 형식 매개 변수를 사용 하 여 제네릭 클래스를 정의 하 고 첫 번째 클래스에서 파생 되는 두 번째 제네릭 클래스를 정의 합니다. 파생된 클래스의 기본 클래스에 두 개의 형식 인수: 첫 번째는 <xref:System.Int32> 두 번째는 파생 된 형식의 형식 매개 변수입니다. 보고 된 위치를 포함 하 여 이러한 제네릭 클래스에 대 한 정보를 표시 하는 예제에는 <xref:System.Type.GenericParameterPosition%2A> 속성입니다.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">리플렉션 및 제네릭 형식</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Reflection.MethodBase" />가 제네릭 메서드의 형식 매개 변수를 나타내는 경우 선언 메서드를 나타내는 <see cref="T:System.Type" />를 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Type" />이 제네릭 메서드의 형식 매개 변수를 나타내면 선언하는 메서드를 나타내는 <see cref="T:System.Reflection.MethodBase" />이고, 그렇지 않으면 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 선언 메서드는 제네릭 메서드 정의입니다. 즉, 경우 <xref:System.Type.DeclaringMethod%2A> 반환 하지 않는 `null`, 한 다음 `DeclaringMethod.IsGenericMethodDefinition` 반환 `true`합니다.  
  
 합니다 <xref:System.Type.DeclaringType%2A> 및 <xref:System.Type.DeclaringMethod%2A> 제네릭 형식 정의 또는 제네릭 메서드 정의 원래 정의 된 제네릭 형식 매개 변수는 속성을 식별 합니다.  
  
-   경우는 <xref:System.Type.DeclaringMethod%2A> 속성이 반환을 <xref:System.Reflection.MethodInfo>하 <xref:System.Reflection.MethodInfo> 제네릭 메서드 정의 나타내며 현재 <xref:System.Type> 개체는 제네릭 메서드 정의의 형식 매개 변수를 나타냅니다.  
  
-   경우는 <xref:System.Type.DeclaringMethod%2A> 속성이 반환 `null`, 해당 <xref:System.Type.DeclaringType%2A> 속성은 항상 반환을 <xref:System.Type> 제네릭 형식 정의 나타내며 현재 개체 <xref:System.Type> 개체는 제네릭 형식의 형식 매개 변수를 나타냅니다 정의 합니다.  
  
-   시작 합니다 <xref:System.Type.DeclaringMethod%2A> 형식의 속성을 해당 <xref:System.Type.IsGenericParameter%2A> 속성은 `false` throw는 <xref:System.InvalidOperationException>합니다.  
  
 <xref:System.Reflection.MethodBase> 에서 반환 하는 합니다 <xref:System.Type.DeclaringMethod%2A> 속성이 <xref:System.Reflection.MethodInfo> 제네릭 메서드인 경우 또는 <xref:System.Reflection.ConstructorInfo> 제네릭 생성자의 경우.  
  
> [!NOTE]
>  제네릭 생성자는.NET framework 버전 2.0에서 지원 되지 않습니다.  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 제네릭 메서드가 메서드에 형식 인수를 할당 하 고 생성된 된 제네릭 메서드를 호출 하는 클래스를 정의 합니다. 또한 생성된 된 메서드 및 제네릭 메서드 정의 대 한 정보를 표시합니다. 제네릭 메서드 정의의 형식 매개 변수에 대 한 정보를 표시 하는 경우는 `DisplayGenericMethodInfo` 메서드를 예제 코드의 값이 표시는 <xref:System.Type.DeclaringMethod%2A> 메서드의 제네릭 형식 매개 변수에 대 한 속성.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">리플렉션 및 제네릭 형식</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 중첩 형식 또는 제네릭 형식 매개 변수를 선언하는 형식을 가져옵니다.</summary>
        <value>현재 형식이 중첩 형식이면 바깥쪽 형식을 나타내고 현재 형식이 제네릭 형식의 형식 매개 변수이면 제네릭 형식 정의를 나타내며 현재 형식이 제네릭 메서드의 형식 매개 변수이면 제네릭 메서드를 선언하는 형식을 나타내는 <see cref="T:System.Type" /> 개체이고, 그렇지 않으면 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 개체는 제네릭 형식의 형식 매개 변수를 나타내며,이 속성에는 제네릭 형식 정의 반환 합니다.  
  
 하는 경우 현재 <xref:System.Type> 개체는 제네릭 메서드의 형식 매개 변수를 나타내며,이 속성에는 제네릭 메서드 정의 포함 하는 형식을 반환 합니다. 형식이 제네릭 인지, 제네릭 형식 정의 반환 됩니다. 다음 코드에서는 제네릭 형식 정의 반환 하는, 합니다 <xref:System.Collections.Generic.List%601> 포함 하는 제네릭 클래스는 <xref:System.Collections.Generic.List%601.ConvertAll%2A> 제네릭 메서드:  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 경우 현재 <xref:System.Type> 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 <xref:System.Type.DeclaringType%2A> 및 <xref:System.Type.DeclaringMethod%2A> 속성의 제네릭 형식 매개 변수는 제네릭 형식 정의 또는 제네릭 메서드 정의 식별 합니다. 원래 정의 된:  
  
-   경우는 <xref:System.Type.DeclaringMethod%2A> 속성이 반환을 <xref:System.Reflection.MethodInfo>하 <xref:System.Reflection.MethodInfo> 제네릭 메서드 정의 나타내며 현재 <xref:System.Type> 개체는 제네릭 메서드 정의의 형식 매개 변수를 나타냅니다.  
  
-   경우는 <xref:System.Type.DeclaringMethod%2A> 속성이 반환 `null`, 해당 <xref:System.Type.DeclaringType%2A> 속성은 항상 반환을 <xref:System.Type> 제네릭 형식 정의 나타내며 현재 개체 <xref:System.Type> 개체는 제네릭 형식의 형식 매개 변수를 나타냅니다 정의 합니다.  
  
-   시작 합니다 <xref:System.Type.DeclaringType%2A> 형식의 속성을 해당 <xref:System.Type.IsGenericParameter%2A> 속성은 `false` throw는 <xref:System.InvalidOperationException>합니다.  
  
   
  
## Examples  
 이 예제에서는 파생된 클래스에서 메서드의 선언 형식이 표시 됩니다.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />에서 호출하는 적절한 멤버를 선택하기 위해 내부 규칙을 구현하는 기본 바인더에 대한 참조를 가져옵니다.</summary>
        <value>시스템에서 사용되는 기본 바인더에 대한 참조입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 공용 언어 런타임에서 제공 하는 기본 바인더는 대부분의 특수 한 경우를 제외한 모든 환경에서 적용 됩니다. 파생 된 형식 제공 되는 기본 바인더의 다른 다음과 같이 규칙을 정의 하는 바인더를 해야 하는 경우는 <xref:System.Reflection.Binder> 클래스를 사용 하 여 해당 형식의 인스턴스를 전달 합니다 `binder` 매개 변수 중 하나는 <xref:System.Type.InvokeMember%2A> 오버 로드.  
  
 리플렉션 공용 형식 시스템의 액세스 가능성 규칙을 모델링합니다. 예를 들어 호출자에 게 동일한 어셈블리의 경우 호출자에 게 필요가 없습니다 특별 한 권한이 내부 멤버에 대 한 합니다. 그렇지 않으면 호출자에 게 필요한 <xref:System.Security.Permissions.ReflectionPermission>합니다. 이것이, 보호 되는 멤버 조회를 사용 하 여 일관 된, private 및 등입니다.  
  
 일반 원칙 <xref:System.Reflection.Binder.ChangeType%2A> 확대 데이터 손실이 없는 변환을 수행 해야 합니다. 확대 변환의 예로 64 비트 부호 있는 정수 값을 32 비트 부호 있는 정수 값을 변환 됩니다. 이 축소 변환 시 데이터가 손실 될 수 있는에서 구분 됩니다. 축소 변환의 예로 64 비트 부호 있는 정수는 32 비트 부호 있는 정수로 변환 하는 것입니다.  
  
 다음 표에 기본 바인더에 의해 지원 되는 변환이 있습니다.  
  
|원본 유형|대상 유형|  
|-----------------|-----------------|  
|모든 형식|해당 기본 형식입니다.|  
|모든 형식|인터페이스를 구현 합니다.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|비참조|참조로 전달 합니다.|  
  
   
  
## Examples  
 다음 예제에서 기본 바인더를 가져옵니다 합니다 `DefaultBinder` 속성을 전달 하 여 MyClass의 멤버를 호출 하 고는 `DefaultBinder` 매개 변수로 값 <xref:System.Type.InvokeMember%2A>합니다.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />의 네임스페이스에 있는 이름을 구분합니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> 형식의 빈 배열을 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제는 `EmptyTypes` 중 하나에 사용 되는 필드를 `GetConstructor` 매개 변수가 없는 생성자를 가져오기 위한 메서드.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 내부 시스템 형식이 지정된 <see cref="T:System.Object" /> 또는 <see cref="T:System.Type" />의 내부 시스템 형식과 동일한지 확인합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">현재 <see cref="T:System.Type" />의 내부 시스템 형식과 비교할 내부 시스템 형식이 있는 개체입니다. 성공적인 비교를 위해 <paramref name="o" />는 캐스팅되거나 <see cref="T:System.Type" /> 형식의 개체로 변환될 수 있어야 합니다.</param>
        <summary>현재 <see cref="T:System.Type" /> 개체의 내부 시스템 형식이 지정된 <see cref="T:System.Object" />의 내부 시스템 형식과 동일한지 확인합니다.</summary>
        <returns><see langword="true" />의 내부 시스템 형식이 현재 <paramref name="o" />의 내부 시스템 형식과 같으면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다. 다음 경우에도 이 메서드는 <see langword="false" />를 반환합니다.  
  
-   <paramref name="o" />이 <see langword="null" />인 경우  
  
-   <paramref name="o" />는 캐스트되거나 <see cref="T:System.Type" /> 개체로 변환될 수 없습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Object.Equals%2A?displayProperty=nameWithType>를 재정의합니다. 캐스팅 `o` 형식의 개체로 <xref:System.Type> 호출을 <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Type.Equals%28System.Object%29> 다양 한 비교할 <xref:System.Type> 다양 한 인스턴스 개체 <xref:System.Object> 인스턴스.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 특히 주목할 예제에 대 한 두 가지 사항은 다음과 같습니다.  
  
-   비교는 <xref:System.Type> 갖는 정수를 나타내는 개체를 <xref:System.Reflection.TypeInfo> 반환 하는 정수를 나타내는 개체입니다 `true` 때문에 <xref:System.Reflection.TypeInfo> 에서 파생 됩니다 <xref:System.Type>합니다.  
  
-   비교는 <xref:System.Type> 나타내는 개체를 <xref:System.Collections.Generic.IList%601> 개체 (개방형 제네릭 형식)를 `List(Of String)` 개체 (폐쇄형된 제네릭 형식)를 반환 합니다 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">현재 <see cref="T:System.Type" />의 내부 시스템 형식과 비교할 내부 시스템 형식이 있는 개체입니다.</param>
        <summary>현재 <see cref="T:System.Type" />의 내부 시스템 형식이 지정된 <see cref="T:System.Type" />의 내부 시스템 형식과 동일한지 확인합니다.</summary>
        <returns><see langword="true" />의 내부 시스템 형식이 현재 <paramref name="o" />의 내부 시스템 형식과 같으면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 `Equals` 두 형식을 비교 하려면.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>특성에 사용되는 멤버 필터를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 필드는 사용 하는 대리자에 대 한 참조를 포함 합니다 <xref:System.Type.FindMembers%2A> 메서드. 이 대리자로 캡슐화 된 메서드는 두 매개 변수: 첫 번째는 <xref:System.Reflection.MemberInfo> 개체 이며 두 번째는 `Object`합니다. 메서드를 결정 하는지 여부를 `MemberInfo` 개체에 의해 지정 된 조건과 일치 하는 `Object`합니다. 합니다 `Object` 클래스의 필드 중 하나의 값을 할당할 수 있습니다 <xref:System.Reflection.FieldAttributes>를 <xref:System.Reflection.MethodAttributes>, 또는 <xref:System.Reflection.MethodImplAttributes>합니다.  
  
 예를 들어 합니다 `Object` 필드의 값을 할당 `FieldAttributes` Public과 같은 합니다. 이런 경우는 `FilterAttribute` 대리자를 호출 반환 `true` 메서드를 나타내는 경우에는 `MemberInfo` 개체 메타 데이터에서 public 필드 특성으로 데코 레이트 된 합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 `FilterAttribute` 대리자를 매개 변수로 전달 합니다 <xref:System.Type.FindMembers%2A> 메서드를 지정 된 멤버 및 해당 특성을 표시 합니다.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이름에 사용되는 멤버 필터(대/소문자 구분)를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 필드는 사용 하는 대리자에 대 한 참조를 포함 합니다 <xref:System.Type.FindMembers%2A> 메서드. 이 대리자로 캡슐화 된 메서드는 두 매개 변수: 첫 번째는 <xref:System.Reflection.MemberInfo> 개체 이며 두 번째는 `Object`합니다. 메서드를 결정 하는지 여부를 `MemberInfo` 개체에 의해 지정 된 조건과 일치 하는 `Object`합니다. `Object` 후행 포함할 수 있는 문자열 값이 할당은 "*" 와일드 카드 문자입니다. 유일한 와일드 카드 최종 문자열 일치가 지원 됩니다.  
  
 예를 들어를 `Object` "바이트 *" 값을 할당할 수 있습니다. 이런 경우는 `FilterName` 대리자를 호출 반환 `true` 메서드를 나타내는 경우에는 `MemberInfo` 개체에 이름이 "바이트"를 사용 하 여 시작 하는 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 연결 된 사용자 정의 메서드를 가져옵니다 `Application` 형식입니다.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이름에 사용되는 멤버 필터(대/소문자를 구분하지 않음)를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 필드는 사용 하는 대리자에 대 한 참조를 포함 합니다 <xref:System.Type.FindMembers%2A> 메서드. 이 대리자로 캡슐화 된 메서드는 두 매개 변수: 첫 번째는 <xref:System.Reflection.MemberInfo> 개체 이며 두 번째는 `Object`합니다. 메서드를 결정 하는지 여부를 `MemberInfo` 개체에 의해 지정 된 조건과 일치 하는 `Object`합니다. `Object` 후행 포함할 수 있는 문자열 값이 할당은 "*" 와일드 카드 문자입니다. 유일한 와일드 카드 최종 문자열 일치가 지원 됩니다.  
  
 예를 들어를 `Object` "바이트 *" 값을 할당할 수 있습니다. 이런 경우는 `FilterName` 대리자 호출 되 면 true를 반환만 메서드를 나타내는 경우는 `MemberInfo` 개체에 이름이 "byte", 대/소문자 무시를 사용 하 여 시작 하는 합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 `MemberFilter` 대리자를 매개 변수로 전달 합니다 <xref:System.Type.FindMembers%2A> 메서드를 메서드 및 해당 특성의 표시를 `String` 대/소문자를 무시 하 고 문자 "c"로 시작 하는 클래스입니다.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">인터페이스를 <paramref name="filterCriteria" />에 대해 비교하는 대리자입니다.</param>
        <param name="filterCriteria">반환되는 배열에 인터페이스가 포함되어야 하는지를 결정하는 검색 조건입니다.</param>
        <summary>현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 인터페이스의 필터링된 목록을 나타내는 <see cref="T:System.Type" /> 개체의 배열을 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Type" />에 의해 구현되거나 상속된 인터페이스의 필터링된 목록을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다. 해당 필터와 일치하는 인터페이스 중에서 현재 <see cref="T:System.Type" />에 의해 구현되거나 상속된 인터페이스가 없는 경우에는 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
 <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> 및 <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> 대리자가 제공한 합니다 <xref:System.Reflection.Module?displayProperty=nameWithType> 클래스도 사용할 수 있습니다, 법률의는 <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> 위임 합니다.  
  
 이 클래스에서 구현 된 인터페이스의 모든 값은 기본 클래스 또는 자체이 클래스에서 선언 하는지 여부를 검색 하는 동안 간주 됩니다.  
  
 이 메서드 검색 인터페이스가 구현 하는 각 인터페이스의 각 각각 구현 하는 일치 하는 모든와 일치 하는 인터페이스를 반환 합니다. 기본 클래스 계층 (즉, 일치 하는 인터페이스의 전이적 closure이 반환 됨). 중복 된 인터페이스가 없는 반환 됩니다.  
  
 하는 경우 현재 <xref:System.Type> 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 <xref:System.Type.FindInterfaces%2A> 형식 매개 변수에 대 한 제약 조건에 선언 된 모든 인터페이스를 검색 하 고 인터페이스를 통해 상속 된 모든 인터페이스 제약 조건에서 선언 됩니다. 하는 경우 현재 <xref:System.Type> 제네릭 형식의 형식 인수를 나타내는 <xref:System.Type.FindInterfaces%2A> 제약 조건과 일치 하는지 여부 또는 형식으로 구현 하는 모든 인터페이스를 검색 합니다.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> 제네릭 되지 않는 형식에도 제네릭 인터페이스를 반환할 수 있습니다. 예를 들어 제네릭이 아닌 형식을 구현할 수 있습니다 `IEnumerable<int>` (`IEnumerable(Of Integer)` Visual basic에서).  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 인터페이스 구현 또는 지정된 된 형식에서 상속 및 인터페이스 이름을 표시 한 다음를 찾습니다.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">정적 이니셜라이저가 호출되고 예외를 발생합니다.</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">검색할 멤버 형식을 나타내는 개체입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <param name="filter">비교를 수행하여 현재 검사 중인 멤버가 <see langword="true" />와 일치하면 <paramref name="filterCriteria" />이고, 그렇지 않으면 <see langword="false" />인 대리자입니다. 이 클래스에서 제공하는 <see langword="FilterAttribute" />, <see langword="FilterName" /> 및 <see langword="FilterNameIgnoreCase" /> 대리자를 사용할 수 있습니다. 첫 번째 대리자는 <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> 및 <see langword="MethodImplAttributes" />의 필드를 검색 조건으로 사용하고 다른 두 대리자는 <see langword="String" /> 개체를 검색 조건으로 사용합니다.</param>
        <param name="filterCriteria"><see langword="MemberInfo" /> 개체의 배열에 멤버가 반환되는지를 결정하는 검색 조건입니다.  
  
<see langword="FieldAttributes" />, <see langword="MethodAttributes" /> 및 <see langword="MethodImplAttributes" />의 필드는 이 클래스에서 제공하는 <see langword="FilterAttribute" /> 대리자와 함께 사용할 수 있습니다.</param>
        <summary>지정된 멤버 형식의 <see cref="T:System.Reflection.MemberInfo" /> 개체에 대한 필터링된 배열을 반환합니다.</summary>
        <returns>지정된 멤버 형식의 <see cref="T:System.Reflection.MemberInfo" /> 개체에 대한 필터링된 배열입니다.  
  
또는 
현재 <see cref="T:System.Reflection.MemberInfo" />에 필터 조건과 일치하는 <see cref="T:System.Type" /> 형식의 멤버가 없으면 <paramref name="memberType" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
 멤버 속성, 메서드, 필드, 이벤트 및 등을 포함 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 멤버를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Instance` 검색에서 인스턴스 멤버를 포함 합니다.  
  
-   지정 `BindingFlags.Static` 검색에 정적 멤버를 포함 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 멤버를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에서 (즉,: private, internal 및 protected 멤버) public이 아닌 멤버를 포함 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하 여 <xref:System.Type>, 상속 된 멤버가 아닌 합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 유효한 값에 대 한 <xref:System.Type.MemberType%2A> 에 정의 된 <xref:System.Reflection.MemberInfo>합니다. 이러한 멤버가 없으면 빈 배열이 반환 됩니다.  
  
 이 메서드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 하는 경우 현재 <xref:System.Type> 제네릭 형식 또는 제네릭 메서드 형식 매개 변수를 나타내는 <xref:System.Type.FindMembers%2A> 클래스 제약 조건 및 형식 매개 변수의 인터페이스 제약 조건으로 선언 된 모든 멤버를 처리 합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정 된 검색 조건과 일치 하는 클래스에서 모든 멤버를 찾아서 다음 일치 하는 멤버를 표시 합니다.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>해당 네임스페이스는 포함하지만 어셈블리는 포함하지 않는 형식의 정규화된 이름을 가져옵니다.</summary>
        <value>해당 네임스페이스는 포함하지만 어셈블리는 포함하지 않는 형식의 정규화된 이름이거나 현재 인스턴스가 제네릭 형식 매개 변수, 배열 형식, 포인터 형식, 형식 매개 변수에 기초한 <see langword="null" /> 형식 또는 제네릭 형식 정의가 아니지만 확인되지 않은 형식 매개 변수가 들어 있는 제네릭 형식인 경우에는 <see langword="byref" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정규화 된 이름에 예를 들어 합니다 <xref:System.String> 형식은 `System.String`합니다. 반환 되는 어셈블리의 정규화 된 이름을 사용 하 여이 대조해 보세요는 <xref:System.Type.AssemblyQualifiedName%2A> 속성을 전체 어셈블리 이름과 전체 이름으로 구성 됩니다.  
  
 문자열에 형식 인수를 반환한 현재 형식이 닫힌된 제네릭 형식을 나타내면는 <xref:System.Type.FullName%2A> 제네릭 형식 자체의 문자열 표현을 해당 전체에서 정규화 되지 않은 경우에 속성 전체 어셈블리 이름으로 정규화 됩니다 어셈블리 이름입니다. 다음 예제에서는 제네릭 형식 정의 나타내는 형식 및 닫힌된 제네릭 형식을 나타내는 FullName 속성 차이 보여 줍니다.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 이 속성은 반환 `null` 경우:  
  
-   현재 <xref:System.Type> 개체는 제네릭 형식의 형식 매개 변수를 나타냅니다.  
  
     다음 예제에서는 형식 매개 변수를 검색 합니다 <xref:System.Nullable%601> 형식 및 표시 하려고 해당 <xref:System.Type.FullName%2A> 속성입니다.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   현재 <xref:System.Type> 개체 배열 형식, 포인터 형식으로 나타내는 또는 `byref` 제네릭 형식 매개 변수를 기반으로 하는 형식입니다.  
  
     다음 예제에서는 제네릭 형식 정의 `Generictype1<T>`, 세 가지 메서드를 사용 하 여: `Display(T[])`, T; 형식의 배열을 전달 되는 `HandleT(T)`를 T 개체를 전달 되는 및 `ChangeValue(ref T)`, T 개체 참조로 전달 됩니다. C# 및 Visual Basic을 허용 하지 않으므로 T에 대 한 포인터로 정의 하는 `HandleT` 메서드를 호출 했습니다를 <xref:System.Type.MakePointerType%2A> 메서드는 <xref:System.Type> 제네릭 형식에 대 한 포인터를 만들려면 메서드의 매개 변수 형식을 나타내는 개체입니다. 예제의 출력 하는 세 가지 경우 모두 표시 합니다 <xref:System.Type.FullName%2A> 속성은 `null`합니다.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   현재 형식에 특정 형식으로 바뀌지 않은 제네릭 형식 매개 변수가 (즉, 합니다 <xref:System.Type.ContainsGenericParameters%2A> 속성에서 반환 `true`), 형식을 제네릭 형식 정의가 아닙니다. 하지만 (즉,는 <xref:System.Type.IsGenericTypeDefinition%2A> 속성 반환 `false`  
  
     다음 예에서 `Derived<T>` 에서 상속 `Base<T>`합니다. <xref:System.Type.BaseType%2A> 속성을 가져옵니다 합니다 <xref:System.Type> 의 기본 형식을 나타내는 개체입니다 `Derived<T>`, 및 해당 <xref:System.Type.FullName%2A> 속성에서 반환 `null`합니다.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     가져오려는 <xref:System.Type.FullName%2A> 없는 `null`, 사용할 수는 <xref:System.Type.GetGenericTypeDefinition%2A> 예제와 같이 제네릭 형식 정의 가져오는 방법.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제에서는 지정 된 형식의 전체 이름을 표시합니다.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 다음 예제에서 반환 된 문자열을 비교 합니다 <xref:System.Type.ToString%2A> 메서드 및 `Name`, <xref:System.Type.FullName%2A>, 및 <xref:System.Type.AssemblyQualifiedName%2A> 속성.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">정규화된 형식 이름 지정</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 제네릭 형식 매개 변수의 공 분산과 특수 제약 조건을 설명하는 <see cref="T:System.Reflection.GenericParameterAttributes" /> 플래그의 조합을 가져옵니다.</summary>
        <value>현재 제네릭 형식 매개 변수의 공 분산 및 특수 제약 조건을 설명하는 <see cref="T:System.Reflection.GenericParameterAttributes" /> 값의 비트 조합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 값을 현재 제네릭 형식 매개 변수를 공변 (covariant) 인지 여부를 나타내는 플래그 및 특수 제약 조건을 설명 하는 플래그를 포함 합니다. 사용 하 여는 <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> 값을 공변성 (covariance) 플래그를 선택 하 고 사용 하 여는 <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> 제약 조건 플래그를 선택 하는 값입니다.  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 제네릭 형식 정의 `Test` 제약 조건이 서로 다른 두 형식 매개 변수를 사용 하 여 합니다. 제약 조건을 사용 하 여 검사 된 프로그램을 실행 하는 경우는 <xref:System.Type.GenericParameterAttributes%2A> 속성 및 <xref:System.Type.GetGenericParameterConstraints%2A> 메서드.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 <see cref="T:System.Type" /> 개체가 제네릭 형식 매개 변수가 아닙니다. 즉, <see cref="P:System.Type.IsGenericParameter" /> 속성이 <see langword="false" />를 반환합니다.</exception>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">리플렉션 및 제네릭 형식</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> 개체가 제네릭 형식이나 제네릭 메서드의 형식 매개 변수를 나타내는 경우, 해당 매개 변수가 선언된 제네릭 형식 또는 메서드의 형식 매개 변수 목록에서 해당 형식 매개 변수가 있는 위치를 가져옵니다.</summary>
        <value>형식 매개 변수가 정의된 제네릭 형식 또는 메서드의 형식 매개 변수 목록에서 해당 형식 매개 변수가 있는 위치입니다. 위치 번호는 0부터 시작합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A> 속성의 위치를 반환 형식 매개 변수를 제네릭 형식 정의 또는 제네릭 메서드 정의의 매개 변수 목록의 형식 매개 변수에 원래 정의 된 합니다. 합니다 <xref:System.Type.DeclaringType%2A> 및 <xref:System.Type.DeclaringMethod%2A> 속성 제네릭 형식 또는 메서드 정의 식별 합니다.  
  
-   경우는 <xref:System.Type.DeclaringMethod%2A> 속성이 반환을 <xref:System.Reflection.MethodInfo>하 <xref:System.Reflection.MethodInfo> 제네릭 메서드 정의 나타내며 현재 <xref:System.Type> 개체는 제네릭 메서드 정의의 형식 매개 변수를 나타냅니다.  
  
-   경우는 <xref:System.Type.DeclaringMethod%2A> 속성이 반환 `null`, 해당 <xref:System.Type.DeclaringType%2A> 속성은 항상 반환을 <xref:System.Type> 제네릭 형식 정의 나타내며 현재 개체 <xref:System.Type> 개체는 제네릭 형식의 형식 매개 변수를 나타냅니다 정의 합니다.  
  
 값에 대 한 올바른 컨텍스트를 지정 하는 <xref:System.Type.GenericParameterPosition%2A> 는 제네릭 형식 또는 형식 매개 변수에 속하는 메서드를 식별 하는 데 필요한 속성입니다. 예를 들어, 제네릭 메서드의 반환 값을 고려할 `GetSomething` 다음 코드에서:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 반환한 형식과 `GetSomething` 클래스에 제공 된 형식 인수에 따라 달라 집니다 `A` 하 고 `GetSomething` 자체입니다. 가져올 수 있습니다는 <xref:System.Reflection.MethodInfo> 에 대 한 `GetSomething`는 반환 형식을 가져올 수 있습니다. 반환 형식의 형식 매개 변수를 검사 하는 경우 <xref:System.Type.GenericParameterPosition%2A> 둘 다에 대해 0을 반환 합니다. 위치가 `V` 이므로 0 `V` 클래스에 대 한 형식 매개 변수 목록의 첫 번째 형식 매개 변수는 `A`합니다. 위치가 `X` 이므로 0 `X` 에 대 한 형식 매개 변수 목록의 첫 번째 형식 매개 변수는 `GetSomething`합니다.  
  
> [!NOTE]
>  호출을 <xref:System.Type.GenericParameterPosition%2A> 속성 예외를 발생 하는 경우 현재 <xref:System.Type> 형식 매개 변수를 나타내지 않습니다. 개방형 생성 형식의 형식 인수를 검사할 때 사용 된 <xref:System.Type.IsGenericParameter%2A> 형식 매개 변수는 형식이 되 고 설명 하는 속성입니다. <xref:System.Type.IsGenericParameter%2A> 속성에서 반환 `true` ; 형식 매개 변수에 대해 사용할 수 있습니다 합니다 <xref:System.Type.GenericParameterPosition%2A> 위치로 사용 하는 메서드를 <xref:System.Type.DeclaringMethod%2A> 및 <xref:System.Type.DeclaringType%2A> 형식 정의 하는 정의 또는 제네릭 메서드를 확인 하는 속성 .  
  
   
  
## Examples  
 다음 예제에서는 두 형식 매개 변수를 사용 하 여 제네릭 클래스를 정의 하 고 첫 번째 클래스에서 파생 되는 두 번째 제네릭 클래스를 정의 합니다. 파생된 클래스의 기본 클래스에 두 개의 형식 인수: 첫 번째는 <xref:System.Int32>, 두 번째는 파생 된 형식의 형식 매개 변수입니다. 보고 된 위치를 포함 하 여 이러한 제네릭 클래스에 대 한 정보를 표시 하는 예제에는 <xref:System.Type.GenericParameterPosition%2A> 속성입니다.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 형식이 형식 매개 변수를 나타내지 않습니다. 즉, <see cref="P:System.Type.IsGenericParameter" />이 <see langword="false" />를 반환합니다.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">리플렉션 및 제네릭 형식</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 형식에 대한 제네릭 형식 인수의 배열을 가져옵니다.</summary>
        <value>이 형식에 대한 제네릭 형식 인수 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에만 제네릭 형식 인수를; 가져옵니다. 즉, 현재 형식의 제네릭 형식 매개 변수에 대해 지정 된 형식입니다. 현재 형식이 제네릭 형식 정의 인 경우이 속성에 빈 배열을 반환 합니다.  
  
> [!NOTE]
>  다른 제네릭 형식 또는 제네릭 메서드는 제네릭 형식을 사용 하는 경우 해당 제네릭 형식 인수 중 일부는 바깥쪽 메서드 또는 형식을 제네릭 형식 매개 변수를 수 있습니다.  
  
 제네릭 형식 정의 나타내는 형식의 제네릭 형식 매개 변수를 사용 합니다 <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> 속성입니다. 가져올는 <xref:System.Reflection.TypeInfo> 현재 <xref:System.Type> 개체를 사용 하 여는 <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> 확장 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>배열의 차원 수를 가져옵니다.</summary>
        <returns>현재 형식의 차수를 포함하는 정수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 배열의 차원 수를 표시합니다.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드의 기능은 기본 클래스에서 지원되지 않으므로 대신에 파생된 클래스에서 구현해야 합니다.</exception>
        <exception cref="T:System.ArgumentException">현재 형식은 배열이 아닙니다.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면 <see cref="P:System.Type.Attributes" /> 속성을 구현하고 <see cref="T:System.Type" />과 연관된 특성을 나타내는 비트 마스크를 가져옵니다.</summary>
        <returns><see cref="T:System.Reflection.TypeAttributes" />의 특성 집합을 나타내는 <see cref="T:System.Type" /> 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 특정 생성자를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">원하는 생성자에 대한 매개 변수의 수, 순서 및 형식을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
또는 
매개 변수를 사용하지 않는 생성자를 가져오기 위한 <see cref="T:System.Type" /> 개체의 빈 배열입니다. 이러한 빈 배열은 <see langword="static" /> 필드 <see cref="F:System.Type.EmptyTypes" />에서 제공됩니다.</param>
        <summary>지정된 배열의 형식과 일치하는 매개 변수를 가진 public 인스턴스 생성자를 검색합니다.</summary>
        <returns>매개 변수 형식 배열의 형식과 일치하는 매개 변수를 가진 public 인스턴스 생성자를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드 public 인스턴스 생성자 찾은 클래스 이니셜라이저가 (.cctor)를 가져오는 데 사용할 수 없습니다. 클래스 이니셜라이저가 사용 하는 오버 로드 <xref:System.Reflection.BindingFlags>를 지정 하 고 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 이 메서드가 반환 하는 경우 요청 된 생성자가 public이 아닌, `null`합니다.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출 하는 경우에 매개 변수를 생략할 수 있습니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다. 하는 경우 현재 <xref:System.Type> 이 메서드는 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `null`합니다.  
  
   
  
## Examples  
 다음 예제에서는의 형식을 가져옵니다 `MyClass`를 가져옵니다는 <xref:System.Reflection.ConstructorInfo> 개체를 생성자 시그니처를 표시 합니다.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />가 다차원 배열인 경우</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
또는 
<see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="types">가져올 생성자에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
또는 
매개 변수를 사용하지 않는 생성자를 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).  
  
또는 
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">매개 변수 형식 배열의 해당 요소와 연관된 특성을 나타내는 <see cref="T:System.Reflection.ParameterModifier" /> 개체의 배열입니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 생성자를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 생성자를 나타내는 <see cref="T:System.Reflection.ConstructorInfo" /> 개체가 있으면 이 개체를 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정확히 일치 하는 존재 하지 않는 경우는 `binder` 에 지정 된 매개 변수 형식을 강제 변환 하려고 합니다 `types` 일치 하는 항목을 선택 하기 위해 배열입니다. 경우는 `binder` 일치 항목을 선택한 다음 수 없는 `null` 반환 됩니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 생성자 검색에 포함할를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 생성자를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 생성자 (즉, 전용, 내부 및 보호 된 생성자)를 포함 합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출 하는 경우에 매개 변수를 생략할 수 있습니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다. 하는 경우 현재 <xref:System.Type> 이 메서드는 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `null`합니다.  
  
   
  
## Examples  
 다음 프로그램의 형식을 얻고 `MyClass1` 클래스를 가져옵니다는 <xref:System.Reflection.ConstructorInfo> 지정 된 바인딩 플래그와 일치 하는 개체를 생성자의 시그니처를 표시 합니다.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />가 다차원 배열인 경우  
  
또는 
 <paramref name="modifiers" />가 다차원 배열인 경우  
  
또는 
 <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
또는 
<see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="callConvention">인수의 순서 및 레이아웃, 반환 값의 전달 방법, 인수에 사용되는 레지스터, 스택 정리 방법 등과 관련하여 사용할 규칙을 지정하는 개체입니다.</param>
        <param name="types">가져올 생성자에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
또는 
매개 변수를 사용하지 않는 생성자를 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <paramref name="types" /> 개체 배열입니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>지정된 바인딩 제약 조건 및 호출 규칙을 사용하여, 지정된 인수 형식 및 한정자와 매개 변수가 일치하는 생성자를 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 생성자를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 정확히 일치 하는 존재 하지 않는 경우는 `binder` 에 지정 된 매개 변수 형식을 강제 변환 하려고 합니다 `types` 일치 하는 항목을 선택 하기 위해 배열입니다. 경우는 `binder` 일치 항목을 선택한 다음 수 없는 `null` 반환 됩니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 생성자 검색에 포함할를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 생성자를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 생성자 (즉, 전용, 내부 및 보호 된 생성자)를 포함 합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 이 메서드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출 하는 경우에 매개 변수를 생략할 수 있습니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다. 하는 경우 현재 <xref:System.Type> 이 메서드는 항상 반환 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `null`합니다.  
  
   
  
## Examples  
 다음 예제에서는의 형식을 가져옵니다 `MyClass1`를 가져옵니다는 <xref:System.Reflection.ConstructorInfo> 개체가 지정 된 바인딩 플래그와 일치 하는 생성자 시그니처를 표시 합니다.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />가 다차원 배열인 경우  
  
또는 
 <paramref name="modifiers" />가 다차원 배열인 경우  
  
또는 
 <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
또는 
<see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="callConvention">인수의 순서 및 레이아웃, 반환 값의 전달 방법, 인수에 사용되는 레지스터, 스택 정리 방법 등과 관련하여 사용할 규칙을 지정하는 개체입니다.</param>
        <param name="types">가져올 생성자에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
또는 
매개 변수를 사용하지 않는 생성자를 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <paramref name="types" /> 개체 배열입니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>파생 클래스에서 재정의되면, 지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 생성자를 지정된 바인딩 제약 조건 및 호출 규칙으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 생성자를 나타내는 <see cref="T:System.Reflection.ConstructorInfo" /> 개체가 있으면 이 개체를 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 정확히 일치 하는 존재 하지 않는 경우는 `binder` 에 지정 된 매개 변수 형식을 강제 변환 하려고 합니다 `types` 일치 하는 항목을 선택 하기 위해 배열입니다. 경우는 `binder` 일치 항목을 선택한 다음 수 없는 `null` 반환 됩니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 생성자 검색에 포함할를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 생성자를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 생성자 (즉, 전용, 내부 및 보호 된 생성자)를 포함 합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 이 메서드는 <xref:System.Type.GetConstructor%2A>를 구현합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />가 다차원 배열인 경우  
  
또는 
 <paramref name="modifiers" />가 다차원 배열인 경우  
  
또는 
 <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</exception>
        <exception cref="T:System.NotSupportedException">현재 형식이 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 또는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />입니다.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 생성자를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 대해 정의된 모든 public 생성자를 반환합니다.</summary>
        <returns>형식 이니셜라이저를 제외하고(정적 생성자) 현재 <see cref="T:System.Reflection.ConstructorInfo" />에 대해 정의된 모든 public 인스턴스 생성자를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다. public 인스턴스 생성자가 현재 <see cref="T:System.Type" />에 대해 정의되어 있지 않거나 현재 <see cref="T:System.Type" />이 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 경우 <see cref="T:System.Reflection.ConstructorInfo" /> 형식의 빈 배열이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A> 메서드 선언 순서와 같은 특정 순서로 생성자를 반환 하지 않습니다. 코드 영향을 받지 않아야 생성자 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 이 메서드 오버 로드를 호출 합니다 <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> 메서드 오버 로드를 사용 하 여 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저가 (.cctor)를 검색 하지 않습니다. 클래스 이니셜라이저를 사용 하는 오버 로드를 사용 <xref:System.Reflection.BindingFlags>를 지정 하 고 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다. 예를 들어 경우 클래스 `C<T>` 생성자가 `C(T t1)` (`Sub New(ByVal t1 As T)` Visual Basic의)를 호출 <xref:System.Type.GetConstructors%2A> 에 `C<int>` 반환을 <xref:System.Reflection.ConstructorInfo> 나타내는 `C(int t1)` C# (`Sub New(ByVal t1 As Integer)` Visual Basic의).  
  
 하는 경우 현재 <xref:System.Type> 제네릭 형식 매개 변수를 <xref:System.Type.GetConstructors%2A> 메서드는 빈 배열을 반환 합니다.  
  
   
  
## Examples  
 출력을 보여 주는이 예제는 <xref:System.Type.GetConstructors%2A> 두 인스턴스 생성자 및 정적 생성자가 하나 있는 클래스에서 오버 로드 합니다.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 이 코드의 출력이 됩니다.  
  
 2  
  
 False  
  
 False  
  
 때문에 <xref:System.Type.GetConstructors> 오버 로드만 사용 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 및 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>에서 정적 생성자를 계산 하지 않습니다는 `for` 식에서 계산 하거나 `IsStatic`.  
  
 정적 생성자를 찾기 위해 사용 하 여는 <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> 오버 로드 하 고 조합을 전달 (논리적 `OR`)의 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>를 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>다음 코드 예제에 나와 있는 것 처럼:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 이제 출력이 됩니다.  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 대해 정의된 생성자를 지정된 <see langword="BindingFlags" />로 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.ConstructorInfo" />에 대해 정의된 생성자 중 지정된 바인딩 제약 조건과 일치하는 모든 생성자(정의된 경우에는 형식 이니셜라이저도 포함)를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다. 생성자가 현재 <see cref="T:System.Reflection.ConstructorInfo" />에 대해 정의되어 있지 않거나, 정의된 생성자 중 바인딩 제약 조건과 일치하는 것이 없거나, 현재 <see cref="T:System.Type" />이 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 경우 <see cref="T:System.Type" /> 형식의 빈 배열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A> 메서드 선언 순서와 같은 특정 순서로 생성자를 반환 하지 않습니다. 코드 영향을 받지 않아야 생성자 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 `bindingAttr` public 생성자 또는 public 및 non-public 생성자만 반환할 것인지를 지정 하려면 사용할 수 있습니다.  
  
 정확히 일치 하는 존재 하지 않는 경우는 `binder` 에 지정 된 매개 변수 형식을 강제 변환 하려고 합니다 `types` 일치 하는 항목을 선택 하기 위해 배열입니다. 경우는 `binder` 일치 항목을 선택한 다음 수 없는 `null` 반환 됩니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 생성자 검색에 포함할를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 생성자를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 생성자 (즉, 전용, 내부 및 보호 된 생성자)를 포함 합니다. 기본 클래스의 생성자는 반환 되지 않습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.ConstructorInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다. 예를 들어 경우 클래스 `C<T>` 생성자가 `C(T t1)` (`Sub New(ByVal t1 As T)` Visual Basic의)를 호출 <xref:System.Type.GetConstructors%2A> 에 `C<int>` 반환을 <xref:System.Reflection.ConstructorInfo> 나타내는 `C(int t1)` C# (`Sub New(ByVal t1 As Integer)` Visual Basic의).  
  
 하는 경우 현재 <xref:System.Type> 제네릭 형식 매개 변수를 <xref:System.Type.GetConstructors%2A> 메서드는 빈 배열을 반환 합니다.  
  
   
  
## Examples  
 출력을 보여 주는이 예제는 <xref:System.Type.GetConstructors> 두 인스턴스 생성자 및 정적 생성자가 하나 있는 클래스에서 오버 로드 합니다.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 이 코드의 출력이 됩니다.  
  
 2  
  
 False  
  
 False  
  
 때문에 <xref:System.Type.GetConstructors%2A> 오버 로드만 사용 <xref:System.Reflection.BindingFlags.Public> 및 <xref:System.Reflection.BindingFlags.Instance>에서 정적 생성자를 계산 하지 않습니다는 `for` 식에서 계산 하거나 `IsStatic`.  
  
 정적 생성자를 찾기 위해 사용 하 여는 <xref:System.Type.GetConstructors%2A> 오버 로드 하 고의 조합 (논리적 OR)을 전달 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>를 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>다음 코드 예제 에서처럼:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 이제 출력이 됩니다.  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 대해 정의된 멤버 중 <see cref="T:System.Reflection.DefaultMemberAttribute" />가 설정된 멤버를 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.MemberInfo" />의 모든 기본 멤버를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
또는 
현재 <see cref="T:System.Reflection.MemberInfo" />에 기본 멤버가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A> 메서드 반환 하지 않습니다 멤버는 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 멤버 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
 멤버 속성, 메서드, 필드, 이벤트 및 등을 포함 합니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다. 예를 들어 경우 클래스 `C<T>` 속성이 `P` 반환 하는 `T`를 호출 <xref:System.Type.GetDefaultMembers%2A> 에 `C<int>` 반환 `int P` C# (`Property P As Integer` Visual Basic에서).  
  
 하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수 검색의 멤버 또는 멤버는 클래스 제약 조건의 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
   
  
## Examples  
 다음 예제에서는의 기본 멤버 정보를 얻고 `MyClass` 기본 멤버를 표시 합니다.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, 현재 배열, 포인터 또는 참조 형식에 의해 포함되거나 참조되는 개체의 <see cref="T:System.Type" />을 반환합니다.</summary>
        <returns>현재 배열, 포인터 또는 참조 형식에서 포함하거나 참조하는 개체의 <see cref="T:System.Type" />입니다. 현재 <see langword="null" />이 배열 또는 포인터가 아니거나, 참조로 전달되지 않거나, 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수나 제네릭 형식을 나타내는 경우에는 <see cref="T:System.Type" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 반환 `null` 에 대 한는 <xref:System.Array> 클래스입니다.  
  
   
  
## Examples  
 다음 예제는 `GetElementType` 메서드.  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">이름을 검색할 값입니다.</param>
        <summary>현재 열거형 형식에 대해 지정된 값을 가진 상수의 이름을 반환합니다.</summary>
        <returns>지정된 값을 가진 현재 열거형 형식의 멤버 이름이거나 그러한 상수가 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">현재 형식은 열거형이 아닙니다.  
  
또는 
 <paramref name="value" />이 현재 형식이 아니며 현재 형식과 동일한 기본 형식이 없습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 열거형 형식의 멤버 이름을 반환합니다.</summary>
        <returns>열거형 멤버의 이름이 포함된 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 값 배열 요소의 열거형 상수의 이진 값 (즉, 부호 없는 값)으로 정렬 됩니다. 동일한 값을 가진 열거 상수를 포함 하는 경우 해당 이름의 순서가 지정 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 형식은 열거형이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 열거형 형식의 내부 형식을 반환합니다.</summary>
        <returns>현재 열거형의 내부 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 C# 및 Visual Basic에서 열거형의 내부 형식은 <xref:System.Int32>합니다. 다른 정수 형식에 지정할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 형식은 열거형이 아닙니다.  
  
또는 
열거형 형식에 두 개 이상의 인스턴스 필드가 포함되어 있으므로 열거형 형식이 잘못되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 열거형 형식에 있는 상수 값의 배열을 반환합니다.</summary>
        <returns>값이 포함된 배열입니다. 배열 요소는 열거형 상수의 이진 값(즉, 부호 없는 값)을 기준으로 정렬됩니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">현재 형식은 열거형이 아닙니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 특정 이벤트를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 이벤트의 이름이 포함된 문자열입니다.</param>
        <summary>지정된 public 이벤트를 나타내는 <see cref="T:System.Reflection.EventInfo" /> 개체를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는, 지정한 public 이벤트(있는 경우)를 나타내는 개체이고, 그렇지 않으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드 또는 공용 접근자를 하나 이상 있을 경우 이벤트 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 이벤트는 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.  
  
 검색 `name` 대/소문자 구분 합니다. 검색에는 public static 및 public 인스턴스 이벤트가 포함 됩니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.EventInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 이벤트를 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Reflection.EventInfo> 개체 및 지정된 된 이벤트에 대 한 단추 클래스에 대 한 이벤트를 가져옵니다.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 이벤트의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면, 지정된 바인딩 제약 조건을 사용하여 지정된 이벤트를 나타내는 <see cref="T:System.Reflection.EventInfo" /> 개체를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는, 지정한 이벤트(있는 경우)를 나타내는 개체이고, 그렇지 않으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 이벤트를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 이벤트를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 이벤트 (즉, 전용, 내부 및 보호 된 이벤트)를 포함 하도록 합니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 이벤트만 검색 하는 <xref:System.Type>, 상속 된 이벤트가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 메서드 또는 공용 접근자를 하나 이상 있을 경우 이벤트 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 이벤트는 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.EventInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 이벤트를 검색 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> public 또는 public이 아닌 이벤트를 "Click" 라는 아닌 형식을 검색 하는 방법 `static` (`Shared` Visual basic에서).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 이벤트를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 모든 public 이벤트를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.EventInfo" />에 의해 선언되거나 상속되는 모든 public 이벤트를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
또는 
현재 <see cref="T:System.Reflection.EventInfo" />에 public 이벤트가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드 또는 공용 접근자를 하나 이상 있을 경우 이벤트 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 이벤트는 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.  
  
 <xref:System.Type.GetEvents%2A> 메서드 반환 하지 않습니다 이벤트를 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 이벤트가 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.EventInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 이벤트를 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 배열을 가져옵니다 <xref:System.Reflection.EventInfo> 개체에 대 한 모든 이벤트는 `Button` 클래스 및 이벤트 이름을 표시 합니다. Visual Basic 예제를 컴파일하려면 다음 명령줄을 사용 합니다.  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 의해 선언되거나 상속되는 이벤트를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.EventInfo" />에 의해 선언되거나 상속되는 이벤트 중 지정된 바인딩 제약 조건과 일치하는 모든 이벤트를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
또는 
현재 <see cref="T:System.Reflection.EventInfo" />에 이벤트가 없거나 해당 바인딩 제약 조건과 일치하는 이벤트가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A> 메서드 반환 하지 않습니다 이벤트를 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 이벤트가 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 이벤트를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 공용 이벤트를 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 이벤트 (즉, 전용, 내부 및 보호 된 이벤트)를 포함 하도록 합니다. 만 보호 하 고 기본 클래스의 내부 이벤트 반환 됩니다. 기본 클래스에서 private 이벤트 반환 되지 않습니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 이벤트만 검색 하는 <xref:System.Type>, 상속 된 이벤트가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 메서드 또는 공용 접근자를 하나 이상 있을 경우 이벤트 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 이벤트는 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.EventInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 이벤트를 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 배열을 가져옵니다 <xref:System.Reflection.EventInfo> 지정 된 바인딩 플래그와 일치 하는 개체에 대 한 모든 이벤트를 가져옵니다는 `Button` 클래스 및 이벤트 이름을 표시 합니다. Visual Basic 예제를 컴파일하려면 다음 명령줄을 사용 합니다.  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 특정 필드를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">가져올 데이터 필드의 이름이 포함된 문자열입니다.</param>
        <summary>지정된 이름의 public 필드를 검색합니다.</summary>
        <returns>지정된 이름의 public 필드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검색 `name` 대/소문자 구분 합니다. 검색에는 public static 및 public 인스턴스 필드가 포함 됩니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.FieldInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건 필드를 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 `Type` 지정된 된 클래스에 대 한 개체를 가져옵니다는 <xref:System.Reflection.FieldInfo> 필드에 대 한 개체 필드의 값을 표시 합니다.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">이 <see cref="T:System.Type" /> 개체는 해당 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 메서드가 아직 호출되지 않은 <see cref="T:System.Reflection.Emit.TypeBuilder" />입니다.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">가져올 데이터 필드의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <summary>지정된 필드를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 필드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 필드를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에서 public 필드를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 (즉, 전용, 내부 및 보호 된) 필드를 포함 합니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 필드만 검색할는 <xref:System.Type>, 상속 된 필드가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.FieldInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건 필드를 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 `Type` 지정된 된 클래스에 대 한 개체를 가져옵니다는 <xref:System.Reflection.FieldInfo> 지정 된 바인딩 플래그와 일치 하는 필드의 값을 표시 필드에 대 한 개체입니다.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 필드를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 모든 public 필드를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.FieldInfo" />에 대해 정의된 모든 public 필드를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
또는 
현재 <see cref="T:System.Reflection.FieldInfo" />에 대해 정의된 public 필드가 없는 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A> 메서드 반환 하지 않습니다 필드를 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 필드가 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.FieldInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 public 필드를 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하 여 `GetFields()` 메서드.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 대해 정의된 필드를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.FieldInfo" />에 대해 정의된 필드 중 지정된 바인딩 제약 조건과 일치하는 모든 필드를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
또는 
현재 <see cref="T:System.Reflection.FieldInfo" />에 대해 정의된 필드가 없거나 정의된 필드 중 해당 바인딩 제약 조건과 일치하는 필드가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A> 메서드 반환 하지 않습니다 필드를 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 필드가 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 필드를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에서 public 필드를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 (즉, 전용, 내부 및 보호 된) 필드를 포함 합니다. 만 보호 하 고 기본 클래스의 내부 필드가 반환 됩니다. 기본 클래스에서 private 필드 반환 되지 않습니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 필드만 검색할는 <xref:System.Type>, 상속 된 필드가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.FieldInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 public 필드를 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하 여 `GetFields(BindingFlags)` 메서드.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>닫힌 제네릭 형식의 형식 정의나 제네릭 형식 정의의 형식 매개 변수를 나타내는 <see cref="T:System.Type" /> 개체의 배열을 반환합니다.</summary>
        <returns>제네릭 형식의 형식 인수를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다. 현재 형식이 제네릭 형식이 아니면 빈 배열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배열 요소는 제네릭 형식의 형식 인수 목록에 나타나는 순서 대로 반환 됩니다.  
  
-   현재 형식이 닫힌 생성 된 형식인 경우 (즉, 합니다 <xref:System.Type.ContainsGenericParameters%2A> 속성이 반환 `false`)를 반환 하는 배열을 <xref:System.Type.GetGenericArguments%2A> 메서드는 제네릭 형식 정의의 제네릭 형식 매개 변수에 할당 된 형식을 포함 .  
  
-   현재 형식이 제네릭 형식 정의 인 경우 배열 형식 매개 변수를 포함 합니다.  
  
-   현재 형식이 개방형 생성된 형식 (즉, 합니다 <xref:System.Type.ContainsGenericParameters%2A> 속성이 반환 `true`) 어떤 종류의 모든 형식 매개 변수 및 바깥쪽 제네릭 형식 또는 메서드의 형식 매개 변수를 할당 된 있지, 배열에 포함 형식 및 형식 매개 변수입니다. 사용 된 <xref:System.Type.IsGenericParameter%2A> 구분 하는 속성입니다. 이 시나리오를 보여 주는 코드 예를 참조 하세요.를 <xref:System.Type.ContainsGenericParameters%2A> 속성입니다.  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Type.GetGenericArguments%2A> 생성 된 형식의 형식 인수 및 해당 제네릭 형식 정의의 형식 매개 변수를 표시 하는 방법입니다.  
  
 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Type.IsGenericTypeDefinition%2A> 속성입니다. 샘플 출력에 대 한 더 큰 예제를 참조 하세요.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다. 파생 클래스에서 구현을 제공해야 합니다.</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">리플렉션 및 제네릭 형식</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 제네릭 형식 매개 변수에 대한 제약 조건을 나타내는 <see cref="T:System.Type" /> 개체의 배열을 반환합니다.</summary>
        <returns>현재 제네릭 형식 매개 변수에 대한 제약 조건을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제네릭 형식 매개 변수의 각 제약 조건으로 표현 됩니다는 <xref:System.Type> 개체입니다. 사용 합니다 <xref:System.Type.IsClass%2A> 제약 조건이 기본 클래스 제약 조건 인지; 속성을 반환 하는 경우를 결정 하는 속성 `false`, 제약 조건 인터페이스 제약 조건입니다. 형식 매개 변수에 클래스 제약 조건이 있고 인터페이스 제약 조건이 없는 경우 빈 배열이 반환 됩니다.  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 제네릭 형식 정의 `Test` 제약 조건이 서로 다른 두 형식 매개 변수를 사용 하 여 합니다. 제약 조건을 사용 하 여 검사 된 프로그램을 실행 하는 경우는 <xref:System.Type.GenericParameterAttributes%2A> 속성 및 <xref:System.Type.GetGenericParameterConstraints%2A> 메서드.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 <see cref="T:System.Type" /> 개체가 제네릭 형식 매개 변수가 아닙니다. 즉, <see cref="P:System.Type.IsGenericParameter" /> 속성이 <see langword="false" />를 반환합니다.</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 제네릭 형식을 생성할 수 있는 제네릭 형식 정의를 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns>현재 형식을 생성할 수 있는 제네릭 형식을 나타내는 <see cref="T:System.Type" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제네릭 형식 정의 다른 형식을 생성 하는 데 사용 될 수 있는 템플릿입니다. 예를 들어, 제네릭 형식 정의에서 `G<T>` (C# 구문;으로 표현 합니다. `G(Of T)` Visual basic에서 또는 `generic <typename T> ref class G` c + +에서)를 생성 하 고 형식을 인스턴스화할 수 있습니다 `G<int>` (`G(Of Integer)` Visual basic에서). 지정 된을 <xref:System.Type> 생성 된 형식을이 나타내는 개체를 <xref:System.Type.GetGenericTypeDefinition%2A> 메서드는 제네릭 형식 정의 반환 합니다.  
  
 두 개의 생성 된 형식을 같은 제네릭 형식 정의에서 생성 되 면 동일한 형식 인수를 사용 하 여는 <xref:System.Type.GetGenericTypeDefinition%2A> 메서드를 반환 하는 동일한 <xref:System.Type> 두 유형 모두에 대 한 개체입니다.  
  
 호출 하는 경우는 <xref:System.Type.GetGenericTypeDefinition%2A> 메서드를 <xref:System.Type> 이미 제네릭 형식 정의 나타내는 개체 현재 반환 <xref:System.Type>.  
  
> [!IMPORTANT]
>  제네릭 형식의 배열 자체는 제네릭이 아닙니다. C# 코드에서 `A<int>[] v;` 또는 Visual Basic 코드 `Dim v() As A(Of Integer)`, 변수의 형식을 `v` 는 제네릭이 아닙니다. 사용 하 여 <xref:System.Type.IsGenericType%2A> 형식을 호출 하기 전에 제네릭 인지 여부를 확인 하려면 <xref:System.Type.GetGenericTypeDefinition%2A>합니다.  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 일반 인스턴스 생성을 사용 하 여 생성 된 형식의 인스턴스를 만들고 사용 하 여는 <xref:System.Type.GetType%2A> 고 <xref:System.Type.GetGenericTypeDefinition%2A> 생성 된 형식 및 제네릭 형식 정의 검색 하는 방법입니다. 이 예제에서는 제네릭 <xref:System.Collections.Generic.Dictionary%602> 유형, 생성 된 형식 나타내는 <xref:System.Collections.Generic.Dictionary%602> 의 `Test` 문자열 키를 사용 하 여 개체입니다.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 형식은 제네릭 형식이 아닙니다.  즉, <see cref="P:System.Type.IsGenericType" />이 <see langword="false" />를 반환합니다.</exception>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다. 파생 클래스에서 구현을 제공해야 합니다.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">리플렉션 및 제네릭 형식</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 해시 코드를 반환합니다.</summary>
        <returns>이 인스턴스의 해시 코드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>를 재정의합니다.  
  
   
  
## Examples  
 해시 코드를 표시 하는 다음 예제는 `System.Windows.Forms.Button` 클래스입니다.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 특정 인터페이스를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">가져올 인터페이스의 이름이 포함된 문자열입니다. 제네릭 인터페이스의 경우 이것은 형식 표시 이름입니다.</param>
        <summary>지정된 이름의 인터페이스를 검색합니다.</summary>
        <returns>개체는 현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는, 지정된 이름의 인터페이스를 나타내는 개체이며(있는 경우) 이를 나타내고, 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검색 `name` 대/소문자 구분 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Type> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 인터페이스 제약 조건과 클래스 또는 인터페이스 제약 조건에서 상속 된 모든 인터페이스 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수를 검색 합니다.  
  
> [!NOTE]
>  제네릭 인터페이스에 대 한 합니다 `name` 매개 변수는 잘못 된 이름, 억음 악센트 끝나는 (\`) 및 형식 매개 변수의 개수입니다. 이것이 제네릭 인터페이스 정 및 생성 된 제네릭 인터페이스를 모두 마찬가지입니다. 예를 들어 찾을 수 `IExample<T>` (`IExample(Of T)` Visual basic에서) 또는 `IExample<string>` (`IExample(Of String)` Visual basic에서), 검색할 ``"IExample`1"``.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Type.GetInterface%28System.String%29> 검색 하는 방법을 <xref:System.Collections.Hashtable> 클래스는 <xref:System.Runtime.Serialization.IDeserializationCallback> 인터페이스 및 인터페이스의 메서드를 나열 합니다.  
  
 코드 예제도 합니다 <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> 메서드 오버 로드 및 <xref:System.Type.GetInterfaceMap%2A> 메서드.  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">현재 <see cref="T:System.Type" />은 다른 형식 인수를 사용하여 동일한 제네릭 인터페이스를 구현하는 형식을 나타냅니다.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">가져올 인터페이스의 이름이 포함된 문자열입니다. 제네릭 인터페이스의 경우 이것은 형식 표시 이름입니다.</param>
        <param name="ignoreCase">단순한 인터페이스 이름을 지정하는 <see langword="true" /> 부분의 대/소문자를 무시하려면 <paramref name="name" />입니다. 네임스페이스를 지정하는 부분은 대/소문자를 올바로 지정해야 합니다.  
  
또는 
 <see langword="false" />의 모든 부분에 대해 대/소문자를 구분하여 검색하려면 <paramref name="name" />입니다.</param>
        <summary>파생 클래스에서 재정의되면 인터페이스 이름에 대해 대/소문자를 구분하지 않고 검색할지를 지정하여 지정된 인터페이스를 검색합니다.</summary>
        <returns>개체는 현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는, 지정된 이름의 인터페이스를 나타내는 개체이며(있는 경우) 이를 나타내고, 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ignoreCase` 매개 변수 단순한 인터페이스 이름을 네임 스페이스 필요가만 적용 됩니다. 부분 `name` 네임 스페이스에는 정확한 대/소문자 있어야 합니다. 또는 인터페이스를 찾을 수 없습니다 지정 합니다. 예를 들어, "System.icomparable" 찾습니다 문자열을 <xref:System.IComparable> 인터페이스 되지만 문자열 "system.icomparable" 하지 않습니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Type> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 인터페이스 제약 조건과 클래스 또는 인터페이스 제약 조건에서 상속 된 모든 인터페이스 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수를 검색 합니다.  
  
> [!NOTE]
>  제네릭 인터페이스에 대 한 합니다 `name` 매개 변수는 잘못 된 이름, 억음 악센트 끝나는 (\`) 및 형식 매개 변수의 개수입니다. 이것이 제네릭 인터페이스 정 및 생성 된 제네릭 인터페이스를 모두 마찬가지입니다. 예를 들어 찾을 수 `IExample<T>` (`IExample(Of T)` Visual basic에서) 또는 `IExample<string>` (`IExample(Of String)` Visual basic에서), 검색할 `"IExample`1"'.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> 의 대/소문자 구분 검색을 수행 하는 방법을 <xref:System.Collections.Hashtable> 클래스는 <xref:System.Collections.IEnumerable> 인터페이스입니다.  
  
 코드 예제도 합니다 <xref:System.Type.GetInterface%28System.String%29> 메서드 오버 로드 및 <xref:System.Type.GetInterfaceMap%2A> 메서드.  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">현재 <see cref="T:System.Type" />은 다른 형식 인수를 사용하여 동일한 제네릭 인터페이스를 구현하는 형식을 나타냅니다.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">매핑을 검색할 인터페이스의 형식입니다.</param>
        <summary>지정된 인터페이스 형식에 대한 인터페이스 매핑을 반환합니다.</summary>
        <returns><paramref name="interfaceType" />에 대한 인터페이스 매핑을 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인터페이스 맵을 인터페이스는 인터페이스를 구현 하는 클래스의 실제 멤버에 매핑되는 방법을 나타냅니다.  
  
 경우 현재 <xref:System.Type> 생성된 된 제네릭 형식을 나타내는, 형식 매개 변수 요소에 적절 한 형식 인수를 바뀝니다는 <xref:System.Reflection.InterfaceMapping> 이 메서드에서 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Type.GetInterfaceMap%2A> 결정 하는 방법 하는 방법을 <xref:System.IFormatProvider> 인터페이스에 매핑됩니다 <xref:System.Globalization.CultureInfo> 메서드를 하는 방법과 <xref:System.IAppDomainSetup> 인터페이스에 매핑됩니다 <xref:System.AppDomainSetup> 속성입니다. 때문에 <xref:System.IAppDomainSetup> 인터페이스의 속성에서 반환된 된 집합 정의 <xref:System.Reflection.InterfaceMapping> 별도 개체에 포함 됩니다 <xref:System.Reflection.MethodInfo> 속성의 get 및 set 접근자에 대 한 개체입니다.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="interfaceType" />이 현재 형식에 의해 구현되지 않았습니다.  
  
또는 
<paramref name="interfaceType" /> 인수는 인터페이스를 참조하지 않습니다.  
  
또는

현재 인스턴스 또는 <paramref name="interfaceType" /> 인수는 개방형 제네릭 형식입니다. 즉, <see cref="P:System.Type.ContainsGenericParameters" /> 속성은 <see langword="true" />를 반환합니다.

또는


 <paramref name="interfaceType" />은 제네릭 인터페이스이며 현재 형식이 배열 형식입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">현재 <see cref="T:System.Type" />은 제네릭 형식 매개 변수를 나타내며, 즉 <see cref="P:System.Type.IsGenericParameter" />는 <see langword="true" />입니다.</exception>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다. 파생 클래스에서 구현을 제공해야 합니다.</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 모든 인터페이스를 가져옵니다.</summary>
        <returns>현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 모든 인터페이스를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
또는 
현재 <see cref="T:System.Type" />에 의해 구현되거나 상속되는 인터페이스가 없는 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A> 메서드 반환 하지 않습니다 인터페이스를 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 인터페이스 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Type> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 인터페이스 제약 조건과 클래스 또는 인터페이스 제약 조건에서 상속 된 모든 인터페이스 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수를 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 클래스의 형식을 가져오고 형식을 구현 하거나 상속 하는 모든 인터페이스를 표시 합니다. Visual Basic 예제를 컴파일하려면 다음 컴파일러 명령을 사용 합니다.  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">정적 이니셜라이저가 호출되고 예외를 발생합니다.</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 지정된 멤버를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">가져올 public 멤버의 이름이 포함된 문자열입니다.</param>
        <summary>지정된 이름의 public 멤버를 검색합니다.</summary>
        <returns>지정된 이름의 public 멤버가 있으면 이를 나타내는 <see cref="T:System.Reflection.MemberInfo" /> 개체의 배열이고, 그렇지 않으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검색 `name` 대/소문자 구분 합니다. Public static 및 public 인스턴스 멤버를 포함 하는 검색 합니다.  
  
 멤버 속성, 메서드, 필드, 이벤트 및 등을 포함 합니다.  
  
 <xref:System.Type.GetMember%2A> 메서드 반환 하지 않습니다 멤버는 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 멤버 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 이 메서드 오버 로드 (.cctor) 클래스 이니셜라이저를 찾지 않습니다. 클래스 이니셜라이저를 사용 하는 오버 로드를 사용 <xref:System.Reflection.BindingFlags>를 지정 하 고 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수 검색의 멤버 또는 멤버는 클래스 제약 조건의 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다. 예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.  
  
   
  
## Examples  
 모든 멤버를 표시 하는 다음 예제는 `String` C 문자로 시작 하는 클래스  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">가져올 멤버의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
빈 배열을 반환하려는 경우 0입니다.</param>
        <summary>지정된 멤버를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 이름의 public 멤버가 있으면 이를 나타내는 <see cref="T:System.Reflection.MemberInfo" /> 개체의 배열이고, 그렇지 않으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
 멤버 속성, 메서드, 필드, 이벤트 및 등을 포함 합니다.  
  
 <xref:System.Type.GetMember%2A> 메서드 반환 하지 않습니다 멤버는 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 멤버 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 멤버를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 멤버를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에서 (즉,: private, internal 및 protected 멤버) public이 아닌 멤버를 포함 합니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하 여 <xref:System.Type>, 상속 된 멤버가 아닌 합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면에 대 한 ".cctor"를 지정 해야 합니다 `name`, 및 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서)에 대 한 `bindingAttr`. 클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수 검색의 멤버 또는 멤버는 클래스 제약 조건의 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다. 예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.  
  
   
  
## Examples  
 모든 공용 정적 멤버를 표시 하는 다음 예제는 `myString` C 문자로 시작 하는 클래스  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">가져올 멤버의 이름이 포함된 문자열입니다.</param>
        <param name="type">검색할 값입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
빈 배열을 반환하려는 경우 0입니다.</param>
        <summary>지정된 멤버 형식의 지정된 멤버를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 이름의 public 멤버가 있으면 이를 나타내는 <see cref="T:System.Reflection.MemberInfo" /> 개체의 배열이고, 그렇지 않으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 멤버 속성, 메서드, 필드, 이벤트 및 등을 포함 합니다.  
  
 <xref:System.Type.GetMember%2A> 메서드 반환 하지 않습니다 멤버는 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 멤버 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 멤버를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 멤버를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에서 (즉,: private, internal 및 protected 멤버) public이 아닌 멤버를 포함 합니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하 여 <xref:System.Type>, 상속 된 멤버가 아닌 합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면에 대 한 ".cctor"를 지정 해야 합니다 `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> 에 대 한 `type`, 및 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 에서 Visual Basic의 경우)에 대 한 `bindingAttr`합니다. 클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수 검색의 멤버 또는 멤버는 클래스 제약 조건의 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다. 예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.  
  
   
  
## Examples  
 모든 메서드를 표시 하는 다음 예제는 `myString` C 문자로 시작 하는 클래스  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">파생 클래스에서 구현을 제공해야 합니다.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 멤버(속성, 메서드, 필드, 이벤트 등)를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 모든 public 멤버를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.MemberInfo" />의 모든 public 멤버를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
또는 
현재 <see cref="T:System.Reflection.MemberInfo" />에 public 멤버가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 멤버 속성, 메서드, 필드, 이벤트 및 등을 포함 합니다.  
  
 <xref:System.Type.GetMembers%2A> 메서드 반환 하지 않습니다 멤버는 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 멤버 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 이 메서드 오버 로드를 호출 합니다 <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> 메서드 오버 로드를 사용 하 여 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저가 (.cctor)를 검색 하지 않습니다. 클래스 이니셜라이저를 사용 하는 오버 로드를 사용 <xref:System.Reflection.BindingFlags>를 지정 하 고 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MemberInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수 검색의 멤버 또는 멤버는 클래스 제약 조건의 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Type.GetMembers> 메서드 오버 로드는 지정 된 클래스의 모든 public 멤버에 대 한 정보를 수집 합니다.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
빈 배열을 반환하려는 경우 0(<see cref="F:System.Reflection.BindingFlags.Default" />)입니다.</param>
        <summary>파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 대해 정의된 멤버를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.MemberInfo" />에 대해 정의된 필드 중 지정된 바인딩 제약 조건과 일치하는 모든 멤버를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
또는 
현재 <see cref="T:System.Reflection.MemberInfo" />에 대해 정의된 멤버가 없거나 정의된 필드 중 해당 바인딩 제약 조건과 일치하는 멤버가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 멤버 속성, 메서드, 필드, 이벤트 및 등을 포함 합니다.  
  
 <xref:System.Type.GetMembers%2A> 메서드 반환 하지 않습니다 멤버는 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 멤버 반환 되는 순서 때문에 순서가 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 멤버를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 멤버를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에서 (즉,: private, internal 및 protected 멤버) public이 아닌 멤버를 포함 합니다. 만 보호 하 고 반환 되는 기본 클래스에 내부 멤버가; 기본 클래스에서 private 멤버는 반환 되지 않습니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하 여 <xref:System.Type>, 상속 된 멤버가 아닌 합니다.  
  
 이 메서드를 호출할 합니다 `Public` 플래그 또는 `NonPublic` 플래그 지정 된 멤버를 반환 하 고 다른 플래그는 필요 하지 않습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 이 메서드 오버 로드를 사용 하 여 클래스 이니셜라이저 (.cctor)을 가져오려면 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual basic에서). 클래스 이니셜라이저를 사용 하 여 가져올 수도 있습니다는 <xref:System.Type.TypeInitializer%2A> 속성입니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MemberInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수 검색의 멤버 또는 멤버는 클래스 제약 조건의 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> 메서드 오버 로드는 지정 된 클래스의 모든 공용 인스턴스 멤버에 대 한 정보를 수집 합니다.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 특정 메서드를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">가져올 public 메서드의 이름이 포함된 문자열입니다.</param>
        <summary>지정된 이름의 public 메서드를 검색합니다.</summary>
        <returns>지정된 이름의 public 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검색 `name` 대/소문자 구분 합니다. Static 및 public에 대 한 공용 인스턴스 메서드를 포함 하는 검색 합니다.  
  
 메서드 오버 로드 하 고 둘 이상의 공용 메서드가 합니다 <xref:System.Type.GetMethod%28System.String%29> 메서드가 throw는 <xref:System.Reflection.AmbiguousMatchException> 예외입니다. 공용 둘 이상의 오버 로드 이므로 다음 예제에서는 예외가 throw 됩니다는 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> 메서드.  반면에 때문에 `Person.ToString` 메서드 재정의 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 따라서 오버 로드 되지 하 고, <xref:System.Type.GetMethod%28System.String%29> 메서드는 검색할 수 있습니다를 <xref:System.Reflection.MethodInfo> 개체.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 특정 메서드를 검색 하려면 다음 중 하나를 수행할 수 있습니다.  
  
-   호출을 <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> 메서드 지정을 `bindingAttr` 메서드를 고유 하 게 식별 하는 인수입니다. 예를 들어, 형식에 정적 및 인스턴스 오버 로드 때문에 예외가 throw 되 면 지정할 수 있습니다는 `bindingAttr` 인수의 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>합니다.  
  
-   오버 로드를 호출 합니다 <xref:System.Type.GetMethod%2A> 포함 하는 메서드를 `types` 메서드의 매개 변수 유형을 정의 하는 매개 변수입니다.  
  
-   호출 된 <xref:System.Type.GetMethods> 모든 형식에 속한 공용 메서드를 포함 하는 배열을 검색 하는 방법입니다. 이름이 중복 된 메서드를 식별 하기 위해 다음 반복할 수 있습니다 `name`합니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다. 예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 메서드를 가져옵니다 `MethodA`합니다.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가진 메서드가 둘 이상 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">가져올 메서드의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <summary>지정된 메서드를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 또는 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> 반환 합니다.  
  
-   지정 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 검색에서 공용 메서드를 포함 합니다.  
  
-   지정 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 합니다.  
  
-   지정할 <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> 대/소문자를 무시 하려면 `name`합니다.  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 메서드 오버 로드 되 고 둘 이상의 오버 로드로 지정 된 제약 조건을 충족 하는 경우는 `bindingAttr` 인수는 메서드가 throw는 <xref:System.Reflection.AmbiguousMatchException> 예외입니다. 다음 예제에서는 없으므로 예외가 throw 됩니다.  
  
-   `TestClass` 형식에는 두 개의 공용 인스턴스 오버 로드가 합니다 `DisplayValue` 메서드를 `DisplayValue(String)` 및 `DisplayValue(String, Object[])`합니다.  
  
-   `TestClass` 형식은 두 공용 인스턴스 오버 로드는 `Equals` 메서드를 그 중 하나에서 상속 됩니다 <xref:System.Object>: `Equals(TestClass)` 및 `Equals(Object)`합니다.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 특정 메서드를 검색 하려면 다음 중 하나를 수행할 수 있습니다.  
  
-   해당 바인딩 제약 조건과 변경 합니다. 공용 인스턴스를 검색 하는 동안 이전 예에서 `Equals` 형식으로 선언 되 고 성공적으로 상속 되지 메서드 검색 `Equals(TestClass)`합니다.  
  
-   오버 로드를 호출 합니다 <xref:System.Type.GetMethod%2A> 포함 하는 메서드를 `types` 메서드의 매개 변수 유형을 정의 하는 매개 변수입니다.  
  
-   호출 된 <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> 모든 형식에 속하는 지정 된 바인딩 특성이 있는 메서드를 포함 하는 배열을 검색 하는 방법입니다. 이름이 중복 된 메서드를 식별 하기 위해 다음 반복할 수 있습니다 `name`합니다. 이 접근 방식에 대 한 이전 예제의 처리기에 설명 되어는 <xref:System.Reflection.AmbiguousMatchException> 예외입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다. 예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 바인딩 플래그와 일치 하는 메서드를 가져옵니다.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 메서드가 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 public 메서드의 이름이 포함된 문자열입니다.</param>
        <param name="types">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
또는 
매개 변수를 사용하지 않는 메서드를 가져올 <see cref="T:System.Type" /> 개체(<see cref="F:System.Type.EmptyTypes" /> 필드에서 제공됨)의 빈 배열입니다.</param>
        <summary>지정된 인수 형식과 일치하는 매개 변수를 가진 지정된 public 메서드를 검색합니다.</summary>
        <returns>지정된 인수 형식과 일치하는 매개 변수를 가진 public 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검색 `name` 대/소문자 구분 합니다. Static 및 public에 대 한 공용 인스턴스 메서드를 포함 하는 검색 합니다.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출 하는 경우에 매개 변수를 생략할 수 있습니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  `name` 매개 변수 형식 인수를 포함할 수 없습니다. 예를 들어 C# 코드 `GetMethod("MyGenericMethod<int>")` 텍스트 이름 사용 하 여 메서드에 대 한 검색 "`MyGenericMethod<int>`"을 대신 명명 된 메서드에 대 한 `MyGenericMethod` 형식의 제네릭 인수 하나가 있는 `int`합니다. 대신 `GetMethod("MyGenericMethod")` 적절 한 매개 변수를 사용 하 여는 `types` 배열입니다.  
  
   
  
## Examples  
 다음 예제에서는 특정 오버 로드 `MethodA`, 다양 한 형식 인수를 지정 합니다.  
  
> [!NOTE]
>  합니다 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 예제는 `/unsafe` 컴파일러 옵션입니다.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 다음 예제에서는 검색 <xref:System.Reflection.MethodInfo> 나타내는 개체를 `Add` 제네릭이 아닌 형식의 메서드 (합니다 <xref:System.Collections.ArrayList> 클래스), 개방형 제네릭 형식 (는 <xref:System.Collections.Generic.List%601> 클래스), 및 닫힌된 제네릭 형식 (는 `List(Of String)` 형식.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 이 예제에서는 정의 `GetAddMethod` 적절 한 검색 하는 메서드 <xref:System.Reflection.MethodInfo> 개체입니다. 제공 하는 `types` 개방형 제네릭 형식에 대 한 인수를 호출 합니다 <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> 메서드. 제공 하는 `types` 의 값을 얻어냅니다 닫힌된 제네릭 형식에 대 한 인수는 <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> 속성.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정된 이름 및 지정된 매개 변수를 사용하는 메서드가 두 개 이상입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="types" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />가 다차원 배열인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 public 메서드의 이름이 포함된 문자열입니다.</param>
        <param name="types">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
또는 
매개 변수를 사용하지 않는 메서드를 가져올 <see cref="T:System.Type" /> 개체(<see cref="F:System.Type.EmptyTypes" /> 필드에서 제공됨)의 빈 배열입니다.</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <paramref name="types" /> 개체 배열입니다. COM interop를 통해 호출하는 경우에만 사용되며 참조에 의해 전달된 매개 변수만 처리합니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 public 메서드를 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 public 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 검색 `name` 대/소문자 구분 합니다. Static 및 public에 대 한 공용 인스턴스 메서드를 포함 하는 검색 합니다.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출 하는 경우에 매개 변수를 생략할 수 있습니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다. 예를 들어 C# 코드 `GetMethod("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다. 대신 `GetMethod("MyMethod")` 적절 한 매개 변수를 사용 하 여는 `types` 배열입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정된 이름 및 지정된 매개 변수를 사용하는 메서드가 두 개 이상입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="types" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />가 다차원 배열인 경우  
  
또는 
 <paramref name="modifiers" />가 다차원 배열인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 메서드의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
또는 
<see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="types">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
또는 
매개 변수를 사용하지 않는 메서드를 가져올 <see cref="T:System.Type" /> 개체(<see cref="F:System.Type.EmptyTypes" /> 필드에서 제공됨)의 빈 배열입니다.</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <paramref name="types" /> 개체 배열입니다. COM interop를 통해 호출하는 경우에만 사용되며 참조에 의해 전달된 매개 변수만 처리합니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 메서드를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에서 공용 메서드를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 합니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출 하는 경우에 매개 변수를 생략할 수 있습니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다. 예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.  
  
   
  
## Examples  
 다음 예제에서는 특정 오버 로드 `MethodA`, 바인딩 제약 조건 및 다양 한 형식 인수를 지정 합니다.  
  
> [!NOTE]
>  합니다 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 예제는 `/unsafe` 컴파일러 옵션입니다.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 메서드가 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="types" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />가 다차원 배열인 경우  
  
또는 
 <paramref name="modifiers" />가 다차원 배열인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 메서드의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
또는 
<see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="callConvention">인수의 순서 및 레이아웃, 반환 값의 전달 방법, 인수에 사용되는 레지스터, 스택 정리 방법 등과 관련하여 사용할 규칙을 지정하는 개체입니다.</param>
        <param name="types">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
또는 
매개 변수를 사용하지 않는 메서드를 가져올 <see cref="T:System.Type" /> 개체(<see cref="F:System.Type.EmptyTypes" /> 필드에서 제공됨)의 빈 배열입니다.</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <paramref name="types" /> 개체 배열입니다. COM interop를 통해 호출하는 경우에만 사용되며 참조에 의해 전달된 매개 변수만 처리합니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 메서드를 지정된 바인딩 제약 조건과 지정된 호출 규칙으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `GetXXX` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에서 공용 메서드를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 합니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출 하는 경우에 매개 변수를 생략할 수 있습니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
> [!NOTE]
>  제네릭 메서드에 대 한 형식 인수를 포함 하지 않습니다 `name`합니다. 예를 들어 C# 코드 `GetMember("MyMethod<int>")` 텍스트 이름 가진 멤버에 대 한 검색 "`MyMethod<int>`", 대신 명명 된 메서드에 대 한 `MyMethod` 제네릭 형식 인수 하나가 있는 `int`합니다.  
  
   
  
## Examples  
 다음 예제에서는 특정 오버 로드 `MethodA`, 바인딩 제약 조건과 지정, 호출 규칙 및 다양 한 인수 형식입니다.  
  
> [!NOTE]
>  합니다 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 예제는 `/unsafe` 컴파일러 옵션입니다.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 메서드가 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="types" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />가 다차원 배열인 경우  
  
또는 
 <paramref name="modifiers" />가 다차원 배열인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 메서드의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
또는 
<see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="callConvention">인수의 순서 및 레이아웃, 반환 값의 전달 방법, 인수에 사용되는 레지스터, 스택을 정리하는 프로세스 등과 관련하여 사용할 규칙을 지정하는 개체입니다.</param>
        <param name="types">가져올 메서드에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
또는 
매개 변수를 사용하지 않는 메서드를 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).  
  
또는 
 <see langword="null" />. <paramref name="types" />가 <see langword="null" />이면 일치되는 인수가 없습니다.</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <paramref name="types" /> 개체 배열입니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>파생 클래스에서 재정의되면, 지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 메서드를 지정된 바인딩 제약 조건 및 호출 규칙으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 메서드를 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 `types`가 `null`이면 일치되는 인수가 없습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에서 공용 메서드를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 합니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 메서드가 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />가 다차원 배열인 경우  
  
또는 
 <paramref name="modifiers" />가 다차원 배열인 경우  
  
또는 
 <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</exception>
        <exception cref="T:System.NotSupportedException">현재 형식이 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 또는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />입니다.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 메서드를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 모든 public 메서드를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.MethodInfo" />에 대해 정의된 모든 public 메서드를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
또는 
현재 <see cref="T:System.Reflection.MethodInfo" />에 대해 정의된 public 메서드가 없는 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A> 메서드 반환 하지 않습니다 메서드를 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 메서드가 반환 되는 순서 때문에 순서에 따라 달라 지는 합니다.  
  
 생성자는 메서드가이 호출에서 반환 된 배열에 포함 되지 않습니다. 별도 호출 `GetConstructors()` 생성자 메서드를 가져오려고 합니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출 하는 경우에 매개 변수를 생략할 수 있습니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />에 대해 정의된 메서드를 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.MethodInfo" />에 대해 정의된 필드 중 지정된 바인딩 제약 조건과 일치하는 모든 메서드를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
또는 
현재 <see cref="T:System.Reflection.MethodInfo" />에 대해 정의된 메서드가 없거나 정의된 필드 중 해당 바인딩 제약 조건과 일치하는 메서드가 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A> 메서드 반환 하지 않습니다 메서드를 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 메서드가 반환 되는 순서 때문에 순서에 따라 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함 하는 메서드를 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에서 공용 메서드를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 메서드 (즉, 전용, 내부 및 보호 된 메서드)를 포함 합니다. 만 보호 하 고 기본 클래스 내부 메서드 반환 됩니다. 기본 클래스의 전용 메서드는 반환 되지 않습니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 메서드만 검색 하는 <xref:System.Type>, 상속 된 메서드가 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
> [!NOTE]
>  생성자와 메서드를 조회할 때 매개 변수를 생략할 수 없습니다. 호출 하는 경우에 매개 변수를 생략할 수 있습니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.MethodInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 나타냅니다는 클래스 제약 조건의 메서드 또는 메서드 정의 제네릭 형식 또는 제네릭 메서드,이 메서드 형식 매개 변수 검색 <xref:System.Object> 클래스 제약 조건이 없는 경우.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 공용 메서드와 하나의 보호 된 메서드를 사용 하 여 클래스를 만들고, 만듭니다는 `Type` 개체에 해당 하 `MyTypeClass`모든 public 및 public이 아닌 메서드를 가져오고 해당 이름을 표시 합니다.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 중첩된 특정 형식을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">가져올 중첩 형식의 이름이 포함된 문자열입니다.</param>
        <summary>지정된 이름의 public 중첩 형식을 검색합니다.</summary>
        <returns>지정된 이름의 public 중첩 형식을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검색 `name` 대/소문자 구분 합니다.  
  
 에 대 한 중첩 된 클래스의 단순한 이름을 사용 하 여 `name`입니다. 외부 클래스의 이름으로 적합 하지 않습니다. 중첩 된 제네릭 클래스에 대 한 잘못 된 이름을 사용 하 여-즉, 억음 악센트 및 제네릭 인수의 개수를 추가 합니다. 예를 들어 문자열을 사용 하 여 "내부\`1" 중첩 된 클래스를 가져오려면 제네릭 `Inner<T>` (`Inner(Of T)` Visual basic에서). 언어별 구문은 형식 매개 변수를 포함 하지 않습니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 중첩된 형식을 검색 합니다.  
  
 중첩된 형식이 제네릭인 경우이 메서드는 제네릭 형식 정의 반환 합니다. 바깥쪽 제네릭 형식이 닫힌 생성 된 형식인 경우에 마찬가지입니다.  
  
> [!NOTE]
>  하는 경우 현재 <xref:System.Type> C#, Visual Basic 또는 c + +에 정의 된 제네릭 형식을 나타내면 자체의 제네릭 매개 변수가 없는 경우에 중첩 형식은 모두 제네릭 해당 합니다. 이것이 반드시 사용 하 여 컴파일된 또는 동적 어셈블리에 정의 된 중첩 형식의 경우 합니다 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다.  
  
 중첩 된 제네릭 형식에 해당 제네릭 형식 정의에서 중첩 된 제네릭 형식을 생성 한 정보를 참조 하세요. <xref:System.Type.MakeGenericType%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">가져올 중첩 형식의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면, 지정된 중첩 형식을 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 중첩 형식을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 중첩 된 클래스의 단순한 이름을 사용 하 여 `name`입니다. 외부 클래스의 이름으로 적합 하지 않습니다. 중첩 된 제네릭 클래스에 대 한 잘못 된 이름을 사용 하 여-즉, 억음 악센트와 제네릭 매개 변수 개수를 추가 합니다. 예를 들어 문자열을 사용 하 여 "내부\`1" 중첩 된 클래스를 가져오려면 제네릭 `Inner<T>` (`Inner(Of T)` Visual basic에서). 언어별 구문은 형식 매개 변수를 포함 하지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 검색에 포함할 형식 필터 플래그를 사용 하는 중첩 된 정의 될 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 또는 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 반환을 가져오려고 합니다.  
  
-   지정 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> public 중첩된 형식을 검색에 포함 합니다.  
  
-   지정 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 검색에 public이 아닌 중첩된 형식 (즉, 전용, 내부 및 보호 된 중첩된 형식)를 포함 합니다.  
  
 이 메서드는 현재 형식의 중첩 된 형식만 반환합니다. 현재 형식의 기본 클래스를 검색 하지 않습니다. 기본 클래스에서 중첩 된 형식을 찾으려고 호출 상속 계층 구조를 검색 해야 <xref:System.Type.GetNestedType%2A> 각 수준에서.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 및 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> 무시 됩니다.  
  
 이 메서드를 호출할 합니다 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 플래그 또는 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 플래그 지정 된 중첩 된 형식과 다른 플래그는 필요 하지 않습니다 반환 됩니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 중첩된 형식을 검색 합니다.  
  
 중첩된 형식이 제네릭인 경우이 메서드는 제네릭 형식 정의 반환 합니다. 바깥쪽 제네릭 형식이 닫힌 생성 된 형식인 경우에 마찬가지입니다.  
  
> [!NOTE]
>  하는 경우 현재 <xref:System.Type> C#, Visual Basic 또는 c + +에 정의 된 제네릭 형식을 나타내면 자체의 제네릭 매개 변수가 없는 경우에 중첩 형식은 모두 제네릭 해당 합니다. 이것이 반드시 사용 하 여 컴파일된 또는 동적 어셈블리에 정의 된 중첩 형식의 경우 합니다 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다.  
  
 중첩 된 제네릭 형식에 해당 제네릭 형식 정의에서 중첩 된 제네릭 형식을 생성 한 정보를 참조 하세요. <xref:System.Type.MakeGenericType%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 중첩된 형식을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 중첩된 public 형식을 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Type" />에 중첩된 public 형식을 나타내는 <see cref="T:System.Type" /> 개체의 배열이거나(검색은 재귀적이 아님), 현재 <see cref="T:System.Type" />에 중첩된 public 형식이 없으면 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A> 메서드 반환 하지 않습니다 형식을 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 형식이 반환 되는 순서 때문에 순서에 따라 달라 지는 합니다.  
  
 즉시 현재 형식에 중첩 된 public 형식만 반환 됩니다. 검색은 재귀적이 아님.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 중첩된 형식을 검색 합니다.  
  
 중첩된 형식이 제네릭인 경우이 메서드는 제네릭 형식 정의 반환 합니다. 바깥쪽 제네릭 형식이 닫힌 생성 된 형식인 경우에 마찬가지입니다.  
  
> [!NOTE]
>  하는 경우 현재 <xref:System.Type> C#, Visual Basic 또는 c + +에 정의 된 제네릭 형식을 나타내면 자체의 제네릭 매개 변수가 없는 경우에 중첩 형식은 모두 제네릭 해당 합니다. 이것이 반드시 사용 하 여 컴파일된 또는 동적 어셈블리에 정의 된 중첩 형식의 경우 합니다 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다.  
  
 중첩 된 제네릭 형식에 해당 제네릭 형식 정의에서 중첩 된 제네릭 형식을 생성 한 정보를 참조 하세요. <xref:System.Type.MakeGenericType%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 중첩 된 클래스를 정의 및 `struct` 에 `MyClass`, 다음 형식을 사용 하는 중첩 형식의 개체를 가져옵니다 `MyClass`합니다.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면 지정된 바인딩 제약 조건을 사용하여 현재 <see cref="T:System.Type" />에 중첩된 형식을 검색합니다.</summary>
        <returns>지정된 바인딩 제약 조건과 일치하는 현재 <see cref="T:System.Type" />에 중첩된 모든 형식을 나타내는 <see cref="T:System.Type" /> 개체의 배열이거나(검색은 재귀적이 아님), 바인딩 제약 조건과 일치하는 중첩 형식이 없으면 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 중첩 된 형식에 대 한 검색은 재귀적이 아님.  
  
 <xref:System.Type.GetNestedTypes%2A> 메서드 반환 하지 않습니다 형식을 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 형식이 반환 되는 순서 때문에 순서에 따라 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 검색에 포함할 형식 필터 플래그를 사용 하는 중첩 된 정의 될 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 또는 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 반환을 가져오려고 합니다.  
  
-   지정 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> public 중첩된 형식을 검색에 포함 합니다.  
  
-   지정 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 검색에 public이 아닌 중첩된 형식 (즉, 전용, 내부 및 보호 된 중첩된 형식)를 포함 합니다.  
  
 이 메서드는 현재 형식의 중첩 된 형식만 반환합니다. 현재 형식의 기본 클래스를 검색 하지 않습니다. 기본 클래스에서 중첩 된 형식을 찾으려고 호출 상속 계층 구조를 검색 해야 <xref:System.Type.GetNestedTypes%2A> 각 수준에서.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 및 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> 무시 됩니다.  
  
 이 메서드를 호출할 합니다 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 플래그 또는 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 플래그 지정 된 중첩 된 형식과 다른 플래그는 필요 하지 않습니다 반환 됩니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 중첩된 형식을 검색 합니다.  
  
 중첩된 형식이 제네릭인 경우이 메서드는 제네릭 형식 정의 반환 합니다. 바깥쪽 제네릭 형식이 닫힌 생성 된 형식인 경우에 마찬가지입니다.  
  
> [!NOTE]
>  하는 경우 현재 <xref:System.Type> C#, Visual Basic 또는 c + +에 정의 된 제네릭 형식을 나타내면 자체의 제네릭 매개 변수가 없는 경우에 중첩 형식은 모두 제네릭 해당 합니다. 이것이 반드시 사용 하 여 컴파일된 또는 동적 어셈블리에 정의 된 중첩 형식의 경우 합니다 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다.  
  
 중첩 된 제네릭 형식에 해당 제네릭 형식 정의에서 중첩 된 제네릭 형식을 생성 한 정보를 참조 하세요. <xref:System.Type.MakeGenericType%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 중첩 된 공용 클래스 및 두 개의 중첩 된 보호 된 클래스를 만들고 지정 된 바인딩 제약 조건과 일치 하는 클래스에 대 한 정보를 표시 합니다.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 속성을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 모든 public 속성을 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.PropertyInfo" />의 모든 public 속성을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
또는 
현재 <see cref="T:System.Reflection.PropertyInfo" />에 public 속성이 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 호출에 해당 하는 <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> 오버 로드를 `bindingAttr` 같음 인수 `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` C# 및 `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` Visual Basic의 합니다. 모든 공용 인스턴스 및 정적 속성을 현재 형식에 의해 정의 된 두 반환 <xref:System.Type> 개체 뿐만 아니라 해당 기본 형식에서 상속 합니다.  
  
 속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.  
  
 <xref:System.Type.GetProperties%2A> 메서드 반환 하지 않습니다 속성을 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 속성 반환 되는 순서 때문에 순서에 따라 달라 지는 합니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 `GetProperties` 메서드를 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <summary>파생 클래스에서 재정의되면, 현재 <see cref="T:System.Type" />의 속성을 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Reflection.PropertyInfo" />의 속성 중 지정된 바인딩 제약 조건과 일치하는 모든 속성을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
또는 
현재 <see cref="T:System.Reflection.PropertyInfo" />에 속성이 없거나 해당 바인딩 제약 조건과 일치하는 속성이 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.  
  
 <xref:System.Type.GetProperties%2A> 메서드 반환 하지 않습니다 속성을 특정 순서로 같은 알파벳 또는 선언 순서입니다. 코드 영향을 받지 않아야 속성 반환 되는 순서 때문에 순서에 따라 달라 지는 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 검색에 포함할 형식 필터 플래그를 사용 하는 중첩 된 정의 될 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에서 공용 속성을 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 속성 (즉, 전용, 내부 및 보호 된 속성)을 포함 하도록 합니다. 만 보호 하 고 기본 클래스의 내부 속성이 반환 됩니다. 기본 클래스에서 private 속성 반환 되지 않습니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 속성만 검색할는 <xref:System.Type>, 상속 된 속성이 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.  
  
 이 메서드가 반환 하는 경우 현재 생성된 된 제네릭 형식을 나타내는는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 개체입니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.  
  
   
  
## Examples  
 라는 클래스를 정의 하는 다음 예제에서는 `PropertyClass` 6 개의 속성을 포함 하는: 두는 공용, 개인 것, 보호 되는 하나, 하나는 내부 (`Friend` Visual basic에서), 내부 보호 되며 하나 (`Protected Friend` Visual Basic에서). 일부 기본 속성 정보를 표시 합니다 (속성 이름 및 형식을 읽기/쓰기가 가능 하며의 표시 여부는 해당 여부를 해당 `get` 및 `set` 접근자) 지정 된 바인딩 제약 조건과 일치 하는 속성에 대 한 합니다.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 특정 속성을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">가져올 공용 속성의 이름이 포함된 문자열입니다.</param>
        <summary>지정된 이름의 public 속성을 검색합니다.</summary>
        <returns>지정된 이름의 공용 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검색 `name` 대/소문자 구분 합니다. 검색 public static 및 public 인스턴스 속성을 포함합니다.  
  
 속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.  
  
 있는 경우 <xref:System.Reflection.AmbiguousMatchException> 발생은 다음과 같습니다.  
  
-   형식에는 두 개의 동일한 인덱싱된 속성 이름을 다른 개수의 매개 변수입니다. 모호성을 해결할 수의 오버 로드를 사용 합니다 <xref:System.Type.GetProperty%2A> 매개 변수 형식을 지정 하는 방법입니다.  
  
-   파생된 된 형식을 사용 하 여 동일한 이름의 상속된 된 속성을 숨기는 속성을 선언 합니다 `new` 한정자 (`Shadows` Visual basic에서). 모호성을 해결 하려면 사용 합니다 <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> 메서드 오버 로드 하 고 추가 <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 상속 되지 않은 멤버에 검색을 제한 하는 플래그입니다.  
  
## <a name="indexers-and-default-properties"></a>인덱서 및 기본 속성  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]하십시오 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 인덱싱된 속성에 액세스 하기 위한 구문을 단순화 하 고 인덱싱된 속성 하나를 해당 형식에 대 한 기본값이 되도록 허용 합니다. 예를 들어 경우 변수의 `myList` 참조를 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual Basic의) 3의 인덱스를 사용 하 여 요소를 검색 합니다. 속성을 오버 로드할 수 있습니다.  
  
 C#에서는이 기능 인덱서 호출 및 이름으로 참조할 수 없습니다. 기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다. 그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다. 예를 들어 합니다 <xref:System.String> 클래스에는 명명 된 인덱서 <xref:System.String.Chars%2A>합니다. C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성 이름도 항목 이외의 있을 수 있습니다.  
  
 형식에 기본 속성이 있는지 여부를 확인 하려면 사용 합니다 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 테스트 방법은 <xref:System.Reflection.DefaultMemberAttribute> 특성. 형식에 있으면 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성의 기본 속성의 이름을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 검색 된 `Type` 사용자 정의 클래스의 개체 클래스의 속성을 검색 하 고 속성 이름을 표시 합니다.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 내부적으로이 속성은 참조 메타 데이터에서 이름이 "항목"입니다. 가져오려면 `PropertyInfo` 리플렉션을 사용 하 여 올바르게 반환 하기 위해이 내부 이름을 지정 해야 합니다는 `PropertyInfo` 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가진 속성이 둘 이상 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">가져올 속성의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <summary>지정된 속성을 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 속성을 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에서 공용 속성을 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 속성 (즉, 전용, 내부 및 보호 된 속성)을 포함 하도록 합니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 속성만 검색할는 <xref:System.Type>, 상속 된 속성이 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.  
  
 있는 경우 <xref:System.Reflection.AmbiguousMatchException> 발생은 다음과 같습니다.  
  
-   형식에는 두 개의 동일한 인덱싱된 속성 이름을 다른 개수의 매개 변수입니다. 모호성을 해결할 수의 오버 로드를 사용 합니다 <xref:System.Type.GetProperty%2A> 매개 변수 형식을 지정 하는 방법입니다.  
  
-   파생된 형식 선언에 동일한 이름의 상속된 된 속성을 숨기는 속성을 사용 하 여는 `new` 한정자 (`Shadows` Visual basic에서). 모호성을 해결 하려면 포함 <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 상속 되지 않은 멤버에 검색을 제한 합니다.  
  
## <a name="indexers-and-default-properties"></a>인덱서 및 기본 속성  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]하십시오 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 인덱싱된 속성에 액세스 하기 위한 구문을 단순화 하 고 인덱싱된 속성 하나를 해당 형식에 대 한 기본값이 되도록 허용 합니다. 예를 들어 경우 변수의 `myList` 참조를 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual Basic의) 3의 인덱스를 사용 하 여 요소를 검색 합니다. 속성을 오버 로드할 수 있습니다.  
  
 C#에서는이 기능 인덱서 호출 및 이름으로 참조할 수 없습니다. 기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다. 그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다. 예를 들어 합니다 <xref:System.String> 클래스에는 명명 된 인덱서 <xref:System.String.Chars%2A>합니다. C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성 이름도 항목 이외의 있을 수 있습니다.  
  
 형식에 기본 속성이 있는지 여부를 확인 하려면 사용 합니다 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 테스트 방법은 <xref:System.Reflection.DefaultMemberAttribute> 특성. 형식에 있으면 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성의 기본 속성의 이름을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용자 정의 클래스의 형식을 검색, 해당 클래스의 속성을 검색 및 지정 된 바인딩 제약 조건에 따라 속성 이름을 표시 합니다.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 속성이 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">가져올 공용 속성의 이름이 포함된 문자열입니다.</param>
        <param name="returnType">속성의 반환 형식입니다.</param>
        <summary>지정된 이름과 반환 형식의 public 속성을 검색합니다.</summary>
        <returns>지정된 이름의 공용 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.  
  
 검색 `name` 대/소문자 구분 합니다. 검색 public static 및 public 인스턴스 속성을 포함합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.  
  
## <a name="indexers-and-default-properties"></a>인덱서 및 기본 속성  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]하십시오 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 인덱싱된 속성에 액세스 하기 위한 구문을 단순화 하 고 인덱싱된 속성 하나를 해당 형식에 대 한 기본값이 되도록 허용 합니다. 예를 들어 경우 변수의 `myList` 참조를 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual Basic의) 3의 인덱스를 사용 하 여 요소를 검색 합니다. 속성을 오버 로드할 수 있습니다.  
  
 C#에서는이 기능 인덱서 호출 및 이름으로 참조할 수 없습니다. 기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다. 그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다. 예를 들어 합니다 <xref:System.String> 클래스에는 명명 된 인덱서 <xref:System.String.Chars%2A>합니다. C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성 이름도 항목 이외의 있을 수 있습니다.  
  
 형식에 기본 속성이 있는지 여부를 확인 하려면 사용 합니다 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 테스트 방법은 <xref:System.Reflection.DefaultMemberAttribute> 특성. 형식에 있으면 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성의 기본 속성의 이름을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 하나의 속성이 있는 클래스를 정의 및 이름 및 형식의 속성을 검색 합니다.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가진 속성이 둘 이상 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />이(가) <see langword="null" />이거나 <paramref name="returnType" />이(가) <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 공용 속성의 이름이 포함된 문자열입니다.</param>
        <param name="types">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
또는 
인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</param>
        <summary>지정된 인수 형식과 일치하는 매개 변수를 가진 지정된 public 속성을 검색합니다.</summary>
        <returns>지정된 인수 형식과 일치하는 매개 변수를 가진 공용 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.  
  
 검색 `name` 대/소문자 구분 합니다. 검색 public static 및 public 인스턴스 속성을 포함합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.  
  
## <a name="indexers-and-default-properties"></a>인덱서 및 기본 속성  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]하십시오 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 인덱싱된 속성에 액세스 하기 위한 구문을 단순화 하 고 인덱싱된 속성 하나를 해당 형식에 대 한 기본값이 되도록 허용 합니다. 예를 들어 경우 변수의 `myList` 참조를 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual Basic의) 3의 인덱스를 사용 하 여 요소를 검색 합니다. 속성을 오버 로드할 수 있습니다.  
  
 C#에서는이 기능 인덱서 호출 및 이름으로 참조할 수 없습니다. 기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다. 그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다. 예를 들어 합니다 <xref:System.String> 클래스에는 명명 된 인덱서 <xref:System.String.Chars%2A>합니다. C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성 이름도 항목 이외의 있을 수 있습니다.  
  
 형식에 기본 속성이 있는지 여부를 확인 하려면 사용 합니다 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 테스트 방법은 <xref:System.Reflection.DefaultMemberAttribute> 특성. 형식에 있으면 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성의 기본 속성의 이름을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 검색 된 `Type` 사용자 정의 클래스의 개체 클래스의 속성을 검색 하 고 속성 이름 및 속성의 형식에 전달 된 인수에 지정 된 대로 표시 `GetProperty`합니다.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 인수 형식과 일치하는 속성이 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="types" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />가 다차원 배열인 경우</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" />의 요소가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 공용 속성의 이름이 포함된 문자열입니다.</param>
        <param name="returnType">속성의 반환 형식입니다.</param>
        <param name="types">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
또는 
인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</param>
        <summary>지정된 인수 형식과 일치하는 매개 변수를 가진 지정된 public 속성을 검색합니다.</summary>
        <returns>지정된 인수 형식과 일치하는 매개 변수를 가진 공용 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.  
  
 검색 `name` 대/소문자 구분 합니다. 검색 public static 및 public 인스턴스 속성을 포함합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.  
  
## <a name="indexers-and-default-properties"></a>인덱서 및 기본 속성  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]하십시오 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 인덱싱된 속성에 액세스 하기 위한 구문을 단순화 하 고 인덱싱된 속성 하나를 해당 형식에 대 한 기본값이 되도록 허용 합니다. 예를 들어 경우 변수의 `myList` 참조를 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual Basic의) 3의 인덱스를 사용 하 여 요소를 검색 합니다. 속성을 오버 로드할 수 있습니다.  
  
 C#에서는이 기능 인덱서 호출 및 이름으로 참조할 수 없습니다. 기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다. 그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다. 예를 들어 합니다 <xref:System.String> 클래스에는 명명 된 인덱서 <xref:System.String.Chars%2A>합니다. C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성 이름도 항목 이외의 있을 수 있습니다.  
  
 형식에 기본 속성이 있는지 여부를 확인 하려면 사용 합니다 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 테스트 방법은 <xref:System.Reflection.DefaultMemberAttribute> 특성. 형식에 있으면 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성의 기본 속성의 이름을 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 인수 형식과 일치하는 속성이 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="types" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />가 다차원 배열인 경우</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" />의 요소가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 공용 속성의 이름이 포함된 문자열입니다.</param>
        <param name="returnType">속성의 반환 형식입니다.</param>
        <param name="types">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
또는 
인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <paramref name="types" /> 개체 배열입니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 public 속성을 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 public 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.  
  
 기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 검색 `name` 대/소문자 구분 합니다. 검색 public static 및 public 인스턴스 속성을 포함합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.  
  
## <a name="indexers-and-default-properties"></a>인덱서 및 기본 속성  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]하십시오 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 인덱싱된 속성에 액세스 하기 위한 구문을 단순화 하 고 인덱싱된 속성 하나를 해당 형식에 대 한 기본값이 되도록 허용 합니다. 예를 들어 경우 변수의 `myList` 참조를 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual Basic의) 3의 인덱스를 사용 하 여 요소를 검색 합니다. 속성을 오버 로드할 수 있습니다.  
  
 C#에서는이 기능 인덱서 호출 및 이름으로 참조할 수 없습니다. 기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다. 그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다. 예를 들어 합니다 <xref:System.String> 클래스에는 명명 된 인덱서 <xref:System.String.Chars%2A>합니다. C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성 이름도 항목 이외의 있을 수 있습니다.  
  
 형식에 기본 속성이 있는지 여부를 확인 하려면 사용 합니다 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 테스트 방법은 <xref:System.Reflection.DefaultMemberAttribute> 특성. 형식에 있으면 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성의 기본 속성의 이름을 반환 합니다.  
  
   
  
## Examples  
 다음 예에서는 `Type` 개체에 해당 하 `MyPropertyClass`, 전달 되는 인수를 사용 하 여이 클래스의 인덱싱된 속성을 검색 하는 및를 `GetProperty` 메서드.  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 인수 형식 및 수정자와 일치하는 속성이 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="types" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />가 다차원 배열인 경우  
  
또는 
 <paramref name="modifiers" />가 다차원 배열인 경우  
  
또는 
 <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" />의 요소가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 속성의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
또는 
<see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="returnType">속성의 반환 형식입니다.</param>
        <param name="types">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
또는 
인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <paramref name="types" /> 개체 배열입니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 속성을 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성을 공용 접근자가 적어도 하나 있으면 반사를 공용으로 간주 됩니다. 그렇지 않은 경우 속성은 개인으로 간주 하 고 사용 해야 합니다 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual basic에서 사용 하 여 값을 결합 `Or`) 가져오려고 합니다.  
  
 기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 속성을 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에서 공용 속성을 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 속성 (즉, 전용, 내부 및 보호 된 속성)을 포함 하도록 합니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 속성만 검색할는 <xref:System.Type>, 상속 된 속성이 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 하는 경우 현재 <xref:System.Type> 이 메서드는 반환 생성된 된 제네릭 형식을 나타내는 <xref:System.Reflection.PropertyInfo> 따라 적절 한 형식 인수로 대체 형식 매개 변수를 사용 하 여 합니다.  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수는 제네릭 형식 또는 제네릭 메서드 정의에서이 메서드는 클래스 제약 조건의 속성을 검색 합니다.  
  
## <a name="indexers-and-default-properties"></a>인덱서 및 기본 속성  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]하십시오 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], 및 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 인덱싱된 속성에 액세스 하기 위한 구문을 단순화 하 고 인덱싱된 속성 하나를 해당 형식에 대 한 기본값이 되도록 허용 합니다. 예를 들어 경우 변수의 `myList` 참조를 <xref:System.Collections.ArrayList>, 구문을 `myList[3]` (`myList(3)` Visual Basic의) 3의 인덱스를 사용 하 여 요소를 검색 합니다. 속성을 오버 로드할 수 있습니다.  
  
 C#에서는이 기능 인덱서 호출 및 이름으로 참조할 수 없습니다. 기본적으로 C# 인덱서 메타 데이터에 "Item" 이라는 인덱싱된 속성으로 나타납니다. 그러나 클래스 라이브러리 개발자가 사용할 수는 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 메타 데이터에 인덱서의 이름을 변경할 특성입니다. 예를 들어 합니다 <xref:System.String> 클래스에는 명명 된 인덱서 <xref:System.String.Chars%2A>합니다. C# 이외의 언어를 사용 하 여 만든 인덱싱된 속성 이름도 항목 이외의 있을 수 있습니다.  
  
 형식에 기본 속성이 있는지 여부를 확인 하려면 사용 합니다 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 테스트 방법은 <xref:System.Reflection.DefaultMemberAttribute> 특성. 형식에 있으면 <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 속성의 기본 속성의 이름을 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 속성이 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="types" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />가 다차원 배열인 경우  
  
또는 
 <paramref name="modifiers" />가 다차원 배열인 경우  
  
또는 
 <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" />의 요소가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">가져올 속성의 이름이 포함된 문자열입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
0(<see langword="null" />을 반환하는 경우)</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 멤버를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
또는 
<see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다.</param>
        <param name="returnType">속성의 반환 형식입니다.</param>
        <param name="types">가져올 인덱싱된 속성에 대한 매개 변수의 수, 차수, 형식 등을 나타내는 <see cref="T:System.Type" /> 개체 배열입니다.  
  
또는 
인덱싱되지 않은 속성을 가져오기 위한 <see cref="T:System.Type" /> 형식의 빈 배열입니다(즉, Type[] types = new Type[0]).</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <paramref name="types" /> 개체 배열입니다. 기본 바인더에서는 이 매개 변수를 처리하지 않습니다.</param>
        <summary>파생 클래스에서 재정의되면, 지정된 인수 형식 및 한정자와 일치하는 매개 변수를 가진 지정된 속성을 지정된 바인딩 제약 조건으로 검색합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 속성을 나타내는 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> (합니다 `modifiers` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `modifiers`합니다. `ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 속성을 정의할 수 있습니다.  
  
-   중 하나를 지정 해야 합니다 `BindingFlags.Instance` 또는 `BindingFlags.Static` 반환 합니다.  
  
-   지정 `BindingFlags.Public` 검색에서 공용 속성을 포함 하도록 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에 public이 아닌 속성 (즉, 전용, 내부 및 보호 된 속성)을 포함 하도록 합니다.  
  
-   지정할 `BindingFlags.FlattenHierarchy` 하기로 `public` 및 `protected` 정적 멤버를 계층 구조 `private` 상속 된 클래스의 정적 멤버가 포함 되지 않습니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 속성만 검색할는 <xref:System.Type>, 상속 된 속성이 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">지정한 이름을 가지며 지정된 바인딩 제약 조건과 일치하는 속성이 둘 이상 발견되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="types" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="types" />의 요소 중 하나가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />가 다차원 배열인 경우  
  
또는 
 <paramref name="modifiers" />가 다차원 배열인 경우  
  
또는 
 <paramref name="types" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.</exception>
        <exception cref="T:System.NotSupportedException">현재 형식이 <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> 또는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />입니다.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 형식을 나타내는 <see cref="T:System.Type" /> 개체를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Type" />를 가져옵니다.</summary>
        <returns>현재 <see cref="T:System.Type" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">정규화된 형식 이름 지정</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">가져올 형식에 대한 어셈블리로 한정된 이름입니다. <see cref="P:System.Type.AssemblyQualifiedName" />을 참조하세요. 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우 네임스페이스로 한정된 형식 이름만 제공하면 됩니다.</param>
        <summary>대/소문자 구분 검색하여 지정된 이름의 <see cref="T:System.Type" />을 가져옵니다.</summary>
        <returns>지정된 이름의 형식이 있으면 이를 반환하고 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Type.GetType%2A> 메서드를 <xref:System.Type> 에서 가져올 수 있는 해당 어셈블리의 정규화 된 이름을 알고 있으면 다른 어셈블리의 형식에 대 한 개체 <xref:System.Type.AssemblyQualifiedName>합니다. <xref:System.Type.GetType%2A> 에 지정 된 어셈블리를 로드 하면 `typeName`합니다. 사용 하 여 어셈블리를 로드할 수도 있습니다는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 합니다 <xref:System.Type.GetType%2A> 또는 <xref:System.Reflection.Assembly.GetTypes%2A> 의 메서드를 <xref:System.Reflection.Assembly> 클래스를 <xref:System.Type> 개체입니다. 형식을 프로그램에 컴파일 타임에 알려진 어셈블리의 경우 것이 보다 효율적으로 C#에서 사용할 <xref:System.Type.GetType%2A> c + + 또는 Visual basic의 경우.  
  
> [!NOTE]
>  하는 경우 `typeName` 찾을 수 없는 호출 합니다 <xref:System.Type.GetType%28System.String%29> 메서드가 반환 되는 `null`합니다. 예외를 throw 하지 않습니다. 제어할 수 있는지 여부는 예외가 발생의 오버 로드를 호출 합니다 <xref:System.Type.GetType%2A> 있는 메서드를 `throwOnError` 매개 변수입니다.  
  
 <xref:System.Type.GetType%2A> 디스크에서 로드 된 어셈블리 에서만 작동 합니다. 호출 하는 경우 <xref:System.Type.GetType%2A> 정의 사용 하 여 동적 어셈블리에 정의 된 형식을 조회 하는 <xref:System.Reflection.Emit> 서비스에 일관 되지 않은 동작이 발생할 수 있습니다. 동작을 동적 어셈블리 인지 영구적 이므로, 즉, 사용 하 여 만든 합니다 `RunAndSave` 또는 `Save` 모드 액세스는 <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 열거형입니다. 동적 어셈블리를 지속적이 고 먼저 디스크에 쓴 경우 `GetType` 는 호출 로더 디스크에 저장 된 어셈블리를 찾아서, 해당 어셈블리를 로드 하 고 해당 어셈블리에서 형식을 검색 합니다. 어셈블리 경우 디스크에 저장 되지 않은 경우 `GetType` 가 호출 메서드는 반환 `null`합니다. `GetType` 임시 동적 어셈블리를 인식 하지 못합니다 따라서 호출 `GetType` 일시적인에서 형식을 검색 하려면 동적 어셈블리는 다음과 같이 반환 됩니다. `null`합니다.  
  
 사용 하도록 `GetType` 구독할 동적 모듈의 경우에 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 이벤트 및 호출 `GetType` 저장 하기 전에 합니다. 이 고, 그렇지 메모리에 어셈블리의 두 복사본을 가져오게 됩니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 배열 또는 COM 형식을 검색할 수 없습니다는 이미 사용할 수 있는 클래스의 테이블에 로드 되지 않은 합니다.  
  
 `typeName` 수 형식 이름으로 한정 되어야 해당 네임 스페이스 또는 어셈블리 이름 사양에 포함 된 어셈블리의 정규화 된 이름. <xref:System.Type.AssemblyQualifiedName%2A>을 참조하세요.  
  
 경우 `typeName` 네임 스페이스만 어셈블리 이름이 아니라 포함이 메서드를 호출 하는 개체의 어셈블리 및 Mscorlib.dll만 순서 대로 검색 합니다. TypeName 부분 또는 전체 어셈블리 이름의 정규화 된 경우이 메서드는 지정된 된 어셈블리에서 검색 합니다. 어셈블리에 강력한 이름이 있으면 전체 어셈블리 이름은 필수입니다.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> 속성에는 중첩 된 형식, 어셈블리 이름 및 제네릭 형식 인수를 포함 하 여 정규화 된 형식 이름을 반환 합니다. 공용 언어 런타임에서 지 원하는 모든 컴파일러 중첩된 된 클래스의 단순한 이름 내보내고 리플렉션에서 다음 규칙에 따라 쿼리를 수행 하면 잘못 된 이름을 생성 합니다.  
  
> [!NOTE]
>  .NET framework 버전 2.0에서 프로세서 아키텍처가 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다. 예를 들어, "ProcessorArchitecture = msil"입니다. 그러나 반환 하는 문자열에서 제외 됩니다는 <xref:System.Type.AssemblyQualifiedName%2A> 호환성을 위해 속성입니다. 형식을 만들어 로드할 수도 있습니다는 <xref:System.Reflection.AssemblyName> 개체의 적절 한 오버 로드에 전달 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드. 사용할 수는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 어셈블리에서 형식을 로드 하는 방법입니다. <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하세요.  
  
|구분 기호|의미|  
|---------------|-------------|  
|백슬래시(\\)|이스케이프 문자입니다.|  
|억음 악센트 기호 (')|형식 매개 변수를 제네릭 형식 이름의 끝에 있는 수를 나타내는 하나 이상의 10 진수 앞에 옵니다.|  
|대괄호 ()|생성된 된 제네릭 형식;에 대 한 제네릭 형식 인수 목록을 묶습니다. 형식 인수 목록을 내는 어셈블리의 정규화 된 유형을 묶습니다.|  
|쉼표 ()|어셈블리 이름을 앞에 옵니다.|  
|마침표 (입니다.)|네임 스페이스 식별자를 나타냅니다.|  
|더하기 기호 (+)|중첩된 된 클래스 앞에 옵니다.|  
  
 예를 들어, 클래스에 대 한 정규화 된 이름을이 같습니다.  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 네임 스페이스 TopNamespace.Sub+Namespace, 된 경우 문자열 앞에 더하기 기호 (+) 이스케이프 문자를 사용 해야 합니다. (\\) 중첩 구분 기호로 해석 되지 않도록 합니다. 리플렉션 다음과 같이이 문자열을 내보냅니다.  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +"가 "\\+\\+", 및 "\\"은 "\\\\"입니다.  
  
 이 정규화 된 이름은 유지 되었다가 나중에 로드 하는 데는 <xref:System.Type>합니다. 찾아 로드 하는 <xref:System.Type>를 사용 하 여 <xref:System.Type.GetType%2A> 만 또는 어셈블리 정규화 된 형식 이름의 이름 형식을 사용 하 여 합니다. <xref:System.Type.GetType%2A> 형식을 사용 하 여 이름을 찾을 것을 <xref:System.Type> 호출자의 어셈블리에서 찾은 다음 시스템 어셈블리에서. <xref:System.Type.GetType%2A> 어셈블리를 사용 하 여 정규화 된 형식 이름에 대 한 표시 됩니다는 <xref:System.Type> 모든 어셈블리에 있습니다.  
  
 형식 이름 형식이 참조 형식, 포인터 형식 또는 배열 형식 인지와 같은 형식에 대 한 추가 정보를 나타내는 후행 문자를 포함할 수 있습니다. 형식 이름 없이 이러한 후행 문자를 검색 하려면 사용 `t.GetElementType().ToString()`여기서 `t` 형식입니다.  
  
 공간은 어셈블리 이름 제외한 모든 형식 이름 구성 요소에 적용 됩니다. 어셈블리 이름에 ',' 구분 기호 앞의 공백은 관련이 있지만 ',' 구분 기호 뒤의 공백은 무시 됩니다.  
  
 제네릭 형식의 이름을 억음 악센트 기호 끝납니다 (\`), 제네릭 형식 인수 개수를 나타내는 숫자입니다. 이 이름 꾸미기의 목적은 컴파일러에서 제네릭 형식을 지원 형식 매개 변수 수가 다른 하지만 같은 이름의 동일한 범위에서 발생 수 있도록 합니다. 리플렉션 바뀐된 이름을 반환 하는 예를 들어 `Tuple`1` and `튜플`2` 제네릭 메서드에서 `Tuple(Of T)` 하 고 `Tuple(Of T0, T1)` Visual basic의 경우 또는 `Tuple<T>` 및 튜플`\<T0, T1>` Visual C#.  
  
 제네릭 형식의 형식 인수 목록을 괄호로 묶고 형식 인수는 쉼표로 구분 합니다. 예를 들어 제네릭 <xref:System.Collections.Generic.Dictionary%602> 두 형식 매개 변수가 있습니다. A <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 형식의 키를 사용 하 여 <xref:System.String> 다음과 같이 표시 될 수 있습니다.  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 형식 인수 목록에는 어셈블리의 정규화 된 형식을 지정 하려면 어셈블리의 정규화 된 형식을 대괄호로 묶습니다. 이 고, 그렇지 어셈블리의 정규화 된 이름의 각 부분을 구분 하는 쉼표는 추가 형식 인수를 구분 기호로 해석 됩니다. 예를 들어를 <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 형식의 키를 사용 하 여 fromMyAssembly.dll <xref:System.String>를 다음과 같이 지정할 수 있습니다.  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  형식 매개 변수 목록에 표시 되는 경우에 어셈블리의 정규화 된 형식에는 대괄호로 묶을 수 있습니다. 형식 매개 변수 목록에서 어셈블리 정규화 형식에 대 한 검색에 대 한 규칙을 정규화 제네릭이 아닌 형식에 대 한 규칙과 동일 합니다.  
  
 Nullable 형식은 제네릭 형식의 특수 한 경우입니다. 예를 들어, null 허용 <xref:System.Int32> "System.Nullable'1[System.Int32]" 문자열에 의해 표시 됩니다.  
  
> [!NOTE]
>  C#, c + + 및 Visual Basic 형식 연산자를 사용 하 여 nullable 형식을 가져올 수도 있습니다. 예를 들어, null 허용 <xref:System.Boolean> 형식을 반환한 `typeof(Nullable<bool>)` C#으로 하 여 `Nullable<Boolean>::typeid` c + +에서 `GetType(Nullable(Of Boolean))` Visual Basic의 합니다.  
  
 다음 표에서 사용 하 여 사용 하는 구문을 `GetType` 다양 한 형식에 대 한 합니다.  
  
|가져오려는|사용|  
|------------|---------|  
|Null 허용 <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|에 대 한 관리 되지 않는 포인터입니다. `MyType`|`Type.GetType("MyType*")`|  
|에 대 한 포인터에 대 한 관리 되지 않는 포인터입니다. `MyType`|`Type.GetType("MyType**")`|  
|관리 되는 포인터 또는 참조 `MyType`|`Type.GetType("MyType&")`. 포인터와 달리 참조는 한 수준으로 제한됩니다.|  
|부모 클래스 및 중첩된 클래스|`Type.GetType("MyParentClass+MyNestedClass")`|  
|하한값으로 0 사용 하 여 1 차원 배열|`Type.GetType("MyType[]")`|  
|알 수 없는 하한값을 사용 하 여 1 차원 배열|`Type.GetType("MyType[*]")`|  
|N 차원 배열|총 n-1 번 대괄호 안에 쉼표 (,)입니다. 예를 들어 `System.Object[,,]` 나타내는 3 차원 `Object` 배열입니다.|  
|1 차원 배열의 배열|`Type.GetType("MyType[][]")`|  
|알 수 없는 하위 범위를 사용 하 여 사각형 2 차원 배열|`Type.GetType("MyType[,]")`|  
|하나의 형식 인수가 있는 제네릭 형식|``Type.GetType("MyGenericType`1[MyType]")``|  
|두 개의 형식 인수를 사용 하 여 제네릭 형식|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|두 어셈블리의 정규화 된 형식 인수가 있는 제네릭 형식|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|어셈블리의 정규화 된 형식 인수를 사용 하 여 어셈블리의 정규화 된 제네릭 형식|' Type.GetType ("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|두 형식 인수가 있는 제네릭 형식인 형식 인수로 제네릭 형식|' Type.GetType ("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")'|  
  
   
  
## Examples  
 다음 예제에서는 검색 유형을 `System.Int32` 형식 개체를 사용 하 여 표시 하 고는 <xref:System.Type.FullName%2A> 의 속성 `System.Int32`.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.  
  
</para>
          </block>  
  
 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 어셈블리는 이후 버전으로 컴파일되었습니다.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">정규화된 형식 이름 지정</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">가져올 형식에 대한 어셈블리로 한정된 이름입니다. <see cref="P:System.Type.AssemblyQualifiedName" />을 참조하세요. 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우 네임스페이스로 한정된 형식 이름만 제공하면 됩니다.</param>
        <param name="throwOnError">형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다. 또한 <see langword="false" />를 지정하면 다른 예외 조건 중 일부(모두 아님)가 표시되지 않습니다. 예외 섹션을 참조하세요.</param>
        <summary>대/소문자를 구분하여 검색하고 형식이 없으면 예외를 throw할지를 지정하여, 지정된 이름의 <see cref="T:System.Type" />을 가져옵니다.</summary>
        <returns>지정된 이름의 형식입니다. 형식을 찾을 수 없는 경우에는 <paramref name="throwOnError" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다. 경우에 따라서는 <paramref name="throwOnError" /> 값과 상관없이 예외가 throw됩니다. 예외 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Type.GetType%2A> 메서드를 <xref:System.Type> 에서 가져올 수 있는 해당 어셈블리의 정규화 된 이름을 알고 있으면 다른 어셈블리의 형식에 대 한 개체 <xref:System.Type.AssemblyQualifiedName>합니다. <xref:System.Type.GetType%2A> 에 지정 된 어셈블리를 로드 하면 `typeName`합니다. 사용 하 여 어셈블리를 로드할 수도 있습니다는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 합니다 <xref:System.Type.GetType%2A> 또는 <xref:System.Reflection.Assembly.GetTypes%2A> 의 메서드를 <xref:System.Reflection.Assembly> 클래스를 <xref:System.Type> 개체입니다. 형식을 프로그램에 컴파일 타임에 알려진 어셈블리의 경우 것이 보다 효율적으로 사용할 `typeof` C# <xref:System.Type.GetType%2A> Visual basic의 경우 또는 `typeid` c + +에서입니다.  
  
 `GetType` 디스크에서 로드 된 어셈블리 에서만 작동 합니다. 호출 하는 경우 `GetType` 정의 사용 하 여 동적 어셈블리에 정의 된 형식을 조회 하는 <xref:System.Reflection.Emit> 서비스에 일관 되지 않은 동작이 발생할 수 있습니다. 동작을 동적 어셈블리 인지 영구적 이므로, 즉, 사용 하 여 만든 합니다 `RunAndSave` 또는 `Save` 모드 액세스는 <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 열거형입니다. 동적 어셈블리를 지속적이 고 먼저 디스크에 쓴 경우 `GetType` 는 호출 로더 디스크에 저장 된 어셈블리를 찾아서, 해당 어셈블리를 로드 하 고 해당 어셈블리에서 형식을 검색 합니다. 어셈블리 경우 디스크에 저장 되지 않은 경우 `GetType` 가 호출 메서드는 반환 `null`합니다. `GetType` 임시 동적 어셈블리를 인식 하지 못합니다 따라서 호출 `GetType` 일시적인에서 형식을 검색 하려면 동적 어셈블리는 다음과 같이 반환 됩니다. `null`합니다.  
  
 사용 하도록 `GetType` 구독할 동적 모듈의 경우에 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 이벤트 및 호출 `GetType` 저장 하기 전에 합니다. 이 고, 그렇지 메모리에 어셈블리의 두 복사본을 가져오게 됩니다.  
  
 `throwOnError` 되나요 유형을 찾을 수 없습니다 하 고 특정 한 다른 예외 조건을 표시 하지 예외 섹션에 설명 된 대로 매개 변수를 지정 합니다. 값에 관계 없이 일부 예외가 throw 됩니다 `throwOnError`합니다. 예를 들어 형식을 찾았지만 로드할 수 없습니다는 <xref:System.TypeLoadException> 이 throw 경우에 `throwOnError` 는 `false`합니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 배열 또는 COM 형식을 검색할 수 없습니다는 이미 사용할 수 있는 클래스의 테이블에 로드 되지 않은 합니다.  
  
 `typeName` 수 형식 이름으로 한정 되어야 해당 네임 스페이스 또는 어셈블리 이름 사양에 포함 된 어셈블리의 정규화 된 이름. <xref:System.Type.AssemblyQualifiedName%2A>을 참조하세요.  
  
 경우 `typeName` 네임 스페이스만 어셈블리 이름이 아니라 포함이 메서드를 호출 하는 개체의 어셈블리 및 Mscorlib.dll만 순서 대로 검색 합니다. TypeName 부분 또는 전체 어셈블리 이름의 정규화 된 경우이 메서드는 지정된 된 어셈블리에서 검색 합니다. 어셈블리에 강력한 이름이 있으면 전체 어셈블리 이름은 필수입니다.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> 속성에는 중첩 된 형식, 어셈블리 이름 및 제네릭 인수를 포함 하 여 정규화 된 형식 이름을 반환 합니다. 공용 언어 런타임에서 지 원하는 모든 컴파일러 중첩된 된 클래스의 단순한 이름 내보내고 리플렉션에서 다음 규칙에 따라 쿼리를 수행 하면 잘못 된 이름을 생성 합니다.  
  
> [!NOTE]
>  .NET framework 버전 2.0에서 프로세서 아키텍처가 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다. 예를 들어, "ProcessorArchitecture = msil"입니다. 그러나 반환 하는 문자열에서 제외 됩니다는 <xref:System.Type.AssemblyQualifiedName%2A> 호환성을 위해 속성입니다. 형식을 만들어 로드할 수도 있습니다는 <xref:System.Reflection.AssemblyName> 개체의 적절 한 오버 로드에 전달 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드. 사용할 수는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 어셈블리에서 형식을 로드 하는 방법입니다. <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하세요.  
  
|구분 기호|의미|  
|---------------|-------------|  
|백슬래시(\\)|이스케이프 문자입니다.|  
|억음 악센트 기호 (')|형식 매개 변수를 제네릭 형식 이름의 끝에 있는 수를 나타내는 하나 이상의 10 진수 앞에 옵니다.|  
|대괄호 ()|생성된 된 제네릭 형식;에 대 한 제네릭 형식 인수 목록을 묶습니다. 형식 인수 목록을 내는 어셈블리의 정규화 된 유형을 묶습니다.|  
|쉼표 ()|어셈블리 이름을 앞에 옵니다.|  
|마침표 (입니다.)|네임 스페이스 식별자를 나타냅니다.|  
|더하기 기호 (+)|중첩된 된 클래스 앞에 옵니다.|  
  
 예를 들어, 클래스에 대 한 정규화 된 이름을이 같습니다.  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 네임 스페이스 TopNamespace.Sub+Namespace, 된 경우 문자열 앞에 더하기 기호 (+) 이스케이프 문자를 사용 해야 합니다. (\\) 중첩 구분 기호로 해석 되지 않도록 합니다. 리플렉션 다음과 같이이 문자열을 내보냅니다.  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +"가 "\\+\\+", 및 "\\"은 "\\\\"입니다.  
  
 이 정규화 된 이름은 유지 되었다가 나중에 로드 하는 데는 <xref:System.Type>합니다. 찾아 로드 하는 <xref:System.Type>를 사용 하 여 <xref:System.Type.GetType%2A> 만 또는 어셈블리 정규화 된 형식 이름의 이름 형식을 사용 하 여 합니다. <xref:System.Type.GetType%2A> 형식을 사용 하 여 이름을 찾을 것을 <xref:System.Type> 호출자의 어셈블리에서 찾은 다음 시스템 어셈블리에서. <xref:System.Type.GetType%2A> 어셈블리를 사용 하 여 정규화 된 형식 이름에 대 한 표시 됩니다는 <xref:System.Type> 모든 어셈블리에 있습니다.  
  
 형식 이름 형식이 참조 형식, 포인터 형식 또는 배열 형식 인지와 같은 형식에 대 한 추가 정보를 나타내는 후행 문자를 포함할 수 있습니다. 형식 이름 없이 이러한 후행 문자를 검색 하려면 사용 `t.GetElementType().ToString()`여기서 `t` 형식입니다.  
  
 공간은 어셈블리 이름 제외한 모든 형식 이름 구성 요소에 적용 됩니다. 어셈블리 이름에 ',' 구분 기호 앞의 공백은 관련이 있지만 ',' 구분 기호 뒤의 공백은 무시 됩니다.  
  
 제네릭 형식의 이름을 억음 악센트 기호 끝납니다 (\`), 제네릭 형식 인수 개수를 나타내는 숫자입니다. 이 이름 꾸미기의 목적은 컴파일러에서 제네릭 형식을 지원 형식 매개 변수 수가 다른 하지만 같은 이름의 동일한 범위에서 발생 수 있도록 합니다. 리플렉션 바뀐된 이름을 반환 하는 예를 들어 `Tuple`1` and `튜플`2` 제네릭 메서드에서 `Tuple(Of T)` 하 고 `Tuple(Of T0, T1)` Visual basic의 경우 또는 `Tuple<T>` 및 튜플`\<T0, T1>` Visual C#.  
  
 제네릭 형식의 형식 인수 목록을 괄호로 묶고 형식 인수는 쉼표로 구분 합니다. 예를 들어 제네릭 <xref:System.Collections.Generic.Dictionary%602> 두 형식 매개 변수가 있습니다. A <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 형식의 키를 사용 하 여 <xref:System.String> 다음과 같이 표시 될 수 있습니다.  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 형식 인수 목록에는 어셈블리의 정규화 된 형식을 지정 하려면 어셈블리의 정규화 된 형식을 대괄호로 묶습니다. 이 고, 그렇지 어셈블리의 정규화 된 이름의 각 부분을 구분 하는 쉼표는 추가 형식 인수를 구분 기호로 해석 됩니다. 예를 들어를 <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 형식의 키를 사용 하 여 MyAssembly.dll에서 <xref:System.String>, 다음과 같이 지정할 수 있습니다.  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  형식 매개 변수 목록에 표시 되는 경우에 어셈블리의 정규화 된 형식에는 대괄호로 묶을 수 있습니다. 형식 매개 변수 목록에서 어셈블리 정규화 형식에 대 한 검색에 대 한 규칙을 정규화 제네릭이 아닌 형식에 대 한 규칙과 동일 합니다.  
  
 Nullable 형식은 제네릭 형식의 특수 한 경우입니다. 예를 들어, null 허용 <xref:System.Int32> "System.Nullable'1[System.Int32]" 문자열에 의해 표시 됩니다.  
  
> [!NOTE]
>  C#, c + + 및 Visual Basic 형식 연산자를 사용 하 여 nullable 형식을 가져올 수도 있습니다. 예를 들어, null 허용 <xref:System.Boolean> 형식을 반환한 `typeof(Nullable<bool>)` C#으로 하 여 `Nullable<Boolean>::typeid` c + +에서 `GetType(Nullable(Of Boolean))` Visual Basic의 합니다.  
  
 다음 표에서 사용 하 여 사용 하는 구문을 `GetType` 다양 한 형식에 대 한 합니다.  
  
|가져오려는|사용|  
|------------|---------|  
|Null 허용 <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|에 대 한 관리 되지 않는 포인터입니다. `MyType`|`Type.GetType("MyType*")`|  
|에 대 한 포인터에 대 한 관리 되지 않는 포인터입니다. `MyType`|`Type.GetType("MyType**")`|  
|관리 되는 포인터 또는 참조 `MyType`|`Type.GetType("MyType&")`. 포인터와 달리 참조는 한 수준으로 제한됩니다.|  
|부모 클래스 및 중첩된 클래스|`Type.GetType("MyParentClass+MyNestedClass")`|  
|하한값으로 0 사용 하 여 1 차원 배열|`Type.GetType("MyArray[]")`|  
|알 수 없는 하한값을 사용 하 여 1 차원 배열|`Type.GetType("MyArray[*]")`|  
|N 차원 배열|총 n-1 번 대괄호 안에 쉼표 (,)입니다. 예를 들어 `System.Object[,,]` 나타내는 3 차원 `Object` 배열입니다.|  
|2 차원 배열의 배열|`Type.GetType("MyArray[][]")`|  
|알 수 없는 하위 범위를 사용 하 여 사각형 2 차원 배열|`Type.GetType("MyArray[,]")`|  
|하나의 형식 인수가 있는 제네릭 형식|``Type.GetType("MyGenericType`1[MyType]")``|  
|두 개의 형식 인수를 사용 하 여 제네릭 형식|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|두 어셈블리의 정규화 된 형식 인수가 있는 제네릭 형식|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|어셈블리의 정규화 된 형식 인수를 사용 하 여 어셈블리의 정규화 된 제네릭 형식|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|두 형식 인수가 있는 제네릭 형식인 형식 인수로 제네릭 형식|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 다음 예제에서는 검색 유형을 `System.Int32` 형식 개체를 사용 하 여 표시 하 고는 <xref:System.Type.FullName%2A> 의 속성 `System.Int32`. 이 예제에서는 형식 개체를 존재 하지 않는 어셈블리를 가리키는 경우 예외가 발생 합니다.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.  
  
또는 
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다. 
또는 
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.  
  
또는 
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 구문을 포함합니다. 예를 들어 "MyType[,*,]"입니다.  
  
또는 
 <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.  
  
</para>
          </block>  
  
 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 어셈블리는 이후 버전으로 컴파일되었습니다.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">정규화된 형식 이름 지정</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">가져올 형식에 대한 어셈블리로 한정된 이름입니다. <see cref="P:System.Type.AssemblyQualifiedName" />을 참조하세요. 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우 네임스페이스로 한정된 형식 이름만 제공하면 됩니다.</param>
        <param name="throwOnError">형식을 찾을 수 없어 예외를 throw하는 경우 <see langword="true" />이고 <see langword="false" />를 반환하는 경우 <see langword="null" />입니다. <see langword="false" />를 지정하면 일부 다른 예외 조건을 표시하지 않지만 모두 그렇지는 않습니다. 예외 섹션을 참조하세요.</param>
        <param name="ignoreCase"><see langword="true" />에 대해 대/소문자를 구분하지 않는 검색을 수행하려는 경우 <paramref name="typeName" />이고, <see langword="false" />에 대해 대/소문자를 구분하는 검색을 수행하려는 경우 <paramref name="typeName" />입니다.</param>
        <summary>대/소문자를 구분하여 검색할지 여부와 형식이 없으면 예외를 throw할지 여부를 지정하여, 지정된 이름의 <see cref="T:System.Type" />을 가져옵니다.</summary>
        <returns>지정된 이름의 형식입니다. 형식을 찾을 수 없는 경우에는 <paramref name="throwOnError" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다. 경우에 따라서는 <paramref name="throwOnError" /> 값과 상관없이 예외가 throw됩니다. 예외 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Type.GetType%2A> 메서드를 <xref:System.Type> 에서 가져올 수 있는 해당 어셈블리의 정규화 된 이름을 알고 있으면 다른 어셈블리의 형식에 대 한 개체 <xref:System.Type.AssemblyQualifiedName>합니다. <xref:System.Type.GetType%2A> 에 지정 된 어셈블리를 로드 하면 `typeName`합니다. 사용 하 여 어셈블리를 로드할 수도 있습니다는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 합니다 <xref:System.Type.GetType%2A> 또는 <xref:System.Reflection.Assembly.GetTypes%2A> 의 메서드를 <xref:System.Reflection.Assembly> 클래스를 <xref:System.Type> 개체입니다. 형식을 프로그램에 컴파일 타임에 알려진 어셈블리의 경우 것이 보다 효율적으로 사용할 `typeof` C# <xref:System.Type.GetType%2A> Visual basic의 경우 또는 `typeid` c + +에서입니다.  
  
 `GetType` 디스크에서 로드 된 어셈블리 에서만 작동 합니다. 호출 하는 경우 `GetType` 정의 사용 하 여 동적 어셈블리에 정의 된 형식을 조회 하는 <xref:System.Reflection.Emit> 서비스에 일관 되지 않은 동작이 발생할 수 있습니다. 동작을 동적 어셈블리 인지 영구적 이므로, 즉, 사용 하 여 만든 합니다 `RunAndSave` 또는 `Save` 모드 액세스는 <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 열거형입니다. 동적 어셈블리를 지속적이 고 먼저 디스크에 쓴 경우 `GetType` 는 호출 로더 디스크에 저장 된 어셈블리를 찾아서, 해당 어셈블리를 로드 하 고 해당 어셈블리에서 형식을 검색 합니다. 어셈블리 경우 디스크에 저장 되지 않은 경우 `GetType` 가 호출 메서드는 반환 `null`합니다. `GetType` 임시 동적 어셈블리를 인식 하지 못합니다 따라서 호출 `GetType` 일시적인에서 형식을 검색 하려면 동적 어셈블리는 다음과 같이 반환 됩니다. `null`합니다.  
  
 사용 하도록 `GetType` 구독할 동적 모듈의 경우에 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 이벤트 및 호출 `GetType` 저장 하기 전에 합니다. 이 고, 그렇지 메모리에 어셈블리의 두 복사본을 가져오게 됩니다.  
  
 `throwOnError` 되나요 유형을 찾을 수 없습니다 하 고 특정 한 다른 예외 조건을 표시 하지 예외 섹션에 설명 된 대로 매개 변수를 지정 합니다. 값에 관계 없이 일부 예외가 throw 됩니다 `throwOnError`합니다. 예를 들어 형식을 찾았지만 로드할 수 없습니다는 <xref:System.TypeLoadException> 이 throw 경우에 `throwOnError` 는 `false`합니다.  
  
 다음 표에서 메서드에서 반환 되는 기본 클래스의 멤버는 `Get` 메서드 형식에 반영 하는 경우.  
  
|멤버 형식|정적|Static이 아니고|  
|-----------------|------------|-----------------|  
|생성자|아니요|아니요|  
|필드|아니요|예. 필드는 항상 이름 및 서명에서 숨겨집니다.|  
|이벤트|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
|메서드|아니요|예. (가상 및 비가상) 메서드 이름에서 숨김 또는 이름 및 서명으로 숨기기 수 있습니다.|  
|중첩된 형식|아니요|아니요|  
|속성|적용할 수 없음|공용 형식 시스템 규칙의 상속 속성을 구현 하는 메서드의 것과 동일 된다는 것입니다. 리플렉션 속성 이름 및 서명으로 숨기기 취급 됩니다. 참고 2 아래를 참조 하세요.|  
  
1.  이름 및 서명으로 숨기기 모든 사용자 지정 한정자를 포함 하 여 서명의 부분 반환 형식, 매개 변수 형식, 센티널, 및 관리 되지 않는 호출 규칙을 고려 합니다. 이것은 이진 비교 합니다.  
  
2.  리플렉션, 속성 및 이벤트는 이름 및 서명에서 숨겨집니다. 기본 클래스에서 get 및 set 접근자 모두를 사용 하 여 속성을 갖지만 파생된 클래스에 get 접근자만 하는 경우 파생된 클래스 속성을 기본 클래스 속성 숨기고 기본 클래스의 setter를 액세스할 수 없습니다.  
  
3.  사용자 지정 특성의 일부분이 아닌 공용 형식 시스템입니다.  
  
 배열 또는 COM 형식을 검색할 수 없습니다는 이미 사용할 수 있는 클래스의 테이블에 로드 되지 않은 합니다.  
  
 `typeName` 수 형식 이름으로 한정 되어야 해당 네임 스페이스 또는 어셈블리 이름 사양에 포함 된 어셈블리의 정규화 된 이름. <xref:System.Type.AssemblyQualifiedName%2A>을 참조하세요.  
  
 경우 `typeName` 네임 스페이스만 어셈블리 이름이 아니라 포함이 메서드를 호출 하는 개체의 어셈블리 및 Mscorlib.dll만 순서 대로 검색 합니다. TypeName 부분 또는 전체 어셈블리 이름의 정규화 된 경우이 메서드는 지정된 된 어셈블리에서 검색 합니다. 어셈블리에 강력한 이름이 있으면 전체 어셈블리 이름은 필수입니다.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> 속성에는 중첩 된 형식, 어셈블리 이름 및 형식 인수를 포함 하 여 정규화 된 형식 이름을 반환 합니다. 공용 언어 런타임에서 지 원하는 모든 컴파일러 중첩된 된 클래스의 단순한 이름 내보내고 리플렉션에서 다음 규칙에 따라 쿼리를 수행 하면 잘못 된 이름을 생성 합니다.  
  
> [!NOTE]
>  .NET framework 버전 2.0에서 프로세서 아키텍처가 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다. 예를 들어, "ProcessorArchitecture = msil"입니다. 그러나 반환 하는 문자열에서 제외 됩니다는 <xref:System.Type.AssemblyQualifiedName%2A> 호환성을 위해 속성입니다. 형식을 만들어 로드할 수도 있습니다는 <xref:System.Reflection.AssemblyName> 개체의 적절 한 오버 로드에 전달 하는 <xref:System.Reflection.Assembly.Load%2A> 메서드. 사용할 수는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 어셈블리에서 형식을 로드 하는 방법입니다. <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하세요.  
  
|구분 기호|의미|  
|---------------|-------------|  
|백슬래시(\\)|이스케이프 문자입니다.|  
|억음 악센트 기호 (')|형식 매개 변수를 제네릭 형식 이름의 끝에 있는 수를 나타내는 하나 이상의 10 진수 앞에 옵니다.|  
|대괄호 ()|생성된 된 제네릭 형식;에 대 한 제네릭 형식 인수 목록을 묶습니다. 형식 인수 목록을 내는 어셈블리의 정규화 된 유형을 묶습니다.|  
|쉼표 ()|어셈블리 이름을 앞에 옵니다.|  
|마침표 (입니다.)|네임 스페이스 식별자를 나타냅니다.|  
|더하기 기호 (+)|중첩된 된 클래스 앞에 옵니다.|  
  
 예를 들어, 클래스에 대 한 정규화 된 이름을이 같습니다.  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 네임 스페이스 TopNamespace.Sub+Namespace, 된 경우 문자열 앞에 더하기 기호 (+) 이스케이프 문자를 사용 해야 합니다. (\\) 중첩 구분 기호로 해석 되지 않도록 합니다. 리플렉션 다음과 같이이 문자열을 내보냅니다.  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +"가 "\\+\\+", 및 "\\"은 "\\\\"입니다.  
  
 이 정규화 된 이름은 유지 되었다가 나중에 로드 하는 데는 <xref:System.Type>합니다. 찾아 로드 하는 <xref:System.Type>를 사용 하 여 <xref:System.Type.GetType%2A> 만 또는 어셈블리 정규화 된 형식 이름의 이름 형식을 사용 하 여 합니다. <xref:System.Type.GetType%2A> 형식을 사용 하 여 이름을 찾을 것을 <xref:System.Type> 호출자의 어셈블리에서 찾은 다음 시스템 어셈블리에서. <xref:System.Type.GetType%2A> 어셈블리를 사용 하 여 정규화 된 형식 이름에 대 한 표시 됩니다는 <xref:System.Type> 모든 어셈블리에 있습니다.  
  
 형식 이름 형식이 참조 형식, 포인터 형식 또는 배열 형식 인지와 같은 형식에 대 한 추가 정보를 나타내는 후행 문자를 포함할 수 있습니다. 형식 이름 없이 이러한 후행 문자를 검색 하려면 사용 `t.GetElementType().ToString()`여기서 `t` 형식입니다.  
  
 공간은 어셈블리 이름 제외한 모든 형식 이름 구성 요소에 적용 됩니다. 어셈블리 이름에 ',' 구분 기호 앞의 공백은 관련이 있지만 ',' 구분 기호 뒤의 공백은 무시 됩니다.  
  
 제네릭 형식의 이름을 억음 악센트 기호 끝납니다 (\`), 제네릭 형식 인수 개수를 나타내는 숫자입니다. 이 이름 꾸미기의 목적은 컴파일러에서 제네릭 형식을 지원 형식 매개 변수 수가 다른 하지만 같은 이름의 동일한 범위에서 발생 수 있도록 합니다. 리플렉션 바뀐된 이름을 반환 하는 예를 들어 `Tuple`1` and `튜플`2` 제네릭 메서드에서 `Tuple(Of T)` 하 고 `Tuple(Of T0, T1)` Visual basic의 경우 또는 `Tuple<T>` 및 튜플`\<T0, T1>` Visual C#.  
  
 제네릭 형식의 형식 인수 목록을 괄호로 묶고 형식 인수는 쉼표로 구분 합니다. 예를 들어 제네릭 <xref:System.Collections.Generic.Dictionary%602> 두 형식 매개 변수가 있습니다. A <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 형식의 키를 사용 하 여 <xref:System.String> 다음과 같이 표시 될 수 있습니다.  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 형식 인수 목록에는 어셈블리의 정규화 된 형식을 지정 하려면 어셈블리의 정규화 된 형식을 대괄호로 묶습니다. 이 고, 그렇지 어셈블리의 정규화 된 이름의 각 부분을 구분 하는 쉼표는 추가 형식 인수를 구분 기호로 해석 됩니다. 예를 들어를 <xref:System.Collections.Generic.Dictionary%602> 의 `MyType` 형식의 키를 사용 하 여 MyAssembly.dll에서 <xref:System.String>, 다음과 같이 지정할 수 있습니다.  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  형식 매개 변수 목록에 표시 되는 경우에 어셈블리의 정규화 된 형식에는 대괄호로 묶을 수 있습니다. 형식 매개 변수 목록에서 어셈블리 정규화 형식에 대 한 검색에 대 한 규칙을 정규화 제네릭이 아닌 형식에 대 한 규칙과 동일 합니다.  
  
 Nullable 형식은 제네릭 형식의 특수 한 경우입니다. 예를 들어, null 허용 <xref:System.Int32> "System.Nullable'1[System.Int32]" 문자열에 의해 표시 됩니다.  
  
> [!NOTE]
>  C#, c + + 및 Visual Basic 형식 연산자를 사용 하 여 nullable 형식을 가져올 수도 있습니다. 예를 들어, null 허용 <xref:System.Boolean> 형식을 반환한 `typeof(Nullable<bool>)` C#으로 하 여 `Nullable<Boolean>::typeid` c + +에서 `GetType(Nullable(Of Boolean))` Visual Basic의 합니다.  
  
 다음 표에서 사용 하 여 사용 하는 구문을 `GetType` 다양 한 형식에 대 한 합니다.  
  
|가져오려는|사용|  
|------------|---------|  
|Null 허용 <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|에 대 한 관리 되지 않는 포인터입니다. `MyType`|`Type.GetType("MyType*")`|  
|에 대 한 포인터에 대 한 관리 되지 않는 포인터입니다. `MyType`|`Type.GetType("MyType**")`|  
|관리 되는 포인터 또는 참조 `MyType`|`Type.GetType("MyType&")`. 포인터와 달리 참조는 한 수준으로 제한됩니다.|  
|부모 클래스 및 중첩된 클래스|`Type.GetType("MyParentClass+MyNestedClass")`|  
|하한값으로 0 사용 하 여 1 차원 배열|`Type.GetType("MyArray[]")`|  
|알 수 없는 하한값을 사용 하 여 1 차원 배열|`Type.GetType("MyArray[*]")`|  
|N 차원 배열|총 n-1 번 대괄호 안에 쉼표 (,)입니다. 예를 들어 `System.Object[,,]` 나타내는 3 차원 `Object` 배열입니다.|  
|2 차원 배열의 배열|`Type.GetType("MyArray[][]")`|  
|알 수 없는 하위 범위를 사용 하 여 사각형 2 차원 배열|`Type.GetType("MyArray[,]")`|  
|하나의 형식 인수가 있는 제네릭 형식|``Type.GetType("MyGenericType`1[MyType]")``|  
|두 개의 형식 인수를 사용 하 여 제네릭 형식|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|두 어셈블리의 정규화 된 형식 인수가 있는 제네릭 형식|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|어셈블리의 정규화 된 형식 인수를 사용 하 여 어셈블리의 정규화 된 제네릭 형식|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|두 형식 인수가 있는 제네릭 형식인 형식 인수로 제네릭 형식|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.  
  
또는 
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다. 
또는 
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.  
  
또는 
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 구문을 포함합니다. 예를 들어 "MyType[,*,]"입니다.  
  
또는 
 <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 어셈블리는 이후 버전으로 컴파일되었습니다.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">정규화된 형식 이름 지정</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">가져올 형식의 이름입니다. <paramref name="typeResolver" /> 매개 변수가 제공되는 경우 형식 이름은 <paramref name="typeResolver" />에서 확인 가능한 임의의 문자열일 수 있습니다. <paramref name="assemblyResolver" /> 매개 변수가 제공되거나 표준 형식 확인이 사용되는 경우 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있지 않으면 <paramref name="typeName" />은 어셈블리로 한정된 이름이어야 합니다(<see cref="P:System.Type.AssemblyQualifiedName" /> 참조). 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우에는 네임스페이스로 한정된 형식 이름을 제공해도 충분합니다.</param>
        <param name="assemblyResolver"><paramref name="typeName" />에 지정된 어셈블리를 찾고 반환하는 메서드입니다. 어셈블리 이름이 <paramref name="assemblyResolver" />에 <see cref="T:System.Reflection.AssemblyName" /> 개체로 전달됩니다. <paramref name="typeName" />에 어셈블리의 이름이 포함되어 있지 않으면 <paramref name="assemblyResolver" />가 호출되지 않습니다. <paramref name="assemblyResolver" />가 제공되지 않으면 표준 어셈블리 확인이 수행됩니다.  
  
주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오. 그렇게 하면 권한이 상승되어 악성 코드가 실행될 수 있습니다. 제공하는 메서드 또는 친숙한 메서드만 사용합니다.</param>
        <param name="typeResolver"><paramref name="typeName" /> 또는 표준 어셈블리 확인에서 반환된 어셈블리에서 <paramref name="assemblyResolver" />에 지정된 형식을 찾고 반환하는 메서드입니다. 어셈블리가 제공되지 않는 경우 <paramref name="typeResolver" /> 메서드에서 어셈블리를 제공할 수 있습니다. 이 메서드는 또한 대/소문자를 구분하지 않는 검색을 수행할지를 지정하는 매개 변수를 사용하며, 해당 매개 변수에 <see langword="false" />가 전달됩니다.  
  
주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오.</param>
        <summary>어셈블리 및 형식을 확인할 수 있는 사용자 지정 메서드를 선택적으로 제공하여, 지정된 이름의 형식을 가져옵니다.</summary>
        <returns>지정된 이름을 가진 형식이거나, 형식이 없으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드와 대 한 세부 정보에 대 한 사용 시나리오는 `assemblyResolver` 하 고 `typeResolver` 에서 매개 변수를 찾을 수 있습니다는 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 합니다.  
  
> [!NOTE]
>  하는 경우 `typeName` 찾을 수 없는 호출 합니다 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> 메서드가 반환 되는 `null`합니다. 예외를 throw 하지 않습니다. 제어할 수 있는지 여부는 예외가 발생의 오버 로드를 호출 합니다 <xref:System.Type.GetType%2A> 있는 메서드를 `throwOnError` 매개 변수입니다.  
  
 이 메서드 오버 로드는 호출 동일 합니다 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 하 고 지정 `false` 에 대 한 합니다 `throwOnError` 및 `ignoreCase` 매개 변수.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외를 throw합니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" />이 형식 이름 및 어셈블리 이름으로 구문 분석되면 오류가 발생합니다(예: 단순 형식 이름에 이스케이프되지 않은 특수 문자가 포함된 경우).  
  
또는 
 <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.  
  
또는 
 <paramref name="typeName" />이 잘못된 어셈블리 이름을 포함합니다.  
  
또는 
 <paramref name="typeName" />이 형식 이름이 없는 올바른 어셈블리 이름입니다.</exception>
        <exception cref="T:System.BadImageFormatException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.  
  
또는 
어셈블리가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">가져올 형식의 이름입니다. <paramref name="typeResolver" /> 매개 변수가 제공되는 경우 형식 이름은 <paramref name="typeResolver" />에서 확인 가능한 임의의 문자열일 수 있습니다. <paramref name="assemblyResolver" /> 매개 변수가 제공되거나 표준 형식 확인이 사용되는 경우 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있지 않으면 <paramref name="typeName" />은 어셈블리로 한정된 이름이어야 합니다(<see cref="P:System.Type.AssemblyQualifiedName" /> 참조). 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우에는 네임스페이스로 한정된 형식 이름을 제공해도 충분합니다.</param>
        <param name="assemblyResolver"><paramref name="typeName" />에 지정된 어셈블리를 찾고 반환하는 메서드입니다. 어셈블리 이름이 <paramref name="assemblyResolver" />에 <see cref="T:System.Reflection.AssemblyName" /> 개체로 전달됩니다. <paramref name="typeName" />에 어셈블리의 이름이 포함되어 있지 않으면 <paramref name="assemblyResolver" />가 호출되지 않습니다. <paramref name="assemblyResolver" />가 제공되지 않으면 표준 어셈블리 확인이 수행됩니다.  
  
주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오. 그렇게 하면 권한이 상승되어 악성 코드가 실행될 수 있습니다. 제공하는 메서드 또는 친숙한 메서드만 사용합니다.</param>
        <param name="typeResolver"><paramref name="typeName" /> 또는 표준 어셈블리 확인에서 반환된 어셈블리에서 <paramref name="assemblyResolver" />에 지정된 형식을 찾고 반환하는 메서드입니다. 어셈블리가 제공되지 않는 경우 이 메서드에서 어셈블리를 제공할 수 있습니다. 이 메서드는 또한 대/소문자를 구분하지 않는 검색을 수행할지를 지정하는 매개 변수를 사용하며, 해당 매개 변수에 <see langword="false" />가 전달됩니다.  
  
주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오.</param>
        <param name="throwOnError">형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다. 또한 <see langword="false" />를 지정하면 다른 예외 조건 중 일부(모두 아님)가 표시되지 않습니다. 예외 섹션을 참조하세요.</param>
        <summary>형식을 찾을 수 없는 경우 예외를 throw할지를 지정하고 어셈블리 및 형식을 확인할 수 있는 사용자 지정 메서드를 선택적으로 제공하여, 지정된 이름의 형식을 가져옵니다.</summary>
        <returns>지정된 이름의 형식입니다. 형식을 찾을 수 없는 경우에는 <paramref name="throwOnError" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다. 경우에 따라서는 <paramref name="throwOnError" /> 값과 상관없이 예외가 throw됩니다. 예외 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드와 대 한 세부 정보에 대 한 사용 시나리오는 `assemblyResolver` 하 고 `typeResolver` 에서 매개 변수를 찾을 수 있습니다는 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 합니다.  
  
 이 메서드 오버 로드는 호출에서와 동일 합니다 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 하 고 지정 `false` 에 대 한는 `ignoreCase` 매개 변수입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.  
  
또는 
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다. 
또는 
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.  
  
또는 
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" />이 형식 이름 및 어셈블리 이름으로 구문 분석되면 오류가 발생합니다(예: 단순 형식 이름에 이스케이프되지 않은 특수 문자가 포함된 경우).  
  
또는 
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 구문(예: "MyType[,*,]")을 포함합니다.  
  
또는 
 <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.  
  
또는 
 <paramref name="typeName" />이 잘못된 어셈블리 이름을 포함합니다.  
  
또는 
 <paramref name="typeName" />이 형식 이름이 없는 올바른 어셈블리 이름입니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.  
  
또는 
어셈블리가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">가져올 형식의 이름입니다. <paramref name="typeResolver" /> 매개 변수가 제공되는 경우 형식 이름은 <paramref name="typeResolver" />에서 확인 가능한 임의의 문자열일 수 있습니다. <paramref name="assemblyResolver" /> 매개 변수가 제공되거나 표준 형식 확인이 사용되는 경우 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있지 않으면 <paramref name="typeName" />은 어셈블리로 한정된 이름이어야 합니다(<see cref="P:System.Type.AssemblyQualifiedName" /> 참조). 형식이 현재 실행 중인 어셈블리나 Mscorlib.dll에 있는 경우에는 네임스페이스로 한정된 형식 이름을 제공해도 충분합니다.</param>
        <param name="assemblyResolver"><paramref name="typeName" />에 지정된 어셈블리를 찾고 반환하는 메서드입니다. 어셈블리 이름이 <paramref name="assemblyResolver" />에 <see cref="T:System.Reflection.AssemblyName" /> 개체로 전달됩니다. <paramref name="typeName" />에 어셈블리의 이름이 포함되어 있지 않으면 <paramref name="assemblyResolver" />가 호출되지 않습니다. <paramref name="assemblyResolver" />가 제공되지 않으면 표준 어셈블리 확인이 수행됩니다.  
  
주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오. 그렇게 하면 권한이 상승되어 악성 코드가 실행될 수 있습니다. 제공하는 메서드 또는 친숙한 메서드만 사용합니다.</param>
        <param name="typeResolver"><paramref name="typeName" /> 또는 표준 어셈블리 확인에서 반환된 어셈블리에서 <paramref name="assemblyResolver" />에 지정된 형식을 찾고 반환하는 메서드입니다. 어셈블리가 제공되지 않는 경우 이 메서드에서 어셈블리를 제공할 수 있습니다. 이 메서드는 또한 대/소문자를 구분하지 않는 검색을 수행할지를 지정하는 매개 변수를 사용하며, 해당 매개 변수에 <paramref name="ignoreCase" />의 값이 전달됩니다.  
  
주의   알 수 없거나 신뢰할 수 없는 호출자의 메서드는 전달하지 마십시오.</param>
        <param name="throwOnError">형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다. 또한 <see langword="false" />를 지정하면 다른 예외 조건 중 일부(모두 아님)가 표시되지 않습니다. 예외 섹션을 참조하세요.</param>
        <param name="ignoreCase"><see langword="true" />에 대해 대/소문자를 구분하지 않는 검색을 수행하려는 경우 <paramref name="typeName" />이고, <see langword="false" />에 대해 대/소문자를 구분하는 검색을 수행하려는 경우 <paramref name="typeName" />입니다.</param>
        <summary>형식을 찾을 수 없는 경우 대/소문자를 구분하는 검색을 수행할지 여부 및 예외를 throw할지를 지정하고 어셈블리 및 형식을 확인할 수 있는 사용자 지정 메서드를 선택적으로 제공하여, 지정된 이름의 형식을 가져옵니다.</summary>
        <returns>지정된 이름의 형식입니다. 형식을 찾을 수 없는 경우에는 <paramref name="throwOnError" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다. 경우에 따라서는 <paramref name="throwOnError" /> 값과 상관없이 예외가 throw됩니다. 예외 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드 및 연결 된 오버 로드를 사용 하 여 (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> 하 고 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>)의 기본 구현을 바꿀는 <xref:System.Type.GetType%2A> 유연한 구현 사용 하 여 메서드. 형식 이름 및 포함 하는 어셈블리의 이름을 확인 하는 사용자 고유의 메서드를 제공 하 여 다음을 수행할 수 있습니다.  
  
-   형식에서 로드 되는 어셈블리의 버전을 제어 합니다.  
  
-   어셈블리 이름을 포함 하지 않는 형식 이름을 검색할 수 있는 다른 위치를 제공 합니다.  
  
-   부분 어셈블리 이름을 사용 하 여 어셈블리를 로드 합니다.  
  
-   서브 클래스를 반환 <xref:System.Type?displayProperty=nameWithType> 는 CLR (공용 언어 런타임)에서 만들어지지 않습니다.  
  
 예를 들어 버전 독립적 serialization에서이 메서드를 사용 하면 부분 이름을 사용 하 여 "최적" 어셈블리를 검색할 수 있습니다. 다른 오버 로드는 <xref:System.Type.GetType%2A> 메서드 버전 번호를 포함 하는 어셈블리의 정규화 된 형식 이름이 필요 합니다.  
  
 형식 시스템의 대체 구현을의 서브 클래스를 반환 해야 할 수 있습니다 <xref:System.Type?displayProperty=nameWithType> CLR에서 만들어지지 않은; 모든 형식에 다른 오버 로드에 의해 반환 되는 <xref:System.Type.GetType%2A> 메서드는 런타임 형식입니다.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>사용 정보  
 이 메서드 오버 로드 및 연결 된 오버 로드를 구문 분석 `typeName` 어셈블리의 이름 및 형식 이름으로 한 다음 이름을 확인 합니다. 어셈블리 이름 확인 형식 이름을 어셈블리의 컨텍스트에서 해결 해야 하기 때문에 형식 이름 확인 하기 전에 발생 합니다.  
  
> [!NOTE]
>  어셈블리의 정규화 된 형식 이름에 대 한 개념을 잘 모르는 경우 참조는 <xref:System.Type.AssemblyQualifiedName%2A> 속성입니다.  
  
 경우 `typeName` 어셈블리의 정규화 된 이름이 아닙니다. 어셈블리 확인을 건너뜁니다. Mscorlib.dll 또는 현재 실행 중인 어셈블리의 컨텍스트에서 정규화 되지 않은 형식 이름을 확인할 수 있습니다 또는 어셈블리를 선택적으로 제공할 수는 `typeResolver` 매개 변수입니다. 영향 포함 하거나 다른 종류의 이름 확인을 테이블로 표시 되는 어셈블리 이름을 생략 합니다 [혼합 된 이름 확인](#mixed_name_resolution) 섹션입니다.  
  
 일반적인 사용법 정보:  
  
-   메서드를 전달 하지 마세요 `assemblyResolver` 또는 `typeResolver` 알 수 없거나 신뢰할 수 없는 호출자를 합니다. 제공하는 메서드 또는 친숙한 메서드만 사용합니다.  
  
    > [!CAUTION]
    >  알 수 없거나 신뢰할 수 없는 호출자의 메서드를 사용 하 여 악성 코드에 대 한 권한 상승 될 수 있습니다.  
  
-   생략 하면는 `assemblyResolver` 및/또는 `typeResolver` 매개 변수, 값은 `throwOnError` 매개 변수는 기본 확인을 수행 하는 메서드에 전달 됩니다.  
  
-   경우 `throwOnError` 됩니다 `true`,이 메서드가 throw를 <xref:System.TypeLoadException> 때 `typeResolver` 반환 `null`, 및 <xref:System.IO.FileNotFoundException> 때 `assemblyResolver` 반환 `null`.  
  
-   이 메서드에 의해 throw 된 예외를 catch 하지 않습니다 `assemblyResolver` 고 `typeResolver`입니다. 확인자 메서드에 의해 throw 되는 모든 예외에 대 한 담당 합니다.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>어셈블리 확인  
 합니다 `assemblyResolver` 메서드는 수신를 <xref:System.Reflection.AssemblyName> 개체에 포함 된 어셈블리 이름 문자열을 구문 분석 하 여 생성 되는 `typeName`합니다. 하는 경우 `typeName` 는 어셈블리 이름을 포함 하지 않는 `assemblyResolver` 가 호출 되지 않습니다 및 `null` 넘어갑니다 `typeResolver`합니다.  
  
 경우 `assemblyResolver` 제공 되는 표준 어셈블리가 아닌 어셈블리를 찾는 데 사용 됩니다 검색 합니다. 경우 `assemblyResolver` 제공 되는 <xref:System.Type.GetType%2A> 메서드는 표준 검색을 수행 하지 않으면 경우 확인 해야 프로그램 `assemblyResolver` 을 전달 하는 모든 어셈블리를 처리할 수 있습니다.  
  
 합니다 `assemblyResolver` 메서드는 반환 해야 `null` 어셈블리를 확인할 수 없는 경우. 경우 `assemblyResolver` 반환 `null`, `typeResolver` 가 호출 되지 않습니다 발생 추가로 처리할 필요가 없습니다; 또한 경우 `throwOnError` 됩니다 `true`, <xref:System.IO.FileNotFoundException> throw 됩니다.  
  
 경우는 <xref:System.Reflection.AssemblyName> 에 전달 된 `assemblyResolver` 이 부분 이름, 하나 이상의 파트 중 `null`합니다. 예를 들어 없는 버전이 있을 경우 합니다 <xref:System.Reflection.AssemblyName.Version%2A> 속성은 `null`합니다. 경우는 <xref:System.Reflection.AssemblyName.Version%2A> 속성을 <xref:System.Reflection.AssemblyName.CultureInfo%2A> 속성을 및 <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> 메서드가 모두 반환 `null`만 어셈블리의 단순한 이름을 제공한 다음. `assemblyResolver` 메서드 사용 하거나 어셈블리 이름의 모든 부분을 무시할 수 있습니다.  
  
 다른 어셈블리 해결 옵션의 효과 테이블로 표시 됩니다는 [혼합 된 이름 확인](#mixed_name_resolution) 섹션을 간단 하 고 어셈블리의 정규화 된 형식 이름입니다.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>형식 확인  
 하는 경우 `typeName` 는 어셈블리 이름을 지정 하지 않습니다 `typeResolver` 가 항상 호출 합니다. 하는 경우 `typeName` 어셈블리 이름 지정 `typeResolver` 어셈블리 이름을 성공적으로 확인 하는 경우에 호출 됩니다. 하는 경우 `assemblyResolver` 또는 표준 어셈블리 검색 반환 `null`, `typeResolver` 호출 되지 않습니다.  
  
 `typeResolver` 메서드 3 개 인수를 받습니다.  
  
-   검색할 어셈블리 또는 `null` 경우 `typeName` 어셈블리 이름이 없습니다.  
  
-   단순한 이름 형식입니다. 중첩된 된 형식의 경우 가장 바깥쪽 포함 하는 형식입니다. 제네릭 형식의 경우 제네릭 형식의 단순 이름입니다.  
  
-   부울 값이 `true` 형식 이름의 대/소문자가 구분 되지 않을 경우.  
  
 이러한 인수를 사용 하는 방법을 결정 하는 구현 합니다. 합니다 `typeResolver` 메서드는 반환 해야 `null` 형식을 확인할 수 없는 경우. 경우 `typeResolver` 반환 `null` 및 `throwOnError` 됩니다 `true`,이 오버 로드 <xref:System.Type.GetType%2A> throw를 <xref:System.TypeLoadException>입니다.  
  
 다른 형식 확인 옵션의 효과 테이블로 표시 됩니다는 [혼합 된 이름 확인](#mixed_name_resolution) 섹션을 간단 하 고 어셈블리의 정규화 된 형식 이름입니다.  
  
#### <a name="resolving-nested-types"></a>중첩된 형식 확인  
 하는 경우 `typeName` 는 중첩 형식이 가장 바깥쪽의 이름만 포함 하는 형식 전달 됩니다 `typeResolver`합니다. 때 `typeResolver` 이 형식을 반환 합니다 <xref:System.Type.GetNestedType%2A> 메서드 가장 안쪽의 중첩 된 형식이 확인 될 때까지 재귀적으로 호출 됩니다.  
  
#### <a name="resolving-generic-types"></a>제네릭 형식 확인  
 <xref:System.Type.GetType%2A> 재귀적으로 제네릭 형식을 확인 하기 위해 호출 됩니다: 제네릭 형식 자체를 해결 하려면 먼저 해당 형식 인수를 해결 하려면 다음입니다. 형식 인수 제네릭인 경우 <xref:System.Type.GetType%2A> 그 형식 인수를 해결 하는 재귀적으로 호출 됩니다.  
  
 조합 `assemblyResolver` 및 `typeResolver` 모든 수준의이 재귀를 해결할 수 제공 합니다. 예를 들어, 제공 하는 `assemblyResolver` 로드를 제어 하는 `MyAssembly`합니다. 제네릭 형식을 확인 하려고 한다고 가정해 보겠습니다 `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` Visual basic에서). 다음 제네릭 형식 이름을 전달할 수 있습니다.  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 `MyType` 만 어셈블리의 정규화 된 유형 인수입니다. 이름을 합니다 <xref:System.Collections.Generic.Dictionary%602> 및 <xref:System.String> 클래스 정규화 된 어셈블리는 없습니다. 프로그램 `typeResolver` 어셈블리로 하거나 처리할 수 있어야 또는 `null`이므로 받을 `null` 에 대 한 <xref:System.Collections.Generic.Dictionary%602> 및 <xref:System.String>합니다. 이런 경우의 오버 로드를 호출 하 여 처리할 수는 <xref:System.Type.GetType%2A> 정규화 되지 않은 형식 이름을 모두 mscorlib.dll에서 때문에 문자열을 사용 하는 메서드:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 `assemblyResolver` 없기 때문에 해당 형식 이름이 어셈블리의 정규화 된 사전 형식 및 문자열 형식에 대 한 메서드가 호출 되지 않습니다.  
  
 이제 대신 가정 `System.String`에 첫 번째 제네릭 인수 형식이 `YourType`에서 `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 해결할 수 없는이 어셈블리 Mscorlib.dll 또는 현재 실행 중인 어셈블리 이므로 `YourType` 어셈블리의 정규화 된 이름이 없는 합니다. 때문에 `assemblyResolve` 됩니다 재귀적으로 호출 있어야이 경우를 처리 하도록 합니다. 반환 하는 대신 `null` 이외의 어셈블리에 대 한 `MyAssembly`, 이제 제공 된 어셈블리를 로드 수행 <xref:System.Reflection.AssemblyName> 개체입니다.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 돌아가기 [사용량 정보](#usage_notes)합니다.  
  
#### <a name="resolving-type-names-with-special-characters"></a>특수 문자가 포함 된 형식 이름 확인  
 특정 문자 어셈블리의 정규화 된 이름에서 특별 한 의미를 갖습니다. 이러한 문자를 포함 하는 단순 형식 이름, 단순한 이름 어셈블리의 정규화 된 이름의 일부인 경우 문자 구문 분석 오류를 발생 합니다. 구문 분석 오류를 방지 하려면 이스케이프 처리 해야 백슬래시를 사용 하 여 특수 문자를 정규화 된 어셈블리 이름을 전달 하기 전에 <xref:System.Type.GetType%2A> 메서드. 예를 들어 형식 이름은 `Strange]Type`, 다음과 같은 이스케이프 문자가 대괄호 미리 추가 해야 합니다: `Strange\]Type`합니다.  
  
> [!NOTE]
>  이러한 특수 문자를 사용 하 여 이름을 Visual Basic 또는 C#에서 만들 수 없지만 동적 어셈블리 내보내기를 또는 MSIL (Microsoft intermediate language)을 사용 하 여 만들 수 있습니다.  
  
 다음 표에서 형식 이름에 대 한 특수 문자를 보여 줍니다.  
  
|문자|의미|  
|---------------|-------------|  
|`,` (쉼표)|어셈블리의 정규화 된 이름에 대 한 구분 기호입니다.|  
|`[]` (대괄호)|접미사 쌍을 나타내는 배열 형식입니다. 구분 기호 쌍을 제네릭 인수 목록 및 어셈블리의 정규화 된 이름을 포함합니다.|  
|`&` (앰퍼샌드)|접미사로, 형식이 참조 형식 인지를 나타냅니다.|  
|`*` (별표)|를 접미사로 형식이 포인터 형식 인지를 나타냅니다.|  
|`+` (더하기)|중첩 된 형식에 대 한 구분 기호입니다.|  
|`\` (백슬래시)|이스케이프 문자입니다.|  
  
 와 같은 속성 <xref:System.Type.AssemblyQualifiedName%2A> 올바르게 이스케이프 된 문자열 반환 합니다. 올바르게 이스케이프 된 문자열을 전달 해야 합니다는 <xref:System.Type.GetType%2A> 메서드. 차례로 합니다 <xref:System.Type.GetType%2A> 메서드를 올바르게 이스케이프 이름을 전달 `typeResolver` 및 기본 형식 확인 방법입니다. 이스케이프 되지 않은 이름에 이름을 비교 해야 하는 경우 `typeResolver`, 이스케이프 문자를 제거 해야 합니다.  
  
 돌아가기 [사용량 정보](#usage_notes)합니다.  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>혼합된 이름 확인  
 다음 표에서 간의 상호 작용 `assemblyResolver`, `typeResolver`, 및의 형식 이름과 어셈블리의 모든 조합에 대 한 기본 이름 확인 `typeName`:  
  
|콘텐츠 형식 이름|어셈블리 확인자 메서드|형식 확인 자가 메서드|결과|  
|---------------------------|------------------------------|--------------------------|------------|  
|형식, 어셈블리|null|null|호출에 해당 하는 <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 메서드 오버 로드 합니다.|  
|형식, 어셈블리|제공|null|`assemblyResolver` 어셈블리를 반환 하거나 반환 `null` 어셈블리를 확인할 수 없는 경우. 어셈블리가 확인 되는 경우는 <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 어셈블리에서 형식을 로드 하는 메서드 오버 로드 되 고, 그렇지 않으면 있습니다 형식을 확인 하지 않습니다.|  
|형식, 어셈블리|null|제공|해당 어셈블리 이름을 변환 하는 <xref:System.Reflection.AssemblyName> 개체와 호출은 <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> 메서드 오버 로드 된 어셈블리를 가져오려고 합니다. 에 전달한 어셈블리 해결 되 면 `typeResolver`이 고, 그렇지 않으면 `typeResolver` 호출 되지 않습니다 추가 시도가 형식을 확인 하 고 있습니다.|  
|형식, 어셈블리|제공|제공|`assemblyResolver` 어셈블리를 반환 하거나 반환 `null` 어셈블리를 확인할 수 없는 경우. 에 전달한 어셈블리 해결 되 면 `typeResolver`이 고, 그렇지 않으면 `typeResolver` 호출 되지 않습니다 추가 시도가 형식을 확인 하 고 있습니다.|  
|형식|null, 제공|null|호출에 해당 하는 <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 메서드 오버 로드 합니다. 어셈블리 이름, 제공 되지 않았으므로 Mscorlib.dll 및 현재 실행 중인 어셈블리가 검색 됩니다. 경우 `assemblyResolver` 제공 무시 됩니다.|  
|type|null, 제공|제공|`typeResolver` 호출 되 고 `null` 어셈블리에 전달 됩니다. `typeResolver` 이 목적을 위해 로드 하는 어셈블리를 포함 하 여 모든 어셈블리에서 형식을 제공할 수 있습니다. 경우 `assemblyResolver` 제공 무시 됩니다.|  
|어셈블리|null, 제공|null, 제공|<xref:System.IO.FileLoadException> throw 되는 어셈블리의 정규화 된 유형 이름 처럼 어셈블리 이름을 구문 분석 되기 때문입니다. 이 인해 잘못 된 어셈블리 이름입니다.|  
  
 다시: [사용 메모](#usage_notes), [어셈블리를 확인할](#resolving_assemblies)를 [형식을 확인](#resolving_types)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.  
  
또는 
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다. 
또는 
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.  
  
또는 
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 배열을 나타냅니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" />이 형식 이름 및 어셈블리 이름으로 구문 분석되면 오류가 발생합니다(예: 단순 형식 이름에 이스케이프되지 않은 특수 문자가 포함된 경우).  
  
또는 
 <paramref name="throwOnError" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 구문(예: "MyType[,*,]")을 포함합니다.  
  
또는 
 <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.  
  
또는 
 <paramref name="typeName" />이 잘못된 어셈블리 이름을 포함합니다.  
  
또는 
 <paramref name="typeName" />이 형식 이름이 없는 올바른 어셈블리 이름입니다.</exception>
        <exception cref="T:System.BadImageFormatException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.  
  
또는 
어셈블리가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">형식을 확인할 개체의 배열입니다.</param>
        <summary>지정된 배열의 개체 형식을 가져옵니다.</summary>
        <returns><see cref="T:System.Type" />의 해당 요소에 대한 형식을 나타내는 <paramref name="args" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Type.GetTypeArray%2A> 배열 요소의 형식을 나열 하는 방법입니다.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="args" />의 요소 중 하나가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 하나 이상이 예외를 throw합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">내부 형식 코드를 가져올 형식입니다.</param>
        <summary>지정된 <see cref="T:System.Type" />의 내부 형식 코드를 가져옵니다.</summary>
        <returns>지정된 형식의 코드이거나, <see cref="F:System.TypeCode.Empty" />이 <paramref name="type" />인 경우는 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상속 하는 경우 <xref:System.Type>를 재정의 하 여이 메서드의 동작을 변경할 수는 <xref:System.Type.GetTypeCodeImpl%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 방법을 <xref:System.TypeCode> 열거형을 사용할 수 있습니다. 의사 결정 블록 내에서 `WriteObjectInfo` 메서드를 <xref:System.TypeCode> 의 <xref:System.Object> 매개 변수를 검사 하 고 적절 한 메시지를 콘솔에 기록 됩니다.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Type" /> 인스턴스에 대한 내부 형식 코드를 반환합니다.</summary>
        <returns>내부 형식의 형식 코드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 구현을 제공 합니다 `static` (C#에서) 또는 `Shared` (Visual Basic)에서는 <xref:System.Type.GetTypeCode%28System.Type%29> 메서드. 상속 하는 경우 <xref:System.Type>의 고유한 구현을 제공 하려면이 메서드를 재정의할 수 있습니다 <xref:System.Type.GetTypeCode%2A>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 CLSID(클래스 식별자)와 연관된 형식을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">가져올 형식의 CLSID입니다.</param>
        <summary>지정된 CLSID(클래스 식별자)와 연관된 형식을 가져옵니다.</summary>
        <returns><see langword="System.__ComObject" /> CLSID가 유효한지 여부에 관계 없습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> 메서드 지원 런타임에 바인딩된 액세스 관리 되지 않는 COM 개체에.NET Framework 앱에서 COM 개체의 CLSID (클래스 식별자)를 알고 있는 경우.  COM 클래스에 대 한 클래스 식별자는 레지스트리의 HKEY_CLASSES_ROOT\CLSID 키에 정의 됩니다. 값을 검색할 수 있습니다는 <xref:System.Type.IsCOMObject%2A> 속성을이 메서드에 의해 반환 되는 형식에는 COM 개체 인지 여부를 결정 합니다.  
  
> [!TIP]
>  호출할 수 있습니다는 <xref:System.Type.GetTypeFromProgID%2A> 메서드를 COM에 런타임에 바인딩된 액세스에 대 한 개체를 해당 ProgID (프로그래밍 식별자) 알 수 있습니다.  
  
 CLSID에서 관리 되지 않는 COM 개체를 인스턴스화하는 2 단계 프로세스입니다.  
  
1.  가져오기는 <xref:System.Type> 나타내는 개체를`__ComObject` CLSID를 호출 하 여 해당 하는 <xref:System.Type.GetTypeFromCLSID%2A> 메서드.  
  
2.  호출 된 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 메서드를 COM 개체를 인스턴스화합니다.  
  
 에 대 한 예제를 참조 하세요.  
  
 <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> 인스턴스화할 때 발생할 수 있는 모든 예외를 무시 하는 오버 로드를 <xref:System.Type> 기준으로 개체를 `clsid` 인수입니다. 예외가 없는 경우 throw 되는 참고 `clsid` 는 레지스트리에서 찾을 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 Microsoft Word의 CLSID [응용 프로그램 개체](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) Microsoft Word 응용 프로그램을 나타내는 COM 종류를 검색 합니다. 다음 호출 하 여 형식을 인스턴스화합니다 합니다 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 메서드를 호출 하 여 닫습니다 합니다 [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) 메서드.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>이 메서드는.NET Framework 개체와 COM 개체를 사용 하 여 작업할 때 사용 하 여 위한 것입니다. 관리 되는 모든 개체를 COM에 표시를 포함 하 여 (즉, 해당 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 특성이 <see langword="true" />)에 의해 반환 되는 GUID는 <see cref="P:System.Type.GUID" /> 속성입니다. 메서드가 <see cref="T:System.Type" /> 개체 GUID에 해당 하는.NET framework는 개체에 사용할 수 없습니다 <see cref="T:System.Type" /> 를 호출 하 여 형식 인스턴스를 만들 개체를 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드를 다음 예제와 같이 합니다.  
  
[! 코드 csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! 코드 vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
대신 합니다 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 결과 및 사용 하는 관리 되지 않는 COM 개체의 GUID를 검색 하려면만 사용 해야 <see cref="T:System.Type" /> 에 전달 되는 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드는 관리 되지 않는 COM 개체를 나타내야 합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">가져올 형식의 CLSID입니다.</param>
        <param name="throwOnError">발생하는 예외를 모두 throw하려면 <see langword="true" />입니다.  
  
또는 
 <see langword="false" />는 발생하는 예외를 모두 무시합니다.</param>
        <summary>지정된 CLSID(클래스 식별자)와 연관된 형식을 가져오고 형식을 로드하는 동안 오류가 발생하면 예외를 throw할지를 지정합니다.</summary>
        <returns><see langword="System.__ComObject" /> CLSID가 유효한지 여부에 관계 없습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> 메서드 지원 런타임에 바인딩된 액세스 관리 되지 않는 COM 개체에.NET Framework 앱에서 COM 개체의 CLSID (클래스 식별자)를 알고 있는 경우.  COM 클래스에 대 한 클래스 식별자는 레지스트리의 HKEY_CLASSES_ROOT\CLSID 키에 정의 됩니다. 값을 검색할 수 있습니다는 <xref:System.Type.IsCOMObject%2A> 속성을이 메서드에 의해 반환 되는 형식에는 COM 개체 인지 여부를 결정 합니다.  
  
> [!TIP]
>  호출할 수 있습니다는 <xref:System.Type.GetTypeFromProgID%2A> 메서드를 COM에 런타임에 바인딩된 액세스에 대 한 개체를 해당 ProgID (프로그래밍 식별자) 알 수 있습니다.  
  
 CLSID에서 관리 되지 않는 COM 개체를 인스턴스화하는 2 단계 프로세스입니다.  
  
1.  가져오기는 <xref:System.Type> 나타내는 개체를 `__ComObject` CLSID를 호출 하 여 해당 하는 <xref:System.Type.GetTypeFromCLSID%2A> 메서드.  
  
2.  호출 된 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 메서드를 COM 개체를 인스턴스화합니다.  
  
 에 대 한 예제를 참조 하세요.  
  
 등의 예외도 <xref:System.OutOfMemoryException> 지정 하는 경우 throw 됩니다 `true` 에 대 한 `throwOnError`, 하지만 등록 되지 않은 Clsid에 대 한 실패 하지 것입니다.  
  
   
  
## Examples  
 다음 예제에서는 Microsoft Word의 CLSID [응용 프로그램 개체](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) Microsoft Word 응용 프로그램을 나타내는 COM 종류를 검색 합니다. 다음 호출 하 여 형식을 인스턴스화합니다 합니다 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 메서드를 호출 하 여 닫습니다 합니다 [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) 메서드. 형식을 로드 하는 동안 오류가 발생 하면 예외가 throw 됩니다.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>이 메서드는.NET Framework 개체와 COM 개체를 사용 하 여 작업할 때 사용 하 여 위한 것입니다. 관리 되는 모든 개체를 COM에 표시를 포함 하 여 (즉, 해당 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 특성이 <see langword="true" />)에 의해 반환 되는 GUID는 <see cref="P:System.Type.GUID" /> 속성입니다. 메서드가 <see cref="T:System.Type" /> 개체 GUID에 해당 하는.NET framework는 개체에 사용할 수 없습니다 <see cref="T:System.Type" /> 를 호출 하 여 형식 인스턴스를 만들 개체를 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드를 다음 예제와 같이 합니다.  
  
[! 코드 csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! 코드 vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
대신 합니다 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 결과 및 사용 하는 관리 되지 않는 COM 개체의 GUID를 검색 하려면만 사용 해야 <see cref="T:System.Type" /> 에 전달 되는 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드는 관리 되지 않는 COM 개체를 나타내야 합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">가져올 형식의 CLSID입니다.</param>
        <param name="server">형식을 로드할 서버입니다. 서버 이름이 <see langword="null" />이면 이 메서드는 자동으로 로컬 컴퓨터로 전환됩니다.</param>
        <summary>지정된 CLSID(클래스 식별자)와 연관된 형식을 지정된 서버에서 가져옵니다.</summary>
        <returns><see langword="System.__ComObject" /> CLSID가 유효한지 여부에 관계 없습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> 메서드 지원 런타임에 바인딩된 액세스 관리 되지 않는 COM 개체에.NET Framework 앱에서 COM 개체의 CLSID (클래스 식별자)를 알고 있는 경우.  COM 클래스에 대 한 클래스 식별자는 레지스트리의 HKEY_CLASSES_ROOT\CLSID 키에 정의 됩니다. 값을 검색할 수 있습니다는 <xref:System.Type.IsCOMObject%2A> 속성을이 메서드에 의해 반환 되는 형식에는 COM 개체 인지 여부를 결정 합니다.  
  
> [!TIP]
>  호출할 수 있습니다는 <xref:System.Type.GetTypeFromProgID%2A> 메서드를 COM에 런타임에 바인딩된 액세스에 대 한 개체를 해당 ProgID (프로그래밍 식별자) 알 수 있습니다.  
  
 CLSID에서 관리 되지 않는 COM 개체를 인스턴스화하는 2 단계 프로세스입니다.  
  
1.  가져오기는 <xref:System.Type> 나타내는 개체를 `__ComObject` CLSID를 호출 하 여 해당 하는 <xref:System.Type.GetTypeFromCLSID%2A> 메서드.  
  
2.  호출 된 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 메서드를 COM 개체를 인스턴스화합니다.  
  
   
  
## Examples  
 다음 예제에서는 Microsoft Word의 CLSID [응용 프로그램 개체](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) computer17.central.contoso.com 라는 서버에서 Microsoft Word 응용 프로그램을 나타내는 COM 종류를 검색 합니다. 다음 호출 하 여 형식을 인스턴스화합니다 합니다 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 메서드를 호출 하 여 닫습니다 합니다 [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) 메서드.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>이 메서드는.NET Framework 개체와 COM 개체를 사용 하 여 작업할 때 사용 하 여 위한 것입니다. 관리 되는 모든 개체를 COM에 표시를 포함 하 여 (즉, 해당 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 특성이 <see langword="true" />)에 의해 반환 되는 GUID는 <see cref="P:System.Type.GUID" /> 속성입니다. 메서드가 <see cref="T:System.Type" /> 개체 GUID에 해당 하는.NET framework는 개체에 사용할 수 없습니다 <see cref="T:System.Type" /> 를 호출 하 여 형식 인스턴스를 만들 개체를 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드를 다음 예제와 같이 합니다.  
  
[! 코드 csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! 코드 vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
대신 합니다 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 결과 및 사용 하는 관리 되지 않는 COM 개체의 GUID를 검색 하려면만 사용 해야 <see cref="T:System.Type" /> 에 전달 되는 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드는 관리 되지 않는 COM 개체를 나타내야 합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">가져올 형식의 CLSID입니다.</param>
        <param name="server">형식을 로드할 서버입니다. 서버 이름이 <see langword="null" />이면 이 메서드는 자동으로 로컬 컴퓨터로 전환됩니다.</param>
        <param name="throwOnError">발생하는 예외를 모두 throw하려면 <see langword="true" />입니다.  
  
또는 
 <see langword="false" />는 발생하는 예외를 모두 무시합니다.</param>
        <summary>지정된 CLSID(클래스 식별자)와 연관된 형식을 지정된 서버에서 가져오고 형식을 로드하는 동안 오류가 발생하면 예외를 throw할지를 지정합니다.</summary>
        <returns><see langword="System.__ComObject" /> CLSID가 유효한지 여부에 관계 없습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> 메서드 지원 런타임에 바인딩된 액세스 관리 되지 않는 COM 개체에.NET Framework 앱에서 COM 개체의 CLSID (클래스 식별자)를 알고 있는 경우.  COM 클래스에 대 한 클래스 식별자는 레지스트리의 HKEY_CLASSES_ROOT\CLSID 키에 정의 됩니다. 값을 검색할 수 있습니다는 <xref:System.Type.IsCOMObject%2A> 속성을이 메서드에 의해 반환 되는 형식에는 COM 개체 인지 여부를 결정 합니다.  
  
> [!TIP]
>  호출할 수 있습니다는 <xref:System.Type.GetTypeFromProgID%2A> 메서드를 COM에 런타임에 바인딩된 액세스에 대 한 개체를 해당 ProgID (프로그래밍 식별자) 알 수 있습니다.  
  
 CLSID에서 관리 되지 않는 COM 개체를 인스턴스화하는 2 단계 프로세스입니다.  
  
1.  가져오기는 <xref:System.Type> 나타내는 개체를 `__ComObject` CLSID를 호출 하 여 해당 하는 <xref:System.Type.GetTypeFromCLSID%2A> 메서드.  
  
2.  호출 된 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 메서드를 COM 개체를 인스턴스화합니다.  
  
 등의 예외도 <xref:System.OutOfMemoryException> 지정 하는 경우 throw 됩니다 `true` 에 대 한 `throwOnError`, 하지만 등록 되지 않은 Clsid에 대 한 실패 하지 것입니다.  
  
   
  
## Examples  
 다음 예제에서는 Microsoft Word의 CLSID [응용 프로그램 개체](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) computer17.central.contoso.com 라는 서버에서 Microsoft Word 응용 프로그램을 나타내는 COM 종류를 검색 합니다. 다음 호출 하 여 형식을 인스턴스화합니다 합니다 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 메서드를 호출 하 여 닫습니다 합니다 [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) 메서드. 형식을 로드 하는 동안 오류가 발생 하면 예외가 throw 됩니다.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>이 메서드는.NET Framework 개체와 COM 개체를 사용 하 여 작업할 때 사용 하 여 위한 것입니다. 관리 되는 모든 개체를 COM에 표시를 포함 하 여 (즉, 해당 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 특성이 <see langword="true" />)에 의해 반환 되는 GUID는 <see cref="P:System.Type.GUID" /> 속성입니다. 있지만 합니다 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 메서드가 반환 되는 <see cref="T:System.Type" /> 관리 되는 특정 개체에 대 한 GUID에 해당 하는 개체는 사용할 수 없습니다 <see cref="T:System.Type" /> 호출 하 여 형식 인스턴스를 만들 개체를 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드를 다음 예제와 같이 보여 줍니다.  
  
[! 코드 csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! 코드 vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
대신 합니다 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 결과 및 사용 하는 관리 되지 않는 COM 개체의 GUID를 검색 하려면만 사용 해야 <see cref="T:System.Type" /> 에 전달 되는 개체는 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 메서드는 관리 되지 않는 COM 개체를 나타내야 합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">형식을 참조하는 개체입니다.</param>
        <summary>지정된 형식 핸들이 참조하는 형식을 가져옵니다.</summary>
        <returns>지정된 <see cref="T:System.RuntimeTypeHandle" />에서 참조하는 형식이거나 <see langword="null" />의 <see cref="P:System.RuntimeTypeHandle.Value" /> 속성이 <paramref name="handle" />인 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핸들은는 가져온 응용 프로그램 도메인 에서만 유효 합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Type.GetTypeFromHandle%2A> 메서드를를 <xref:System.Type> 에서 개체를 <xref:System.RuntimeTypeHandle> 제공한는 <xref:System.Type.GetTypeHandle%2A> 메서드.  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 ProgID(프로그램 식별자)와 연관된 형식을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">가져올 형식의 ProgID입니다.</param>
        <summary>지정된 ProgID(프로그램 식별자)와 연관된 형식을 가져오고 <see cref="T:System.Type" />을 로드하는 동안 오류가 발생하면 null을 반환합니다.</summary>
        <returns><paramref name="progID" />가 유효한 레지스트리 항목이고 형식과 관련되어 있으면 지정된 ProgID와 관련된 형식을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 제공 하는 COM 지원에 대 한 합니다. Progid 네임 스페이스의 개념에 의해 대체 하기 때문에 Microsoft.NET Framework에서 사용 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">가져올 형식의 ProgID입니다.</param>
        <param name="throwOnError">발생하는 예외를 모두 throw하려면 <see langword="true" />입니다.  
  
또는 
 <see langword="false" />는 발생하는 예외를 모두 무시합니다.</param>
        <summary>지정된 ProgID(프로그램 식별자)와 연관된 형식을 가져오고 형식을 로드하는 동안 오류가 발생하면 예외를 throw할지를 지정합니다.</summary>
        <returns><paramref name="progID" />가 유효한 레지스트리 항목이고 형식과 관련되어 있으면 지정된 ProgID(프로그램 식별자)와 관련된 형식을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 제공 하는 COM 지원에 대 한 합니다. 네임 스페이스의 개념에 의해 대체 하기 때문에 Microsoft.NET Framework의 프로그램 Id는 사용 되지 않습니다.  
  
   
  
## Examples  
 다음 예제를 progid가 유효 하지 않은 경우 예외를 throw 할지를 지정 된 ProgID를 전달 하 여 형식을 검색 합니다. 다음 예제에서는 모든 적절 한 예외 메시지와 함께 ProgID와 관련 된 ClassID를 표시 합니다.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">지정된 ProgID가 등록되어 있지 않습니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">가져올 형식의 ProgID입니다.</param>
        <param name="server">형식을 로드할 서버입니다. 서버 이름이 <see langword="null" />이면 이 메서드는 자동으로 로컬 컴퓨터로 전환됩니다.</param>
        <summary>지정된 ProgID(프로그램 식별자)와 연관된 형식을 지정된 서버에서 가져오고, 형식을 로드하는 동안 오류가 발생하면 null을 반환합니다.</summary>
        <returns><paramref name="progID" />가 유효한 레지스트리 항목이고 형식과 관련되어 있으면 지정된 ProgID(프로그램 식별자)와 관련된 형식을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 제공 하는 COM 지원에 대 한 합니다. 네임 스페이스의 개념에 의해 대체 하기 때문에 Microsoft.NET Framework의 프로그램 Id는 사용 되지 않습니다.  
  
   
  
## Examples  
 다음 예에서는 ProgID 및 서버 이름을 전달 하 여 형식을 검색 합니다. 예제는 다음의 ProgID와 관련 된 ClassID를 표시 또는 ProgID 또는 서버 이름이 유효 하지 않은 경우 예외를 throw 합니다.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="prodID" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">가져올 <see cref="T:System.Type" />의 ProgID입니다.</param>
        <param name="server">형식을 로드할 서버입니다. 서버 이름이 <see langword="null" />이면 이 메서드는 자동으로 로컬 컴퓨터로 전환됩니다.</param>
        <param name="throwOnError">발생하는 예외를 모두 throw하려면 <see langword="true" />입니다.  
  
또는 
 <see langword="false" />는 발생하는 예외를 모두 무시합니다.</param>
        <summary>지정된 ProgID(프로그램 식별자)와 연관된 형식을 지정된 서버에서 가져오고, 형식을 로드하는 동안 오류가 발생하면 예외를 throw할지를 지정합니다.</summary>
        <returns><paramref name="progID" />가 유효한 레지스트리 항목이고 형식과 관련되어 있으면 지정된 ProgID(프로그램 식별자)와 관련된 형식을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 제공 하는 COM 지원에 대 한 합니다. 네임 스페이스의 개념에 의해 대체 하기 때문에 Microsoft.NET Framework의 프로그램 Id는 사용 되지 않습니다.  
  
   
  
## Examples  
 다음 예에서는 ProgID 및 서버 이름을 전달 하 여 형식을 검색 합니다. 다음 예제를 ProgID 또는 서버 이름이 유효 하지 않은 경우 예외를 throw 할지를 지정 된 ProgID와 관련 된 ClassID를 표시 합니다.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">지정된 ProgID가 등록되어 있지 않습니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Type 핸들을 가져올 개체입니다.</param>
        <summary>지정된 개체의 <see cref="T:System.Type" />에 대한 핸들을 가져옵니다.</summary>
        <returns>지정된 <see cref="T:System.Type" />의 <see cref="T:System.Object" />에 대한 핸들입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핸들은는 가져온 응용 프로그램 도메인 에서만 유효 합니다.  
  
   
  
## Examples  
 다음 예제에서는 클래스 정의 `MyClass1`인스턴스를 가져오고 개체의 런타임 핸들을 검색 합니다.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />과 관련된 GUID를 가져옵니다.</summary>
        <value><see cref="T:System.Type" />과 관련된 GUID입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GUID가 사용 하 여 형식을 사용 하 여 연결 된 <xref:System.Runtime.InteropServices.GuidAttribute> 특성입니다.  
  
   
  
## Examples  
 다음 예제에서는 클래스를 만듭니다 `MyClass1` 공용 메서드를 사용 하 여 만듭니다를 `Type` 개체에 해당 하 `MyClass1`, 가져옵니다를 <xref:System.Guid> 구조체를 사용 하 여를 `GUID` 의 속성을 `Type` 클래스.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />이 다른 형식을 포함하거나 참조하는지 여부, 즉 현재 <see cref="T:System.Type" />이 배열 또는 포인터이거나 참조로 전달되는지를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 배열 또는 포인터이거나 참조로 전달되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예를 들어 Type.GetType("Int32[]") 합니다. HasElementType 반환 `true`, 하지만 Type.GetType("Int32") 합니다. HasElementType 반환 `false`합니다. HasElementType 반환 `true` "Int32 *"에 대 한 및 "Int32 &".  
  
 하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수에이 속성은 항상 반환 `false`합니다.  
  
   
  
## Examples  
 다음 예제에서는 반환 `true` 또는 `false` 개체의 배열, 참조 형식 또는 포인터 인지 여부에 따라 합니다.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, <see cref="P:System.Type.HasElementType" /> 속성을 구현하고 현재 <see cref="T:System.Type" />이 다른 형식을 포함하거나 참조하는지 여부, 즉 현재 <see cref="T:System.Type" />이 배열 또는 포인터이거나 참조로 전달되는지를 확인합니다.</summary>
        <returns><see langword="true" />이 배열 또는 포인터이거나 참조로 전달되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예를 들어 Type.GetType("Int32[]") 합니다. 에서는 반환 `true`, 하지만 Type.GetType("Int32") 합니다. 에서는 반환 `false`합니다. 에서는 또한 반환 `true` "Int32 *"에 대 한 및 "Int32 &".  
  
   
  
## Examples  
 다음 예제에서는 클래스를 정의 `MyTypeDelegator`를 재정의 하는 `HasElementTypeImpl` 메서드. 기본 클래스에 대 한 검사는 `HasElementType` 요소 입력 속성을 표시 합니다.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />의 특정 멤버를 호출합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">호출할 생성자, 메서드, 속성 또는 필드 멤버의 이름이 포함된 문자열입니다.  
  
또는 
기본 멤버를 호출하는 빈 문자열("")입니다.  
  
또는 
<see langword="IDispatch" /> 멤버의 경우 DispID를 나타내는 문자열(예: "[DispID=3]")입니다.</param>
        <param name="invokeAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다. 액세스 권한은 <see langword="BindingFlags" />, <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" /> 등과 같은 <see langword="GetField" /> 중 하나가 될 수 있습니다. 조회 형식을 지정할 필요가 없습니다. 조회 형식을 생략하면 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />이 사용됩니다.</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
또는 
<see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다. 변수 인수를 사용하여 메서드 오버로드를 호출하려면 <see cref="T:System.Reflection.Binder" /> 개체를 명시적으로 정의해야 할 수도 있습니다.</param>
        <param name="target">지정한 멤버를 호출할 개체입니다.</param>
        <param name="args">호출할 멤버에 전달하는 인수를 포함하는 배열입니다.</param>
        <summary>지정된 바인딩 제약 조건과 인수 목록을 사용하여 지정된 멤버를 호출합니다.</summary>
        <returns>호출된 멤버의 반환 값을 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  사용할 수 없습니다 <xref:System.Type.InvokeMember%2A> 제네릭 메서드를 호출 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 멤버를 정의할 수 있습니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 멤버를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에서 (즉, private 및 protected 멤버) public이 아닌 멤버를 포함 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 계층 정적 멤버를 포함 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하 여 <xref:System.Type>, 상속 된 멤버가 아닌 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 호출 플래그 멤버를 사용 하 여 수행할 작업을 나타내는 데 사용할 수 있습니다.  
  
-   `CreateInstance` 생성자를 호출 합니다. `name` 무시 됩니다. 다른 호출 플래그를 사용 하 여 유효 하지 않습니다.  
  
-   `InvokeMethod` 생성자 또는 형식 이니셜라이저가 없습니다 메서드를 하지만 호출 합니다. 잘못 된 `SetField` 또는 `SetProperty`합니다. 하는 경우 `InvokeMethod` 자체에 의해 지정 됩니다 `BindingFlags.Public`를 `BindingFlags.Instance`, 및 `BindingFlags.Static` 자동으로 포함 됩니다.  
  
-   `GetField` 에 필드의 값을 가져옵니다. 잘못 된 `SetField`합니다.  
  
-   `SetField` 필드의 값을 설정 합니다. 잘못 된 `GetField`합니다.  
  
-   `GetProperty` 속성을 가져오기 합니다. 잘못 된 `SetProperty`합니다.  
  
-   `SetProperty` 속성을 설정 합니다. 잘못 된 `GetProperty`합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 메서드는 다음 조건이 모두 참인 경우 호출 됩니다.  
  
-   메서드 선언에서 매개 변수 수가 같음의 인수 개수는 `args` 배열 (기본 인수는 멤버에 정의 되지 않은 경우 및 `BindingFlags.OptionalParamBinding` 지정).  
  
-   매개 변수의 형식 바인더를 통해 각 인수의 형식을 변환할 수 있습니다.  
  
 바인더 모든 일치 하는 메서드를 찾을 수 있습니다. 요청 된 바인딩 형식에 따라 이러한 메서드를 찾습니다 (<xref:System.Reflection.BindingFlags> 값 `InvokeMethod`, `GetProperty`등). 메서드의 집합 이름, 인수 개수를 및 바인더에서 정의 된 검색 한정자 집합으로 필터링 됩니다.  
  
 메서드를 선택한 후 호출 됩니다. 이때에 내게 필요한 옵션 확인 됩니다. 검색은 메서드를 사용 하 여 연결 된 내게 필요한 옵션 특성에 따라 검색할 메서드의 집합을 제어할 수 있습니다. 합니다 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 메서드를 <xref:System.Reflection.Binder> 클래스는 메서드를 호출할 수를 선택 하는 일을 담당 합니다. 기본 바인더를 가장 구체적으로 일치를 선택합니다.  
  
 완전히 신뢰할 수 있는 코드에 대 한 액세스 제한이 무시 됩니다. 즉, 개인 생성자, 메서드, 필드 및 속성 액세스 하 고 수를 통해 호출 <xref:System.Reflection> 때마다 코드는 완전히 신뢰할 수 있습니다.  
  
 사용할 수 있습니다 `Type.InvokeMember` 필드를 지정 하 여 특정 값으로 설정 하려면 <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>합니다. 예를 들어, 클래스 C F에 F 라는 공용 인스턴스 필드를 설정 하려는 경우는 `String`와 같은 코드를 사용할 수 있습니다.  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 F가는 `String[]`와 같은 코드를 사용할 수 있습니다.  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 이 새 배열 F 필드가 초기화 됩니다. 사용할 수도 있습니다 `Type.InvokeMember` 다음과 같은 코드를 사용 하 여 값 및 다음 값의 인덱스를 제공 하 여 배열에서 위치를 설정 하려면:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 이 문자열 "z" F "b" 문자열을 포함 하는 배열에서 변경 됩니다.  
  
 호출 하는 경우는 `IDispatch` 멤버의 경우 DispID 멤버 이름 대신 문자열 형식을 사용 하 여 지정할 수 있습니다 "[DispID = # #]"입니다. 예를 들어 MyComMethod dispid가 3 인 경우 문자열을 지정할 수 "[DispID = 3]" 대신 "MyComMethod"입니다. DispID로 멤버를 호출 하는 것은 멤버 이름으로 조회 보다 빠릅니다. 복잡 한 집계 시나리오의 경우 DispID의 경우에 따라 원하는 멤버를 호출 하는 유일한 방법은 합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 멤버의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 `InvokeMember` 형식의 멤버에 액세스 해야 합니다.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" />에 <see langword="CreateInstance" />가 포함되어 있지 않으며 <paramref name="name" />이 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" />이 올바른 <see cref="T:System.Reflection.BindingFlags" /> 특성이 아닙니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" /> 바인딩 플래그 중 하나가 포함되어 있지 않습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="CreateInstance" />가 포함되어 있습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="GetField" />와 <see langword="SetField" />가 둘 다 포함되어 있습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="GetProperty" />와 <see langword="SetProperty" />가 둘 다 포함되어 있습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="SetField" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="InvokeMethod" />가 포함되어 있습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="SetField" />가 포함되어 있으며 <paramref name="args" />에 둘 이상의 요소가 있습니다.  
  
또는 
이 메서드가 COM 개체에 대해 호출되고 다음 바인딩 플래그 중 하나가 <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> 또는 <see langword="BindingFlags.PutRefDispProperty" />로 전달되지 않았습니다.  
  
또는 
명명된 매개 변수 배열 중 하나에 <see langword="null" />인 문자열이 포함되어 있습니다.</exception>
        <exception cref="T:System.MethodAccessException">지정된 멤버가 클래스 이니셜라이저입니다.</exception>
        <exception cref="T:System.MissingFieldException">필드 또는 속성을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="args" />의 인수와 일치하는 메서드를 찾을 수 없습니다.  
  
또는 
현재 <see cref="T:System.Type" /> 개체가 개방형 매개 변수를 포함하는 형식, 즉, <see cref="P:System.Type.ContainsGenericParameters" />가 <see langword="true" />를 반환하는 형식을 나타냅니다.</exception>
        <exception cref="T:System.Reflection.TargetException">지정된 멤버를 <paramref name="target" />에 대해 호출할 수 없습니다.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">두 개 이상의 메서드가 바인딩 기준과 일치합니다.</exception>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework에서는 현재 이 메서드를 지원하지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" />이 나타내는 메서드에 두 개 이상의 제네릭 형식 매개 변수가 지정되지 않았습니다. 즉, 메서드의 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 속성이 <see langword="true" />를 반환합니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">해당 권한 부여에 관계 없이 public이 아닌 멤버에 액세스 하기 위해 다음을 설정 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">호출할 생성자, 메서드, 속성 또는 필드 멤버의 이름이 포함된 문자열입니다.  
  
또는 
기본 멤버를 호출하는 빈 문자열("")입니다.  
  
또는 
<see langword="IDispatch" /> 멤버의 경우 DispID를 나타내는 문자열(예: "[DispID=3]")입니다.</param>
        <param name="invokeAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다. 액세스 권한은 <see langword="BindingFlags" />, <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" /> 등과 같은 <see langword="GetField" /> 중 하나가 될 수 있습니다. 조회 형식을 지정할 필요가 없습니다. 조회 형식을 생략하면 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />이 사용됩니다.</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
또는 
<see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="P:System.Type.DefaultBinder" />)입니다. 변수 인수를 사용하여 메서드 오버로드를 호출하려면 <see cref="T:System.Reflection.Binder" /> 개체를 명시적으로 정의해야 할 수도 있습니다.</param>
        <param name="target">지정한 멤버를 호출할 개체입니다.</param>
        <param name="args">호출할 멤버에 전달하는 인수를 포함하는 배열입니다.</param>
        <param name="culture">사용할 전역화 로캘을 나타내는 개체입니다. 이 개체는 숫자 <see cref="T:System.String" />을 <see cref="T:System.Double" />로 변환하는 등의 로캘별 변환에 사용할 수 있습니다.  
  
또는 
현재 스레드의 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="T:System.Globalization.CultureInfo" />)입니다.</param>
        <summary>지정된 바인딩 제약 조건과 지정된 인수 목록 및 문화권을 사용하여 지정된 멤버를 호출합니다.</summary>
        <returns>호출된 멤버의 반환 값을 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Globalization.CultureInfo> (합니다 `culture` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 는 사용자 지정 처리 하는 바인더를 작성 하는 클래스 `culture`합니다.  
  
> [!NOTE]
>  사용할 수 없습니다 <xref:System.Type.InvokeMember%2A> 제네릭 메서드를 호출 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 멤버를 정의할 수 있습니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 멤버를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에서 (즉,: private, internal 및 protected 멤버) public이 아닌 멤버를 포함 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 계층 정적 멤버를 포함 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하 여 <xref:System.Type>, 상속 된 멤버가 아닌 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 호출 플래그 멤버를 사용 하 여 수행할 작업을 나타내는 데 사용할 수 있습니다.  
  
-   `CreateInstance` 생성자를 호출 합니다. `name` 무시 됩니다. 다른 호출 플래그를 사용 하 여 유효 하지 않습니다.  
  
-   `InvokeMethod` 생성자 또는 형식 이니셜라이저가 없습니다 메서드를 하지만 호출 합니다. 잘못 된 `SetField` 또는 `SetProperty`합니다. 하는 경우 `InvokeMethod` 자체에 의해 지정 됩니다 `BindingFlags.Public`를 `BindingFlags.Instance`, 및 `BindingFlags.Static` 자동으로 포함 됩니다.  
  
-   `GetField` 에 필드의 값을 가져옵니다. 잘못 된 `SetField`합니다.  
  
-   `SetField` 필드의 값을 설정 합니다. 잘못 된 `GetField`합니다.  
  
-   `GetProperty` 속성을 가져오기 합니다. 잘못 된 `SetProperty`합니다.  
  
-   `SetProperty` 속성을 설정 합니다. 잘못 된 `GetProperty`합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 메서드는 다음 조건이 모두 참인 경우 호출 됩니다.  
  
-   메서드 선언에서 매개 변수 수가 같음의 인수 개수는 `args` 배열 (기본 인수는 멤버에 정의 되지 않은 경우 및 `BindingFlags.OptionalParamBinding` 지정).  
  
-   매개 변수의 형식 바인더를 통해 각 인수의 형식을 변환할 수 있습니다.  
  
 바인더 모든 일치 하는 메서드를 찾을 수 있습니다. 요청 된 바인딩 형식에 따라 이러한 메서드를 찾습니다 (<xref:System.Reflection.BindingFlags> 값 `InvokeMethod`, `GetProperty`등). 메서드의 집합 이름, 인수 개수를 및 바인더에서 정의 된 검색 한정자 집합으로 필터링 됩니다.  
  
 메서드를 선택한 후 호출 됩니다. 이때에 내게 필요한 옵션 확인 됩니다. 검색은 메서드를 사용 하 여 연결 된 내게 필요한 옵션 특성에 따라 검색할 메서드의 집합을 제어할 수 있습니다. 합니다 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 메서드를 <xref:System.Reflection.Binder> 클래스는 메서드를 호출할 수를 선택 하는 일을 담당 합니다. 기본 바인더를 가장 구체적으로 일치를 선택합니다.  
  
 완전히 신뢰할 수 있는 코드에 대 한 액세스 제한이 무시 됩니다. 즉, 개인 생성자, 메서드, 필드 및 속성 액세스 하 고 수 코드를 완전히 신뢰할 수 있는 경우 리플렉션을 통해 호출 합니다.  
  
 사용할 수 있습니다 `Type.InvokeMember` 필드를 지정 하 여 특정 값으로 설정 하려면 <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>합니다. 예를 들어, 클래스 C F에 F 라는 공용 인스턴스 필드를 설정 하려는 경우는 `String` 와 같은 코드를 사용할 수 있습니다.  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 F가는 `String[]`와 같은 코드를 사용할 수 있습니다.  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 이 새 배열 F 필드가 초기화 됩니다. 사용할 수도 있습니다 `Type.InvokeMember` 다음과 같은 코드를 사용 하 여 값 및 다음 값의 인덱스를 제공 하 여 배열에서 위치를 설정 하려면:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 이 문자열 "z" F "b" 문자열을 포함 하는 배열에서 변경 됩니다.  
  
 호출 하는 경우는 `IDispatch` 멤버의 경우 DispID 멤버 이름 대신 문자열 형식을 사용 하 여 지정할 수 있습니다 "[DispID = # #]"입니다. 예를 들어 MyComMethod dispid가 3 인 경우 문자열을 지정할 수 "[DispID = 3]" 대신 "MyComMethod"입니다. DispID로 멤버를 호출 하는 것은 멤버 이름으로 조회 보다 빠릅니다. 복잡 한 집계 시나리오의 경우 DispID의 경우에 따라 원하는 멤버를 호출 하는 유일한 방법은 합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 멤버의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" />에 <see langword="CreateInstance" />가 포함되어 있지 않으며 <paramref name="name" />이 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" />이 올바른 <see cref="T:System.Reflection.BindingFlags" /> 특성이 아닙니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" /> 바인딩 플래그 중 하나가 포함되어 있지 않습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="CreateInstance" />가 포함되어 있습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="GetField" />와 <see langword="SetField" />가 둘 다 포함되어 있습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="GetProperty" />와 <see langword="SetProperty" />가 둘 다 포함되어 있습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="SetField" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="InvokeMethod" />가 포함되어 있습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="SetField" />가 포함되어 있으며 <paramref name="args" />에 둘 이상의 요소가 있습니다.  
  
또는 
이 메서드가 COM 개체에 대해 호출되고 다음 바인딩 플래그 중 하나가 <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> 또는 <see langword="BindingFlags.PutRefDispProperty" />로 전달되지 않았습니다.  
  
또는 
명명된 매개 변수 배열 중 하나에 <see langword="null" />인 문자열이 포함되어 있습니다.</exception>
        <exception cref="T:System.MethodAccessException">지정된 멤버가 클래스 이니셜라이저입니다.</exception>
        <exception cref="T:System.MissingFieldException">필드 또는 속성을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="args" />의 인수와 일치하는 메서드를 찾을 수 없습니다.  
  
또는 
현재 <see cref="T:System.Type" /> 개체가 개방형 매개 변수를 포함하는 형식, 즉, <see cref="P:System.Type.ContainsGenericParameters" />가 <see langword="true" />를 반환하는 형식을 나타냅니다.</exception>
        <exception cref="T:System.Reflection.TargetException">지정된 멤버를 <paramref name="target" />에 대해 호출할 수 없습니다.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">두 개 이상의 메서드가 바인딩 기준과 일치합니다.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" />이 나타내는 메서드에 두 개 이상의 제네릭 형식 매개 변수가 지정되지 않았습니다. 즉, 메서드의 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 속성이 <see langword="true" />를 반환합니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">해당 권한 부여에 관계 없이 public이 아닌 멤버에 액세스 하기 위해 다음을 설정 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">호출할 생성자, 메서드, 속성 또는 필드 멤버의 이름이 포함된 문자열입니다.  
  
또는 
기본 멤버를 호출하는 빈 문자열("")입니다.  
  
또는 
<see langword="IDispatch" /> 멤버의 경우 DispID를 나타내는 문자열(예: "[DispID=3]")입니다.</param>
        <param name="invokeAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다. 액세스 권한은 <see langword="BindingFlags" />, <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" /> 등과 같은 <see langword="GetField" /> 중 하나가 될 수 있습니다. 조회 형식을 지정할 필요가 없습니다. 조회 형식을 생략하면 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />이 사용됩니다.</param>
        <param name="binder">속성 집합을 정의하고 바인딩을 활성화하는 개체입니다. 이 개체는 또한 리플렉션을 통해 오버로드된 메서드를 선택할 수 있고 인수 형식을 강제 변환할 수 있으며 멤버를 호출할 수도 있습니다.  
  
또는 
<see cref="P:System.Type.DefaultBinder" />를 사용할 null 참조(Visual Basic에는 없음)입니다. 변수 인수를 사용하여 메서드 오버로드를 호출하려면 <see cref="T:System.Reflection.Binder" /> 개체를 명시적으로 정의해야 할 수도 있습니다.</param>
        <param name="target">지정한 멤버를 호출할 개체입니다.</param>
        <param name="args">호출할 멤버에 전달하는 인수를 포함하는 배열입니다.</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 배열에서 해당하는 요소와 연관된 특성을 나타내는 <paramref name="args" /> 개체 배열입니다. 매개 변수의 관련 특성은 해당 멤버의 시그니처에 저장됩니다.  
  
기본 바인더는 COM 구성 요소를 호출하는 경우에만 이 매개 변수를 처리합니다.</param>
        <param name="culture">사용할 전역화 로캘을 나타내는 <see cref="T:System.Globalization.CultureInfo" /> 개체입니다. 이 개체는 숫자 String을 Double로 변환하는 등의 로캘 관련 변환에 사용할 수 있습니다.  
  
또는 
현재 스레드의 <see langword="Nothing" />를 사용하려면 null 참조(Visual Basic의 경우 <see cref="T:System.Globalization.CultureInfo" />)입니다.</param>
        <param name="namedParameters"><paramref name="args" /> 배열의 값이 전달될 매개 변수의 이름이 있는 배열입니다.</param>
        <summary>파생 클래스에서 재정의되면, 지정된 바인딩 제약 조건과 지정된 인수 목록, 한정자 및 문화권을 사용하여 지정된 멤버를 호출합니다.</summary>
        <returns>호출된 멤버의 반환 값을 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` 생성자 멤버 또는 메서드 멤버를 호출, 가져옵니다 또는 속성 멤버를 설정, 또는 데이터 필드 멤버, 집합 또는 가져옵니다 가져오거나 배열 멤버의 요소.  
  
> [!NOTE]
>  사용할 수 없습니다 <xref:System.Type.InvokeMember%2A> 제네릭 메서드를 호출 합니다.  
  
 호출 하는 경우는 `IDispatch` 멤버의 경우 DispID 멤버 이름 대신 문자열 형식을 사용 하 여 지정할 수 있습니다 "[DispID = # #]"입니다. 예를 들어 MyComMethod dispid가 3 인 경우 문자열을 지정할 수 "[DispID = 3]" 대신 "MyComMethod"입니다. DispID로 멤버를 호출 하는 것은 멤버 이름으로 조회 보다 빠릅니다. 복잡 한 집계 시나리오의 경우 DispID의 경우에 따라 원하는 멤버를 호출 하는 유일한 방법은 합니다.  
  
 기본 바인더를 처리 하지 않습니다 하지만 <xref:System.Reflection.ParameterModifier> 또는 <xref:System.Globalization.CultureInfo> (합니다 `modifiers` 및 `culture` 매개 변수), 추상을 사용할 수 있습니다 <xref:System.Reflection.Binder?displayProperty=nameWithType> 클래스에서 처리 하는 사용자 지정 바인더를 작성할 `modifiers` 및 `culture`. `ParameterModifier` COM interop를 통해 호출 하는 경우에 사용 되는 참조로 전달 되는 매개 변수만 처리 됩니다.  
  
 `namedParameters` 배열의 각 매개 변수는 `args` 배열의 해당 요소에 있는 값을 가져옵니다. `args`의 길이가 `namedParameters`의 길이보다 크면 남은 인수 값이 순서대로 전달됩니다.  
  
 `namedParameters` 배열 입력 배열의 인수 순서를 변경 하려면 사용할 수 있습니다. 예를 들어 메서드를 제공 `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` Visual Basic의) 및 입력된 배열의 `{ 42, "x" }`, 입력된 배열이 변경 되지 않고 전달 될 수 있습니다 `args` 경우 배열 `{ "b", "a" }` 제공 되어 `namedParameters`.  
  
 다음 <xref:System.Reflection.BindingFlags> 필터 플래그를 사용 하 여 검색에 포함할 멤버를 정의할 수 있습니다.  
  
-   지정 `BindingFlags.Public` 검색에 public 멤버를 포함 합니다.  
  
-   지정 `BindingFlags.NonPublic` 검색에서 (즉,: private, internal 및 protected 멤버) public이 아닌 멤버를 포함 합니다.  
  
-   지정 `BindingFlags.FlattenHierarchy` 계층 정적 멤버를 포함 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 한정자 플래그를 사용 하 여 검색의 작동 방식을 변경할 수 있습니다.  
  
-   `BindingFlags.IgnoreCase` 대/소문자를 무시 하려면 `name`합니다.  
  
-   `BindingFlags.DeclaredOnly` 에 선언 된 멤버만 검색 하 여 <xref:System.Type>, 상속 된 멤버가 아닌 합니다.  
  
 다음 <xref:System.Reflection.BindingFlags> 호출 플래그 멤버를 사용 하 여 수행할 작업을 나타내는 데 사용할 수 있습니다.  
  
-   `CreateInstance` 생성자를 호출 합니다. `name` 무시 됩니다. 다른 호출 플래그를 사용 하 여 유효 하지 않습니다.  
  
-   `InvokeMethod` 생성자 또는 형식 이니셜라이저가 없습니다 메서드를 하지만 호출 합니다. 잘못 된 `SetField` 또는 `SetProperty`합니다. 하는 경우 `InvokeMethod` 자체에 의해 지정 됩니다 `BindingFlags.Public`를 `BindingFlags.Instance`, 및 `BindingFlags.Static` 자동으로 포함 됩니다.  
  
-   `GetField` 에 필드의 값을 가져옵니다. 잘못 된 `SetField`합니다.  
  
-   `SetField` 필드의 값을 설정 합니다. 잘못 된 `GetField`합니다.  
  
-   `GetProperty` 속성을 가져오기 합니다. 잘못 된 `SetProperty`합니다.  
  
-   `SetProperty` 속성을 설정 합니다. 잘못 된 `GetProperty`합니다.  
  
 자세한 내용은 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>를 참조하세요.  
  
 메서드는 다음 조건이 모두 참인 경우 호출 됩니다.  
  
-   메서드 선언에서 매개 변수 수가 같음의 인수 개수는 `args` 배열 (기본 인수는 멤버에 정의 되지 않은 경우 및 `BindingFlags.OptionalParamBinding` 지정).  
  
-   매개 변수의 형식 바인더를 통해 각 인수의 형식을 변환할 수 있습니다.  
  
 바인더 모든 일치 하는 메서드를 찾을 수 있습니다. 요청 된 바인딩 형식에 따라 이러한 메서드를 찾습니다 (<xref:System.Reflection.BindingFlags> 값 `InvokeMethod`, `GetProperty`등). 메서드의 집합 이름, 인수 개수를 및 바인더에서 정의 된 검색 한정자 집합으로 필터링 됩니다.  
  
 메서드를 선택한 후 호출 됩니다. 이때에 내게 필요한 옵션 확인 됩니다. 검색은 메서드를 사용 하 여 연결 된 내게 필요한 옵션 특성에 따라 검색할 메서드의 집합을 제어할 수 있습니다. 합니다 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 메서드를 <xref:System.Reflection.Binder> 클래스는 메서드를 호출할 수를 선택 하는 일을 담당 합니다. 기본 바인더를 가장 구체적으로 일치를 선택합니다.  
  
 `InvokeMember` 기본값이 있는 매개 변수를 사용 하 여 메서드를 호출할 수 있습니다. 이러한 메서드에 바인딩할 리플렉션 해야 <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> 를 지정 해야 합니다. 기본값이 있는 매개 변수에 다른 값을 제공 하거나 제공 <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> 에 기본값을 사용 합니다.  
  
 예를 들어 MyMethod와 같은 메서드 (int x, y float 2.0 =) 합니다. MyMethod(4)로 첫 번째 인수에만 사용 하 여이 메서드를 호출 하려면 위의 바인딩 플래그 중 하나를 전달 하 고 첫 번째 인수에 대 한 4 즉, 두 가지 인수를 전달 하 고 `Missing.Value` 두 번째 인수에 대 한 합니다. 사용 하지 않는 경우 `Missing.Value`를 사용 하 여 선택적 매개 변수를 생략할 수 없습니다는 `Invoke` 메서드. 이렇게 해야 하는 경우 사용 하 여 `InvokeMember` 대신 합니다.  
  
 완전히 신뢰할 수 있는 코드에 대 한 액세스 제한이 무시 됩니다. 즉, 개인 생성자, 메서드, 필드 및 속성 액세스 하 고 수를 통해 호출 <xref:System.Reflection> 때마다 코드는 완전히 신뢰할 수 있습니다.  
  
 사용할 수 있습니다 `Type.InvokeMember` 필드를 지정 하 여 특정 값으로 설정 하려면 <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>합니다. 예를 들어, 클래스 C F에 F 라는 공용 인스턴스 필드를 설정 하려는 경우는 `String`와 같은 코드를 사용할 수 있습니다.  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 F가는 `String[]`와 같은 코드를 사용할 수 있습니다.  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 이 새 배열 F 필드가 초기화 됩니다. 사용할 수도 있습니다 `Type.InvokeMember` 다음과 같은 코드를 사용 하 여 값 및 다음 값의 인덱스를 제공 하 여 배열에서 위치를 설정 하려면:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 이 문자열 "z" F "b" 문자열을 포함 하는 배열에서 변경 됩니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 멤버의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" />에 <see langword="CreateInstance" />가 포함되어 있지 않으며 <paramref name="name" />이 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="args" />와 <paramref name="modifiers" />의 길이가 동일하지 않습니다.  
  
또는 
 <paramref name="invokeAttr" />이 올바른 <see cref="T:System.Reflection.BindingFlags" /> 특성이 아닙니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" /> 바인딩 플래그 중 하나가 포함되어 있지 않습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="CreateInstance" />가 포함되어 있습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="GetField" />와 <see langword="SetField" />가 둘 다 포함되어 있습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="GetProperty" />와 <see langword="SetProperty" />가 둘 다 포함되어 있습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="SetField" /> 또는 <see langword="SetProperty" />와 결합된 <see langword="InvokeMethod" />가 포함되어 있습니다.  
  
또는 
 <paramref name="invokeAttr" />에 <see langword="SetField" />가 포함되어 있으며 <paramref name="args" />에 둘 이상의 요소가 있습니다.  
  
또는 
명명된 매개 변수 배열이 인수 배열보다 큽니다.  
  
또는 
이 메서드가 COM 개체에 대해 호출되고 다음 바인딩 플래그 중 하나가 <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> 또는 <see langword="BindingFlags.PutRefDispProperty" />로 전달되지 않았습니다.  
  
또는 
명명된 매개 변수 배열 중 하나에 <see langword="null" />인 문자열이 포함되어 있습니다.</exception>
        <exception cref="T:System.MethodAccessException">지정된 멤버가 클래스 이니셜라이저입니다.</exception>
        <exception cref="T:System.MissingFieldException">필드 또는 속성을 찾을 수 없습니다.</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="args" />의 인수와 일치하는 메서드를 찾을 수 없습니다.  
  
또는 
인수 이름이 제공된 멤버를 <paramref name="namedParameters" />에서 찾을 수 없습니다.  
  
또는 
현재 <see cref="T:System.Type" /> 개체가 개방형 매개 변수를 포함하는 형식, 즉, <see cref="P:System.Type.ContainsGenericParameters" />가 <see langword="true" />를 반환하는 형식을 나타냅니다.</exception>
        <exception cref="T:System.Reflection.TargetException">지정된 멤버를 <paramref name="target" />에 대해 호출할 수 없습니다.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">두 개 이상의 메서드가 바인딩 기준과 일치합니다.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" />이 나타내는 메서드에 두 개 이상의 제네릭 형식 매개 변수가 지정되지 않았습니다. 즉, 메서드의 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 속성이 <see langword="true" />를 반환합니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">해당 권한 부여에 관계 없이 public이 아닌 멤버에 액세스 하기 위해 다음을 설정 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 추상이며 재정의되어야 하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Type" />이 추상이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Type.IsAbstract%2A> 속성이 반환 `true` 다음과 같은 경우:  
  
-   현재 형식이 추상; 즉, 인스턴스화할 수 없으며, 되지만 파생된 클래스에 대 한 기본 클래스로 사용할 수 있습니다. C#에서 추상 클래스는 표시 됩니다는 [추상](~/docs/csharp/language-reference/keywords/abstract.md) 키워드를 사용 하 여 표시 된 Visual basic에서는 합니다 [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) 키워드.  
  
-   현재 형식이 인터페이스입니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 다음 예제에서는 배열을 <xref:System.Type> 다음 형식을 나타내는 개체: 형식 반환을 포함 `true` 지정 된 개체가 `abstract`이 고, 그렇지 않으면 반환 `false`합니다.  
  
-   `AbstractClass`추상 클래스 (클래스로 표시 `abstract` C# 및 `MustInherit` Visual basic에서).  
  
-   `DerivedClass`를 클래스에서 상속 되는 `AbstractClass`합니다.  
  
-   `SingleClass`에서 상속할 수 없는 클래스입니다. 로 정의 되어 있으므로 `sealed` C# 및 `NotInheritable` Visual Basic의 합니다.  
  
-   `ITypeInfo`에 인터페이스입니다.  
  
-   `ImplementingClass`를 구현 하는 클래스는 `ITypeInfo` 인터페이스입니다.  
  
 메서드는 반환 `true` 동안만 `AbstractClass`, 추상 클래스 및 `ITypeInfo`, 인터페이스입니다.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="AnsiClass" />에 대해 문자열 형식 특성 <see cref="T:System.Type" />가 선택되었는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />에 대해 문자열 형식 특성 <see langword="AnsiClass" />가 선택되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> 문자열 형식 특성을 선택 합니다. 문자열을 해석할 방법을 정의 하 여 상호 운용성을 개선 하는 문자열 형식 특성입니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 합니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 다음 예에서는 필드 정보를 가져와 확인 된 `AnsiClass` 특성입니다.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>유형이 배열인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>현재 유형이 배열이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Type.IsArray%2A> 속성이 반환 `false` 에 대 한는 <xref:System.Array> 클래스입니다. 또한 반환 `false` 현재 인스턴스가 <xref:System.Type> 컬렉션 형식 또는 컬렉션과 같은 작동 하도록 디자인 된 인터페이스를 나타내는 개체입니다 <xref:System.Collections.IEnumerable> 또는 <xref:System.Collections.Generic.IEnumerable%601>합니다.  
  
 배열에 대해 검사할 코드를 같이 사용 합니다.  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 이 속성은 항상 현재 형식이 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수나 제네릭 형식을 나타내면 `false`합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Type.IsArray%2A> 속성입니다.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, <see cref="P:System.Type.IsArray" /> 속성을 구현하고 <see cref="T:System.Type" />이 배열인지를 확인합니다.</summary>
        <returns><see langword="true" />이 배열이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인스턴스를 <xref:System.Array> 클래스를 반환 해야 `false` 배열이 아닌 개체 이기 때문에 합니다.  
  
   
  
## Examples  
 다음 예제에서는 재정의 `IsArrayImpl` 의 메서드는 `MyTypeDelegator` 클래스 변수 배열 및 결과 표시 하는지 확인 합니다.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">현재 형식과 비교할 형식입니다.</param>
        <summary>지정한 형식의 인스턴스를 현재 형식의 인스턴스에 할당할 수 있는지 여부를 결정합니다.</summary>
        <returns>다음 조건 중 하나 이상이 true일 경우 <see langword="true" />입니다. 
-   <paramref name="c" /> 및 현재 인스턴스가 동일한 형식으로 나타납니다.  
  
-   <paramref name="c" />가 현재 인스턴스에서 직접 또는 간접으로 파생됩니다. 현재 인스턴스에서 상속하는 경우 <paramref name="c" />는 현재 인스턴스에서 직접 파생되며 현재 인스턴스에서 상속하는 하나 이상의 클래스의 연속에서 상속하는 경우 <paramref name="c" />는 현재 인스턴스에서 직접 파생됩니다.  
  
-  현재 인스턴스는 <paramref name="c" />를 구현하는 인터페이스입니다.  
  
-   <paramref name="c" />는 제네릭 형식 매개 변수이며, 현재 인스턴스는 <paramref name="c" />의 제약 조건 중 하나를 나타냅니다.  
  
다음 예제에서 현재 인스턴스는 <see cref="T:System.IO.Stream" /> 클래스를 나타내는 <see cref="T:System.Type" /> 개체입니다. <c>GenericWithConstraint</c>는 제네릭 형식 매개 변수가 <see cref="T:System.IO.Stream" /> 형식이어야 하는 제네릭 형식입니다. <see cref="M:System.Type.IsAssignableFrom(System.Type)" />에 제네릭 형식 매개 변수를 전달하는 것은 제네릭 형식 매개 변수의 인스턴스를 <see cref="T:System.IO.Stream" /> 개체에 할당할 수 있음을 나타냅니다.  
  
[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)] 
-   <paramref name="c" />는 값 유형을 나타내며 현재 인스턴스는 <c>Nullable&lt;c&gt;</c>(Visual Basic에서 <c>Nullable(Of c)</c>)를 나타냅니다.  
  
 이러한 조건에 해당하지 않거나 <paramref name="c" />가 <see langword="false" />이면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Type.IsAssignableFrom%2A> 인스턴스의 여부를 확인 하려면 메서드를 사용할 수 `c` 할당할 수 있습니다 현재 형식의 인스턴스에 메서드 디자인 타임에 형식이 알려지지 않은 개체를 처리 하는 경우 가장 유용 하 고 조건부 허용 다음 예제와 같이 할당을 보여 줍니다.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 이 메서드 따라서를 사용 하면 다음이 런타임에 throw 하지 않고 실행 됩니다와 같은 코드 줄을 <xref:System.InvalidCastException> 예외 또는 유사한 예외:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
> [!NOTE]
>  제네릭 형식 정의 폐쇄형된 생성된 형식에서 할당할 수 없는 경우. 즉, 폐쇄형된 생성된 형식을 할당할 수 없습니다 `MyGenericList<int>` (`MyGenericList(Of Integer)` Visual basic에서) 형식의 변수에 `MyGenericList<T>`합니다.  
  
 경우는 `c` 매개 변수는 형식 <xref:System.Reflection.Emit.TypeBuilder>, 결과 빌드하는 형식에 기반 합니다. 다음 코드 예제에서는이 라는 기본 제공된 형식을 사용 하 여 `B`입니다.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 다음 예제는 `IsAssignableFrom` 정의 된 클래스, 정수 배열 및 제네릭 메서드를 사용 하 여 합니다.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="AutoClass" />에 대해 문자열 형식 특성 <see cref="T:System.Type" />가 선택되었는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />에 대해 문자열 형식 특성 <see langword="AutoClass" />가 선택되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> 문자열 형식 특성을 선택 합니다. 문자열을 해석할 방법을 정의 하 여 상호 운용성을 개선 하는 문자열 형식 특성입니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식의 필드가 공용 언어 런타임에 의해 자동으로 배치되는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 형식의 <see langword="true" /> 속성에 <see cref="P:System.Type.Attributes" />이 포함되어 있으면 <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 편의 위해 제공 됩니다. 사용할 수 있습니다는 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 열거형 값 형식 레이아웃 특성 및 다음 테스트를 여부 선택 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> 설정 됩니다. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, 및 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 열거형 값 형식의 필드는 메모리에 배치 하는 방법을 나타냅니다.  
  
 동적 형식에 대해 지정할 수 있습니다 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> 유형을 만들 때. 코드에 적용 합니다 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 특성을 <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> 클래스의 레이아웃에 적절 한 방법을 결정 하는 런타임 수 있도록 형식에 열거형 값입니다.  
  
> [!NOTE]
>  사용할 수 없습니다는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 결정 하는 방법 여부를 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 형식에 적용 된 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>.`  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 다음 예제에서는 형식의 인스턴스를 만들고 표시는 <xref:System.Type.IsAutoLayout%2A> 속성입니다.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">메타데이터 및 자동 기술 구성 요소</related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 참조로 전달되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 참조로 전달되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 실제 형식으로 가져오려고 역참조 참조로 전달 된 형식 및 호출 <xref:System.Type.GetElementType%2A> 해당 형식에 있습니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법을 보여 줍니다는 `IsByRef` 속성을 지정된 된 형식 참조로 전달 되는지 여부를 확인 합니다. 이 예제에서는 클래스를 정의 `MyTypeDelegator`를 재정의 하는 `HasElementTypeImpl` 메서드. 기본 클래스에 대 한 검사는 `HasElementType` 요소 입력 속성을 표시 합니다.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, <see cref="P:System.Type.IsByRef" /> 속성을 구현하고 <see cref="T:System.Type" />이 참조로 전달되는지를 확인합니다.</summary>
        <returns><see langword="true" />이 참조로 전달되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 클래스 혹은 대리자인지, 즉 값 형식 또는 인터페이스가 아닌지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 클래스이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 반환 `true` 대리자 뿐만 아니라 클래스에 대 한 합니다. 반환 `false` 형식에 대해 값 (구조 및 enumeration) boxed 됩니다 하는 경우에 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `true`합니다. 하는 경우 현재 <xref:System.Type> 이 속성을 반환 합니다. 생성된 된 제네릭 형식을 나타내는 `true` 제네릭 형식 정의가 클래스 정의; 경우 즉, 정의 하지 않습니다 인터페이스 또는 값 형식입니다.  
  
> [!NOTE]
>  이 속성은 반환 `true` 에 대 한 `Type` 나타내는 인스턴스를 <xref:System.Enum> 및 <xref:System.ValueType> 클래스입니다. 이러한 두 클래스는 각각 된 열거형에 대 한 기본 형식 및 값 형식에 있지만 열거형 또는 값 형식 자체는 없습니다. 자세한 내용은 참조는 <xref:System.Type.IsValueType%2A> 및 <xref:System.Type.IsEnum%2A> 속성입니다.  
  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> 클래스 또는 인터페이스 형식 선언의 구별 하는 열거형 값입니다. 그러나 클래스 및 값 형식이 둘 다로 표시 됩니다는는 <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> 특성입니다. 형식의 특성 속성을 사용 하 여 값을 검색 하는 경우는 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> 도 호출 해야 합니다는 형식이 값 형식이 아닌 클래스 인지 확인 하는 값을 <xref:System.Type.IsValueType%2A> 속성입니다. 에 대 한 예제는 <xref:System.Reflection.TypeAttributes> 열거형 anexample 뿐만 아니라 추가 정보를 포함 합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제에서는 형식의 인스턴스를 만들고이 형식이 클래스 인지를 나타냅니다.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 COM 개체인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 COM 개체이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 반환 `false` 개체 하지 않기 때문에 COM 인터페이스에 대 한 합니다. Microsoft.NET Framework 개체에서 COM 인터페이스를 구현할 수 있습니다.  
  
 또한 COM 클래스를 로드 하 고 받을 수는 `Type` 를 사용 하 여 해당 COM 클래스에 대 한 개체를 [Tlbimp.exe (형식 라이브러리 가져오기)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) 도구.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int`> (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, <see cref="P:System.Type.IsCOMObject" /> 속성을 구현하고 <see cref="T:System.Type" />이 COM 개체인지를 확인합니다.</summary>
        <returns><see langword="true" />이 COM 개체이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 반환 `false` 개체 하지 않기 때문에 COM 인터페이스에 대 한 합니다. Microsoft.NET Framework 개체에서 COM 인터페이스를 구현할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 개체가 생성된 제네릭 형식을 나타내는지를 지정하는 값을 가져옵니다. 생성된 제네릭 형식의 인스턴스를 만들 수 있습니다.</summary>
        <value>이 개체가 생성된 제네릭 형식을 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 생성된 된 제네릭 형식을 명시적 형식을 해당 제네릭 형식 매개 변수를 모두 제공 했습니다. 이 닫힌된 제네릭 형식을 라고도 합니다.  
  
 이 속성이 `true`, 현재 형식의 인스턴스를 만들 수 있습니다. 즉, 경우 `false`를 할 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 컨텍스트에서 호스팅될 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Type" />이 컨텍스트에서 호스팅될 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨텍스트는 클래스 멤버에 대 한 호출을 가로채서 동기화와 같이 클래스에 적용 되는 정책을 적용 합니다. 원격 컨텍스트에 대 한 정보를 자세한 참조 <xref:System.Runtime.Remoting.Contexts.Context>합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 다음 예제는 `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, 및 <xref:System.Type.IsPrimitive%2A> 의 속성을 <xref:System.Type> 클래스. 그리고 형식은 기본 데이터 형식을 참조로 마샬링할 수 인지 컨텍스트에서 지정된 된 형식의 호스팅할 수 있는지 여부를 확인 합니다.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Type.IsContextful" /> 속성을 구현하고, <see cref="T:System.Type" />이 컨텍스트에서 호스팅될 수 있는지 여부를 확인합니다.</summary>
        <returns><see cref="T:System.Type" />이 컨텍스트에서 호스팅될 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
 컨텍스트는 클래스 멤버에 대 한 호출을 가로채서 동기화와 같이 클래스에 적용 되는 정책을 적용 합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법을 보여 줍니다는 `IsContextfulImpl` 메서드.  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 열거형을 나타내는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>현재 <see langword="true" />이 열거형을 나타내면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 반환 `true` 열거형에 대 한는 <xref:System.Enum> 자체를 입력 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 `IsEnum` 속성입니다.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">테스트할 값입니다.</param>
        <summary>현재 열거형 형식에 지정된 값이 있는지를 나타내는 값을 반환합니다.</summary>
        <returns>지정된 값이 현재 열거형 형식의 멤버이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">현재 형식은 열거형이 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" />는 열거형의 기본 형식이 될 수 없는 형식입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">현재 형식과 같은지 테스트되는 COM 형식입니다.</param>
        <summary>두 COM 형식이 같은 ID를 갖고 동일 형식이 될 수 있는지를 확인합니다.</summary>
        <returns>COM 형식이 현재 형식과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 한 형식은 실행하기 위해 로드된 어셈블리에 있고 나머지 형식은 리플렉션 전용 컨텍스트로 로드된 어셈블리에 있는 경우에도 이 메서드는 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], interop에서 COM 형식에 대 한 형식 정보를 얻기 위해 관리 되는 어셈블리를 요구 하는 대신 관리 되는 어셈블리에 직접 COM 형식에 대 한 형식 정보를 포함 하는 공용 언어 런타임 지원 어셈블리입니다. 포함된 형식 정보에는 관리되는 어셈블리에서 실제로 사용되는 형식 및 멤버만 포함되므로 두 개의 관리되는 어셈블리에서 동일한 COM 형식이 전혀 다르게 표시될 수 있습니다. 관리되는 어셈블리마다 COM 형식의 해당 보기를 나타내는 다른 <xref:System.Type> 개체가 있습니다. 공용 언어 런타임은 인터페이스, 구조체, 열거형 및 대리자에 대한 이러한 다양한 보기 간에 형식 동등을 지원합니다.  
  
 형식 동등은 관리되는 어셈블리 간에 전달되는 COM 개체를 수신 어셈블리에서 적절한 관리되는 형식으로 캐스팅할 수 있음을 의미합니다. <xref:System.Type.IsEquivalentTo%2A> 메서드 다른 어셈블리에서 가져온 COM 개체에 첫 번째 어셈블리의 자체 포함 된 interop 형식 중 하나로 동일한 COM id를 확인 하려면 어셈블리를 사용 하도록 설정 하 고 있으므로 해당 형식으로 캐스팅 될 수 있습니다.  
  
 자세한 내용은 [형식 동등 및 포함 된 Interop 형식](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식의 필드가 명시적으로 지정된 오프셋에 배치되는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 형식의 <see langword="true" /> 속성에 <see cref="P:System.Type.Attributes" />이 포함되어 있으면 <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 편의 위해 제공 됩니다. 사용할 수 있습니다는 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 열거형 값 형식 레이아웃 특성 및 다음 테스트를 여부 선택 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> 설정 됩니다. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, 및 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 열거형 값 형식의 필드는 메모리에 배치 하는 방법을 나타냅니다.  
  
 동적 형식에 대해 지정할 수 있습니다 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> 유형을 만들 때. 코드에 적용 합니다 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 특성과 <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> 열거형 값을 필드에서 시작할 오프셋을 명시적으로 지정 되어 있는지를 지정 하는 형식으로 합니다.  
  
> [!NOTE]
>  사용할 수 없습니다는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 결정 하는 방법 여부를 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 형식에 적용 된 합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 다음 예제에서는 형식의 인스턴스를 만들고 값을 표시는 <xref:System.Type.IsExplicitLayout%2A> 속성입니다. 사용 된 `MySystemTime` 클래스에 대 한 코드 예제는 <xref:System.Runtime.InteropServices.StructLayoutAttribute>합니다.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">메타데이터 및 자동 기술 구성 요소</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />이 제네릭 형식 또는 메서드 정의의 형식 매개 변수를 나타내는지를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Type" /> 개체가 제네릭 형식 정의나 메서드 정의의 형식 매개 변수를 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> 제네릭 형식 매개 변수를 나타내는 개체를 호출 하 여 얻을 수 있습니다는 <xref:System.Type.GetGenericArguments%2A> 메서드를 <xref:System.Type> 제네릭 형식 정의 나타내는 개체 또는 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> 메서드의 <xref:System.Reflection.MethodInfo> 제네릭 메서드를 나타내는 개체 정의 합니다.  
  
-   제네릭 형식 또는 메서드 정의 <xref:System.Type.IsGenericParameter%2A> 속성이 반환 `true` 결과 배열의 모든 요소에 대 한 합니다.  
  
-   폐쇄형된 생성된 형식 또는 메서드를 실행 하는 것에 대 한 합니다 <xref:System.Type.IsGenericParameter%2A> 속성이 반환 `false` 에서 반환 된 배열의 모든 요소에 대 한는 <xref:System.Type.GetGenericArguments%2A> 메서드.  
  
-   개방형 생성된 형식 또는 메서드를 실행 하는 것에 대 한 몇 가지 배열 요소의 특정 형식일 수 있습니다 및 형식 매개 변수를 되기도 합니다. <xref:System.Type.IsGenericParameter%2A> 반환 `false` 유형에 대 한 및 `true` 형식 매개 변수입니다. 에 대 한 코드 예제는 <xref:System.Type.ContainsGenericParameters%2A> 속성 형식 및 형식 매개 변수 혼합 하 여 제네릭 클래스를 보여 줍니다.  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Type.IsGenericParameter%2A> 제네릭 형식에 제네릭 형식 매개 변수에 대해 테스트할 속성입니다.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">리플렉션 및 제네릭 형식</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식이 제네릭 형식인지를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" /> 현재 형식이 제네릭 형식의 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Type.IsGenericType%2A> 속성을 여부를 <xref:System.Type> 개체 제네릭 형식을 나타냅니다. 사용 하 여는 <xref:System.Type.ContainsGenericParameters%2A> 속성을 확인 하는지 여부를 <xref:System.Type> 개방형 생성된 형식 또는 폐쇄형된 생성된 형식 개체를 나타냅니다.  
  
> [!NOTE]
>  합니다 <xref:System.Type.IsGenericType%2A> 속성이 반환 `false` 직접적인 형식 제네릭이 아닌 경우. 예를 들어 형식 요소가 들어 있는 배열을 `A<int>` (`A(Of Integer)` Visual Basic의)이 자체는 제네릭 형식입니다.  
  
 다음 표에서 제네릭 리플렉션에 사용 되는 일반적인 용어에 대 한 고정 조건입니다.  
  
|용어|고정|  
|----------|---------------|  
|제네릭 형식 정의(generic type definition)|<xref:System.Type.IsGenericTypeDefinition%2A> 속성은 `true`입니다.<br /><br /> 제네릭 형식을 정의합니다. 생성된 된 형식을 호출 하 여 만든 합니다 <xref:System.Type.MakeGenericType%2A> 메서드는 <xref:System.Type> 제네릭 형식 정의 나타내는 개체를 형식 인수의 배열을 지정 하 합니다.<br /><br /> <xref:System.Type.MakeGenericType%2A> 제네릭 형식 정의에 호출할 수 있습니다.<br /><br /> 모든 제네릭 형식 정의 제네릭 형식 (합니다 <xref:System.Type.IsGenericType%2A> 속성은 `true`), 그 반대도 마찬가지로 true 이지만 합니다.|  
|제네릭 형식(generic type)|<xref:System.Type.IsGenericType%2A> 속성은 `true`입니다.<br /><br /> 제네릭 형식 정의 개방형 생성된 형식, 또는 폐쇄형된 생성된 형식 수 있습니다.<br /><br /> 배열 형식은 요소 형식이 제네릭 인지는 제네릭 형식 자체가 없습니다. 마찬가지는 <xref:System.Type> 제네릭 형식에 대 한 포인터를 나타내는 개체입니다.|  
|개방형 생성된 형식|<xref:System.Type.ContainsGenericParameters%2A> 속성은 `true`입니다.<br /><br /> 할당 되지 않은 형식 매개 변수는 제네릭 형식, 제네릭 형식 정의 또는 개방형 생성된 형식, 중첩 된 형식 또는는 형식 인수가 있는 제네릭 형식을 예로 합니다 <xref:System.Type.ContainsGenericParameters%2A> 속성은 `true`합니다.<br /><br /> 개방형 생성된 형식 인스턴스의 생성 하는 것이 불가능 합니다.<br /><br /> 모든 열려 있지 않은 생성 된 형식 제네릭는 note 합니다. 예를 들어, 요소 형식이 제네릭 형식 정의 배열을 제네릭인 및 개방형 생성된 형식에 대 한 포인터는 제네릭이 아닙니다.|  
|폐쇄형된 생성된 형식|<xref:System.Type.ContainsGenericParameters%2A> 속성은 `false`입니다.<br /><br /> 재귀적으로 검사 형식에 할당 되지 않은 제네릭 매개 변수가 없는 경우.|  
|제네릭 형식 매개 변수(generic type parameter)|<xref:System.Type.IsGenericParameter%2A> 속성은 `true`입니다.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 속성은 `true`입니다.<br /><br /> 제네릭 형식 정의 나중에 할당할 수 있는 형식에 대 한 자리 표시자입니다.|  
|제네릭 형식 인수(generic type argument)|제네릭 형식 매개 변수를 포함 하 여 형식일 수 있습니다.<br /><br /> 형식 인수 배열을 <xref:System.Type> 에 전달 된 개체는 <xref:System.Type.MakeGenericType%2A> 메서드 생성된 된 제네릭 형식을 만들 때. 결과 형식의 인스턴스를 만들 경우 합니다 <xref:System.Type.ContainsGenericParameters%2A> 속성 이어야 `false` 모든 형식 인수에 대 한 합니다.|  
  
 다음 코드 예제 및 테이블을 고정과 이러한 조건 중 일부를 보여 줍니다. `Derived` 해당 기본 형식이 해당 형식 인수 목록에 형식 및 형식 매개 변수 혼합 되어 생성 된 형식 이므로 클래스는 특히 중요 합니다.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 다음 표에서 클래스의 빌드 및 사용 하는 예를 보여 줍니다 `Base`, `Derived`, 및 `G`합니다. C + + 및 C# 코드가 동일 하면 항목이 하나만 표시 됩니다.  
  
|예|고정|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|이 유형의 경우:<br /><br /> <xref:System.Type.IsGenericType%2A>가 `true`인 경우<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>가 `true`인 경우<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>가 `true`인 경우|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|이 유형의 경우:<br /><br /> <xref:System.Type.IsGenericType%2A>가 `true`인 경우<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>가 `false`인 경우<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>가 `true`인 경우|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|변수의 형식에 대 한 `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> 됩니다 `false` 있으므로 `d` 배열이 있습니다.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>가 `false`인 경우<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>가 `false`인 경우|  
|`T`하십시오 `U`, 및 `V` (everywhere 표시 됨)|<xref:System.Type.IsGenericParameter%2A>가 `true`인 경우<br /><br /> <xref:System.Type.IsGenericType%2A> `false` 제네릭 형식에 형식 매개 변수를 제한할 수 있기 때문입니다.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>가 `false`인 경우<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 됩니다 `true` 때문에 `T`를 `U`, 및 `V` 은 그 자체가 제네릭 형식 매개 변수입니다. 이 의미 하지 않습니다 나중에 할당 되는 형식 인수에 대 한 모든 것.|  
|필드의 형식 `F`|<xref:System.Type.IsGenericType%2A>가 `true`인 경우<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 됩니다 `false` 의 형식 매개 변수에 할당 된 형식 때문에 `G`입니다. 이 호출한 것과 동일 합니다 <xref:System.Type.MakeGenericType%2A> 메서드.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 됩니다 `true` 때문에 필드의 형식을 `F` 형식 인수가 개방형 생성된 형식입니다. 생성 된 형식이 공개 형식임 때문에 해당 형식 인수 (즉, `Base`)은 제네릭 형식 정의입니다. 이의 재귀적 특성을 보여 줍니다는 <xref:System.Type.IsGenericType%2A> 속성입니다.|  
|중첩된 클래스 `Nested`|<xref:System.Type.IsGenericType%2A> 됩니다 `true`경우에는 `Nested` 클래스 제네릭 형식 매개 변수가 없는 자체에 대 한 제네릭 형식에 중첩 되어 있으므로.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>가 `true`인 경우 즉, 호출할 수 있습니다 합니다 <xref:System.Type.MakeGenericType%2A> 메서드와 공급 바깥쪽 형식의 형식 매개 변수 `Derived`합니다.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 됩니다 `true` 바깥쪽 형식 `Derived`, 제네릭 형식 매개 변수가 있습니다. 이의 재귀적 특성을 보여 줍니다는 <xref:System.Type.ContainsGenericParameters%2A> 속성입니다.|  
  
   
  
## Examples  
 다음 코드 예제에서는 값을 표시 합니다 <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, 및 <xref:System.Type.ContainsGenericParameters%2A> 주의 섹션에서 설명한 형식에 대 한 속성입니다. 속성 값에 대 한 설명에 함께 제공 되는 테이블을 참조 하세요.  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">리플렉션 및 제네릭 형식</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />이 다른 제네릭 형식을 생성하는 데 사용될 수 있는 제네릭 형식 정의를 나타내는지를 가리키는 값을 가져옵니다.</summary>
        <value><see langword="true" /> 개체가 제네릭 형식 정의를 나타내면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제네릭 형식 정의 다른 형식을 생성 하는 데 사용 될 수 있는 템플릿입니다. 예를 들어, 제네릭 형식 정의에서 `G<T>` (C# 구문;으로 표현 합니다. `G(Of T)` Visual Basic의 또는 `generic <typename T> ref class G` c + +에서)를 생성 하 고 형식을 인스턴스화할 수 있습니다 `G<int>` (`G(Of Integer)` Visual Basic의)를 호출 하 여를 <xref:System.Type.MakeGenericType%2A> 포함 하는 제네릭 인수 목록을 사용 하 여 메서드를 <xref:System.Int32> 형식. 지정 된을 <xref:System.Type> 생성 된 형식을이 나타내는 개체를 <xref:System.Type.GetGenericTypeDefinition%2A> 메서드 제네릭 형식 정의 다시 가져옵니다 다시 합니다.  
  
 사용 된 <xref:System.Type.IsGenericTypeDefinition%2A> 속성을 현재 형식에서 새 형식을 만들 수 있는지 여부를 결정 합니다. 경우는 <xref:System.Type.IsGenericTypeDefinition%2A> 속성이 반환 `true`를 호출할 수 있습니다는 <xref:System.Type.MakeGenericType%2A> 새 제네릭 형식을 만드는 방법.  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
   
  
## Examples  
 다음 예제에서는 제네릭 형식 정의 인 여부를 포함 하 여 형식에 대 한 정보를 표시 합니다. 생성된 된 형식, 제네릭 형식 정의 및 일반 형식에 대 한 정보가 표시 됩니다.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">리플렉션 및 제네릭 형식</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />에 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 특성이 적용되어 있는지 여부를 나타내는 값을 가져옵니다. 이 특성은 해당 형식이 COM 형식 라이브러리에서 가져온 것임을 나타냅니다.</summary>
        <value><see langword="true" />에 <see cref="T:System.Type" />가 있으면 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>.`  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">현재 형식과 비교할 개체입니다.</param>
        <summary>지정된 개체가 현재 <see cref="T:System.Type" />의 인스턴스인지를 확인합니다.</summary>
        <returns>현재 <see langword="Type" />이 <paramref name="o" />가 나타내는 개체의 상속 계층 구조에 속하거나 현재 <see langword="Type" />이 <paramref name="o" />가 구현하는 인터페이스이면 <see langword="true" />입니다. 이러한 조건에 해당하지 않거나 <paramref name="o" />가 <see langword="null" />이거나 현재 <see langword="Type" />이 개방형 제네릭 형식(즉, <see cref="P:System.Type.ContainsGenericParameters" />가 <see langword="true" /> 반환)이면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
> [!NOTE]
>  생성된 된 형식을 해당 제네릭 형식 정의의 인스턴스가 아닙니다. 즉, `MyGenericList<int>` (`MyGenericList(Of Integer)` Visual basic에서)의 인스턴스가 아닙니다 `MyGenericList<T>` (`MyGenericList(Of T)` Visual basic에서).  
  
   
  
## Examples  
 다음 예제에서는 `IsInstanceOfType` 메서드를 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 인터페이스인지, 즉 클래스 또는 값 형식이 아닌지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 인터페이스이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> 형식 선언을 클래스, 인터페이스 또는 값 형식으로 구분 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제에서는 인터페이스를 만듭니다 인터페이스 형식을 확인 하 고 클래스에 있는지 여부를 나타냅니다는 `IsInterface` 속성 집합입니다.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메타데이터에 정의되고 내보낸 순서로 현재 형식의 필드가 순차적으로 배치되는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 형식의 <see langword="true" /> 속성에 <see cref="P:System.Type.Attributes" />이 포함되어 있으면 <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 편의 위해 제공 됩니다. 사용할 수 있습니다는 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 열거형 값 형식 레이아웃 특성 및 다음 테스트를 여부 선택 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 설정 됩니다. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, 및 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 열거형 값 형식의 필드는 메모리에 배치 하는 방법을 나타냅니다.  
  
 동적 형식에 대해 지정할 수 있습니다 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 유형을 만들 때. 코드에 적용 합니다 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 특성과 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 열거형 값을 해당 레이아웃은 순차를 지정 하는 형식으로 합니다.  
  
> [!NOTE]
>  사용할 수 없습니다는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 결정 하는 방법 여부를 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 형식에 적용 된 합니다.  
  
 자세한 내용은 "파티션 II: 메타 데이터 정의 및 의미" 공용 언어 인프라 (CLI) 설명서에 대 한 사양의 9.1.2 섹션을 참조 하세요. 이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](https://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](https://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 다음 예제는 클래스의 인스턴스를 만듭니다를 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 열거 값을 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 클래스 설정 된 경우 확인를 <xref:System.Type.IsLayoutSequential%2A> 속성을 결과 표시 합니다.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">메타데이터 및 자동 기술 구성 요소</related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 참조로 마샬링되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 참조에 의해 마샬링되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제는 `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, 및 <xref:System.Type.IsPrimitive%2A> 의 속성을 <xref:System.Type> 클래스. 그리고 형식은 기본 데이터 형식을 참조로 마샬링할 수 인지 컨텍스트에서 지정된 된 형식의 호스팅할 수 있는지 여부를 확인 합니다.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Type.IsMarshalByRef" /> 속성을 구현하고, <see cref="T:System.Type" />이 참조에 의해 마샬링되는지 여부를 확인합니다.</summary>
        <returns><see langword="true" />이 참조에 의해 마샬링되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 형식 참조로 마샬링되 및 결과 표시 하는지 여부를 결정 합니다.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" /> 개체가 다른 형식의 정의 안에 중첩된 정의를 가진 형식을 나타내는지를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 다른 형식 안에 중첩되어 있으면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsNested%2A> 속성이 반환 `true` 모두에 대 한 표시 여부에 관계 없이 형식에 중첩 합니다. 동시에 중첩 및 표시 유형에 대해 테스트 하려면 관련된 속성을 사용 <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>를 <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>를 <xref:System.Type.IsNestedPrivate%2A>, 또는 <xref:System.Type.IsNestedPublic%2A>합니다.  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask> 열거형 멤버 유형에 대 한 표시 유형 특성을 선택 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 표시 유형의 다양 한 형식을 포함 하는 중첩 된 클래스를 사용 하 여 외부 클래스를 만듭니다. 다양 한 표시 유형 관련 값을 검색 <xref:System.Type> 부모 유형 및 해당 중첩 형식의 각 속성입니다.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 중첩되었으며 자체 어셈블리 내에서만 표시되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 중첩되어 있고 자체 어셈블리 내에서만 표시되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 표시 유형의 다양 한 형식을 포함 하는 중첩 된 클래스를 사용 하 여 외부 클래스를 만듭니다. 다양 한 표시 유형 관련 값을 검색 <xref:System.Type> 부모 유형 및 해당 중첩 형식의 각 속성입니다.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 중첩되었으며 자체 패밀리와 자체 어셈블리 모두에 속하는 클래스에만 표시되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 중첩되어 있고 자체 패밀리와 자체 어셈블리 모두에 속하는 클래스에만 표시되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.  
  
> [!NOTE]
>  C# 및 Visual Basic 언어는 고유한 어셈블리에서 보호 된 형식에만 표시 되는 중첩 된 형식을 정의할 수 있도록 하는 의미 체계를 포함 하지 않습니다. `protected internal` C#의 표시 유형 및 `Protected Friend` Visual Basic의 가시성을 보호 된 형식 및 동일한 어셈블리의 형식에 표시 되는 중첩된 형식을 정의 합니다.  
  
 A <xref:System.Type> 개체의 제품군의 모든 개체로 정의 됩니다 <xref:System.Type> 및 해당 하위 유형입니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 표시 유형의 다양 한 형식을 포함 하는 중첩 된 클래스를 사용 하 여 외부 클래스를 만듭니다. 다양 한 표시 유형 관련 값을 검색 <xref:System.Type> 부모 유형 및 해당 중첩 형식의 각 속성입니다.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 중첩되었으며 자체 패밀리 내에서만 표시되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 중첩되어 있고 자체 패밀리 내에서만 표시되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.  
  
 A <xref:System.Type> 개체의 제품군의 정확한 모든 개체로 정의 됩니다 동일한 <xref:System.Type> 및 해당 하위 유형입니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 표시 유형의 다양 한 형식을 포함 하는 중첩 된 클래스를 사용 하 여 외부 클래스를 만듭니다. 다양 한 표시 유형 관련 값을 검색 <xref:System.Type> 부모 유형 및 해당 중첩 형식의 각 속성입니다.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 중첩되었으며 자체 패밀리와 자체 어셈블리 중 하나에 속하는 클래스에만 표시되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 중첩되어 있고 자체 패밀리 또는 자체 어셈블리에 속하는 클래스에만 표시되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식의 표시 되 면 `protected internal` C# 또는 `Protected Friend` Visual Basic의 경우에 <xref:System.Type.IsNestedFamORAssem%2A> 속성에서 반환 `true`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.  
  
 A <xref:System.Type> 개체의 제품군의 정확한 모든 개체로 정의 됩니다 동일한 <xref:System.Type> 및 해당 하위 유형입니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 표시 유형의 다양 한 형식을 포함 하는 중첩 된 클래스를 사용 하 여 외부 클래스를 만듭니다. 다양 한 표시 유형 관련 값을 검색 <xref:System.Type> 부모 유형 및 해당 중첩 형식의 각 속성입니다.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 중첩되어 있고 private 형식으로 선언되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 중첩되어 있고 private 형식으로 선언되어 있으면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 표시 유형의 다양 한 형식을 포함 하는 중첩 된 클래스를 사용 하 여 외부 클래스를 만듭니다. 다양 한 표시 유형 관련 값을 검색 <xref:System.Type> 부모 유형 및 해당 중첩 형식의 각 속성입니다.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>클래스가 중첩되어 있고 public 형식으로 선언되어 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>클래스가 중첩되어 있고 public 형식으로 선언되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 표시 유형의 다양 한 형식을 포함 하는 중첩 된 클래스를 사용 하 여 외부 클래스를 만듭니다. 다양 한 표시 유형 관련 값을 검색 <xref:System.Type> 부모 유형 및 해당 중첩 형식의 각 속성입니다.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 public으로 선언되어 있지 않은지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 public으로 선언되어 있지 않고 중첩 형식이 아니면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 중첩 된 형식을 사용 하 여이 속성을 사용 하지 마십시오 사용 된 <xref:System.Type.IsNestedPublic%2A> 속성 대신 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성을 반환 합니다. 제네릭 형식의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 이 예제에서는 용도 `IsNotPublic` 속성 형식의 가시성을 확보 하세요.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 다음 코드 예제에서는 사용할 수 없습니다는 이유는 방법을 보여 줍니다 `IsPublic` 고 `IsNotPublic` 중첩된 클래스에 대 한 합니다.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 중첩 된 클래스에 대 한 결과를 무시 `IsPublic` 하 고 `IsNotPublic` 결과에 주의 하 고 `IsNestedPublic` 및 `IsNestedPrivate`합니다. 이 코드 조각에 대 한 리플렉션을 출력은 다음과 같을 수: 있습니다.  
  
|클래스|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|A|false|true|FALSE|false|  
|B|false|false|true|FALSE|  
|C|false|false|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 포인터인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 포인터이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수에이 속성은 항상 반환 `false`합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하 여 `IsPointer` 속성입니다.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, <see cref="P:System.Type.IsPointer" /> 속성을 구현하고 <see cref="T:System.Type" />이 포인터인지를 확인합니다.</summary>
        <returns><see langword="true" />이 포인터이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 기본 형식 중 하나인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 기본 형식 중 하나이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 형식은 <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>를 <xref:System.Int32>, <xref:System.UInt32>를 <xref:System.Int64>, <xref:System.UInt64>를 <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, 및 <xref:System.Single>합니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수에이 속성은 항상 반환 `false`합니다.  
  
   
  
## Examples  
 다음 예제는 `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, 및 <xref:System.Type.IsPrimitive%2A> 의 속성을 <xref:System.Type> 클래스. 그리고 형식은 기본 데이터 형식을 참조로 마샬링할 수 인지 컨텍스트에서 지정된 된 형식의 호스팅할 수 있는지 여부를 확인 합니다.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면, <see cref="P:System.Type.IsPrimitive" /> 속성을 구현하고 <see cref="T:System.Type" />이 기본 형식 중 하나인지를 확인합니다.</summary>
        <returns><see langword="true" />이 기본 형식 중 하나이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 형식은 <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>를 <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>를 <xref:System.Char>, <xref:System.Double>, 및 <xref:System.Single>합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 형식의 기본 형식이 고 결과 표시 하는지 여부를 결정 합니다.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 public으로 선언되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 public으로 선언되어 있고 중첩 형식이 아니면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 중첩 된 형식을 사용 안 함 사용 하 여 <xref:System.Type.IsNestedPublic%2A> 대신 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성을 반환 합니다. 제네릭 형식의 형식 매개 변수를 나타내는 `true`합니다.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 표시 유형 특성을 선택합니다.  
  
   
  
## Examples  
 다음 예제에서는 인스턴스를 만듭니다 `MyTestClass`, 확인을 `IsPublic` 속성 결과 표시 합니다.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 중첩 된 클래스에 대 한 결과를 무시 `IsPublic` 하 고 `IsNotPublic` 결과에 주의 하 고 <xref:System.Type.IsNestedPublic%2A> 및 <xref:System.Type.IsNestedPrivate%2A>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 봉인된 형식으로 선언되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 봉인된 형식으로 선언되어 있으면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 반환 제네릭 형식의 형식 매개 변수를 나타내는 `true`합니다.  
  
   
  
## Examples  
 다음 예제에서는 인스턴스를 만듭니다는 `sealed` 클래스에 대 한 검사는 `IsSealed` 속성 결과 표시 합니다.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식이 현재 신뢰 수준에서 보안에 중요한 형식이거나 보안 안전에 중요한 형식이어서 중요한 작업을 수행할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 형식이 보안에 중요한 형식이거나 보안 안전에 중요한 형식인 경우 <see langword="true" />이고 투명 형식인 경우 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, 및 <xref:System.Type.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에 있는 형식의 투명도 수준을 보고 합니다. 이러한 속성의 조합도 표에 표시 됩니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
> [!IMPORTANT]
>  부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다. 어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임에서 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다. 런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다. 반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다. 사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.  
  
 리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다. 투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">리플렉션의 보안 고려 사항</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework의 보안 변경 내용</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식이 현재 신뢰 수준에서 보안 안전에 중요한 형식인지 즉, 중요한 작업을 수행할 수 있고 투명 코드로 액세스할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 형식이 현재 신뢰 수준에서 보안에 중요한 형식인 경우 <see langword="true" />이고 보안에 중요한 형식이거나 투명 형식인 경우 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, 및 <xref:System.Type.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에 있는 형식의 투명도 수준을 보고 합니다. 이러한 속성의 조합도 표에 표시 됩니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
> [!IMPORTANT]
>  부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다. 어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임에서 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다. 런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다. 반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다. 사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.  
  
 리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다. 투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">리플렉션의 보안 고려 사항</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework의 보안 변경 내용</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식이 현재 신뢰 수준에서 투명하여 중요한 작업을 수행할 수 없는지를 나타내는 값을 가져옵니다.</summary>
        <value>형식이 현재 신뢰 수준에서 보안에 투명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 반환 하는 경우 `true`는 <xref:System.Type.IsSecurityCritical%2A> 하 고 <xref:System.Type.IsSecuritySafeCritical%2A> 속성 반환 `false`합니다.  
  
 합니다 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, 및 <xref:System.Type.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에 있는 형식의 투명도 수준을 보고 합니다. 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
> [!IMPORTANT]
>  부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다. 어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임에서 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다. 런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다. 반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다. 사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.  
  
 리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다. 투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">리플렉션의 보안 고려 사항</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework의 보안 변경 내용</related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />의 serialization 가능 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Type" />을 serialize할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
.NET 표준에 정의 된 형식으로 표시 되어 있지 <xref:System.SerializableAttribute>합니다. 대신, 각.NET 구현 형식이 직렬화 가능 인지 확인 합니다. 런타임에 사용할 수는 <xref:System.Type.IsSerializable%2A> 구현에는 형식 인스턴스의 serialization을 지원 하는지 여부를 결정 하는 속성입니다. 자세한 내용 및 예제를 참조 하세요 [.NET Standard 개체를 직렬화 가능 인지 확인 하는 방법을](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)합니다.
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
   
  
## Examples  
 다음 예제에서는 인스턴스를 만듭니다 `MyTestClass` 클래스 [Serializable] 특성을 설정 하 고 확인 합니다 `IsSerializable` 속성에 대 한 `true` 또는 `false`합니다.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>별도의 처리가 필요한 이름이 형식에 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>별도의 처리가 필요한 이름이 형식에 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로 시작 하거나 밑줄 문자 (_), 속성 접근자 및 메서드를 오버 로드할 연산자를 포함 하는 이름은 일부 컴파일러에서 특수 한 처리가 필요할 수 있는 형식의 예입니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">현재 형식과 비교할 형식입니다.</param>
        <summary>현재 <see cref="T:System.Type" />이 지정된 <see cref="T:System.Type" />에서 파생되는지 여부를 확인합니다.</summary>
        <returns>현재 <see langword="true" />이 <see langword="Type" />에서 파생되면 <paramref name="c" />이고, 그렇지 않으면 <see langword="false" />입니다. 이 메서드는 <see langword="false" /> 및 현재 <paramref name="c" />이 동일한 경우에도 <see langword="Type" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출할 수 있습니다는 <xref:System.Type.IsSubclassOf%2A> 메서드 중 하나를 확인 하려면:  
  
-   여부 하나의 클래스는 다른에서 파생 됩니다.  
  
-   형식에서 파생 되는 여부를 <xref:System.ValueType>입니다. 그러나는 <xref:System.Type.IsValueType%2A> 는 형식이 값 형식 인지 여부를 결정 하는 보다 효율적인 방법이 됩니다.  
  
-   형식에서 파생 되는 여부를 <xref:System.Enum>입니다. 그러나는 <xref:System.Type.IsEnum%2A> 메서드는 형식이 열거형 인지 여부를 결정 하는 데 보다 효율적입니다.  
  
-   형식 인지 대리자, 중 하나에서 파생 되므로 여부 <xref:System.Delegate> 또는 <xref:System.MulticastDelegate>합니다.  
  
 <xref:System.Type.IsSubclassOf%2A> 인터페이스가 다른 인터페이스에서 파생 되는 여부 또는 클래스에서 인터페이스를 구현 하는 여부를 결정 하는 메서드를 사용할 수 없습니다. 사용 된 <xref:System.Type.IsAssignableFrom%2A> 다음 예와 같이를 위해서는 메서드.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 하는 경우 현재 <xref:System.Type> 형식 매개 변수 또는 해당 클래스 제약 조건에서 파생 된 제네릭 형식 또는 제네릭 메서드 정의에서 <xref:System.Object?displayProperty=nameWithType> 클래스 제약 조건이 있는 경우.  
  
> [!NOTE]
>  인터페이스를 사용 하는 경우를 제외 하 고 <xref:System.Type.IsSubclassOf%2A> 의 반대입니다 <xref:System.Type.IsAssignableFrom%2A>합니다. 즉, 경우 `t1.IsSubclassOf(t2)` 됩니다 `true`, 한 다음 `t2.IsAssignableFrom(t1)` 이기도 `true`.  
  
 이 메서드는 파생된 클래스에서 재정의할 수 있습니다.  
  
   
  
## Examples  
 다음 예에서는 이라는 클래스를 만듭니다 `Class1` 및 파생된 클래스가 `DerivedC1`합니다. 호출 된 <xref:System.Type.IsSubclassOf%2A> 표시 하는 방법 `DerivedC1` 서브 클래스입니다 `Class1`합니다.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" />가 <see langword="null" />인 경우</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="UnicodeClass" />에 대해 문자열 형식 특성 <see cref="T:System.Type" />가 선택되었는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />에 대해 문자열 형식 특성 <see langword="UnicodeClass" />가 선택되면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> 문자열 형식 특성을 선택 하는 데 사용 됩니다. 문자열을 해석할 방법을 정의 하 여 상호 운용성을 개선 하는 문자열 형식 특성입니다.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />이 값 형식인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 값 형식이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값 형식은 비트; 시퀀스로 표현 되는 형식 값 형식은 클래스 또는 인터페이스 되지 않습니다. 값 형식 이라고 "구조체" 일부 프로그래밍 언어에서입니다. 열거형은 값 형식의 특수 한 경우입니다.  
  
 이 속성은 반환 `false` 에 대 한 합니다 <xref:System.ValueType> 클래스 <xref:System.ValueType> 자체 값 형식이 아닙니다. 모든 값 형식에 대 한 기본 클래스 이므로에 모든 값 형식에 할당할 수 있으므로. 하지 않는 것이 가능한 경우 <xref:System.ValueType> 값 형식 자체 되었습니다. 형식의 필드에 할당 될 때 값 형식이 boxed <xref:System.ValueType>합니다.  
  
 이 속성은 반환 `true` 열거형에 대 한는 <xref:System.Enum> 자체를 입력 합니다. 이 동작을 보여 주는 예제를 참조 하세요. <xref:System.Type.IsEnum%2A>합니다.  
  
 이 속성은 읽기 전용입니다.  
  
   
  
## Examples  
 다음 예제에서는 형식의 변수를 만듭니다 `MyEnum`를 확인는 `IsValueType` 속성 결과 표시 합니다.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Type.IsValueType" /> 속성을 구현하고 <see cref="T:System.Type" />이 값 형식인지 여부, 즉 클래스 또는 인터페이스가 아닌지 여부를 확인합니다.</summary>
        <returns><see langword="true" />이 값 형식이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 다른 형식 시스템의 구현을 사용할 수 있도록 제공 됩니다. 일반적으로 응용 프로그램 코드에서 사용 되지 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />을 어셈블리 외부의 코드에서 액세스할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>현재 <see langword="true" />이 public 형식이거나 바깥쪽 형식이 모두 public인 public 중첩 형식이면 <see cref="T:System.Type" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하 여 형식을 구성 요소 어셈블리의 공용 인터페이스의 일부 인지 여부를 확인 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 클래스를 하나씩만 어셈블리 외부에 표시 되는지 테스트 합니다.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 형식의 배열을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>하한이 0인 현재 형식의 1차원 배열을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns>하한이 0인 현재 형식의 1차원 배열을 나타내는 <see cref="T:System.Type" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> 메서드 요소 형식이 런타임 시 계산 되는 배열 형식을 생성 하는 방법을 제공 합니다.  
  
 **참고** 공용 언어 런타임 구별 벡터 (즉, 1 차원 배열에 항상 0부터 시작) 및 다차원 배열입니다. 항상 하나의 차원에 있는 벡터에 차원이 하나만 발생 하는 다차원 배열로 같지는 않습니다. 벡터 형식을 만드는 경우에이 메서드 오버 로드를 데 수 이며 벡터 형식 만들기 위한 유일한 방법입니다. 사용 된 <xref:System.Type.MakeArrayType%28System.Int32%29> 다차원 배열 형식을 만들려면 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 배열에 `ref` (`ByRef` Visual basic에서), 및 포인터 형식에는 `Test` 클래스.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다. 파생 클래스에서 구현을 제공해야 합니다.</exception>
        <exception cref="T:System.TypeLoadException">현재 형식이 <see cref="T:System.TypedReference" />입니다.  
  
또는 
현재 형식이 <see langword="ByRef" /> 형식입니다. 즉, <see cref="P:System.Type.IsByRef" />이 <see langword="true" />를 반환합니다.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">배열의 차수입니다. 이 수는 32보다 작거나 같아야 합니다.</param>
        <summary>지정된 차수의 현재 형식 배열을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns>지정된 차수의 현재 형식 배열을 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> 메서드 요소 형식이 런타임 시 계산 되는 배열 형식을 생성 하는 방법을 제공 합니다.  
  
> [!NOTE]
>  공용 언어 런타임 구별 벡터 (즉, 1 차원 배열에 항상 0부터 시작) 및 다차원 배열입니다. 항상 하나의 차원에 있는 벡터에 차원이 하나만 발생 하는 다차원 배열로 같지는 않습니다. 벡터 형식; 키를 만들려면이 메서드 오버 로드를 사용할 수 없습니다. 경우 `rank` 이 1 이면이 메서드 오버 로드에는 차원 수가 발생 하는 다차원 배열 형식을 반환 합니다. 사용 된 <xref:System.Type.MakeArrayType> 형식을 만들려면 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 배열에 `ref` (`ByRef` Visual basic에서), 및 포인터 형식에는 `Test` 클래스.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="rank" />이 잘못되었습니다. 예를 들면, 0 또는 음수입니다.</exception>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</exception>
        <exception cref="T:System.TypeLoadException">현재 형식이 <see cref="T:System.TypedReference" />입니다.  
  
또는 
현재 형식이 <see langword="ByRef" /> 형식입니다. 즉, <see cref="P:System.Type.IsByRef" />이 <see langword="true" />를 반환합니다.  
  
또는 
 <paramref name="rank" />이(가) 32보다 큽니다.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Type" />(Visual Basic의 경우 <see langword="ref" />) 매개 변수로 전달될 때 현재 형식을 나타내는 <see langword="ByRef" /> 개체를 반환합니다.</summary>
        <returns><see cref="T:System.Type" />(Visual Basic의 경우 <see langword="ref" />) 매개 변수로 전달될 때 현재 형식을 나타내는 <see langword="ByRef" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Type.MakeByRefType%2A> 메서드를 생성 하는 방법을 제공 `ref` 형식 (`ByRef` Visual basic에서) 매개 변수를 나열 합니다.  
  
 경우 MSIL (Microsoft intermediate language), 구문을 사용 하 여 현재 <xref:System.Type> 개체가 나타내는 <xref:System.Int32>,이 메서드는 반환을 <xref:System.Type> 개체를 나타내는 `Int32&`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 배열에 `ref` (`ByRef` Visual basic에서), 및 포인터 형식에는 `Test` 클래스.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</exception>
        <exception cref="T:System.TypeLoadException">현재 형식이 <see cref="T:System.TypedReference" />입니다.  
  
또는 
현재 형식이 <see langword="ByRef" /> 형식입니다. 즉, <see cref="P:System.Type.IsByRef" />이 <see langword="true" />를 반환합니다.</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">현재 제네릭 형식의 형식 매개 변수로 대체할 형식 배열입니다.</param>
        <summary>형식 배열의 요소를 현재 제네릭 형식 정의의 형식 매개 변수로 대체하며 생성된 형식을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns><see cref="T:System.Type" />의 요소를 현재 제네릭 형식의 형식 매개 변수로 대체하여 생성된 형식을 나타내는 <paramref name="typeArguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Type.MakeGenericType%2A> 메서드를 사용 하면 특정 형식을 만들어 제네릭 형식 정의의 형식 매개 변수에 할당 하는 코드를 작성할 수 있습니다는 <xref:System.Type> 생성된 된 특정 형식을 나타내는 개체입니다. 이 사용 하 여 <xref:System.Type> 개체는 생성 된 형식의 런타임 인스턴스를 만듭니다.  
  
 형식을 사용 하 여 생성 하는 <xref:System.Type.MakeGenericType%2A> 열 수, 즉, 바깥쪽 형식 또는 제네릭 메서드 형식 매개 변수를 해당 형식 인수 중 일부가 될 수 있습니다. 동적 어셈블리를 생성할 때 이러한 개방형 생성된 형식을 사용할 수 있습니다. 예를 들어, 클래스는 것이 좋습니다 `Base` 고 `Derived` 다음 코드에서입니다.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 생성할 `Derived` 동적 어셈블리의 기본 형식을 생성 하는 데 필요한 것입니다. 이 위해 호출 합니다 <xref:System.Type.MakeGenericType%2A> 메서드를 <xref:System.Type> 클래스를 나타내는 개체 `Base`, 제네릭 형식 인수를 사용 하 여 <xref:System.Int32> 형식 매개 변수 `V` 에서 `Derived`합니다. 형식 및 제네릭 형식 매개 변수는 모두로 표시 되므로 <xref:System.Type> 개체를 모두 포함 된 배열을 전달할 수는 <xref:System.Type.MakeGenericType%2A> 메서드.  
  
> [!NOTE]
>  생성 된 형식으로 `Base<int, V>` 코드를 내보낼 때 유용 하지만 호출할 수 없습니다는 <xref:System.Type.MakeGenericType%2A> 이 형식에 메서드를 제네릭 형식 정의 하지 않기 때문에 합니다. 인스턴스화할 수 있는 폐쇄형된 생성된 형식을 만들려면 먼저 호출 합니다 <xref:System.Type.GetGenericTypeDefinition%2A> 메서드를를 <xref:System.Type> 제네릭 형식 정의 나타내는 개체를 호출 <xref:System.Type.MakeGenericType%2A> 원하는 형식 인수를 사용 합니다.  
  
 <xref:System.Type> 에서 반환 된 개체 <xref:System.Type.MakeGenericType%2A> 와 같습니다는 <xref:System.Type> 호출 하 여 가져올를 <xref:System.Object.GetType%2A> 생성 된 형식, 메서드 결과 또는 <xref:System.Object.GetType%2A> 모든 메서드의 생성 된 제네릭 같은 생성 된 형식 동일한 형식 인수를 사용 하 여 정의 입력 합니다.  
  
> [!NOTE]
>  제네릭 형식의 배열 자체는 제네릭 형식이 됩니다. 호출할 수 없습니다 <xref:System.Type.MakeGenericType%2A> 같은 배열을 입력 `C<T>[]` (`Dim ac() As C(Of T)` Visual basic에서). 닫힌된 제네릭 형식을 생성 하려면 `C<T>[]`, 호출 <xref:System.Type.GetElementType%2A> 제네릭 형식 정의를 가져오는 `C<T>`; 호출 <xref:System.Type.MakeGenericType%2A> 생성 된 형식; 만들고 마지막으로 호출 하는 제네릭 형식 정의에 <xref:System.Type.MakeArrayType%2A> 메서드 배열 형식을 만들려면 생성 된 형식입니다. 포인터 형식의 마찬가지 및 `ref` 형식 (`ByRef` Visual basic에서).  
  
 제네릭 리플렉션에 사용되는 용어의 고정 조건 목록은 <xref:System.Type.IsGenericType%2A> 속성 설명을 참조하세요.  
  
## <a name="nested-types"></a>중첩 형식  
 C#, c + + 또는 Visual Basic을 사용 하 여 제네릭 형식 정의 된 경우 해당 중첩된 형식 모두 제네릭 됩니다. 3 가지 언어 중첩 형식의 형식 매개 변수 목록이 바깥쪽 형식의 형식 매개 변수를 포함 하기 때문에 자체의 형식 매개 변수 없이 중첩된 된 형식에 있는 경우에 마찬가지입니다. 다음 클래스를 고려 합니다.  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 중첩된 된 클래스의 형식 매개 변수 목록 `Inner` 두 개의 형식 매개 변수가 `T` 및 `U`는 첫 번째는 바깥쪽 클래스의 형식 매개 변수입니다. 마찬가지로, 중첩된 된 클래스의 형식 매개 변수 목록 `Innermost1` 세 가지 형식 매개 변수가 `T`, `U`, 및 `V`를 사용 하 여 `T` 및 `U` 는 바깥쪽 클래스에서 제공 될 예정입니다. 중첩된 클래스 `Innermost2` 두 개의 형식 매개 변수가 `T` 고 `U`는 바깥쪽 클래스에서 제공 되는 합니다.  
  
 바깥쪽 형식의 매개 변수 목록에 둘 이상의 형식 매개 변수의 경우 순서로 모든 형식 매개 변수는 중첩 형식의 형식 매개 변수 목록에 포함 됩니다.  
  
 중첩 형식의 제네릭 형식 정의에서 제네릭 형식을 생성을 호출 합니다 <xref:System.Type.MakeGenericType%2A> 모든 바깥쪽 형식의부터 가장 바깥쪽 제네릭 형식 및로 끝나는 형식 인수 배열을 연결 하 여 형성 된 배열 사용 하 여 메서드를 자체의 형식 매개 변수가 있는 경우에 중첩된 형식 자체의 인수 배열을 입력 합니다. 인스턴스를 만드는 `Innermost1`를 호출 합니다 <xref:System.Type.MakeGenericType%2A> T, U 및 V를 할당할 수는 세 가지 형식이 포함 된 배열 사용 하 여 메서드. 인스턴스를 만드는 `Innermost2`를 호출 합니다 <xref:System.Type.MakeGenericType%2A> 할당할 T 및 u입니다. 두 형식이 포함 된 배열 사용 하 여 메서드  
  
 언어는 중첩 된 형식의 필드를 정의 하는 바깥쪽 형식의 형식 매개 변수를 사용할 수 있도록이 방식으로 바깥쪽 형식의 형식 매개 변수를 전파 합니다. 이 고, 그렇지 형식 매개 변수는 범위는 중첩 형식의 본문 내에서 수 없습니다. 동적 어셈블리에서 코드를 생성 하거나 사용 하 여 바깥쪽 형식의 형식 매개 변수를 전파 하지 않고 중첩된 형식을 정의 하는 것이 불가능 합니다 [Ilasm.exe (IL 어셈블러)](~/docs/framework/tools/ilasm-exe-il-assembler.md)합니다. MSIL 어셈블러에 대해 다음 코드를 살펴보세요.  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 이 예제에서는 수 없는 형식의 필드를 정의 하려면 `T` 나 `U` 클래스에서 `Innermost`이므로 해당 형식 매개 변수 범위에 없는 합니다. 다음 어셈블러 코드를 c + +, Visual Basic 및 C#에 정의 된 경우 방식으로 작동 하는 중첩된 클래스를 정의 합니다.  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 사용할 수는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 고급 언어에 정의 된 중첩 된 클래스를 검사 하 고이 명명 스키마를 확인할입니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Type.MakeGenericType%2A> 에 대 한 제네릭 형식 정의에서 생성된 된 형식을 만드는 방법의 <xref:System.Collections.Generic.Dictionary%602> 형식. 생성 된 형식은 <xref:System.Collections.Generic.Dictionary%602> 의 `Test` 문자열 키를 사용 하 여 개체입니다.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 형식이 제네릭 형식의 정의를 나타내지 않습니다. 즉, <see cref="P:System.Type.IsGenericTypeDefinition" />이 <see langword="false" />를 반환합니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArguments" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="typeArguments" />의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">요소 개수가 <paramref name="typeArguments" /> 현재 제네릭 형식 정의의 형식 매개 변수 개수와 다릅니다.  
  
또는 
<paramref name="typeArguments" />의 요소가 현재 제네릭 형식의 해당 형식 매개 변수에 대해 지정된 제약 조건을 충족하지 않습니다.  
  
또는 
 <paramref name="typeArguments" />에 포인터 형식(<see cref="P:System.Type.IsPointer" />가 <see langword="true" /> 반환), by-ref 형식(<see cref="P:System.Type.IsByRef" />가 <see langword="true" /> 반환) 또는 <see cref="T:System.Void" />인 요소가 포함되어 있습니다.</exception>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다. 파생 클래스에서 구현을 제공해야 합니다.</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">리플렉션 및 제네릭 형식</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">방법: 리플렉션을 사용하여 제네릭 형식 검사 및 인스턴스화</related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 형식에 대한 포인터를 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns>현재 형식에 대한 포인터를 나타내는 <see cref="T:System.Type" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A> 메서드 매개 변수 목록에 대 한 포인터 형식을 생성 하는 방법을 제공 합니다.  
  
 경우 MSIL (Microsoft intermediate language), 구문을 사용 하 여 현재 <xref:System.Type> 개체가 나타내는 <xref:System.Int32>,이 메서드는 반환을 <xref:System.Type> 개체를 나타내는 `Int32*`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 배열에 `ref` (`ByRef` Visual basic에서), 및 포인터 형식에는 `Test` 클래스.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</exception>
        <exception cref="T:System.TypeLoadException">현재 형식이 <see cref="T:System.TypedReference" />입니다.  
  
또는 
현재 형식이 <see langword="ByRef" /> 형식입니다. 즉, <see cref="P:System.Type.IsByRef" />이 <see langword="true" />를 반환합니다.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버가 형식 또는 중첩 형식임을 나타내는 <see cref="T:System.Reflection.MemberTypes" /> 값을 가져옵니다.</summary>
        <value>이 멤버가 형식 또는 중첩 형식임을 나타내는 <see cref="T:System.Reflection.MemberTypes" /> 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 재정의 <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>합니다. 따라서 집합을 조사할 때 <xref:System.Reflection.MemberInfo> 개체-예를 들어, 반환 된 배열 <xref:System.Type.GetMembers%2A>-는 <xref:System.Reflection.MemberInfo.MemberType%2A> 속성에서 반환 <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> 지정된 된 멤버 중첩 된 형식인 경우.  
  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 형식이 생성 된 제네릭 형식 정의에 적용 됩니다. 예를 들어 경우 현재 <xref:System.Type> 나타냅니다 `MyGenericType<int>` (`MyGenericType(Of Integer)` Visual basic에서),이 속성의 값으로 결정 됩니다 `MyGenericType<T>`합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성은 항상 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 코드 예제는 `MemberType` 필드에 대 한 매개 변수로 `GetMember` 메서드:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> 정보의 손실된 값을 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 `Missing` 매개 변수의 기본 값을 가져오려면 리플렉션을 통해 호출에 대 한 필드입니다. 경우는 `Missing` 필드 매개 변수 값에 대 한 전달 되며 해당 매개 변수에 대해 기본값이 <xref:System.ArgumentException> throw 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 `Missing` 기본 인수를 사용 하 여 메서드를 호출 하는 필드입니다.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 이 코드의 결과는 다음과 같습니다.  
  
 a = 10 b = 55.3 c = 12  
  
 10 = b = 1.3 c = 1  
  
 10 = b 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />이 정의된 모듈(DLL)을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Type" />이 정의된 모듈입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Type> 나타내는 생성된 된 제네릭 형식,이 속성은 제네릭 형식 정의가 정의 된 모듈을 반환 합니다. 예를 들어의 인스턴스를 만듭니다 `MyGenericStack<int>`는 <xref:System.Type.Module%2A> 생성 된 형식에 대 한 속성에는 모듈을 반환 합니다. `MyGenericStack<T>` 정의 됩니다.  
  
 마찬가지로, 경우 현재 <xref:System.Type> 제네릭 매개 변수를 나타내는 `T`,이 속성을 정의 하는 제네릭 형식이 포함 된 어셈블리를 반환 합니다. `T`합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법을 보여 줍니다 합니다 <xref:System.Type.Namespace%2A> 하 고 `Module` 속성 및 <xref:System.Type.ToString%2A> 메서드의 <xref:System.Type>합니다.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />의 네임스페이스를 가져옵니다.</summary>
        <value><see cref="T:System.Type" />의 네임스페이스입니다. 현재 인스턴스가 제네릭 매개 변수를 나타내거나 네임스페이스가 없으면 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 네임 스페이스는 논리적 디자인 타임 명명 편리 하 게 하는 데 주로 응용 프로그램에서 범위를 정의 하 고 클래스와 기타 형식을 단일 계층 구조에서를 구성 합니다. 런타임의 측면에서 보면 네임 스페이스가 있습니다.  
  
 하는 경우 현재 <xref:System.Type> 은 생성 된 제네릭 형식을 나타내며,이 속성은 제네릭 형식 정의가 포함 된 네임 스페이스를 반환 합니다. 마찬가지로, 경우 현재 <xref:System.Type> 제네릭 매개 변수를 나타내는 `T`,이 속성을 정의 하는 제네릭 형식 정의 포함 하는 네임 스페이스를 반환 합니다. `T`합니다.  
  
 하는 경우 현재 <xref:System.Type> 개체는 제네릭 매개 변수를 나타내는 경우이 속성은 반환 `null`합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법을 보여 줍니다 합니다 `Namespace` 하 고 <xref:System.Type.Module%2A> 속성 및 <xref:System.Type.ToString%2A> 메서드의 <xref:System.Type>합니다.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">정규화된 형식 이름 지정</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 개체입니다.</param>
        <param name="right">비교할 두 번째 개체입니다.</param>
        <summary>두 <see cref="T:System.Type" /> 개체가 같은지를 나타냅니다.</summary>
        <returns><see langword="true" />가 <paramref name="left" />와 같으면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 개체입니다.</param>
        <param name="right">비교할 두 번째 개체입니다.</param>
        <summary>두 <see cref="T:System.Type" /> 개체가 같지 않은지를 나타냅니다.</summary>
        <returns><see langword="true" />가 <paramref name="left" />와 다르면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버를 얻는 데 사용된 클래스 개체를 가져옵니다.</summary>
        <value>이 <see langword="Type" /> 개체를 얻는 데 사용된 <see cref="T:System.Type" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 <xref:System.Type> 개체의 경우이 속성의 값은 항상 동일한 값으로는 <xref:System.Type.DeclaringType%2A> 속성입니다.  
  
   
  
## Examples  
 이 예제에 중첩된 된 클래스의 리플렉션된 형식과 됩니다.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">가져올 <see cref="T:System.Type" />의 어셈블리로 한정된 이름입니다.</param>
        <param name="throwIfNotFound">형식을 찾을 없는 경우 <see langword="true" />을 throw하려면 <see cref="T:System.TypeLoadException" />이고, 형식을 찾을 수 없는 경우 <see langword="false" />을 반환하려면 <see langword="null" />입니다. 또한 <see langword="false" />를 지정하면 다른 예외 조건 중 일부(모두 아님)가 표시되지 않습니다. 예외 섹션을 참조하세요.</param>
        <param name="ignoreCase"><see langword="true" />에 대해 대/소문자를 구분하지 않는 검색을 수행하려면 <paramref name="typeName" />이고, <see langword="false" />에 대해 대/소문자를 구분하는 검색을 수행하려면 <paramref name="typeName" />입니다.</param>
        <summary>대/소문자를 구분하여 검색할지 여부와 형식이 없으면 예외를 throw할지를 지정하여, 지정된 이름의 <see cref="T:System.Type" />을 가져옵니다. 형식은 실행을 위해서가 아니라 리플렉션을 위해서만 로드됩니다.</summary>
        <returns>지정된 이름의 형식이 있으면 이를 반환하고 그렇지 않으면 <see langword="null" />을 반환합니다. 형식을 찾을 수 없는 경우에는 <paramref name="throwIfNotFound" /> 매개 변수가 <see langword="null" />을 반환할지 아니면 예외를 throw할지 지정합니다. 경우에 따라서는 <paramref name="throwIfNotFound" /> 값과 상관없이 예외가 throw됩니다. 예외 섹션을 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식을 포함 하는 어셈블리 없는 경우 리플렉션 전용 컨텍스트에 로드를 사용 하는 <xref:System.Type.ReflectionOnlyGetType%2A> 메서드는 먼저 해당 어셈블리를 로드 리플렉션 위해서만 사용 하 여를 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 메서드를 호출 하 여 형식을 로드 한 다음는 어셈블리의 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 메서드. 어셈블리의 정규화 된 이름에 대 한 자세한 내용은 참조는 <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> 속성입니다. 형식 이름 지정에 대 한 자세한 내용은 참조는 <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> 메서드 오버 로드 합니다.  
  
 어셈블리가 이미 실행에 대 한 로드를 다른 복사본 리플렉션 전용 컨텍스트로 로드 됩니다.  
  
 `throwIfNotFound` 되나요 유형을 찾을 수 없습니다 하 고 특정 한 다른 예외 조건을 표시 하지 예외 섹션에 설명 된 대로 매개 변수를 지정 합니다. 값에 관계 없이 일부 예외가 throw 됩니다 `throwIfNotFound`합니다. 예를 들어, 어셈블리 유효 하지 않은 경우는 <xref:System.BadImageFormatException> 이 throw 경우에 `throwIfNotFound` 는 `false`합니다.  
  
 리플렉션 전용 컨텍스트를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [방법: 리플렉션 전용 컨텍스트에 어셈블리 로드](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">클래스 이니셜라이저가 호출되고 예외가 발생합니다.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwIfNotFound" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.  
  
또는 
 <paramref name="throwIfNotFound" />가 <see langword="true" />이고 <paramref name="typeName" />이 포함된 탭 등의 잘못된 문자를 포함합니다. 
또는 
 <paramref name="throwIfNotFound" />가 <see langword="true" />이고 <paramref name="typeName" />이 빈 문자열입니다.  
  
또는 
 <paramref name="throwIfNotFound" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 크기를 가진 배열 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />이 <see cref="T:System.TypedReference" /> 개체의 배열을 나타냅니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" />에 어셈블리 이름이 포함되지 않습니다.  
  
또는 
 <paramref name="throwIfNotFound" />가 <see langword="true" />이고 <paramref name="typeName" />이 잘못된 구문(예: "MyType[,*,]")을 포함합니다.  
  
또는 
 <paramref name="typeName" />이 형식 인수 중 하나로 포인터 형식, <see langword="ByRef" /> 형식 또는 <see cref="T:System.Void" />를 가진 제네릭 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />은 형식 인수의 개수가 잘못된 제네릭 형식을 나타냅니다.  
  
또는 
 <paramref name="typeName" />은 제네릭 형식을 나타내며 그 형식 인수 중 하나가 해당 형식 매개 변수에 대한 제약 조건을 충족하지 않습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwIfNotFound" />가 <see langword="true" />이고 어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나를 찾았지만 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">어셈블리 또는 여기에 종속되어 있는 어셈블리 중 하나가 올바르지 않습니다.  
  
또는 
어셈블리가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">정규화된 형식 이름 지정</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md">방법: 리플렉션 전용 컨텍스트에 어셈블리 로드</related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식의 레이아웃을 설명하는 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />를 가져옵니다.</summary>
        <value>현재 형식의 전체 레이아웃 기능을 설명하는 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />를 가져옵니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 반환 하지 않습니다는 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 메서드. 대신,이 속성을 사용 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 먼저 클래스, 구조체 및 특별 한 레이아웃이 특성 (구조 내에 중첩 된 클래스)를 사용 하 여 구조를 정의 합니다. 이 예제에서는 다음 사용 합니다 <xref:System.Type.StructLayoutAttribute%2A> 속성을를 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 각 형식과 표시 특성의 속성에 대 한 합니다.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="rgszNames">매핑할 전달된 이름의 배열입니다.</param>
        <param name="cNames">매핑할 이름의 수입니다.</param>
        <param name="lcid">이름을 해석할 로캘 컨텍스트입니다.</param>
        <param name="rgDispId">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</param>
        <summary>이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">반환할 형식 정보입니다.</param>
        <param name="lcid">형식 정보의 로캘 식별자입니다.</param>
        <param name="ppTInfo">요청된 형식 정보 개체에 대한 포인터입니다.</param>
        <summary>인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</param>
        <summary>개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">멤버를 식별합니다.</param>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="lcid">인수를 해석할 로캘 컨텍스트입니다.</param>
        <param name="wFlags">호출의 컨텍스트를 설명하는 플래그입니다.</param>
        <param name="pDispParams">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="pVarResult">결과를 저장할 위치에 대한 포인터입니다.</param>
        <param name="pExcepInfo">예외 정보가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="puArgErr">오류가 있는 첫 번째 인수의 인덱스입니다.</param>
        <summary>개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see langword="String" />의 이름을 나타내는 <see langword="Type" />을 반환합니다.</summary>
        <returns>현재 <see cref="T:System.String" />의 이름을 나타내는 <see cref="T:System.Type" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 모든 기본 형식에 대 한 이름과 정규화 된 공용 언어 런타임 네임 스페이스를 반환합니다. 예를 들어 C# 명령 `(long)0.Type().ToString()` 단순히 "Int64" 대신 "System.Int64"를 반환 합니다.  
  
 하는 경우 현재 <xref:System.Type> 네임 스페이스 및 중첩 된 형식으로는 어셈블리가 아니라 제네릭 형식, 형식 및 형식 인수는 정규화 된 나타냅니다. 하는 경우 현재 <xref:System.Type> 나타내는 제네릭 형식 또는 제네릭 메서드,이 메서드 정의의 형식 매개 변수는 형식 매개 변수의 정규화 되지 않은 이름을 반환 합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법을 보여 줍니다 합니다 <xref:System.Type.Namespace%2A> 하 고 <xref:System.Type.Module%2A> 속성 및 `ToString` 메서드의 <xref:System.Type>합니다.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 다음 예제에서 반환 된 문자열을 비교 합니다 <xref:System.Type.ToString%2A> 메서드 및 `Name`, <xref:System.Type.FullName%2A>, 및 <xref:System.Type.AssemblyQualifiedName%2A> 속성.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Type" />에 대한 핸들을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Type" />에 대한 핸들입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` 형식을 나타내는 내부 데이터 구조에 대 한 포인터를 캡슐화 합니다. 이 핸들은 프로세스 수명 동안 고유 합니다. 핸들을 얻은 응용 프로그램 도메인에만 유효 합니다.  
  
   
  
## Examples  
 다음 예제에서는 해당 유형의 핸들을 반환 하 고 핸들에서 형식을 가져옵니다을 표시 하는 메서드 핸들을 전달 합니다.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework에서는 현재 이 속성을 지원하지 않습니다.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>형식에 대한 이니셜라이저를 가져옵니다.</summary>
        <value><see cref="T:System.Type" />에 대한 클래스 생성자의 이름이 들어 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스 이니셜라이저를 통해 사용할 수도 있습니다는 <xref:System.Type.FindMembers%2A> 메서드를 또는 오버 로드를 통해 합니다 <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, 및 <xref:System.Type.GetConstructors%2A> 메서드를 <xref:System.Reflection.BindingFlags> 매개 변수로 합니다.  
  
 하는 경우 현재 <xref:System.Type> 이 속성을 반환 합니다. 제네릭 형식 또는 제네릭 메서드 정의의 형식 매개 변수를 나타내는 `null`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 형식을 나타내는 공용 언어 런타임에서 제공되는 형식을 나타냅니다.</summary>
        <value><see cref="T:System.Type" />의 내부 시스템 형식입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>