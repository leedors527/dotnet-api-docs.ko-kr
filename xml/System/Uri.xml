<Type Name="Uri" FullName="System.Uri">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bc748165070ca7c2fc35cc5a3d821923907161f7" />
    <Meta Name="ms.sourcegitcommit" Value="41742a1055cefdeaf2f9d76364f4bad3c9f83126" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="10/16/2018" />
    <Meta Name="ms.locfileid" Value="48689801" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Uri = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>URI(Uniform Resource Indentifier)의 개체 표현을 제공하며 URI 부분에 쉽게 액세스할 수 있도록 합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URI에는 인트라넷 또는 인터넷에서 응용 프로그램에 사용할 수 있는 리소스의 compact 표현입니다. <xref:System.Uri> 속성 및 메서드 구문 분석, 비교 및 결합을 포함 하는 Uri를 처리 하기 위한 클래스를 정의 합니다. 합니다 <xref:System.Uri> 클래스 속성 읽기 전용 이며 수정할 수 있는 개체를 만들려면 사용 합니다 <xref:System.UriBuilder> 클래스입니다.  
  
 상대 Uri (예를 들어, "/ new/index.htm") 절대 수 있도록 기본 URI와 관련 하 여 확장 해야 합니다. <xref:System.Uri.MakeRelative%2A> 필요한 경우 상대 Uri를 절대 Uri를 변환할 메서드가 제공 됩니다.  
  
 <xref:System.Uri> 생성자 문자열은 올바른 형식의 URI 구성표 식별자를 포함 하는 경우 URI 문자열을 이스케이프 하지 않습니다.  
  
 <xref:System.Uri> 속성의 해당 16 진수 대체 127 보다 큰 유니코드 값을 사용 하 여 모든 문자를 사용 하 여 이스케이프 된 인코딩으로 정규 데이터 표현 반환 합니다. 정규 형식에서 URI를 삽입할는 <xref:System.Uri> 생성자에는 다음 단계를 수행 합니다.  
  
-   URI 체계를 소문자로 변환합니다.  
  
-   호스트 이름을 소문자로 변환합니다.  
  
-   호스트 이름이 IPv6 주소 이면에 정식 IPv6 주소가 사용 됩니다. ScopeId 및 기타 선택적인 IPv6 데이터가 제거 됩니다.  
  
-   기본 및 빈 포트 번호를 제거합니다.

-   예약 된 용도가 없는 이스케이프 된 문자 (라고도: 백분율로 인코딩된 옥텟을) 디코딩 (라고도 이스케이프 해제 된). 예약 되지 않은 이러한 문자는 대문자 및 소문자 (%41 %5A 및 %61 %7A), 소수 자릿수 (%30-%39), 하이픈 (%2D), 마침표 (%2E) (%5F), 밑줄 및 물결표 (%7E).

-   이스케이프 된 계층적 Uri에 대 한 압축 순서에서 같은 /. / /... 및 / / (시퀀스 이스케이프 여부). 이러한 시퀀스 압축 되지 않습니다 일부 구성표는 참고 합니다.
  
-   계층적 Uri에 대 한 호스트 슬래시 (/)로 종료 되지 않으면 추가 됩니다.  
  
-   기본적으로 RFC 2396에 따라 URI에서 예약 된 문자가 이스케이프 됩니다. URI의 경우 예약된 문자는 다국어 리소스 식별자 또는 국제 도메인 이름 구문 분석을 활성화 한 경우이 동작 변경 내용 RFC 3986 및 RFC 3987에 따라 이스케이프 됩니다.

 일부 구성표, 점 세그먼트 및 빈 세그먼트에 대 한 생성자에는 정규화의 일부로 (/. / /... 및 / /)이 압축 됩니다 (즉, 제거 됨). URI는 이러한 시퀀스는 압축 체계는 http, https, tcp, net.pipe 및 net.tcp 포함 합니다. 이러한 시퀀스는 일부 다른 스키마에 대 한 압축 되지 않습니다. 이 압축 되는 모양을 실제로 다음과 같습니다.
  
```  
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("ftp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("ftp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, escaped

Console.WriteLine(uri.AbsoluteUri);  
Console.WriteLine(uri.PathAndQuery);  
```  
  
 이 코드를 실행 하는 경우 필요한 경우 이스케이프 해제 하 고 압축 한 다음 이스케이프 시퀀스를 사용 하 여 다음 출력을 반환 합니다.

```  
http://myUrl/  
/  
```  
  
 콘텐츠를 변환할 수 있습니다 합니다 <xref:System.Uri> 클래스를 사용 하 여 읽을 수 있는 URI 참조에 대 한 이스케이프 인코딩된 URI 참조를 <xref:System.Uri.ToString%2A> 메서드. 일부 예약 된 문자 수 여전히의 출력에서 이스케이프 된 <xref:System.Uri.ToString%2A> 메서드. 반환한 값에서 URI의 명확한 재구성을 지원 하기 위해 이것이 <xref:System.Uri.ToString%2A>합니다.  
  
 일부 Uri 조각 식별자 또는 쿼리를 포함 합니다. 단편 식별자는 숫자 기호 뒤에 오는 모든 텍스트 (#), 숫자 기호;를 포함 하지 않음 조각 텍스트에 저장 되는 <xref:System.Uri.Fragment%2A> 속성입니다. 쿼리 정보는 URI에서 물음표 (?) 뒤에 오는 텍스트는 쿼리 텍스트에 저장 되는 <xref:System.Uri.Query%2A> 속성입니다.  
  
 .NET framework 버전 1.1에서는 생성자에 지정 된 문자열을 알 수 없는 스키마를 포함 하는 경우 및 "c:\\"를 Uri 클래스 삽입 "/ /" 콜론입니다. 예를 들어, URI `xyz:c:\abc` 변환할 `xyz://c:/abc`합니다. .NET framework 버전 2.0에서이 동작이 제거 되었습니다, 그리고 및 문자열의 예는 변환할 `xyz:c:/abc`합니다.  
  
> [!NOTE]
>  URI 클래스 IPv4 프로토콜에 대 한 두 자리 표기법 및 콜론 16 진수 IPv6 프로토콜에 대 한 IP 주소 사용을 지원합니다. 해야 http://[::1와 같이 대괄호 안에 있는 IPv6 주소를 묶습니다] 합니다.  
  
## <a name="international-resource-identifier-support"></a>국가별 리소스 식별자 지원  
 웹 주소는 대개 매우 제한적인된 문자 집합을 구성 하는 uniform resource identifier를 사용 하 여 표현 됩니다.  
  
-   영문자의 대문자 및 소문자 ASCII 문자.  
  
-   0~9의 숫자.  
  
-   일부 기타 ASCII 기호.  
  
 Uri에 대 한 사양은 RFC 2396, RFC 2732, RFC 3986 및 RFC 3987을 게시 하 여는 Task Force IETF (Internet Engineering)에 나와 있습니다.  
  
 인터넷이 성장하면서 영어 이외의 언어로 리소스를 식별해야 할 필요성이 증가하고 있습니다. 이 필요성을 가능하게 하고 ASCII 이외 문자(유니코드/ISO 10646 문자 집합의 문자)를 허용하는 식별자를 IRI(International Resource Identifier)라고 합니다. IRI 사양은 IETF에서 게시한 RFC 3987에 설명되어 있습니다. IRI를 사용하면 URL에 유니코드 문자를 포함할 수 있습니다.  
  
 기존 <xref:System.Uri> RFC 3987을 기반으로 IRI 지원을 제공할 수 있는 2.0 SP1 및.NET Framework v3.5, 3.0 SP1에서에서이 클래스는 확장 되었습니다. 버전 4.5 이전.NET Framework 버전의 사용자는 특히 IRI 사용 하지 않는 한.NET Framework 2.0 동작에서 표시 되지 않습니다. 이 덕분에 .NET Framework 이전 버전과의 응용 프로그램 호환성이 제공됩니다.  
  
 Iri 지원을 사용 하려면 다음과 같이 변경 하면이 필요 합니다.  
  
-   다국어 도메인 이름 (IDN) 구문 분석 된 도메인 이름에 적용할 것인지와 IRI 구문 분석 규칙을 적용 해야 하는지 여부를 지정 합니다. 이 작업을 수행할 수 있습니다 합니다 *machine.config* 또는 합니다 *app.config* 파일입니다. 예를 들어, 다음 추가 합니다.  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 사용자가.NET Framework 4.5 이상에 항상 IRI를 사용 하도록 설정 해야 합니다. IRI 구문 분석 변경할 수 없습니다를 사용 하는 *.config* 파일입니다.  
  
 IDN을 사용하면 도메인 이름의 모든 유니코드 레이블이 해당 Punycode 문자로 변환됩니다. Punycode 이름에는 ASCII 문자만 사용되며 항상 xn-- 접두사로 시작합니다. 대부분의 DNS 서버는 ASCII 문자만 지원하므로(RFC 3940 참조) 이렇게 해야 인터넷에서 기존 DNS 서버를 지원할 수 있습니다.  
  
 IRI 및 IDN을 사용하도록 설정하면 <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType> 속성 값에 영향을 줍니다. IRI 및 IDN을 사용하면 <xref:System.Uri.Equals%2A>, <xref:System.Uri.OriginalString%2A>, <xref:System.Uri.GetComponents%2A> 및 <xref:System.Uri.IsWellFormedOriginalString%2A> 메서드의 동작을 변경할 수도 있습니다.  
  
 세 가지 idn 관련 값을 사용 하는 DNS 서버에 따라 가지가 있습니다.  
  
-   idn 사용 = All  
  
     이 값은 모든 유니코드 도메인 이름을 해당하는 Punycode 항목(IDN 이름)으로 변환합니다.  
  
-   사용 하도록 설정 하는 idn AllExceptIntranet =  
  
     이 값은 Punycode 항목 (IDN 이름)을 사용 하려면 로컬 인트라넷에 없는 모든 유니코드 도메인 이름을 변환 합니다. 이 경우를 처리 하기 위해 로컬 인트라넷에 있는 국가별 이름을 인트라넷에 사용 되는 DNS 서버가 유니코드 이름 확인을 지원 해야 합니다.  
  
-   idn 사용 = 없음  
  
     이 값은 Punycode를 사용하도록 어떠한 유니코드 도메인 이름도 변환하지 않습니다. .NET Framework 2.0 동작을 사용 하 여 일치 하는 기본 값입니다.  
  
 IRI 구문 분석을 사용 하는 경우 (iriParsing 사용 = `true`) 정규화 및 문자 검사는 RFC 3986 및 RFC 3987의 최신 IRI 규칙에 따라 수행 됩니다. IRI 구문 분석 사용 안 함, 정규화 및 문자 검사 (IPv6 리터럴)에 대 한 RFC 2396 및 RFC 2732에 따라 수행 됩니다.  기본값은.NET framework 버전 4.5 이전 버전에서는 `false`합니다. .NET framework 4.5 이상 버전에서 기본값은 `true`, 설정에 따라 IRI 구문 분석의 활성화 상태를 수정할 수 없습니다는 *.config* 파일입니다.  
  
 IRI 및 IDN 처리는 <xref:System.Uri> 를 사용 하 여 클래스 제어할 수도 있습니다는 <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>를 <xref:System.Configuration.IdnElement?displayProperty=nameWithType>, 및 <xref:System.Configuration.UriSection?displayProperty=nameWithType> 구성 설정 클래스입니다. <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> 설정은 <xref:System.Uri> 클래스에서 IRI 처리를 사용하거나 사용하지 않도록 설정합니다. <xref:System.Configuration.IdnElement?displayProperty=nameWithType> 설정은 <xref:System.Uri> 클래스에서 IDN 처리를 사용하거나 사용하지 않도록 설정합니다. <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> 설정도 IDN을 간접적으로 제어합니다. IDN 처리가 가능하려면 IRI 처리를 사용하도록 설정해야 합니다. IRI 처리가 사용하지 않도록 설정되면 IDN 처리는 .NET Framework 2.0 동작이 호환성에 사용되고 IDN 이름이 사용되지 않는 기본 설정으로 지정됩니다.  
  
 에 대 한 구성 설정을 합니다 <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> 및 <xref:System.Configuration.IdnElement?displayProperty=nameWithType> 는 한 번 읽을 때 첫 번째 <xref:System.Uri?displayProperty=nameWithType> 클래스 생성 됩니다. 해당 시점 후의 구성 설정 변경 내용은 무시됩니다.  
  
 또한 <xref:System.GenericUriParser?displayProperty=nameWithType> 클래스는 IRI 및 IDN을 지원하는 사용자 지정 가능한 파서를 만들 수 있도록 확장되었습니다. <xref:System.GenericUriParser?displayProperty=nameWithType> 개체의 동작은 <xref:System.GenericUriParserOptions?displayProperty=nameWithType> 열거형에서 사용 가능한 값의 비트 조합을 <xref:System.GenericUriParser?displayProperty=nameWithType> 생성자에 전달하여 지정합니다. <xref:System.GenericUriParserOptions.IriParsing?displayProperty=nameWithType> 형식은 파서가 RFC 3987에 지정된 IRI(International Resource Identifier)에 대한 구문 분석 규칙을 지원함을 나타냅니다. IRI 사용 여부는 위에 설명 된 구성 값에 따라 결정 됩니다.  
  
 <xref:System.GenericUriParserOptions.Idn?displayProperty=nameWithType> 형식은 파서가 호스트 이름의 IDN(Internationalized Domain Name) 구문 분석을 지원함을 나타냅니다. IDN 사용 여부는 위에 설명 된 구성 값에 따라 결정 됩니다.  
  
## <a name="performance-considerations"></a>성능 고려 사항  
 *Web.config을 사용 하는 경우 * 파일이 응용 프로그램, 추가 시간을 초기화 하는 Uri를 포함 하는 구성표 식별자가 비표준 경우 Uri를 처리 하는 데 필요 합니다. 이러한 경우 시작 때가 아니라 Uri가 필요할 때 응용 프로그램의 영향을 받는 파트를 초기화 합니다.  
  
   
  
## Examples  
 다음 예제에서는 인스턴스를 만듭니다는 <xref:System.Uri> 클래스를 사용 하 여 만들기는 <xref:System.Net.WebRequest> 인스턴스.  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>보안 문제 때문에 응용 프로그램 때는 주의 해야 수락 <see cref="T:System.Uri" /> 신뢰할 수 없는 소스에서 사용 하 여 인스턴스 <paramref name="dontEscape" /> 로 <see langword="true" />합니다. 호출 하 여 URI 문자열의 유효성을 확인할 수 있습니다는 <see cref="M:System.Uri.IsWellFormedOriginalString" /> 메서드.</para>
    </block>
    <altmember cref="T:System.Configuration.IdnElement" />
    <altmember cref="T:System.Configuration.IriParsingElement" />
    <altmember cref="T:System.Configuration.UriSection" />
    <altmember cref="P:System.Uri.DnsSafeHost" />
    <altmember cref="M:System.Uri.MakeRelative(System.Uri)" />
    <altmember cref="M:System.Uri.IsWellFormedOriginalString" />
    <altmember cref="T:System.UriBuilder" />
    <related type="Article" href="http://msdn.microsoft.com/library/35883fe9-2d09-4d8b-80ca-cf23a941e459">버전 2.0에서 System.Uri 네임스페이스 변경 내용</related>
    <related type="Article" href="http://msdn.microsoft.com/library/b5e994c3-3535-4aff-8e1b-b69be22e9a22">System.UriSystem.Uri의 국가별 리소스 식별자 지원</related>
    <related type="Article" href="~/docs/framework/network-programming/index.md">.NET Framework의 네트워크 프로그래밍</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Uri" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString);" />
      <MemberSignature Language="F#" Value="new Uri : string -&gt; Uri" Usage="new System.Uri uriString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">
          <see cref="T:System.Uri" /> 인스턴스가 나타낼 리소스를 식별하는 문자열입니다. 문자열 형식에서 IPv6 주소는 대괄호로 묶어야 합니다. 예를 들어 "http://[2607:f8b0:400d:c06::69]"입니다.</param>
        <summary>URI가 지정된 <see cref="T:System.Uri" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.Uri> URI 문자열에서 인스턴스. URI 구문 분석, 정규 형식으로 배치 하 고 필요한 이스케이프 인코딩을 만듭니다.  
  
 이 생성자는 보장 하지 않습니다는 <xref:System.Uri> 액세스할 수 있는 리소스를 가리킵니다.  
  
 이 생성자에 있다고 가정 합니다 `string` 매개 변수는 절대 URI를 참조 하 고 호출 하는 것과 같습니다는 <xref:System.Uri.%23ctor%2A> 생성자 <xref:System.UriKind> 로 <xref:System.UriKind.Absolute>. 경우는 `string` 생성자에 전달 된 매개 변수는 상대 URI를이 생성자가 throw를 <xref:System.UriFormatException>입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Uri> URI 사용 하 여 인스턴스 "http://www.contoso.com/"입니다.  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>
              <see href="http://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.FormatException" />을 catch합니다.</para>
          </block>
          <paramref name="uriString" />가 비어 있는 경우  
  
또는 
<paramref name="uriString" />에서 지정된 구성표가 올바르게 구성되지 않았습니다. <see cref="M:System.Uri.CheckSchemeName(System.String)" />을 참조하세요.  
  
또는 
 <paramref name="uriString" />에 너무 많은 슬래시가 들어 있습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 암호가 올바르지 않습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 호스트 이름이 올바르지 않습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 파일 이름이 올바르지 않습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 사용자 이름이 올바르지 않습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 호스트 또는 기관 이름은 백슬래시로 종료할 수 없습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 포트 번호가 올바르지 않거나 해당 번호를 구문 분석할 수 없습니다.  
  
또는 
<paramref name="uriString" />의 길이가 65519자를 초과합니다.  
  
또는 
<paramref name="uriString" />에서 지정된 구성표 길이가 1023자를 초과합니다.  
  
또는 
<paramref name="uriString" />에 잘못된 문자 시퀀스가 있습니다.  
  
또는 
<paramref name="uriString" />에 지정된 MS-DOS 경로는 c:\\\\로 시작해야 합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Uri(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new Uri : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Uri" Usage="new System.Uri (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">새 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 인스턴스를 serialize하는 데 필요한 정보가 포함된 <see cref="T:System.Uri" /> 클래스의 인스턴스입니다.</param>
        <param name="streamingContext">새 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 인스턴스와 관련하여 serialize된 스트림의 소스가 포함된 <see cref="T:System.Uri" /> 클래스의 인스턴스입니다.</param>
        <summary>
          <see cref="T:System.Uri" />와 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 클래스의 지정된 인스턴스로부터 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 구현 하는 <xref:System.Runtime.Serialization.ISerializable> 에 대 한 인터페이스를 <xref:System.Uri> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serializationInfo" /> 매개 변수에 <see langword="null" /> URI가 포함된 경우</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="serializationInfo" /> 매개 변수에 비어 있는 URI가 포함된 경우  
  
또는 
지정된 체계가 올바르게 구성되지 않은 경우 <see cref="M:System.Uri.CheckSchemeName(System.String)" />을 참조하세요.  
  
또는 
URI에 너무 많은 슬래시가 들어 있습니다.  
  
또는 
URI에 지정된 암호가 잘못된 경우  
  
또는 
URI에 지정된 호스트 이름이 잘못된 경우  
  
또는 
URI에 지정된 파일 이름이 잘못된 경우  
  
또는 
URI에 지정된 사용자 이름이 잘못된 경우  
  
또는 
URI에 지정된 호스트 또는 기관 이름을 백슬래시로 종료할 수 없는 경우  
  
또는 
URI에 지정된 포트 번호가 잘못되었거나 해당 번호를 구문 분석할 수 없는 경우  
  
또는 
URI의 길이가 65519자를 초과합니다.  
  
또는 
URI에 지정된 체계 길이가 1023자를 초과한 경우  
  
또는 
URI에 잘못된 문자 시퀀스가 있습니다.  
  
또는 
URI에 지정된 MS-DOS 경로는 c:\\\\로 시작해야 합니다.</exception>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">XML 및 SOAP Serialization</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : string * bool -&gt; Uri" Usage="new System.Uri (uriString, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="uriString">
          <see cref="T:System.Uri" /> 인스턴스가 나타낼 리소스를 식별하는 문자열입니다. 문자열 형식에서 IPv6 주소는 대괄호로 묶어야 합니다. 예를 들어 "http://[2607:f8b0:400d:c06::69]"입니다.</param>
        <param name="dontEscape">
          <c>uriString</c>이 완전히 이스케이프되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>문자 이스케이프를 명시적으로 제어하여 URI가 지정된 <see cref="T:System.Uri" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.Uri> URI 문자열에서 인스턴스. URI 구문 분석 하 고 정식으로 넣습니다.  
  
 `dontEscape` 매개 변수 예약 된 문자를 변환할지 여부를에 이스케이프 시퀀스입니다. 이 매개 변수를 설정 해야 `true` URI에 모든 예약 된 문자가 이스케이프 처리 되었습니다 되었음을 확인 하는 경우에 합니다. 값을 설정 `true` 에 이스케이프 되지 않은 URI는 예기치 않은 동작이 발생할 수 있습니다. 이 매개 변수를 항상 설정 하는 것이 좋습니다 `false`합니다.  
  
 하는 경우 `dontEscape` 로 설정 된 `false`, 생성자는 모든 백분율 (%) 뒤에 올바른 이스케이프 시퀀스를 확인 하 여 예약된 된 문자를 이스케이프 합니다. 다음의 백분율 문자 시퀀스 올바르지 않으면 백분율 25%로 바뀝니다.  
  
 이 생성자는 보장 하지 않습니다는 <xref:System.Uri> 액세스할 수 있는 리소스를 가리킵니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Uri> URI에 대 한 인스턴스 http://www.contoso.com/Hello%20World.htm합니다. 포함 된 URI가 완전히 이스케이프 정규 형식에서 이므로 합니다 `dontEscape` 매개 변수 설정할 수 있습니다 `true`합니다.  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="uriString" />이 비어 있거나 공백만 포함하는 경우  
  
또는 
<paramref name="uriString" />에 지정된 체계가 잘못된 경우  
  
또는 
 <paramref name="uriString" />에 너무 많은 슬래시가 들어 있습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 암호가 올바르지 않습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 호스트 이름이 올바르지 않습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 파일 이름이 올바르지 않습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 사용자 이름이 올바르지 않습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 호스트 또는 기관 이름은 백슬래시로 종료할 수 없습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 포트 번호가 올바르지 않거나 해당 번호를 구문 분석할 수 없습니다.  
  
또는 
<paramref name="uriString" />의 길이가 65519자를 초과합니다.  
  
또는 
<paramref name="uriString" />에서 지정된 구성표 길이가 1023자를 초과합니다.  
  
또는 
<paramref name="uriString" />에 잘못된 문자 시퀀스가 있습니다.  
  
또는 
<paramref name="uriString" />에 지정된 MS-DOS 경로는 c:\\\\로 시작해야 합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="new Uri : string * UriKind -&gt; Uri" Usage="new System.Uri (uriString, uriKind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">
          <see cref="T:System.Uri" /> 인스턴스가 나타낼 리소스를 식별하는 문자열입니다. 문자열 형식에서 IPv6 주소는 대괄호로 묶어야 합니다. 예를 들어 "http://[2607:f8b0:400d:c06::69]"입니다.</param>
        <param name="uriKind">URI 문자열이 상대 URI 또는 절대 URI인지, 아니면 결정되지 않았는지를 지정합니다.</param>
        <summary>URI가 지정된 <see cref="T:System.Uri" /> 클래스의 새 인스턴스를 초기화합니다. 이 생성자를 사용하면 URI 문자열이 상대 URI 또는 절대 URI인지, 아니면 결정되지 않았는지를 지정할 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상대 및 절대 Uri의 형식에 다른 제한이 있습니다. 예를 들어, 상대 URI 체계를 또는 인증 기관에는 필요 하지 않습니다. 지정 하는 값 `uriKind` 에 전달 된 URI의 형식과 일치 해야 `uriString`합니다. 그러나 경우 <xref:System.UriKind.RelativeOrAbsolute> 를 지정 하면 URI 문자열이 상대 또는 절대 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uriKind" />이 잘못되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>
              <see href="http://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.FormatException" />을 catch합니다.</para>
          </block>
          <paramref name="uriString" />이 상대 URI를 포함하고 <paramref name="uriKind" />가 <see cref="F:System.UriKind.Absolute" />인 경우  
  
또는 
 <paramref name="uriString" />이 절대 URI를 포함하고 <paramref name="uriKind" />가 <see cref="F:System.UriKind.Relative" />인 경우  
  
또는 
 <paramref name="uriString" />가 비어 있는 경우  
  
또는 
<paramref name="uriString" />에서 지정된 구성표가 올바르게 구성되지 않았습니다. <see cref="M:System.Uri.CheckSchemeName(System.String)" />을 참조하세요.  
  
또는 
 <paramref name="uriString" />에 너무 많은 슬래시가 들어 있습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 암호가 올바르지 않습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 호스트 이름이 올바르지 않습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 파일 이름이 올바르지 않습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 사용자 이름이 올바르지 않습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 호스트 또는 기관 이름은 백슬래시로 종료할 수 없습니다.  
  
또는 
<paramref name="uriString" />에서 지정된 포트 번호가 올바르지 않거나 해당 번호를 구문 분석할 수 없습니다.  
  
또는 
<paramref name="uriString" />의 길이가 65519자를 초과합니다.  
  
또는 
<paramref name="uriString" />에서 지정된 구성표 길이가 1023자를 초과합니다.  
  
또는 
<paramref name="uriString" />에 잘못된 문자 시퀀스가 있습니다.  
  
또는 
<paramref name="uriString" />에 지정된 MS-DOS 경로는 c:\\\\로 시작해야 합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">기본 URI입니다.</param>
        <param name="relativeUri">기본 URI에 추가할 상대 URI입니다.</param>
        <summary>지정된 기본 URI와 상대 URI 문자열을 기반으로 <see cref="T:System.Uri" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 만듭니다는 <xref:System.Uri> 결합 하 여 인스턴스를 `baseUri` 하며 `relativeUri`합니다. 하는 경우 `relativeUri` (구성표, 호스트 이름 및 필요에 따라 포트 번호를 포함)는 절대 uri를 <xref:System.Uri> 만 사용 하 여 인스턴스가 만들어질 `relativeUri`합니다.  
 
 경우는 `baseUri` 상대 부분이 (같은 `/api`), 상대 파트 슬래시로 끝나야 합니다 (같은 `/api/`) 이면 상대 부분 `baseUri` 되도록에서 생성 된 유지 <xref:System.Uri>. 

 또한 경우는 `relativeUri` 상대 부분이 대체한 다음 슬래시로 시작 되는 `baseUri`

 이 생성자는 보장 하지 않습니다는 <xref:System.Uri> 액세스할 수 있는 리소스를 가리킵니다.  
  
   
  
## Examples  
 다음 예제에서는의 새 인스턴스를 <xref:System.Uri> 클래스는 상대 Uri를 결합 하 여 http://www.contoso.com catalog/shownew.htm 절대 URI를 구성 하 고 http://www.contoso.com/catalog/shownew.htm입니다.  
  
 [!code-cpp[Classic Uri.Uri3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" />가 절대 <see cref="T:System.Uri" /> 인스턴스가 아닙니다.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>
              <see href="http://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.FormatException" />을 catch합니다.</para>
          </block>
          <paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 만든 URI가 비어 있거나 공백만 있습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 만든 URI에서 지정된 구성이 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 만든 URI가 너무 많은 슬래시를 포함합니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 만든 URI에 지정된 암호가 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 호스트 이름이 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 파일 이름이 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 사용자 이름이 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 호스트 또는 인증 기관 이름은 백슬래시로 종료될 수 없습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 포트 번호가 올바르지 않거나 구문 분석할 수 없습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI의 길이가 65519자를 초과합니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 스키마의 길이가 1023자를 초과합니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 잘못된 문자 시퀀스가 있습니다.  
  
또는 
<paramref name="uriString" />에 지정된 MS-DOS 경로는 c:\\\\로 시작해야 합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, Uri ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * Uri -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseUri">새 <see cref="T:System.Uri" /> 인스턴스의 기본인 절대 <see cref="T:System.Uri" />입니다.</param>
        <param name="relativeUri">
          <c>baseUri</c>와 결합되는 상대 <see cref="T:System.Uri" /> 인스턴스입니다.</param>
        <summary>지정된 기본 <see cref="T:System.Uri" /> 인스턴스와 상대 <see cref="T:System.Uri" /> 인스턴스의 조합을 기반으로 <see cref="T:System.Uri" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 만듭니다 <xref:System.Uri> 절대를 결합 하 여 인스턴스 <xref:System.Uri> 인스턴스에 `baseUri`, 상대를 사용 하 여 <xref:System.Uri> 인스턴스에 `relativeUri`합니다. 경우 `relativeUri` 가 절대 <xref:System.Uri> (구성표, 호스트 이름 및 필요에 따라 포트 번호를 포함) 인스턴스를 <xref:System.Uri> 만 사용 하 여 인스턴스가 만들어집니다 `relativeUri`합니다.  
 
 경우는 `baseUri` 상대 부분이 (같은 `/api`), 상대 파트 슬래시로 끝나야 합니다 (같은 `/api/`) 이면 상대 부분 `baseUri` 되도록에서 생성 된 유지 <xref:System.Uri>. 

 또한 경우는 `relativeUri` 상대 부분이 대체한 다음 슬래시로 시작 되는 `baseUri`
 
 이 생성자는 보장 하지 않습니다는 <xref:System.Uri> 액세스할 수 있는 리소스를 가리킵니다.  
  
   
  
## Examples  
 이 예제에서는 절대 <xref:System.Uri> 인스턴스에 `absoluteUri`, 및 상대 <xref:System.Uri> 인스턴스에 `relativeUri`합니다. 새 <xref:System.Uri> 인스턴스를 `combinedUri`, 그런 다음 이러한 두 인스턴스에서 생성 됩니다.  
  
 [!code-cpp[NCLUriEnhancements#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#2)]
 [!code-csharp[NCLUriEnhancements#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#2)]
 [!code-vb[NCLUriEnhancements#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseUri" />가 절대 <see cref="T:System.Uri" /> 인스턴스가 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" />가 절대 <see cref="T:System.Uri" /> 인스턴스가 아닙니다.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>
              <see href="http://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.FormatException" />을 catch합니다.</para>
          </block>
          <paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 만든 URI가 비어 있거나 공백만 있습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 만든 URI에서 지정된 구성이 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 만든 URI가 너무 많은 슬래시를 포함합니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 만든 URI에 지정된 암호가 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 호스트 이름이 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 파일 이름이 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 사용자 이름이 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 호스트 또는 인증 기관 이름은 백슬래시로 종료될 수 없습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 포트 번호가 올바르지 않거나 구문 분석할 수 없습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI의 길이가 65519자를 초과합니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 스키마의 길이가 1023자를 초과합니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 잘못된 문자 시퀀스가 있습니다.  
  
또는 
<paramref name="uriString" />에 지정된 MS-DOS 경로는 c:\\\\로 시작해야 합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string * bool -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="baseUri">기본 URI입니다.</param>
        <param name="relativeUri">기본 URI에 추가할 상대 URI입니다.</param>
        <param name="dontEscape">
          <c>uriString</c>이 완전히 이스케이프되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>문자 이스케이프를 명시적으로 제어하여 지정된 기본 URI와 상대 URI를 기반으로 <see cref="T:System.Uri" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.Uri> 결합 하 여 인스턴스 `baseUri` 및 `relativeUri`합니다. 에 전달 된 URI `relativeUri` (구성표, 호스트 이름 및 필요에 따라 포트 번호를 포함)는 절대 uri를 <xref:System.Uri> 만 사용 하 여 인스턴스가 만들어질 `relativeUri`합니다.  
  
 `dontEscape` 매개 변수 예약 된 문자를 변환할지 여부를에 이스케이프 시퀀스입니다. 이 매개 변수를 설정 해야 `true` URI에 모든 예약 된 문자가 이스케이프 처리 되었습니다 되었음을 확인 하는 경우에 합니다. 값을 설정 `true` 에 이스케이프 되지 않은 URI는 예기치 않은 동작이 발생할 수 있습니다. 이 매개 변수를 항상 설정 하는 것이 좋습니다 `false`합니다. 하는 경우 `dontEscape` 로 설정 된 `false`, 생성자는 모든 백분율 (%) 뒤에 올바른 이스케이프 시퀀스를 확인 하 여 예약된 된 문자를 이스케이프 합니다. 다음의 백분율 문자 시퀀스 올바르지 않으면 백분율 25%로 바뀝니다.  
  
 이 생성자는 보장 하지 않습니다는 <xref:System.Uri> 액세스할 수 있는 리소스를 가리킵니다.  
  
   
  
## Examples  
 다음 예제에서는의 새 인스턴스를 만듭니다는 <xref:System.Uri> 클래스는 상대 Uri를 결합 하 여 http://www.contoso.com 및 절대 URI를 구성 하기 위해 Hello%20World.htm 합니다.  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" />가 절대 <see cref="T:System.Uri" /> 인스턴스가 아닙니다.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 만든 URI가 비어 있거나 공백만 있습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 만든 URI에서 지정된 구성이 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 만든 URI가 너무 많은 슬래시를 포함합니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 만든 URI에 지정된 암호가 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 호스트 이름이 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 파일 이름이 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 사용자 이름이 올바르지 않습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 호스트 또는 인증 기관 이름은 백슬래시로 종료될 수 없습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 포트 번호가 올바르지 않거나 구문 분석할 수 없습니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI의 길이가 65519자를 초과합니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 지정된 스키마의 길이가 1023자를 초과합니다.  
  
또는 
<paramref name="baseUri" />와 <paramref name="relativeUri" />를 결합하여 구성한 URI에 잘못된 문자 시퀀스가 있습니다.  
  
또는 
<paramref name="uriString" />에 지정된 MS-DOS 경로는 c:\\\\로 시작해야 합니다.</exception>
        <block subset="none" type="usage">
          <para>보안 문제 때문에 응용 프로그램은이 생성자를 호출 하지이 URI 문자열을 사용 하 여 신뢰할 수 없는 소스에서 사용 하 여 <paramref name="dontEscape" /> 로 <see langword="true" />합니다. 또는 호출 하 여 URI 문자열의 유효성을 확인할 수 있습니다는 <see cref="M:System.Uri.IsWellFormedOriginalString" /> 이 생성자를 호출 하기 전에 메서드.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsolutePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsolutePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsolutePath : string" Usage="System.Uri.AbsolutePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>URI의 절대 경로를 가져옵니다.</summary>
        <value>리소스에 대한 절대 경로가 포함된 <see cref="T:System.String" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.AbsolutePath%2A> 속성 정보에 대 한 요청을 해결 하려면 서버를 사용 하는 경로 정보를 포함 합니다. 일반적으로 확보 하 여 응용 프로그램 또는 스크립트 정보를 제공 하도록 서버를 실행 해야 하지만 서버의 파일 시스템에 원하는 정보에 대 한 경로입니다.  
  
 구성표, 호스트 이름 또는 URI의 쿼리 부분 경로 정보가 포함 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 경로 /catalog/shownew.htm을 콘솔에 씁니다.  
  
 [!code-cpp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsolutePath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsoluteUri As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsoluteUri { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsoluteUri : string" Usage="System.Uri.AbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>절대 URI를 가져옵니다.</summary>
        <value>전체 URI가 포함된 <see cref="T:System.String" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Uri.AbsoluteUri%2A> 속성에 저장 된 전체 URI를 포함 합니다 <xref:System.Uri> 인스턴스, 모든 조각 및 쿼리 문자열을 포함 하 여 합니다.  
  
   
  
## Examples  
 다음 예제에서는 기록의 전체 콘텐츠를 <xref:System.Uri> 콘솔로 인스턴스. 표시 된 예제에서 http://www.contoso.com/catalog/shownew.htm?date=today 콘솔에 기록 됩니다.  
  
 [!code-cpp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authority : string" Usage="System.Uri.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버의 DNS(Domain Name System) 호스트 이름이나 IP 주소 및 포트 번호를 가져옵니다.</summary>
        <value>이 인스턴스가 나타내는 URI의 인증 기관 구성 요소가 포함된 <see cref="T:System.String" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Authority%2A> 속성은 일반적으로 서버 DNS 호스트 이름 또는 IP 주소입니다. 이 속성의 URI에 대 한 기본 포트에서 서로 다른 경우 서비스 포트 번호를 포함할 수 있습니다. 경우는 <xref:System.Uri.Authority%2A> 예약 된 문자를 포함 하는 구성 요소,이 속성에 의해 반환 되는 문자열 값에서 이러한 이스케이프 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 호스트 이름 (www.contoso.com) 및 포트 번호 기록 (8080) 콘솔에 서버.  
  
 [!code-cpp[Classic Uri.Authority Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Authority Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Authority Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Canonicalize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Canonicalize();" />
      <MemberSignature Language="F#" Value="abstract member Canonicalize : unit -&gt; unit&#xA;override this.Canonicalize : unit -&gt; unit" Usage="uri.Canonicalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>내부적으로 저장된 URI를 정규형으로 변환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URI의 정식 버전을 내부적으로 저장합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
        <exception cref="T:System.UriFormatException">URI가 잘못 구성된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckHostName (name As String) As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UriHostNameType CheckHostName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member CheckHostName : string -&gt; UriHostNameType" Usage="System.Uri.CheckHostName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">유효성을 확인할 호스트 이름입니다. IPv4 또는 IPv6 주소이거나 인터넷 호스트 이름일 수 있습니다.</param>
        <summary>지정된 호스트 이름이 유효한 DNS 이름인지 여부를 확인합니다.</summary>
        <returns>호스트 이름의 형식을 나타내는 <see cref="T:System.UriHostNameType" />입니다. 호스트 이름의 형식을 확인할 수 없거나 호스트 이름이 <see langword="null" /> 또는 길이가 0인 문자열이면 이 메서드에서 <see cref="F:System.UriHostNameType.Unknown" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.CheckHostName%2A> 메서드 제공한 호스트 이름은 올바른 인터넷 호스트 이름에 대 한 요구 사항을 충족 하는지 확인 합니다. 그러나 호스트의 존재 여부 확인에 대 한 호스트 이름 조회가 수행 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 호스트 이름이 올바른지 여부를 확인 합니다.  
  
 [!code-cpp[Classic Uri.CheckHostName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.CheckHostName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.CheckHostName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckSchemeName (schemeName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CheckSchemeName(System::String ^ schemeName);" />
      <MemberSignature Language="F#" Value="static member CheckSchemeName : string -&gt; bool" Usage="System.Uri.CheckSchemeName schemeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">유효성을 확인할 체계 이름입니다.</param>
        <summary>지정된 체계 이름이 유효한지 여부를 확인합니다.</summary>
        <returns>스키마 이름이 유효하면 <see cref="T:System.Boolean" /> 값이  <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 기본적으로 RFC 2396에 따라 유효성에 대 한 스키마 이름을 확인합니다. 다국어 리소스 식별자 (IRIs) 또는 다국어 도메인 이름 (IDN) 구문 분석을 사용 하는 경우이 메서드는 RFC 3986에 따라 유효성 검사에 대 한 스키마 이름을 확인 합니다. 체계 이름 문자로 시작 해야 하며 문자, 숫자 및 문자를 포함 해야 합니다 ".", "+" 또는 "-"입니다.  
  
 IRI 지원에 대 한 자세한 내용은 설명 섹션을 참조 하세요.를 <xref:System.Uri> 클래스입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Uri> 인스턴스 및 스키마 이름이 올바른지 여부를 확인 합니다.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CheckSecurity ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CheckSecurity();" />
      <MemberSignature Language="F#" Value="abstract member CheckSecurity : unit -&gt; unit&#xA;override this.CheckSecurity : unit -&gt; unit" Usage="uri.CheckSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메서드를 호출해도 아무런 효과가 나타나지 않습니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (uri1 As Uri, uri2 As Uri, partsToCompare As UriComponents, compareFormat As UriFormat, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(Uri ^ uri1, Uri ^ uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : Uri * Uri * UriComponents * UriFormat * StringComparison -&gt; int" Usage="System.Uri.Compare (uri1, uri2, partsToCompare, compareFormat, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" />
        <Parameter Name="compareFormat" Type="System.UriFormat" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="uri1">첫 번째 <see cref="T:System.Uri" />입니다.</param>
        <param name="uri2">두 번째 <see cref="T:System.Uri" />입니다.</param>
        <param name="partsToCompare">비교할 <c>uri1</c>과 <c>uri2</c>의 부분을 지정하는 <see cref="T:System.UriComponents" /> 값의 비트 조합입니다.</param>
        <param name="compareFormat">URI 구성 요소를 비교할 때 사용되는 문자 이스케이프를 지정하는 <see cref="T:System.UriFormat" /> 값 중 하나입니다.</param>
        <param name="comparisonType">
          <see cref="T:System.StringComparison" /> 값 중 하나입니다.</param>
        <summary>지정된 비교 규칙을 사용하여 두 URI의 지정된 부분을 비교합니다.</summary>
        <returns>비교한 <see cref="T:System.Int32" /> 구성 요소 간의 어휘 관계를 나타내는 <see cref="T:System.Uri" /> 값입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 의미 
 </description></listheader><item><term> 0보다 작음 
 </term><description><paramref name="uri1" />가 <paramref name="uri2" />보다 작은 경우  
  
 </description></item><item><term> 0 
 </term><description><paramref name="uri1" />가 <paramref name="uri2" />와 같습니다.  
  
 </description></item><item><term> 0보다 큼 
 </term><description><paramref name="uri1" />가 <paramref name="uri2" />보다 큰 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모두 `uri1` 하 고 `uri2` 는 `null`,이 메서드에서 0을 반환 합니다. URI 값을 비교할 때 상대 URI는 항상 절대 URI가 null이 아닌 URI 이며 항상 null URI 보다 큰 미만입니다. 사례에 대 한는 둘 다 `uri1` 및 `uri2` 되지 `null` 와 상대 Uri 또는 둘 다 절대 Uri를 모두는 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> 메서드는 비교를 수행 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" />은 유효한 <see cref="T:System.StringComparison" /> 값이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DnsSafeHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DnsSafeHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DnsSafeHost : string" Usage="System.Uri.DnsSafeHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>필요한 경우 이스케이프 해제된 후 호스트 이름을 가져오는 것이 DNS 확인에 사용하기에 안전합니다.</summary>
        <value>
          <see cref="T:System.String" /> 확인을 위해 이미 적합 한 경우 DNS 확인용으로 또는 원래 호스트 문자열에 대 한 적합 한 형식에서 URI 호스트 부분을 포함 하 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IPv6 주소를 대괄호 () 제거 됩니다 및 <xref:System.Net.IPAddress.ScopeId%2A> 이 인스턴스를 만들 때 지정 된 경우 속성이 설정 되어 있습니다.

(예를 들어, "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), 다음 DnsSafeHost는 이스케이프 된 문자열 반환이 인스턴스를 생성 하는 이스케이프 된 문자열을 사용 하는 경우 합니다. 반환 된 모든 이스케이프 된 문자열을 이스케이프 해제 `DnsSafeHost` DNS 확인을 위해 해당 문자열을 사용 하기 전에 (예제 참조). (예를 들어, "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), 다음 DnsSafeHost 이스케이프 되지 않은 문자열이 반환이 인스턴스를 생성 하는 잘못 된 이스케이프 해제 된 문자열을 사용 하는 경우.
  
 <xref:System.Uri.DnsSafeHost%2A> 속성은이 항목의 뒷부분에 설명 된 대로 구성 설정에 따라 달라 집니다. 구성 설정을 사용 하는 경우 일관성 없는 결과가 발생할 수 있는 Windows 스토어 응용 프로그램에서 변경할 수 없습니다 <xref:System.Uri.DnsSafeHost%2A>합니다. <xref:System.Uri.IdnHost%2A> 속성은 사용 하 여 안으로 제공 <xref:System.Uri.DnsSafeHost%2A>이므로 <xref:System.Uri.IdnHost%2A> 안전한 지, 어떤 현재 관계 없이 DNS를 항상 되도록 보장 됩니다 *app.config* 설정이 필요할 수 있습니다.  
  
 <xref:System.Uri.DnsSafeHost%2A> 속성이.NET Framework v3.5, 3.0 SP1에서에서 확장 되 고 2.0 식별자 IRI (International Resource)을 제공 하는 SP1에 따라 RFC 3987을 지원 합니다. 현재 사용자의 경우 IRI를 사용하도록 설정하지 않는 한 .NET Framework 2.0 동작에서 차이를 느끼지 못할 것입니다. 이 덕분에 .NET Framework 이전 버전과의 응용 프로그램 호환성이 제공됩니다.  
  
 Iri 지원을 사용 하는 다음 두 변경이 필요 합니다.  
  
1.  다음 줄을 추가 합니다 *machine.config* .NET Framework 2.0 디렉터리  
  
     \<section name="uri" type="System.Configuration.UriSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  
2.  다국어 도메인 이름 (IDN) 구문 분석 된 도메인 이름에 적용할 것인지와 IRI 구문 분석 규칙을 적용 해야 하는지 여부를 지정 합니다. 이 작업을 수행할 수 있습니다 합니다 *machine.config* 또는 합니다 *app.config* 파일입니다. 예를 들어, 다음 추가 합니다.  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 IDN을 사용하면 도메인 이름의 모든 유니코드 레이블이 해당 Punycode 문자로 변환됩니다. Punycode 이름에는 ASCII 문자만 사용되며 항상 xn-- 접두사로 시작합니다. 대부분의 DNS 서버는 ASCII 문자만 지원하므로(RFC 3940 참조) 이렇게 해야 인터넷에서 기존 DNS 서버를 지원할 수 있습니다.  
  
 값에만 영향을 줍니다 IDN을 사용 하면는 <xref:System.Uri.DnsSafeHost%2A> 속성입니다.  
  
 세 가지 idn 관련 값을 사용 하는 DNS 서버에 따라 가지가 있습니다.  
  
-   idn 사용 = All  
  
     이 값은 모든 유니코드 도메인 이름을 해당하는 Punycode 항목(IDN 이름)으로 변환합니다.  
  
-   사용 하도록 설정 하는 idn AllExceptIntranet =  
  
     이 값은 해당하는 Punycode 항목(IDN 이름)을 사용하도록 모든 외부 유니코드 도메인 이름을 변환합니다. 이 경우 로컬 인트라넷에 있는 국가별 이름을 처리하기 위해 인트라넷에 사용되는 DNS 서버가 유니코드 이름 확인을 지원해야 합니다.  
  
-   idn 사용 = 없음  
  
     이 값은 Punycode를 사용하도록 어떠한 유니코드 도메인 이름도 변환하지 않습니다. .NET Framework 2.0 동작을 사용 하 여 일치 하는 기본 값입니다.  
  
 IRI 구분 분석 (iriParsing 사용 = `true`) 문자 검사가 최신 IRI 규칙 RFC 3987 및 정규화를 수행 합니다. 기본값은 `false` 및는 정규화 수행 (및 문자 검사가 RFC 2396 및 RFC 2732 IPv6 리터럴)입니다.  
  
 IRI 지원에 대 한 자세한 내용은 설명 섹션을 참조 하세요.를 <xref:System.Uri> 클래스입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Uri> 문자열 인스턴스입니다. 반환 된 값 간의 차이 보여 줍니다 <xref:System.Uri.Host%2A>호스트 이름 또는 URI에 지정 된 주소를 반환 하는, 및에서 반환 되는 값 <xref:System.Uri.DnsSafeHost%2A>, DNS 확인에 사용 하기에 안전 하 게 연결 되는 주소를 반환 하는 합니다.  
  
 [!code-cpp[NCLUriEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#4)]
 [!code-csharp[NCLUriEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#4)]
 [!code-vb[NCLUriEnhancements#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#4)]  

 설명에서 설명 했 듯이를 해결 하기 전에 호스트 이름을 이스케이프 해제 합니다. 사용할 수는 <xref:System.Uri.UnescapeDataString%2A> 호스트 이름에 고 이스케이프 해제 하는 메서드를 호출 하 여 해결할 수는 <xref:System.Net.Dns.GetHostEntry%2A> 메서드.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uri.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">현재 인스턴스와 비교할 URI 식별자나 <see cref="T:System.Uri" /> 인스턴스입니다.</param>
        <summary>두 <see cref="T:System.Uri" /> 인스턴스가 같은지 비교합니다.</summary>
        <returns>두 인스턴스가 같은 URI를 나타내면 <see cref="T:System.Boolean" /> 값이 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Uri.Equals%2A> 사용자 정보에 관계 없이 두 인스턴스를 비교 하는 메서드 (<xref:System.Uri.UserInfo%2A>) 및 조각 (<xref:System.Uri.Fragment%2A>)를 포함할 수 있는 부분입니다. 예를 들어, Uri를 지정 http://www.contoso.com/index.htm#search 하 고 http://user:password@www.contoso.com/index.htm서 <xref:System.Uri.Equals%2A> 메서드는 반환 `true`합니다.  
  
 없으면 <xref:System.Uri> 인스턴스 유니코드 호스트 이름의 형식이 및 `comparand` 매개 변수에 포함을 <xref:System.Uri> 인스턴스나 다음 해당 Punycode 호스트 이름에 있는 호스트 이름으로 구성 되는 식별자 <xref:System.Uri.Equals%2A> 반환 `true` 식별자 IRI (International Resource) 및 다국어 도메인 이름 (IDN)를 지원 하는 경우에 사용할 수 있습니다. Punycode 이름에는 ASCII 문자만 사용되며 항상 xn-- 접두사로 시작합니다.  
  
 IRI 지원에 대 한 자세한 내용은 설명 섹션을 참조 하세요.를 <xref:System.Uri> 클래스입니다.  
  
> [!NOTE]
>  .NET Framework 버전 1.0 및 1.1의 <xref:System.Uri.Query%2A> 도 무시 됩니다.  
  
> [!NOTE]
>  <xref:System.Uri.Equals%2A> 파생된 클래스에서 메서드를 재정의할 수 있습니다 주의 악의적인 엔터티가 메서드를 수정할 수 없습니다. 이 인스턴스가 신뢰할 수 있는 원본에서 가져온는 알 수 없는 경우 보안 검사를 수행 하려면이 메서드를 사용 하지 해야 합니다.  
  
   
  
## Examples  
 이 예제에서는 두 <xref:System.Uri> 문자열에서 인스턴스를 비교 하 여 동일한 값을 나타내는지 여부를 확인할 수 있습니다. `address1` 및 `address2` 동일 하기 때문에 <xref:System.Uri.Fragment%2A> 이 비교에 대 한 부분은 무시 됩니다. 결과 콘솔에 기록 됩니다.  
  
 [!code-cpp[NCLUriExamples#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#8)]
 [!code-csharp[NCLUriExamples#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#8)]
 [!code-vb[NCLUriExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">부분적으로 신뢰할 수 있는 코드에서 파생 되지 않도록 하려면 <see cref="T:System.Uri" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Escape ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Escape();" />
      <MemberSignature Language="F#" Value="abstract member Escape : unit -&gt; unit&#xA;override this.Escape : unit -&gt; unit" Usage="uri.Escape " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>경로 구성 요소에서 안전하지 않거나 예약된 문자를 해당 16진 문자 표현으로 변환합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">생성자에서 전달된 URI가 잘못된 경우. 이 예외는 URI에 너무 많은 문자가 있거나 URI가 상대 URI인 경우 발생할 수 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeDataString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeDataString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeDataString : string -&gt; string" Usage="System.Uri.EscapeDataString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">이스케이프할 문자열입니다.</param>
        <summary>문자열을 이스케이프된 표현으로 변환합니다.</summary>
        <returns>
          <see cref="T:System.String" />에 대해 이스케이프된 표현이 포함된 <paramref name="stringToEscape" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 <xref:System.Uri.EscapeDataString%2A> 메서드는 RFC 2396 예약 되지 않은 문자를 제외한 모든 문자는 16 진수 표현으로 변환 합니다. 다국어 리소스 식별자 (IRIs) 또는 다국어 도메인 이름 (IDN) 구문 분석을 사용 하는 경우는 <xref:System.Uri.EscapeDataString%2A> 메서드 변환 모든 문자를 RFC 제외 하 고 3986 예약 되지 않은 문자를 해당 16 진수 표현입니다. 모든 유니코드 문자는 이스케이프 되지 전에 utf-8 형식으로 변환 됩니다.  
  
 이 메서드는 가정 `stringToEscape` 에 이스케이프 시퀀스가 없습니다.  
  
 기본적으로 문자열은 RFC 2396에 따라 이스케이프 됩니다. 다국어 리소스 식별자 (IRIs) 또는 다국어 도메인 이름 (IDN) 구문 분석을 사용 하는 경우 문자열은 RFC 3986 및 RFC 3987에 따라 이스케이프 됩니다. 예약 된 문자와 예약 되지 않은의 정의 대 한 이러한 Rfc를 참조 하세요.  
  
 IRI 지원에 대 한 자세한 내용은 설명 섹션을 참조 하세요.를 <xref:System.Uri> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>
              <see href="http://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.FormatException" />을 catch합니다.</para>
          </block>
          <paramref name="stringToEscape" />의 길이가 32766자를 초과합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function EscapeString (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::String ^ EscapeString(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member EscapeString : string -&gt; string" Usage="System.Uri.EscapeString str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">이스케이프된 표현으로 변형할 문자열입니다.</param>
        <summary>문자열을 이스케이프된 표현으로 변환합니다.</summary>
        <returns>이스케이프된 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.EscapeString%2A> 메서드 RFC 2396의 예약 된 문자 및 문자 값이 127 보다 큰 모든 문자 16 진수 표현으로 변환 합니다. 모든 유니코드 문자는 이스케이프 되지 전에 utf-8 형식으로 변환 됩니다.  
  
 기본적으로 문자열은 RFC 2396에 따라 이스케이프 됩니다. 다국어 리소스 식별자 (IRIs) 또는 다국어 도메인 이름 (IDN) 구문 분석을 사용 하는 경우 문자열은 RFC 3986 및 RFC 3987에 따라 이스케이프 됩니다.  
  
 IRI 지원에 대 한 자세한 내용은 설명 섹션을 참조 하세요.를 <xref:System.Uri> 클래스입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeUriString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeUriString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeUriString : string -&gt; string" Usage="System.Uri.EscapeUriString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">이스케이프할 문자열입니다.</param>
        <summary>URI 문자열을 이스케이프된 표현으로 변환합니다.</summary>
        <returns>
          <see cref="T:System.String" />에 대해 이스케이프된 표현이 포함된 <paramref name="stringToEscape" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Uri.EscapeUriString%2A> 대 한 매개 변수일 언 이스케이프 된 URI 문자열을 준비 하는 방법의 <xref:System.Uri.%23ctor%2A> 생성자입니다.  
  
 기본적으로 <xref:System.Uri.EscapeUriString%2A> 메서드 RFC 2396 예약 되지 않은 문자를 제외한 모든 문자를 16 진수 표현으로 변환 합니다. 다국어 리소스 식별자 (IRIs) 또는 다국어 도메인 이름 (IDN) 구문 분석을 사용 하는 경우는 <xref:System.Uri.EscapeUriString%2A> 메서드 변환 모든 문자를 RFC 제외 하 고 3986 예약 되지 않은 문자를 해당 16 진수 표현입니다. 모든 유니코드 문자는 이스케이프 되지 전에 utf-8 형식으로 변환 됩니다.  
  
 이 메서드는 가정 `stringToEscape` 에 이스케이프 시퀀스가 없습니다.  
  
 기본적으로 문자열은 RFC 2396에 따라 이스케이프 됩니다. 다국어 리소스 식별자 (IRIs) 또는 다국어 도메인 이름 (IDN) 구문 분석을 사용 하는 경우 문자열은 RFC 3986 및 RFC 3987에 따라 이스케이프 됩니다. 예약 된 문자와 예약 되지 않은의 정의 대 한 이러한 Rfc를 참조 하세요.  
  
 IRI 지원에 대 한 자세한 내용은 설명 섹션을 참조 하세요.를 <xref:System.Uri> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>
              <see href="http://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.FormatException" />을 catch합니다.</para>
          </block>
          <paramref name="stringToEscape" />의 길이가 32766자를 초과합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Fragment As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Fragment { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Fragment : string" Usage="System.Uri.Fragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이스케이프된 URI 조각을 가져옵니다.</summary>
        <value>URI 조각 정보가 포함된 <see cref="T:System.String" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Fragment%2A> 속성 단편 마커를 포함 하 여 URI에는 조각 표식 (#)를 수행 하는 모든 텍스트를 가져옵니다. URI를 지정 된 http://www.contoso.com/index.htm#main, <xref:System.Uri.Fragment%2A> 속성 #main을 반환 합니다.  
  
 합니다 <xref:System.Uri.Fragment%2A> 속성이 있는 고려 되지 않습니다 <xref:System.Uri.Equals%2A> 비교 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Uri> 인스턴스 및 조각 정보를 콘솔에 씁니다.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHex (digit As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FromHex(char digit);" />
      <MemberSignature Language="F#" Value="static member FromHex : char -&gt; int" Usage="System.Uri.FromHex digit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="digit">변환할 16진수(0-9, a-f, A-F)입니다.</param>
        <summary>16진수의 10진수 값을 가져옵니다.</summary>
        <returns>지정된 16진수에 해당하는 0에서 15까지의 숫자가 포함된 <see cref="T:System.Int32" /> 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.FromHex%2A> 메서드 나타내는 16 진수 문자를 변환 (0-9, a-f, A-F) 10 진수 값 (0 ~ 15). 하는 경우 `digit` 유효한 16 진수가 아닙니다는 <xref:System.ArgumentException> 예외가 throw 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 인지 결정 문자를 16 진수 문자, 인 경우 해당 10 진수 값을 콘솔에 씁니다.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="digit" />가 유효한 16진수(0-9, a-f, A-F)가 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComponents (components As UriComponents, format As UriFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComponents(UriComponents components, UriFormat format);" />
      <MemberSignature Language="F#" Value="member this.GetComponents : UriComponents * UriFormat -&gt; string" Usage="uri.GetComponents (components, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" />
        <Parameter Name="format" Type="System.UriFormat" />
      </Parameters>
      <Docs>
        <param name="components">호출자에게 반환할 현재 인스턴스 부분을 지정하는 <see cref="T:System.UriComponents" /> 값의 비트 조합입니다.</param>
        <param name="format">특수 문자가 이스케이프되는 방법을 제어하는 <see cref="T:System.UriFormat" /> 값 중 하나입니다.</param>
        <summary>특수 문자에 지정된 이스케이프를 사용하여 현재 인스턴스에 지정된 구성 요소를 가져옵니다.</summary>
        <returns>구성 요소가 포함된 <see cref="T:System.String" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UriComponents.Query>, <xref:System.UriComponents.Fragment>를 <xref:System.UriComponents.Scheme>, <xref:System.UriComponents.UserInfo>를 <xref:System.UriComponents.Host>를 <xref:System.UriComponents.Port>, 및 <xref:System.UriComponents.Path> 구성 요소 구분 기호를 넣지 마십시오. 결합할 수는 <xref:System.UriComponents.KeepDelimiter> 구분 기호를 사용 하 여 값을 가져오려면 이러한 값 중 하나를 사용 하 여 플래그 (비트 OR 연산자 사용). 다른 모든 <xref:System.UriComponents> 값 및 값의 조합을 구분 기호는 반환된 된 값에 포함 됩니다.  
  
 구성 요소는 URI에 표시 되는 순서 대로 반환 됩니다. 예를 들어 경우 <xref:System.UriComponents.Scheme> 를 지정 하면 가장 먼저 나타납니다.  
  
 식별자 IRI (International Resource) 및 다국어 도메인 이름 (IDN) 지원이 활성화 된 경우에서 반환 된 문자 수를 <xref:System.String> 증가 합니다. IRI를 지원 하기 위해 사용 하는 Punycode 이름 ASCII 문자만 포함 하 고 항상 xn--접두사로 시작 합니다. 유니코드 서로게이트 문자에서 올바르게 처리 된 IRI 및 IDN을 사용 하는 경우는 <xref:System.Uri.GetComponents%2A> 메서드.  
  
 IRI 지원에 대 한 자세한 내용은 설명 섹션을 참조 하세요.를 <xref:System.Uri> 클래스입니다.  
  
> [!NOTE]
>  경우는 <xref:System.Uri.GetComponents%2A> 메서드를 호출 `format` 로 설정 <xref:System.UriFormat.Unescaped> , 반환 값에 대 한 인수로 사용할 수 없습니다는 <xref:System.Uri.%23ctor%2A> 비슷한 생성자 <xref:System.Uri>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="components" />가 유효한 <see cref="T:System.UriComponents" /> 값의 조합이 아닌 경우</exception>
        <exception cref="T:System.InvalidOperationException">현재 <see cref="T:System.Uri" />가 절대 URI가 아닌 경우. 상대 URI는 이 메서드에서 사용할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uri.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>URI의 해시 코드를 가져옵니다.</summary>
        <returns>이 URI에 대해 생성된 해시 값을 포함하는 <see cref="T:System.Int32" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 <xref:System.Uri> 인스턴스 및 해시 코드를 콘솔에 씁니다.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeftPart (part As UriPartial) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetLeftPart(UriPartial part);" />
      <MemberSignature Language="F#" Value="member this.GetLeftPart : UriPartial -&gt; string" Usage="uri.GetLeftPart part" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" />
      </Parameters>
      <Docs>
        <param name="part">반환할 URI 부분의 끝을 지정하는 <see cref="T:System.UriPartial" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Uri" /> 인스턴스 부분을 가져옵니다.</summary>
        <returns>지정된 <see cref="T:System.String" /> 인스턴스 부분을 포함하는 <see cref="T:System.Uri" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Uri.GetLeftPart%2A> 메서드가 반환 하 여 지정 하는 부분으로 끝나는 URI 문자열의 맨 왼쪽 부분을 포함 하는 문자열 `part`합니다.  
  
 <xref:System.Uri.GetLeftPart%2A> 다음과 같은 경우에 구분 기호를 포함합니다.  
  
-   <xref:System.UriPartial.Scheme> 스키마 구분 기호를 포함 합니다.  
  
-   <xref:System.UriPartial.Authority> 경로 구분 기호를 포함 하지 않습니다.  
  
-   <xref:System.UriPartial.Path> 쿼리 또는 조각 구분 기호는 원래 URI에서 구분 기호를 포함 합니다.  
  
-   <xref:System.UriPartial.Query> 포함 된 <xref:System.UriPartial.Path>, 쿼리 및 해당 구분 기호.  
  
 다음 예제 URI 및 호출의 결과 보여 <xref:System.Uri.GetLeftPart%2A> 사용 하 여 <xref:System.UriPartial.Scheme>, <xref:System.UriPartial.Authority>합니다 <xref:System.UriPartial.Path>, 또는 <xref:System.UriPartial.Query>합니다.  
  
|URI|Scheme|인증 기관|Path|Query|  
|---------|------------|---------------|----------|-----------|  
|http://www.contoso.com/index.htm?date=today|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm?date=today|  
|http://www.contoso.com/index.htm#main|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm|  
|mailto:user@contoso.com?subject=uri|mailto:|mailto:user@contoso.com|mailto:user@contoso.com?subject=uri|\<없음 >|  
|nntp://news.contoso.com/123456@contoso.com|nntp://|nntp://news.contoso.com|nntp://news.contoso.com/123456@contoso.com|nntp://news.contoso.com/123456@contoso.com|  
|news:123456@contoso.com|뉴스:|news:123456@contoso.com|news:123456@contoso.com|\<없음 >|  
|file://server/filename.ext|file://|file://server|file://server/filename.ext|file://server/filename.ext|  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Uri> 인스턴스 및 경로 콘솔에 씁니다.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 <see cref="T:System.Uri" /> 인스턴스가 절대 인스턴스가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException">지정된 <paramref name="part" />가 잘못된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="member this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="uri.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" />를 serialize하는 데 필요한 정보가 포함된 <see cref="T:System.Uri" /> 개체입니다.</param>
        <param name="streamingContext">
          <see cref="T:System.Runtime.Serialization.StreamingContext" />와 연결된 serialize된 스트림의 소스와 대상이 포함된 <see cref="T:System.Uri" />개체입니다.</param>
        <summary>현재 인스턴스를 serialize하는 데 필요한 데이터를 반환합니다.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">serialization 메서드를 사용 하 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexEscape (character As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HexEscape(char character);" />
      <MemberSignature Language="F#" Value="static member HexEscape : char -&gt; string" Usage="System.Uri.HexEscape character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">16진수 표현으로 변환할 문자입니다.</param>
        <summary>지정된 문자를 16진수 값으로 변환합니다.</summary>
        <returns>지정된 문자의 16진수 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 16 진수 값에 문자를 변환 하 고 콘솔에 씁니다.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="character" />가 255보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexUnescape (pattern As String, ByRef index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char HexUnescape(System::String ^ pattern, int % index);" />
      <MemberSignature Language="F#" Value="static member HexUnescape : string *  -&gt; char" Usage="System.Uri.HexUnescape (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pattern">문자의 16진수 표현입니다.</param>
        <param name="index">문자의 16진수 표현이 시작되는 <c>pattern</c>의 위치입니다.</param>
        <summary>지정된 문자의 16진수 표현을 문자로 변환합니다.</summary>
        <returns>
          <paramref name="index" /> 위치에 있으며 16진수로 인코딩된 문자입니다. <paramref name="index" />의 문자가 16진수로 인코딩되지 않은 경우 <paramref name="index" />의 문자가 반환됩니다. <paramref name="index" />의 값이 증분되어 반환된 문자 다음에 오는 문자를 가리킵니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 코드 예제에서는 여부를 확인 문자는 16 진수 인코딩, 그렇다면 해당 문자를 콘솔에 씁니다.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작거나 <paramref name="pattern" />의 문자 수보다 크거나 같은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : string" Usage="System.Uri.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 인스턴스의 호스트 구성 요소를 가져옵니다.</summary>
        <value>호스트 이름이 포함된 <see cref="T:System.String" />입니다. 일반적으로 서버의 DNS 호스트 이름이나 IP 주소입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 달리는 <xref:System.Uri.Authority%2A> 속성, 속성 값이 포트 번호를 다루지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 콘솔에 서버의 호스트 이름 (www.contoso.com)을 씁니다.  
  
 [!code-cpp[Classic Uri.Host Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Host Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Host Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HostNameType As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property UriHostNameType HostNameType { UriHostNameType get(); };" />
      <MemberSignature Language="F#" Value="member this.HostNameType : UriHostNameType" Usage="System.Uri.HostNameType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>URI에 지정된 호스트 이름의 형식을 가져옵니다.</summary>
        <value>
          <see cref="T:System.UriHostNameType" /> 열거의 멤버입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예에서는 <xref:System.Uri> 인스턴스 및 쓰기는 <xref:System.Uri.HostNameType%2A> 콘솔.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IdnHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IdnHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IdnHost : string" Usage="System.Uri.IdnHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Punycode를 적절하게 사용하는 호스트의 RFC 3490 규격 국제 도메인 이름입니다. 필요한 경우 이스케이프 해제된 후 이 문자열이 DNS 확인에 사용하기에 안전합니다.</summary>
        <value>IDN 표준에 따라 Punycode로 포맷된 호스트 이름을 반환합니다.<see cref="T:System.String" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 Punycode 형태로 도메인 이름이 필요로 하는 하위 수준 네트워킹 프로토콜의 사용에 대 한 제공 됩니다. 사용 하 여 코드에는 해당 특정 형식으로 필요 하지 않으면, <xref:System.Uri.Host%2A> 호스트 이름에 대 한 합니다.  
  
 사용 되지 않는 <xref:System.Uri.DnsSafeHost%2A> 속성에 따라 달라 집니다 *app.config* 설정에는 Windows 스토어 응용 프로그램에서 변경할 수 없습니다. IdnHost 안으로 제공 됩니다 <xref:System.Uri.DnsSafeHost%2A>이므로 <xref:System.Uri.IdnHost%2A> 안전한 지, 어떤 현재 관계 없이 DNS를 항상 되도록 보장 됩니다 *app.config* 설정이 필요할 수 있습니다.  

 (예를 들어, "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), 다음 IdnHost는 이스케이프 된 문자열 반환이 인스턴스를 생성 하는 이스케이프 된 문자열을 사용 하는 경우 합니다. DNS 확인을 위해 해당 문자열을 사용 하기 전에 IdnHost에서 반환 된 모든 이스케이프 된 문자열을 이스케이프 해제 해야 합니다. 주의 경우 데 잘못 된 이스케이프 되지 않은 문자열 (예를 들어, "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), 다음 IdnHost 이스케이프 되지 않은 문자열이 반환이 인스턴스를 생성 합니다.


 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbsoluteUri As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbsoluteUri { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbsoluteUri : bool" Usage="System.Uri.IsAbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Uri" /> 인스턴스가 절대 URI인지 여부를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Boolean" /> 인스턴스가 절대 URI이면 <see langword="true" /> 값이 <see cref="T:System.Uri" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 `true` 하는 경우 문자열 또는 <xref:System.Uri> 생성자에 전달 된 인스턴스는 절대로 구문 분석할 수 <xref:System.Uri> 는 체계, 기관 및 경로 포함 하는 경우. 그렇지 않은 경우는 <xref:System.Uri> 인스턴스 상대 경로로 처리 되 고 스키마 또는 다른 URI 구성 요소를 생략할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsBadFileSystemCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsBadFileSystemCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsBadFileSystemCharacter : char -&gt; bool&#xA;override this.IsBadFileSystemCharacter : char -&gt; bool" Usage="uri.IsBadFileSystemCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">테스트할 <see cref="T:System.Char" />입니다.</param>
        <summary>파일 시스템 이름에 있는 문자가 잘못되었는지 여부를 가져옵니다.</summary>
        <returns>지정된 문자가 잘못되었으면 <see cref="T:System.Boolean" /> 값이 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 문자는 NTFS 파일 시스템에 대 한 규칙에 따라 분석 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBaseOf(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.IsBaseOf : Uri -&gt; bool" Usage="uri.IsBaseOf uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">테스트할 지정된 <see cref="T:System.Uri" /> 인스턴스입니다.</param>
        <summary>현재 <see cref="T:System.Uri" /> 인스턴스가 지정된 <see cref="T:System.Uri" /> 인스턴스의 기본 URI인지 여부를 확인합니다.</summary>
        <returns>현재 <see langword="true" /> 인스턴스가 <see cref="T:System.Uri" />의 기본 URI이면 <paramref name="uri" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A> 현재 비교 하는 데 사용 됩니다 <xref:System.Uri> 인스턴스를 지정 된 <xref:System.Uri> 이 URI에 지정 된 기본 인지 여부를 확인 하려면 <xref:System.Uri>합니다. 두 개를 비교 하는 경우 <xref:System.Uri> 사용자 정보를 기본 관계를 결정 하는 개체 (<xref:System.Uri.UserInfo%2A>) 평가 되지 않습니다. Uri1과 uri2 두 Uri 비교 시 uri1는 마지막 슬래시 (/) 이후의 uri2의 모든 항목을 무시 하는 경우 두 Uri가 동일한 경우 uri2의 밑수입니다. 사용 하 여 http://host/path/path/file?query 기본 URI로 다음 표는 다른 Uri에 대 한 기본 인지 합니다.  
  
|URI|http://host/path/path/file?query 형식의 기본 형식 인지|  
|---------|------------------------------------------------------|  
|http://host/path/path/file/|예|  
|http://host/path/path/#fragment|예|  
|http://host/path/path/MoreDir/"|예|  
|http://host/path/path/OtherFile?Query|예|  
|http://host/path/path/|예|  
|http://host/path/path/file|예|  
|http://host/path/path|no|  
|http://host/path/path?query|아니요|  
|http://host/path/path#Fragment|아니요|  
|http://host/path/path2/|아니요|  
://host/path/path2/MoreDir|아니요|  
|http://host/path/File|아니요|  
  
   
  
## Examples  
 이 예제에서는 만듭니다는 <xref:System.Uri> 자료를 나타내는 인스턴스 <xref:System.Uri> 인스턴스. 그런 다음 두 번째 만듭니다 <xref:System.Uri> 문자열 인스턴스입니다. 호출 <xref:System.Uri.IsBaseOf%2A> 기본 인스턴스는 두 번째 인스턴스의 기본 인지 여부를 확인 합니다. 결과 콘솔에 기록 됩니다.  
  
 [!code-cpp[NCLUriEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#6)]
 [!code-csharp[NCLUriEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#6)]
 [!code-vb[NCLUriEnhancements#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDefaultPort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDefaultPort { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefaultPort : bool" Usage="System.Uri.IsDefaultPort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>URI의 포트 값이 이 체계의 기본값인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Boolean" /> 속성 값이 이 체계의 기본 포트이면 <see langword="true" /> 값이 <see cref="P:System.Uri.Port" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 <xref:System.Uri> 인스턴스 및 기본 포트를 사용 하는지 여부를 확인 합니다.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function IsExcludedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool IsExcludedCharacter(char character);" />
      <MemberSignature Language="F#" Value="static member IsExcludedCharacter : char -&gt; bool" Usage="System.Uri.IsExcludedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">테스트할 <see cref="T:System.Char" />입니다.</param>
        <summary>지정된 문자가 이스케이프되어야 하는지 여부를 가져옵니다.</summary>
        <returns>지정된 문자가 이스케이프되어야 하면 <see cref="T:System.Boolean" /> 값이 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFile { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFile : bool" Usage="System.Uri.IsFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>지정된 <see cref="T:System.Uri" />가 파일 URI인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Boolean" />가 파일 URI이면 <see langword="true" /> 값이 <see cref="T:System.Uri" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Uri.IsFile%2A> 속성은 `true` 때 합니다 <xref:System.Uri.Scheme%2A> 속성이 <xref:System.Uri.UriSchemeFile>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Uri> 인스턴스 및 파일 URI 인지 확인 합니다.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexDigit (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexDigit(char character);" />
      <MemberSignature Language="F#" Value="static member IsHexDigit : char -&gt; bool" Usage="System.Uri.IsHexDigit character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">유효성을 확인할 문자입니다.</param>
        <summary>지정된 문자가 유효한 16진수인지 여부를 확인합니다.</summary>
        <returns>문자가 유효한 16진수이면 <see cref="T:System.Boolean" /> 값이 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 16 진수 숫자 0-9와 A-f 또는 a-f 문자는 합니다.  
  
   
  
## Examples  
 다음 예제에서는 인지 결정 문자를 16 진수 문자, 인 경우 해당 10 진수 값을 콘솔에 씁니다.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexEncoding (pattern As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexEncoding(System::String ^ pattern, int index);" />
      <MemberSignature Language="F#" Value="static member IsHexEncoding : string * int -&gt; bool" Usage="System.Uri.IsHexEncoding (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pattern">확인할 문자열입니다.</param>
        <param name="index">16진수 인코딩을 확인할 <c>pattern</c>의 위치입니다.</param>
        <summary>문자열의 문자가 16진수로 인코딩되었는지 여부를 확인합니다.</summary>
        <returns>
          <see cref="T:System.Boolean" />이 지정된 위치에 16진수로 인코딩되어 있으면 <see langword="true" /> 값이 <paramref name="pattern" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsHexEncoding%2A> 메서드 확인 인코딩에 대 한 16 진수 문자열에서 "%hexhex" 패턴 "hex" 위치 뒤에 오는 숫자 0에서 9에는 문자 A-f (대/소문자 구분).  
  
   
  
## Examples  
 다음 코드 예제에서는 여부를 확인 문자는 16 진수 인코딩, 그렇다면 해당 문자를 콘솔에 씁니다.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoopback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoopback : bool" Usage="System.Uri.IsLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>지정된 <see cref="T:System.Uri" />가 로컬 호스트를 참조하는지 여부를 가져옵니다.</summary>
        <value>이 <see cref="T:System.Boolean" />가 로컬 호스트를 참조하면 <see langword="true" /> 값이 <see cref="T:System.Uri" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A> 반환 `true` 이 인스턴스가 만들어질 때 지정 된 URI는 127.0.0.1, 루프백, 하는 경우 localhost 또는 URI를 지정 하지 않은 경우 또는 호스트 정보 (예를 들어 file:///c:Dir/file.txt). 다른 모든 Uri 반환 `false`합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Uri> 인스턴스 및 로컬 호스트를 참조 하는지 여부를 결정 합니다.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsReservedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsReservedCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsReservedCharacter : char -&gt; bool&#xA;override this.IsReservedCharacter : char -&gt; bool" Usage="uri.IsReservedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">테스트할 <see cref="T:System.Char" />입니다.</param>
        <summary>지정된 문자가 예약된 문자인지 여부를 가져옵니다.</summary>
        <returns>지정된 문자가 예약된 문자이면 <see cref="T:System.Boolean" /> 값이 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnc As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnc { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnc : bool" Usage="System.Uri.IsUnc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>지정된 <see cref="T:System.Uri" />가 UNC(Universal Naming Convention) 경로인지 여부를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Boolean" />가 UNC 경로이면 <see langword="true" /> 값이 <see cref="T:System.Uri" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsUnc%2A> 속성은 `true` 하는 경우 지정 된 <xref:System.Uri> 인스턴스가 UNC 경로 (같은 \\\server\folder 또는 file://server/folder). 이 속성은 항상 반환 `true` URI는 file:// scheme 있고 호스트 구성 요소를 지정 하는 경우.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Uri> 인스턴스 및 UNC 경로 인지 확인 합니다.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberSignature Language="VB.NET" Value="Public Function IsWellFormedOriginalString () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsWellFormedOriginalString();" />
      <MemberSignature Language="F#" Value="member this.IsWellFormedOriginalString : unit -&gt; bool" Usage="uri.IsWellFormedOriginalString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Uri" />를 구성하는 데 사용된 문자열의 형식이 올바른지, 이후에 문자열을 이스케이프하지 않아도 되는지 여부를 나타냅니다.</summary>
        <returns>문자열이 제대로 구성되었으면 <see cref="T:System.Boolean" /> 값이 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 문자열을 제대로 구성에 따라 RFC 2396 및 RFC 2732 기본적으로 간주 됩니다. 문자열은 RFC 3986 및 RFC 3987에 따라 제대로 구성 된 것으로 간주 됩니다 International Resource Identifier (IRIs) 또는 다국어 도메인 이름 (IDN) 구문 분석을 사용 하는 경우  
  
 문자열은 잘못 구성 된, 다음 조건 중 하나가 발생할 경우에 false를 반환 하도록 메서드를 일으키는 것으로 간주 됩니다.  
  
|Error|예제|  
|-----------|-------------|  
|문자열은 올바르게 이스케이프 되지 않습니다.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) 이름|  
|문자열은 절대 <xref:System.Uri> 암시적 파일을 나타내는 <xref:System.Uri>합니다.|c:\\\directory\filename|  
|이 문자열은 절대 URI의 경로 앞에 슬래시를이 누락 되었습니다.|file://c:/directory/filename|  
|문자열 이스케이프 백슬래시가 포함 슬래시로 간주 됩니다.|http:\\\host/path/file|  
|문자열을 나타내는 계층적 절대 <xref:System.Uri> "://"에 포함 되어 있지 않습니다.|www.contoso.com/path/file|  
|에 대 한 파서를 <xref:System.Uri.Scheme%2A?displayProperty=nameWithType> 원래 문자열을 제대로 구성 되지 않았음을 나타냅니다.|이 예제에서는 URI의 구성표에 따라 달라 집니다.|  
  
 기본적으로 문자열을이 만드는 데 <xref:System.Uri> RFC 2396 및 RFC 2732에 따라 잘 구성 된 것으로 간주 됩니다.  
  
 다국어 도메인 이름 (IDN) 지원과 식별자 IRI (International Resource)는 사용 하는 경우,이 생성 하는 데 문자열 <xref:System.Uri> RFC 3986 및 RFC 3987을 사용 하 여 따라 잘 구성 된 것으로 간주 됩니다. IRI를 지원 하기 위해 사용 하는 Punycode 이름 ASCII 문자만 포함 하 고 항상 xn--접두사로 시작 합니다.  
  
 IRI 지원에 대 한 자세한 내용은 설명 섹션을 참조 하세요.를 <xref:System.Uri> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://www.ietf.org/">http://www.ietf.org</related>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWellFormedUriString(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="static member IsWellFormedUriString : string * UriKind -&gt; bool" Usage="System.Uri.IsWellFormedUriString (uriString, uriKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">
          <see cref="T:System.Uri" /> 생성을 시도하는 데 사용되는 문자열입니다.</param>
        <param name="uriKind">
          <c>uriString</c>에 있는 <see cref="T:System.Uri" />의 형식입니다.</param>
        <summary>문자열로 URI 생성을 시도하여 문자열 형식이 올바른지 여부를 나타내고 이후에 문자열을 이스케이프하지 않아도 되는지 확인합니다.</summary>
        <returns>문자열이 제대로 구성되었으면 <see cref="T:System.Boolean" /> 값이 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 버전 4.5 이전 버전의.NET에 기본적으로 문자열 간주 됩니다 RFC 2396 및 RFC 2732 따른 올바른 형식된. 다국어 리소스 식별자 (IRIs) 또는 다국어 도메인 이름 (IDN) 구문 분석을 사용 하는 문자열 RFC 3986 및 RFC 3987에 따라 올바른 형식된으로 간주 됩니다.  
  
 .NET 4.5부터, 문자열은 항상 간주 따라 잘 구성 된 RFC 3986 및 RFC 3987 여부 IRI 또는 IDN은 사용 하도록 설정 합니다. 그러나 이것이.NET 4.5를 대상으로 하는 앱에 대 한 true 이상. .NET 4.0을 대상으로 하는 앱 호환성 코드를 호출 하 고 이전 (4.5 버전 이전의) 동작이 발생 합니다.  
  
 문자열을 잘못 구성 된, 다음 조건 중 하나가 발생할 경우에 false를 반환 하도록 메서드를 일으키는 것으로 간주 됩니다.  
  
|Error|예제|  
|-----------|-------------|  
|문자열은 올바르게 이스케이프 되지 않습니다.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) 이름|  
|문자열은 절대 <xref:System.Uri> 암시적 파일을 나타내는 <xref:System.Uri>합니다.|c:\\\directory\filename|  
|이 문자열은 절대 URI의 경로 앞에 슬래시를이 누락 되었습니다.|file://c:/directory/filename|  
|문자열 이스케이프 백슬래시가 포함 슬래시도 간주 됩니다.|http:\\\host/path/file|  
|문자열을 나타내는 계층적 절대 <xref:System.Uri> "://"에 포함 되어 있지 않습니다|www.contoso.com/path/file|  
|에 대 한 파서를 <xref:System.Uri.Scheme%2A> 원래 문자열을 제대로 구성 되지 않았음을 나타냅니다.|이 예제에서는 URI의 구성표에 따라 달라 집니다.|  
|상대 Uri에 콜론을 사용 하 여.NET 4.5부터 (': ')가 첫 번째 세그먼트에 고려 되지 않습니다 잘 구성 된 합니다.|2013.05.29_14:33:41|  
  
 IRI 지원에 대 한 자세한 내용은 설명 섹션을 참조 하세요.를 <xref:System.Uri> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://www.ietf.org/">http://www.ietf.org</related>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalPath : string" Usage="System.Uri.LocalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파일 이름에 대한 로컬 운영 체제 표현을 가져옵니다.</summary>
        <value>파일 이름에 대한 로컬 운영 체제 표현이 포함된 <see cref="T:System.String" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환한 값 이스케이프 아닙니다. 모든 슬래시 (/)을 Windows 파일 경로로 경로가 인식 되 면 이전 버전과 슬래시 바뀝니다 (\\).  
  
 URI에 대 한 `file://computer/file.ext`, 절대 경로가 `/file.ext` 로컬 경로 이며 `\\computer\file.ext`합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Uri> 인스턴스 및 로컬 경로를 콘솔에 씁니다.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function MakeRelative (toUri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MakeRelative(Uri ^ toUri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelative : Uri -&gt; string" Usage="uri.MakeRelative toUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="toUri">현재 URI와 비교할 URI입니다.</param>
        <summary>두 <see cref="T:System.Uri" /> 인스턴스 간의 차이점을 확인합니다.</summary>
        <returns>이 URI 인스턴스와 <paramref name="toUri" />의 호스트 이름 및 체계가 같으면 이 메서드에서 상대 URI를 나타내는 <see cref="T:System.String" />을 반환합니다. 이 상대 URI가 현재 URI 인스턴스에 추가되면 <paramref name="toUri" /> 매개 변수가 생성됩니다.  
  
호스트 이름이나 체계가 다르면 이 메서드에서 <see cref="T:System.String" /> 매개 변수를 나타내는 <paramref name="toUri" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 표에서 URI 인스턴스 `toUri`, 호출의 결과 <xref:System.Uri.MakeRelative%2A>합니다.  
  
|현재 URI 인스턴스|`toUri`|반환 값|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1/test1.txt|  
  
 사용자 정보를 URI에 있는 경우 무시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 2 <xref:System.Uri> 인스턴스. 경로 정보 차이 콘솔에 기록 됩니다.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toUri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ MakeRelativeUri(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelativeUri : Uri -&gt; Uri" Usage="uri.MakeRelativeUri uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">현재 URI와 비교할 URI입니다.</param>
        <summary>두 <see cref="T:System.Uri" /> 인스턴스 간의 차이점을 확인합니다.</summary>
        <returns>이 URI 인스턴스와 <paramref name="uri" />의 호스트 이름 및 스키마가 같으면 이 메서드에서 상대 <see cref="T:System.Uri" />를 반환합니다. 이 상대 URI가 현재 URI 인스턴스에 추가되면 <paramref name="uri" />가 생성됩니다.  
  
호스트 이름이나 체계가 다르면 이 메서드에서 <see cref="T:System.Uri" /> 매개 변수를 나타내는 <paramref name="uri" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 표에서 URI 인스턴스 `toUri`, 호출의 결과 <xref:System.Uri.MakeRelativeUri%2A>합니다.  
  
|현재 URI 인스턴스|`toUri`|반환 값|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1/test1.txt|  
  
 사용자 정보를 URI에 있는 경우 무시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 2 <xref:System.Uri> 인스턴스. 경로 정보 차이 콘솔에 기록 됩니다.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Uri * Uri -&gt; bool" Usage="uri1 = uri2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">
          <c>uri2</c>와 비교할 <see cref="T:System.Uri" /> 인스턴스입니다.</param>
        <param name="uri2">
          <c>uri1</c>과 비교할 <see cref="T:System.Uri" /> 인스턴스입니다.</param>
        <summary>두 <see cref="T:System.Uri" /> 인스턴스의 값이 같은지를 확인합니다.</summary>
        <returns>두 <see cref="T:System.Boolean" /> 인스턴스가 동일하면 <see langword="true" /> 값이 <see cref="T:System.Uri" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하는 <xref:System.Uri.Equals%2A> 결정 하는 방법 여부를 두 <xref:System.Uri> 인스턴스가 동일 합니다. <xref:System.Uri.UserInfo%2A> 및 <xref:System.Uri.Fragment%2A> 이 비교를 수행 하는 경우 콘텐츠는 무시 됩니다.  
  
   
  
## Examples  
 이 예제에서는 세 가지 <xref:System.Uri> 문자열에서 인스턴스를 비교 하 여 동일한 값을 나타내는지 여부를 확인할 수 있습니다. `Address1` 및 `Address2` 동일 하기 때문에 <xref:System.Uri.Fragment%2A> 이 비교에 대 한 부분은 무시 됩니다. 결과 콘솔에 기록 됩니다.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Uri * Uri -&gt; bool" Usage="System.Uri.op_Inequality (uri1, uri2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">
          <c>uri2</c>와 비교할 <see cref="T:System.Uri" /> 인스턴스입니다.</param>
        <param name="uri2">
          <c>uri1</c>과 비교할 <see cref="T:System.Uri" /> 인스턴스입니다.</param>
        <summary>두 <see cref="T:System.Uri" /> 인스턴스의 값이 다른지 여부를 확인합니다.</summary>
        <returns>두 <see cref="T:System.Boolean" /> 인스턴스가 동일하면 <see langword="true" /> 값이 <see cref="T:System.Uri" />이고, 그렇지 않으면 <see langword="false" />입니다. 매개 변수 중 하나가 <see langword="null" />이면 이 메서드에서 <see langword="true" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여는 <xref:System.Uri.Equals%2A> 결정 하는 방법 여부를 두 <xref:System.Uri> 인스턴스 같지 않습니다. <xref:System.Uri.UserInfo%2A> 및 <xref:System.Uri.Fragment%2A> 이 비교를 수행 하는 경우 콘텐츠는 무시 됩니다.  
  
   
  
## Examples  
 이 예제에서는 세 가지 <xref:System.Uri> 문자열에서 인스턴스를 비교 하 여 동일한 값을 나타내는지 여부를 확인할 수 있습니다. `Address2` 및 `Address3` 동일 하지 않은 때문에 `Address3` 포함 된 <xref:System.Uri.Query%2A> 에 없는 `Address2`합니다. 결과 콘솔에 기록 됩니다.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OriginalString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalString : string" Usage="System.Uri.OriginalString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Uri" /> 생성자에 전달된 원래 URI 문자열을 가져옵니다.</summary>
        <value>이 인스턴스를 만들 때 URI를 지정했으면 해당 URI가 포함된 <see cref="T:System.String" />이고, 그렇지 않으면 <see cref="F:System.String.Empty" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 생성자에 지정 된 URI에 선행 또는 후행 공백을 포함 하는 경우 이러한 공백이 유지 됩니다.  
  
 이 속성에서 반환한 값에서 다른 <xref:System.Uri.ToString%2A> 고 <xref:System.Uri.AbsoluteUri%2A>입니다. <xref:System.Uri.ToString%2A> 정규화 적으로 이스케이프 되지 않은 형식의 URI 반환합니다. <xref:System.Uri.AbsoluteUri%2A> 정규화 적으로 이스케이프 된 형식의 URI 반환합니다.  
  
 식별자 IRI (International Resource) 및 다국어 도메인 이름 (IDN) 지원이 활성화 된 경우 <xref:System.Uri.OriginalString%2A> 초기화 하는 데 사용 된 하나 경우 Punycode 호스트 이름 사용 하 여 원래 비 정규화 된 문자열을 반환 합니다 <xref:System.Uri> 인스턴스. Punycode 이름에는 ASCII 문자만 사용되며 항상 xn-- 접두사로 시작합니다.  
  
 IRI 지원에 대 한 자세한 내용은 설명 섹션을 참조 하세요.를 <xref:System.Uri> 클래스입니다.  
  
 경우는 <xref:System.Uri> 개체가 serialize 되는 <xref:System.Uri.OriginalString%2A> 유지 되지 않습니다. Serialization 프로세스 및 사용 하는 완벽 하 게 이스케이프 된 정규화 된 <xref:System.Uri.AbsoluteUri%2A> 직렬화 할 때 속성입니다. 에 대 한는 <xref:System.Uri> IPv6 주소를 포함 하는, IPv6 주소 및 범위 ID가 포함 된 serialize 된에서 <xref:System.Uri> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.Uri> 문자열 인스턴스입니다. 반환 된 값 간의 차이 보여 줍니다 <xref:System.Uri.OriginalString%2A>, 생성자를 호출에서 전달 된 문자열을 반환 하는 <xref:System.Uri.ToString%2A>, 문자열의 정규 형식이 반환 합니다.  
  
 [!code-cpp[NCLUriEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#3)]
 [!code-csharp[NCLUriEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#3)]
 [!code-vb[NCLUriEnhancements#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Parse ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Parse();" />
      <MemberSignature Language="F#" Value="abstract member Parse : unit -&gt; unit&#xA;override this.Parse : unit -&gt; unit" Usage="uri.Parse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 인스턴스의 URI를 구문 분석하여 유효한 URI에 필요한 모든 부분이 포함되어 있는지 확인합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">생성자에서 전달된 URI가 잘못된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathAndQuery As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathAndQuery { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathAndQuery : string" Usage="System.Uri.PathAndQuery" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>물음표(?)로 구분된 <see cref="P:System.Uri.AbsolutePath" /> 및 <see cref="P:System.Uri.Query" /> 속성을 가져옵니다.</summary>
        <value>물음표(?)로 구분된 <see cref="T:System.String" /> 및 <see cref="P:System.Uri.AbsolutePath" /> 속성이 포함된 <see cref="P:System.Uri.Query" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.PathAndQuery%2A> 속성 서버에서 요청을 사용 하 여 전송 된 쿼리 정보 절대 경로 포함 합니다. 연결 하는 것과 동일 합니다 <xref:System.Uri.AbsolutePath%2A> 고 <xref:System.Uri.Query%2A> 속성입니다.  
  
 <xref:System.Uri.PathAndQuery%2A> 속성은 RFC 2396에 따라 기본적으로 이스케이프 됩니다. 다국어 리소스 식별자 (IRIs) 또는 다국어 도메인 이름 (IDN) 구문 분석을 사용 하는 경우는 <xref:System.Uri.PathAndQuery%2A> RFC 3986 및 RFC 3987에 따라 속성을 이스케이프 합니다.  
  
 IRI 지원에 대 한 자세한 내용은 설명 섹션을 참조 하세요.를 <xref:System.Uri> 클래스입니다.  
  
   
  
## Examples  
 다음 예제에서는 URI 경로 씁니다 (/ catalog/shownew.htm) 및 쿼리 (날짜가 오늘과 같거나 오늘) 정보를 콘솔.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.PathAndQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Port : int" Usage="System.Uri.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 URI의 포트 번호를 가져옵니다.</summary>
        <value>이 URI의 포트 번호가 포함된 <see cref="T:System.Int32" /> 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 포트 번호를 URI에서 참조 되는 서버에 연결 하기 위해 사용 되는 프로토콜 포트를 정의 합니다. 포트 URI의 일부로 지정 하지 않으면는 <xref:System.Uri.Port%2A> 속성 프로토콜에 대 한 기본값을 반환 합니다. 기본 포트 번호가 있으면-1을 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 콘솔에 URI의 포트 번호를 씁니다. 이 경우 값은 HTTP에 포트 80에 대 한 기본 포트 번호입니다.  
  
 [!code-cpp[Classic Uri.Port Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Port Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Port Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Query As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Query { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Query : string" Usage="System.Uri.Query" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>지정된 URI에 포함된 쿼리 정보를 가져옵니다.</summary>
        <value>지정된 URI에 포함된 쿼리 정보를 포함하는 <see cref="T:System.String" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Query%2A> 속성 URI에 포함 된 쿼리 정보를 포함 합니다. 쿼리 정보는 물음표 (?)로 경로 정보에서 분리 되 고 URI의 끝까지 계속 합니다. 반환 된 쿼리 정보를 선행 물음표를 포함 합니다.  
  
 쿼리 정보는 RFC 2396에 따라 기본적으로 이스케이프 됩니다. 다국어 리소스 식별자 (IRIs) 또는 다국어 도메인 이름 (IDN) 구문 분석을 사용 하는 경우 쿼리 내용은 RFC 3986 및 RFC 3987에 따라 이스케이프 됩니다.  
  
 IRI 지원에 대 한 자세한 내용은 설명 섹션을 참조 하세요.를 <xref:System.Uri> 클래스입니다.  
  
   
  
## Examples  
 쿼리를 작성 하는 다음 예제에서는? 날짜가 오늘과 같거나 오늘 콘솔로 합니다.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#2)]
 [!code-vb[Classic Uri.PathAndQuery Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.Uri.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 URI의 체계 이름을 가져옵니다.</summary>
        <value>소문자로 변환된 이 URI의 스키마가 포함된 <see cref="T:System.String" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Uri.Scheme%2A> 속성 초기화를 사용 하는 체계를 반환 합니다 <xref:System.Uri> 인스턴스. 이 속성 초기화에 사용 되는 체계를 나타내지 않습니다는 <xref:System.Uri> 인스턴스 인식 되었습니다.  
  
 다음 표에서 반환 하는 몇 가지 가능한 값의 예는 <xref:System.Uri.Scheme%2A> 속성입니다.  
  
|Scheme|설명|  
|------------|-----------------|  
|파일|리소스는 로컬 컴퓨터의 파일입니다.|  
|ftp|FTP를 통해 리소스에 액세스 합니다.|  
|gopher|Gopher 프로토콜을 통해 리소스에 액세스 합니다.|  
|http|HTTP를 통해 리소스에 액세스 합니다.|  
|https|SSL 암호화 HTTP를 통해 리소스에 액세스 합니다.|  
|ldap|LDAP 프로토콜을 통해 리소스에 액세스 합니다.|  
|mailto|리소스 전자 메일 주소 이며 SMTP 프로토콜을 통해 액세스 합니다.|  
|net.pipe|명명 된 파이프를 통해 리소스에 액세스 합니다.|  
|net.tcp|리소스는 TCP 끝점에서 액세스 됩니다.|  
|news|NNTP 프로토콜을 통해 리소스에 액세스 합니다.|  
|nntp|NNTP 프로토콜을 통해 리소스에 액세스 합니다.|  
|telnet|텔넷 프로토콜을 통해 리소스에 액세스 합니다.|  
|uuid|리소스는 서비스와 통신 하는 것에 대 한 고유한 UUID 끝점 이름을 통해 액세스 됩니다.|  
  
   
  
## Examples  
 다음 예제에서는 콘솔에 체계 이름 (http)를 기록 합니다 http://www.contoso.com/ URI입니다.  
  
 [!code-cpp[Classic Uri.Scheme Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Scheme Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Scheme Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SchemeDelimiter As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ SchemeDelimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable SchemeDelimiter : string" Usage="System.Uri.SchemeDelimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>통신 프로토콜 체계를 URI의 주소 부분과 구분하는 문자를 지정합니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서 문자열을 만듭니다 <xref:System.Uri.UriSchemeHttp>, <xref:System.Uri.SchemeDelimiter>, 및 주소입니다. <xref:System.Uri> 인스턴스가 다음 문자열에서 만들어집니다.  
  
 [!code-cpp[NCLUriExamples#17](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#17)]
 [!code-csharp[NCLUriExamples#17](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#17)]
 [!code-vb[NCLUriExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Segments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Segments { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Segments : string[]" Usage="System.Uri.Segments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>지정된 URI를 구성하는 경로 세그먼트가 포함된 배열을 가져옵니다.</summary>
        <value>지정된 URI를 구성하는 경로 세그먼트가 포함된 <see cref="T:System.String" /> 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Segments%2A> 속성이 URI의 절대 경로 형성 하는 "세그먼트" (부분)를 포함 하는 문자열의 배열을 반환 합니다. 첫 번째 세그먼트는 슬래시 (/) 또는 경로 끝에 도달할 때까지 해당 첫 번째 문자에서 절대 경로 구문 분석 하 여 가져옵니다. 각 추가 세그먼트는 이전 세그먼트 다음 첫 번째 문자에서 시작 하 고 슬래시 또는 경로의 끝을 사용 하 여 종료 합니다. (URI의 절대 경로 포함 모든 호스트 및 포트와 쿼리 및 조각.)  
  
 다음 예제에서는 두 Uri에 대 한 절대 경로 세그먼트를 보여 줍니다. 두 번째 예제 조각 및 쿼리를 절대 경로에 속하지 않는 및 세그먼트 많지 않기를 보여 줍니다.  
  
 절대 URI:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm  
  
 절대 경로:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 세그먼트:  
 - /
 - 장 /
 - Chapter1 /
 - 섹션 /
 - Section1.htm  
  
 절대 URI:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#page1?answer=NO  
  
 절대 경로:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 세그먼트:  
 - /
 - 장 /
 - Chapter1 /
 - 섹션 /
 - Section1.htm  
  
 참고 절대 경로 '/'를 사용 하 여 시작 하므로 첫 번째 세그먼트를 포함 하 고 아무 것도 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Uri> 3 사용 하 여 인스턴스 세그먼트 및 세그먼트 화면에 표시 합니다.  
  
 [!code-cpp[NCLUriExamples#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#5)]
 [!code-csharp[NCLUriExamples#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#5)]
 [!code-vb[NCLUriExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" />를 serialize하는 데 필요한 정보가 포함된 <see cref="T:System.Uri" /> 개체입니다.</param>
        <param name="streamingContext">
          <see cref="T:System.Runtime.Serialization.StreamingContext" />와 연결된 serialize된 스트림의 소스와 대상이 포함된 <see cref="T:System.Uri" />개체입니다.</param>
        <summary>현재 인스턴스를 serialize하는 데 필요한 데이터를 반환합니다.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">serialization 메서드를 사용 하 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="uri.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>지정된 <see cref="T:System.Uri" /> 인스턴스에 대한 정식 문자열 표현을 가져옵니다.</summary>
        <returns>이스케이프되지 않은 <see cref="T:System.String" /> 인스턴스의 정식 표현을 포함하는 <see cref="T:System.Uri" /> 인스턴스입니다. #, ? 및 %를 제외한 모든 문자가 이스케이프되지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에서 반환 된 문자열에 포트 정보가 없습니다 포트 구성표에 대 한 기본 포트는 경우.  
  
> [!NOTE]
>  반환한 문자열을 <xref:System.Uri.ToString%2A> 메서드는 콘솔 응용 프로그램의 상태를 손상 시킬 수 있는 제어 문자를 포함할 수 있습니다. 사용할 수는 <xref:System.Uri.GetComponents%2A> 메서드는 <xref:System.UriFormat.SafeUnescaped?displayProperty=nameWithType> 반환된 된 문자열에서 제어 문자를 제거 하는 형식입니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.Uri> 문자열 인스턴스입니다. 반환 된 값 간의 차이 보여 줍니다 <xref:System.Uri.OriginalString%2A>, 생성자를 호출에서 전달 된 문자열을 반환 하는 <xref:System.Uri.ToString%2A>, 문자열의 정규 형식이 반환 합니다.  
  
 [!code-cpp[NCLUriExamples#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#7)]
 [!code-csharp[NCLUriExamples#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#7)]
 [!code-vb[NCLUriExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#7)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">부분적으로 신뢰할 수 있는 코드에서 파생 되지 않도록 하려면 <see cref="T:System.Uri" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryCreate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>새 <see cref="T:System.Uri" />를 만듭니다. <see cref="T:System.Uri" />를 만들 수 없으면 예외를 throw하지 않습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::String ^ uriString, UriKind uriKind, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : string * UriKind *  -&gt; bool" Usage="System.Uri.TryCreate (uriString, uriKind, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="uriString">
          <see cref="T:System.String" />를 나타내는 <see cref="T:System.Uri" />입니다.</param>
        <param name="uriKind">URI의 형식입니다.</param>
        <param name="result">이 메서드가 반환될 때 생성된 <see cref="T:System.Uri" />를 포함합니다.</param>
        <summary>지정된 <see cref="T:System.Uri" /> 인스턴스와 <see cref="T:System.String" />를 사용하여 새 <see cref="T:System.UriKind" />를 만듭니다.</summary>
        <returns>
          <see cref="T:System.Boolean" />가 만들어졌으면 <see langword="true" /> 값이 <see cref="T:System.Uri" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 반환 하는 경우 `true`, 새 <xref:System.Uri> 상태인 `result`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As String, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, System::String ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * string *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">기본 <see cref="T:System.Uri" />입니다.</param>
        <param name="relativeUri">기본 <see cref="T:System.Uri" />에 추가할 <see cref="T:System.String" />으로 나타낸 상대 <see cref="T:System.Uri" />입니다.</param>
        <param name="result">이 메서드가 반환될 때 <c>baseUri</c>와 <c>relativeUri</c>에서 만든 <see cref="T:System.Uri" />를 포함합니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
        <summary>지정된 기본 및 상대 <see cref="T:System.Uri" /> 인스턴스를 사용하여 새 <see cref="T:System.String" />를 만듭니다.</summary>
        <returns>
          <see cref="T:System.Boolean" />가 만들어졌으면 <see langword="true" /> 값이 <see cref="T:System.Uri" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 반환 하는 경우 `true`, 새 <xref:System.Uri> 상태인 `result`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As Uri, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, Uri ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * Uri *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">기본 <see cref="T:System.Uri" />입니다.</param>
        <param name="relativeUri">기본 <see cref="T:System.Uri" />에 추가할 상대 <see cref="T:System.Uri" />입니다.</param>
        <param name="result">이 메서드가 반환될 때 <c>baseUri</c>와 <c>relativeUri</c>에서 만든 <see cref="T:System.Uri" />를 포함합니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
        <summary>지정된 기본 및 상대 <see cref="T:System.Uri" /> 인스턴스를 사용하여 새 <see cref="T:System.Uri" />를 만듭니다.</summary>
        <returns>
          <see cref="T:System.Boolean" />가 만들어졌으면 <see langword="true" /> 값이 <see cref="T:System.Uri" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 반환 하는 경우 `true`, 새 <xref:System.Uri> 상태인 `result`합니다.  
  
 이 메서드 URI를 생성, 정규 형식으로 저장 및 유효성 검사를 수행 합니다. 처리 되지 않은 예외가 발생 하는 경우이 메서드를 catch 합니다. 생성 하려는 경우는 <xref:System.Uri> get 예외 중 하나를 사용 하 고는 <xref:System.Uri.%23ctor%2A> 생성자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Unescape (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ Unescape(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member Unescape : string -&gt; string&#xA;override this.Unescape : string -&gt; string" Usage="uri.Unescape path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">변환할 <see cref="T:System.String" />입니다.</param>
        <summary>이스케이프 시퀀스를 이스케이프되지 않은 표현으로 대체하여 지정된 문자열을 변환합니다.</summary>
        <returns>
          <see cref="T:System.String" /> 매개 변수에 대해 이스케이프되지 않은 값이 포함된 <paramref name="path" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnescapeDataString (stringToUnescape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UnescapeDataString(System::String ^ stringToUnescape);" />
      <MemberSignature Language="F#" Value="static member UnescapeDataString : string -&gt; string" Usage="System.Uri.UnescapeDataString stringToUnescape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">이스케이프되지 않을 문자열입니다.</param>
        <summary>문자열을 이스케이프되지 않은 표현으로 변환합니다.</summary>
        <returns>
          <see cref="T:System.String" />에 대해 이스케이프되지 않은 표현이 포함된 <paramref name="stringToUnescape" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 신중 하 게 해야 합니다. 이전에 이스케이프 된 문자열을 이스케이프 모호 해지고 오류가 발생할 수 있습니다.  
  
 다양 한 웹 브라우저에 더하기 Uri의 공백을 이스케이프 문자 ("+") 그러나 여 응용 프로그램이 UnescapeDataString 메서드 변환 하지 않습니다 더하기 문자 공간으로 모든 URI 구성표에서이 동작은 표준 없기 때문에.  
  
   
  
## Examples  
 다음 코드 예제에서는 URI를 이스케이프 해제 하 고 더하기 문자 ("+") 공간에 하나를 변환 합니다.  
  
 [!code-csharp[NCLUriExamples#19](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToUnescape" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Uri.EscapeDataString(System.String)" />
        <altmember cref="M:System.Uri.EscapeUriString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFile As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFile;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFile : string" Usage="System.Uri.UriSchemeFile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>URI를 파일 포인터로 지정합니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 버전 1.1에에서는 "`file:///path`"URI로 번역 되어"`file:/path`"입니다. 이 버전 2.0에 대 한 수정 되었습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Uri> 인스턴스 및 스키마 인지 여부를 결정 <xref:System.Uri.UriSchemeFile>합니다.  
  
 [!code-cpp[NCLUriExamples#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#10)]
 [!code-csharp[NCLUriExamples#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#10)]
 [!code-vb[NCLUriExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFtp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFtp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFtp : string" Usage="System.Uri.UriSchemeFtp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>FTP(파일 전송 프로토콜)를 통해 URI에 액세스하도록 지정합니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제는 <xref:System.Uri> 인스턴스 및 스키마 인지 여부를 결정 <xref:System.Uri.UriSchemeFtp>합니다.  
  
 [!code-cpp[NCLUriExamples#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#15)]
 [!code-csharp[NCLUriExamples#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#15)]
 [!code-vb[NCLUriExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeGopher As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeGopher;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeGopher : string" Usage="System.Uri.UriSchemeGopher" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gopher 프로토콜을 통해 URI에 액세스하도록 지정합니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제는 <xref:System.Uri> 인스턴스 및 스키마 인지 여부를 결정 <xref:System.Uri.UriSchemeGopher>합니다.  
  
 [!code-cpp[NCLUriExamples#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#14)]
 [!code-csharp[NCLUriExamples#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#14)]
 [!code-vb[NCLUriExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttp : string" Usage="System.Uri.UriSchemeHttp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP(Hypertext Transfer Protocol)를 통해 URI에 액세스하도록 지정합니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제는 <xref:System.Uri> 인스턴스 및 스키마 인지 여부를 결정 <xref:System.Uri.UriSchemeHttp>합니다.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttps As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttps;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttps : string" Usage="System.Uri.UriSchemeHttps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTPS(Secure Hypertext Transfer Protocol)를 통해 URI에 액세스하도록 지정합니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제는 <xref:System.Uri> 인스턴스 및 스키마 인지 여부를 결정 <xref:System.Uri.UriSchemeHttps>합니다.  
  
 [!code-cpp[NCLUriExamples#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#16)]
 [!code-csharp[NCLUriExamples#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#16)]
 [!code-vb[NCLUriExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeMailto As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeMailto;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeMailto : string" Usage="System.Uri.UriSchemeMailto" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>URI를 이메일 주소로 지정하고 SMTP(Simple Mail Transport Protocol)를 통해 URI에 액세스하도록 지정합니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제는 <xref:System.Uri> 인스턴스 및 스키마 인지 여부를 결정 <xref:System.Uri.UriSchemeMailto>합니다.  
  
 [!code-cpp[NCLUriExamples#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#11)]
 [!code-csharp[NCLUriExamples#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#11)]
 [!code-vb[NCLUriExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetPipe As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetPipe;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetPipe : string" Usage="System.Uri.UriSchemeNetPipe" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>WCF(Windows Communication Foundation)에서 사용하는 NetPipe 체계를 통해 URI에 액세스하도록 지정합니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetTcp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetTcp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetTcp : string" Usage="System.Uri.UriSchemeNetTcp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>WCF(Windows Communication Foundation)에서 사용하는 NetTcp 체계를 통해 URI에 액세스하도록 지정합니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNews As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNews;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNews : string" Usage="System.Uri.UriSchemeNews" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>URI를 인터넷 뉴스 그룹으로 지정하고 NNTP(Network News Transport Protocol)를 통해 URI에 액세스하도록 지정합니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제는 <xref:System.Uri> 인스턴스 및 스키마 인지 여부를 결정 <xref:System.Uri.UriSchemeNews>합니다.  
  
 [!code-cpp[NCLUriExamples#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#12)]
 [!code-csharp[NCLUriExamples#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#12)]
 [!code-vb[NCLUriExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNntp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNntp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNntp : string" Usage="System.Uri.UriSchemeNntp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>URI를 인터넷 뉴스 그룹으로 지정하고 NNTP(Network News Transport Protocol)를 통해 URI에 액세스하도록 지정합니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NNTP <xref:System.Uri> 구문 분석 오류에서.NET Framework 버전 1.1 수정 되었습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Uri> 인스턴스 및 스키마 인지 여부를 결정 <xref:System.Uri.UriSchemeNntp>합니다.  
  
 [!code-cpp[NCLUriExamples#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#13)]
 [!code-csharp[NCLUriExamples#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#13)]
 [!code-vb[NCLUriExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserEscaped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UserEscaped { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserEscaped : bool" Usage="System.Uri.UserEscaped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Uri" /> 인스턴스를 만들기 전에 URI 문자열을 완전히 이스케이프했음을 나타냅니다.</summary>
        <value>
          <see cref="T:System.Boolean" /> 인스턴스를 만들 때 <see langword="true" /> 매개 변수를 <paramref name="dontEscape" />로 설정했으면 <see langword="true" /> 값이 <see cref="T:System.Uri" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Uri.UserEscaped%2A> 속성이로 설정 되어 `true` 를 나타내는 문자열을 만드는 데는 <xref:System.Uri> 인스턴스가 완전히 이스케이프 생성자에 전달 된 것입니다. 즉, `dontEscape` 생성자 호출의 매개 변수 로설정된`true`.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Uri> 인스턴스를 만들 때 완전히 이스케이프 했는지 여부를 확인 합니다.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInfo : string" Usage="System.Uri.UserInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>지정된 URI와 연결된 사용자 이름, 암호 및 기타 사용자 관련 정보를 가져옵니다.</summary>
        <value>URI와 연결된 사용자 정보가 포함된 <see cref="T:System.String" />입니다. 반환된 값에는 URI의 사용자 정보 부분을 구분하기 위해 예약된 '@' 문자가 포함되지 않습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환 값은 일반적으로 "userName:password" 형식으로.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Uri> 인스턴스 및 사용자 정보를 콘솔에 씁니다.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 인스턴스가 상대 URI를 나타내고 이 속성이 절대 URI에만 유효한 경우</exception>
      </Docs>
    </Member>
  </Members>
</Type>